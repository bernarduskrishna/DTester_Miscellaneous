{"/bernard/dataset_construction/prep/repos/ofdrw/ofdrw-tool/src/main/java/org/ofdrw/tool/merge/OFDPageDeleter.java":{"class_content":["package org.ofdrw.tool.merge;\n","\n","\n","import org.dom4j.DocumentException;\n","import org.ofdrw.core.basicStructure.doc.Document;\n","import org.ofdrw.core.basicStructure.ofd.DocBody;\n","import org.ofdrw.core.basicStructure.ofd.OFD;\n","import org.ofdrw.core.basicStructure.ofd.docInfo.CT_DocInfo;\n","import org.ofdrw.core.basicStructure.pageTree.Page;\n","import org.ofdrw.core.basicStructure.pageTree.Pages;\n","import org.ofdrw.core.basicType.ST_Loc;\n","import org.ofdrw.pkg.container.OFDDir;\n","import org.ofdrw.reader.OFDReader;\n","import org.ofdrw.reader.ResourceLocator;\n","\n","import java.io.Closeable;\n","import java.io.IOException;\n","import java.nio.file.Path;\n","import java.time.LocalDate;\n","import java.util.ArrayList;\n","import java.util.List;\n","\n","/**\n"," * OFD文档页面删除器\n"," * <p>\n"," * 该删除器仅删除文档树中的页面节点，不会删除相关资源和页面对象 Content.xml\n"," *\n"," * @author 权观宇\n"," * @since 2023-8-2 19:31:00\n"," */\n","public class OFDPageDeleter implements Closeable {\n","\n","    /**\n","     * OFD文档虚拟容器\n","     */\n","    private final OFDDir ofdDir;\n","    /**\n","     * OFD.xml 主入口\n","     */\n","    private final OFD ofd;\n","    /**\n","     * OFD文档根节点\n","     */\n","    private final Document ofdRoot;\n","\n","    /**\n","     * OFD解析器\n","     */\n","    private final OFDReader reader;\n","    /**\n","     * 输出路径\n","     */\n","    private final Path outPath;\n","\n","    /**\n","     * 创建OFD文档页面删除器\n","     *\n","     * @param src OFD文件路径\n","     * @param out 删除后文件路径\n","     * @throws IOException       文件解析异常\n","     * @throws DocumentException 文档结构无法解析\n","     */\n","    public OFDPageDeleter(Path src, Path out) throws IOException, DocumentException {\n","        if (src == null || !src.toFile().exists()) {\n","            throw new IllegalArgumentException(\"OFD文件不存在\");\n","        }\n","        if (out == null) {\n","            throw new IllegalArgumentException(\"输出路径（out）为空\");\n","        }\n","\n","        this.reader = new OFDReader(src);\n","        this.outPath = out;\n","        this.ofdDir = reader.getOFDDir();\n","        this.ofd = ofdDir.getOfd();\n","        // 资源定位器\n","        ResourceLocator rl = reader.getResourceLocator();\n","        DocBody docBody = ofd.getDocBody();\n","        // 找到 Document.xml文件并且序列化\n","        ST_Loc docRoot = docBody.getDocRoot();\n","        this.ofdRoot = rl.get(docRoot, Document::new);\n","    }\n","\n","\n","    /**\n","     * 删除指定索引的页面\n","     *\n","     * @param indexes 页面索引列表（从0起）\n","     * @return this\n","     */\n","    public OFDPageDeleter delete(int... indexes) {\n","        if (indexes == null || indexes.length == 0) {\n","            return this;\n","        }\n","        Pages pages = this.ofdRoot.getPages();\n","        List<Page> tbd = new ArrayList<>();\n","        for (int index : indexes) {\n","            for (int i = 0; i < pages.getPages().size(); i++) {\n","                if (i == index) {\n","                    tbd.add(pages.getPageByIndex(i));\n","                }\n","            }\n","        }\n","        for (Page page : tbd) {\n","            pages.remove(page);\n","        }\n","        return this;\n","    }\n","\n","\n","    /**\n","     * 保存删除后的文档，并关闭删除器\n","     * <p>\n","     * 注意：请在所有操作完成后调用该方法，否则无法删除页面。\n","     *\n","     * @throws IOException 文件读写异常\n","     */\n","    @Override\n","    public void close() throws IOException {\n","        DocBody docBody = ofd.getDocBody();\n","        CT_DocInfo docInfo = docBody.getDocInfo();\n","        // 设置文档修改时间\n","        docInfo.setModDate(LocalDate.now());\n","\n","        // final. 执行打包程序\n","        if (outPath != null) {\n","            ofdDir.jar(outPath.toAbsolutePath());\n","        }\n","\n","        if (reader != null) {\n","            reader.close();\n","        }\n","    }\n","}\n"],"test_content":["package org.ofdrw.tool.merge;\n","\n","import org.junit.jupiter.api.Test;\n","\n","import java.nio.file.Path;\n","import java.nio.file.Paths;\n","\n","\n","/**\n"," * 文档页面删除测试\n"," */\n","class OFDPageDeleterTest {\n","\n","    /**\n","     * 文档页面删除示例\n","     */\n","    @Test\n","    void delete() throws Exception {\n","        Path srcP = Paths.get(\"src/test/resources\", \"Page5.ofd\");\n","        Path outP = Paths.get(\"target/page_deleted.ofd\");\n","        try (OFDPageDeleter deleter = new OFDPageDeleter(srcP, outP)) {\n","            deleter.delete(0, 1, 2);\n","        }\n","        System.out.println(\">> 生成文档位置：\" + outP.toAbsolutePath());\n","    }\n","}"],"method_lines_dic":{"OFDPageDeleter::::delete(int[])":[90,107],"OFDPageDeleter::::close()":[117,132]},"test_method_lines_dic":{"OFDPageDeleterTest::::delete()":[17,25]},"reverse_method_lines_dic":{"90":"OFDPageDeleter::::delete(int[])","91":"OFDPageDeleter::::delete(int[])","92":"OFDPageDeleter::::delete(int[])","93":"OFDPageDeleter::::delete(int[])","94":"OFDPageDeleter::::delete(int[])","95":"OFDPageDeleter::::delete(int[])","96":"OFDPageDeleter::::delete(int[])","97":"OFDPageDeleter::::delete(int[])","98":"OFDPageDeleter::::delete(int[])","99":"OFDPageDeleter::::delete(int[])","100":"OFDPageDeleter::::delete(int[])","101":"OFDPageDeleter::::delete(int[])","102":"OFDPageDeleter::::delete(int[])","103":"OFDPageDeleter::::delete(int[])","104":"OFDPageDeleter::::delete(int[])","105":"OFDPageDeleter::::delete(int[])","106":"OFDPageDeleter::::delete(int[])","107":"OFDPageDeleter::::delete(int[])","117":"OFDPageDeleter::::close()","118":"OFDPageDeleter::::close()","119":"OFDPageDeleter::::close()","120":"OFDPageDeleter::::close()","121":"OFDPageDeleter::::close()","122":"OFDPageDeleter::::close()","123":"OFDPageDeleter::::close()","124":"OFDPageDeleter::::close()","125":"OFDPageDeleter::::close()","126":"OFDPageDeleter::::close()","127":"OFDPageDeleter::::close()","128":"OFDPageDeleter::::close()","129":"OFDPageDeleter::::close()","130":"OFDPageDeleter::::close()","131":"OFDPageDeleter::::close()","132":"OFDPageDeleter::::close()"},"test_reverse_method_lines_dic":{"17":"OFDPageDeleterTest::::delete()","18":"OFDPageDeleterTest::::delete()","19":"OFDPageDeleterTest::::delete()","20":"OFDPageDeleterTest::::delete()","21":"OFDPageDeleterTest::::delete()","22":"OFDPageDeleterTest::::delete()","23":"OFDPageDeleterTest::::delete()","24":"OFDPageDeleterTest::::delete()","25":"OFDPageDeleterTest::::delete()"},"tests":[{"test_lines":[17,25],"covered_lines":[63,64,67,71,72,73,74,76,77,79,80,81,91,94,95,96,97,98,99,103,104,105,106,119,120,122,125,126,129,130,132],"label":"OFDPageDeleter::::delete(int[])"}]},"/bernard/dataset_construction/prep/repos/ofdrw/ofdrw-tool/src/main/java/org/ofdrw/tool/merge/OFDMerger.java":{"class_content":["package org.ofdrw.tool.merge;\n","\n","\n","import org.bouncycastle.jcajce.provider.digest.SM3;\n","import org.bouncycastle.util.encoders.Hex;\n","import org.dom4j.*;\n","import org.ofdrw.core.OFDElement;\n","import org.ofdrw.core.annotation.Annotations;\n","import org.ofdrw.core.annotation.pageannot.AnnPage;\n","import org.ofdrw.core.annotation.pageannot.PageAnnot;\n","import org.ofdrw.core.basicStructure.doc.CT_PageArea;\n","import org.ofdrw.core.basicStructure.pageObj.CT_TemplatePage;\n","import org.ofdrw.core.basicStructure.pageObj.Template;\n","import org.ofdrw.core.basicStructure.pageTree.Page;\n","import org.ofdrw.core.basicStructure.pageTree.Pages;\n","import org.ofdrw.core.basicStructure.res.CT_MultiMedia;\n","import org.ofdrw.core.basicType.ST_ID;\n","import org.ofdrw.core.basicType.ST_Loc;\n","import org.ofdrw.core.basicType.ST_RefID;\n","import org.ofdrw.core.compositeObj.CT_VectorG;\n","import org.ofdrw.core.pageDescription.color.colorSpace.CT_ColorSpace;\n","import org.ofdrw.core.pageDescription.drawParam.CT_DrawParam;\n","import org.ofdrw.core.text.font.CT_Font;\n","import org.ofdrw.pkg.container.*;\n","import org.ofdrw.reader.ResourceLocator;\n","import org.ofdrw.reader.model.TemplatePageEntity;\n","\n","import java.io.Closeable;\n","import java.io.FileNotFoundException;\n","import java.io.IOException;\n","import java.io.InputStream;\n","import java.nio.file.Files;\n","import java.nio.file.Path;\n","import java.util.ArrayList;\n","import java.util.HashMap;\n","import java.util.List;\n","import java.util.Map;\n","import java.util.concurrent.atomic.AtomicInteger;\n","\n","/**\n"," * 文档合并工具\n"," *\n"," * @author 权观宇\n"," * @since 2021-11-08 20:49:36\n"," */\n","public class OFDMerger implements Closeable {\n","\n","    /**\n","     * 新页面列表\n","     * <p>\n","     * 每一个元素代表新文档中的一页\n","     */\n","    public final ArrayList<PageEntry> pageArr;\n","    /**\n","     * 文档上下文映射\n","     */\n","    private final Map<String, DocContext> docCtxMap;\n","\n","\n","    /**\n","     * 合并后生成文档位置\n","     */\n","    private final Path dest;\n","\n","    /**\n","     * 合并的目标文档，仅在合并时设置\n","     * 在合并完成后将会被打包存储\n","     */\n","    private BareOFDDoc ofdDoc;\n","\n","    /**\n","     * 注释入口文件\n","     */\n","    private Annotations newDocAnnotations = null;\n","    /**\n","     * 注释目录\n","     */\n","    private AnnotsDir annotsDir = null;\n","\n","\n","    /**\n","     * 资源文件哈希表\n","     * <p>\n","     * Key: 文件SM3 Hash Hex\n","     * Value: 文件在新文档中的文件名\n","     */\n","    private final Map<String, ST_Loc> resFileHashTable;\n","\n","\n","    /**\n","     * 模板页面映射表\n","     * <p>\n","     * Key: 模板页对象ID\n","     * Value: 模板页面对象\n","     */\n","    private final Map<String, CT_TemplatePage> tplPageMap;\n","\n","    private final AtomicInteger resFileCounter;\n","    /**\n","     * - Layer 的 DrawParam\n","     * - 每个图像对象都可能含有 DrawParam 引用\n","     * - Color 中 Pattern CellContent Thumbnail 引用\n","     * - Color 中 ColorSpace 引用\n","     * - Image 中 ResourceID、Substitution、ImageMask\n","     * - Text 中 Font\n","     * - Composite 复合对象 中 ResourceID\n","     * Res资源中的 CompositeGraphUnit CT_VectorG：Thumbnail、Substitution\n","     */\n","    private static final Map<String, XPath> AttrQueries = new HashMap<String, XPath>() {{\n","        this.put(\"Font\", DocumentHelper.createXPath(\"//*[@Font]\"));\n","        this.put(\"ResourceID\", DocumentHelper.createXPath(\"//*[@ResourceID]\"));\n","        this.put(\"Substitution\", DocumentHelper.createXPath(\"//*[@Substitution]\"));\n","        this.put(\"ImageMask\", DocumentHelper.createXPath(\"//*[@ImageMask]\"));\n","        this.put(\"Thumbnail\", DocumentHelper.createXPath(\"//*[@Thumbnail]\"));\n","        this.put(\"DrawParam\", DocumentHelper.createXPath(\"//*[@DrawParam]\"));\n","        this.put(\"ColorSpace\", DocumentHelper.createXPath(\"//*[@ColorSpace]\"));\n","    }};\n","\n","    public OFDMerger(Path dest) {\n","        if (dest == null) {\n","            throw new IllegalArgumentException(\"合并结果路径(dest)为空\");\n","        }\n","        pageArr = new ArrayList<>(10);\n","        docCtxMap = new HashMap<>();\n","        this.dest = dest;\n","        final Path parent = dest.getParent();\n","        if (parent == null || !Files.exists(parent)) {\n","            throw new IllegalArgumentException(\"OFD文件存储路径(dest)上级目录 [\" + parent + \"] 不存在\");\n","        }\n","        resFileHashTable = new HashMap<>(3);\n","        tplPageMap = new HashMap<>(2);\n","        resFileCounter = new AtomicInteger(0);\n","    }\n","\n","\n","    /**\n","     * 向合并文件中添加页面\n","     *\n","     * @param filepath    待合并的OFD文件路径\n","     * @param pageIndexes 页面序序列，如果为空表示所有页面（页码从1开始）\n","     * @return this\n","     * @throws IOException 页面读写异常\n","     */\n","    public OFDMerger add(Path filepath, int... pageIndexes) throws IOException {\n","        String key = filepath.toAbsolutePath().getFileName().toString();\n","        DocContext ctx = docCtxMap.get(key);\n","        // 缓存中没有该文件映射\n","        if (ctx == null) {\n","            // 加载文件上下文\n","            ctx = new DocContext(filepath);\n","            docCtxMap.put(key, ctx);\n","        }\n","        // 没有传递页码时认为需要追加所有页面\n","        if (pageIndexes == null || pageIndexes.length == 0) {\n","            int numberOfPages = ctx.reader.getNumberOfPages();\n","            pageIndexes = new int[numberOfPages];\n","            for (int i = 0; i < pageIndexes.length; i++) {\n","                pageIndexes[i] = i + 1;\n","            }\n","        }\n","        // 追加内容到页面列表中\n","        for (int pageIndex : pageIndexes) {\n","            pageArr.add(new PageEntry(pageIndex, ctx));\n","        }\n","        return this;\n","    }\n","\n","    /**\n","     * 向合并文件中添加页面\n","     * <p>\n","     * 通过该方法可以详细设置页面迁移时的属性参数\n","     *\n","     * @param pages 页面对象\n","     * @return this\n","     */\n","    public OFDMerger add(PageEntry... pages) {\n","        if (pages == null) {\n","            return this;\n","        }\n","        for (PageEntry page : pages) {\n","            if (page.docCtx == null || page.docCtx.filepath == null) {\n","                continue;\n","            }\n","            String key = page.docCtx.filepath.toAbsolutePath().getFileName().toString();\n","            // 缓存中没有该文件映射\n","            if (!docCtxMap.containsKey(key)) {\n","                docCtxMap.put(key, page.docCtx);\n","            }\n","\n","            pageArr.add(page);\n","        }\n","\n","        return this;\n","    }\n","\n","    /**\n","     * 执行合并\n","     */\n","    private void doMerge() throws IOException, DocumentException {\n","        // 删除原来存在的问题\n","        if (Files.exists(dest)) {\n","            Files.delete(dest);\n","        }\n","        // 创建新文档\n","        try (final BareOFDDoc ofdDoc = new BareOFDDoc(dest)) {\n","            this.ofdDoc = ofdDoc;\n","            final Pages pages = ofdDoc.document.getPages();\n","            // 如果存在Pages那么获取，不存在那么创建\n","            final PagesDir pagesDir = ofdDoc.docDir.obtainPages();\n","            for (final PageEntry pageEntry : pageArr) {\n","                // 取0文档对象\n","                final CT_PageArea docDefaultArea = new CT_PageArea((Element) pageEntry.docCtx.getDefaultArea(0).clone());\n","                org.ofdrw.core.basicStructure.pageObj.Page page = null;\n","                ST_ID oldPageID = null;\n","                ST_ID newPageID = null;\n","                // 解析原OFD页面的Content.xml 为Page对象\n","                try {\n","                    // 获取页面在原文档中的对象ID\n","                    oldPageID = pageEntry.docCtx.reader.getPageObjectId(pageEntry.pageIndex);\n","\n","                    Element copy = (Element) pageEntry.docCtx.reader.getPage(pageEntry.pageIndex).clone();\n","                    final Document document = DocumentHelper.createDocument();\n","                    document.add(copy);\n","                    page = new org.ofdrw.core.basicStructure.pageObj.Page(copy);\n","                } catch (NumberFormatException e) {\n","                    // 忽略页码非法的页面复制\n","                    continue;\n","                }\n","\n","                // 若当前页面的页面区域的大小和位置为空，则使用文档默认的尺寸\n","                if (page.getArea() == null) {\n","                    page.setArea(docDefaultArea);\n","                }\n","\n","                // 创建页面容器\n","                PageDir pageDir = pagesDir.newPageDir();\n","                String pageLoc = String.format(\"Pages/Page_%d/Content.xml\", pageDir.getIndex());\n","                // 将创建的页面加入 Document.xml 中的 Pages 内\n","                final Page newPageItem = new Page(this.ofdDoc.MaxUnitID.incrementAndGet(), pageLoc);\n","                pages.addPage(newPageItem);\n","                // 获取页面在新文档中的ID\n","                newPageID = newPageItem.getID();\n","\n","                // 迁移页面模板\n","                if (pageEntry.copyTemplate) {\n","                    // 页面模板的迁移的替换\n","                    final List<Template> pageTplArr = page.getTemplates();\n","                    for (Template tplObj : pageTplArr) {\n","                        // 迁移页面\n","                        ST_RefID tplNewId = pageTplMigrate(pageEntry.docCtx, tplObj);\n","                        tplObj.setTemplateID(tplNewId);\n","                    }\n","                }\n","\n","                // 通过XML 选中与资源有关对象，并实现资源迁移和引用替换\n","                domMigrate(pageEntry.docCtx, page);\n","                // 把替换后得到页面放入页面容器中\n","                pageDir.setContent(page);\n","\n","                // 迁移注释\n","                if (pageEntry.copyAnnotations && oldPageID != null && newPageID != null) {\n","                    String pageDirName = pageDir.getContainerName();\n","                    pageAnnotationMigrate(pageEntry.docCtx, oldPageID, newPageID, pageDirName);\n","                }\n","            }\n","        }\n","    }\n","\n","    /**\n","     * 页面注释迁移到新文档，若页面无注释则跳过。\n","     *\n","     * @param docCtx           文档上下文\n","     * @param oldPageID        原页面ID\n","     * @param newPageID        迁移后页面ID\n","     * @param pageAnnotDirName 页面所处容器名称，格式为Page_N\n","     */\n","    private void pageAnnotationMigrate(DocContext docCtx, ST_ID oldPageID, ST_ID newPageID, String pageAnnotDirName) throws IOException {\n","        final ResourceLocator rl = docCtx.reader.getResourceLocator();\n","        try {\n","            rl.save();\n","            org.ofdrw.core.basicStructure.doc.Document srcDoc = docCtx.reader.cdDefaultDoc();\n","            // 获取 注释入口文件 Annotations.xml\n","            ST_Loc srcAnnotListPath = srcDoc.getAnnotations();\n","            if (srcAnnotListPath == null || !(rl.exist(srcAnnotListPath.toString()))) {\n","                return;\n","            }\n","            Annotations annotList = rl.get(srcAnnotListPath, Annotations::new);\n","            if (annotList == null) {\n","                return;\n","            }\n","            // 获取指定页面的注释\n","            AnnPage annPage = annotList.getByPageId(oldPageID.toString());\n","            if (annPage == null || annPage.getFileLoc() == null) {\n","                return;\n","            }\n","            // 进入 注释入口文件 所在目录\n","            rl.cd(srcAnnotListPath.parent());\n","            // 解析并获取 分页注释文件\n","            PageAnnot pageAnnot = rl.get(annPage.getFileLoc(), PageAnnot::new);\n","            if (pageAnnot == null) {\n","                return;\n","            }\n","            Element copy = (Element) pageAnnot.clone();;\n","            final Document document = DocumentHelper.createDocument();\n","            document.add(copy);\n","            pageAnnot = new PageAnnot(copy);\n","\n","            if (this.newDocAnnotations == null) {\n","                // 创建注释目录 /Doc_0/Annots/\n","                this.annotsDir = this.ofdDoc.docDir.obtainAnnots();\n","                // 创建注释入口文件 /Doc_0/Annots/Annotations.xml\n","                this.newDocAnnotations = new Annotations();\n","                this.annotsDir.setAnnotations(this.newDocAnnotations);\n","                this.ofdDoc.document.setAnnotations(this.annotsDir.getAbsLoc().cat(DocDir.AnnotationsFileName));\n","            }\n","\n","            // 获取页面注释容器 /Doc_0/Annots/Page_N/ ，不存在则创建\n","            PageDir pageDir = annotsDir.obtainContainer(pageAnnotDirName, PageDir::new);\n","            // 向容器中加入 分页注释文件 /Doc_0/Annots/Page_N/Annot_N.xml\n","            ST_Loc pageAnnotPath = pageDir.addAnnot(pageAnnot);\n","            // 设置新文档中的页面ID\n","            AnnPage annotItem = new AnnPage().setPageID(newPageID).setFileLoc(pageAnnotPath);\n","            this.newDocAnnotations.addPage(annotItem);\n","\n","            // 迁移注释中资源\n","            domMigrate(docCtx, pageAnnot);\n","        } catch (FileNotFoundException | DocumentException e) {\n","            System.err.println(\"页面注释迁移失败：\" + e.getMessage());\n","        } finally {\n","            // 还原原有工作区\n","            rl.restore();\n","        }\n","    }\n","\n","    /**\n","     * 页面模板迁移到新文档\n","     * <p>\n","     * 若模板已经迁移过，那么直接返回迁移后的页面ID\n","     *\n","     * @param docCtx 原文档上下文\n","     * @param tplObj 页面模板信息对象\n","     * @return 迁移后模板页面在新文档中的引用ID\n","     * @throws IOException 文件复制异常\n","     */\n","    private ST_RefID pageTplMigrate(DocContext docCtx, Template tplObj) throws IOException {\n","        final String oldId = tplObj.getTemplateID().toString();\n","        CT_TemplatePage templatePage = tplPageMap.get(oldId);\n","        if (templatePage != null) {\n","            // 页面已经复制过\n","            // 如果模板ID一样，但是模板内容不一样\n","            if (templatePage.asXML().equals(tplObj.asXML())) {\n","                return templatePage.getID().ref();\n","            }\n","        }\n","\n","        // 从文档中加载模板页面实体\n","        final TemplatePageEntity entity = docCtx.reader.getTemplate(oldId);\n","        // 复制模板页面\n","        org.ofdrw.core.basicStructure.pageObj.Page pageObj = entity.getPage();\n","        Element copy = (Element) pageObj.clone();\n","        final Document document = DocumentHelper.createDocument();\n","        document.add(copy);\n","        pageObj = new org.ofdrw.core.basicStructure.pageObj.Page(copy);\n","\n","        templatePage = entity.getTplInfo();\n","        templatePage.setParent(null);\n","\n","        // 迁移模板页面中相关的资源，并替换模板页面中ID\n","        domMigrate(docCtx, pageObj);\n","        // 写入到模板容器中，并更新模板信息对象\n","        final ST_Loc tplPageLoc = ofdDoc.docDir.obtainTemps().add(pageObj);\n","        templatePage.setBaseLoc(tplPageLoc);\n","\n","        // 分配新文档的ID，并添加到新文档中的CommonData\n","        ST_ID newId = new ST_ID(ofdDoc.MaxUnitID.incrementAndGet());\n","        templatePage.setID(newId);\n","        ofdDoc.cdata.addTemplatePage(templatePage);\n","\n","        // 缓存并返回文件引用\n","        tplPageMap.put(oldId, templatePage);\n","        return newId.ref();\n","    }\n","\n","\n","    /**\n","     * DOM元素节点的资源迁移\n","     * <p>\n","     * 检查DOM节点下所有引用资源，并将资源迁移到新文档中\n","     * 更新DOM引用ID\n","     * <p>\n","     * 重新分配对象ID\n","     *\n","     * @param docCtx DOM相关的文档上下文\n","     * @param dom    待迁移DOM\n","     * @throws IOException 文件读取或复制异常\n","     */\n","    private void domMigrate(DocContext docCtx, Element dom) throws IOException {\n","        List<Node> nodes;\n","        for (Map.Entry<String, XPath> entry : AttrQueries.entrySet()) {\n","            nodes = entry.getValue().selectNodes(dom);\n","            if (nodes.isEmpty()) {\n","                continue;\n","            }\n","            String attrName = entry.getKey();\n","            for (Node node : nodes) {\n","                if (node instanceof Element) {\n","                    Element element = (Element) node;\n","                    // 获取原资源ID\n","                    final String oldResId = element.attributeValue(attrName);\n","                    // 迁移资源到新文档，并返回新文档中该资源的ID\n","                    long newResId = resMigrate(docCtx, oldResId);\n","                    // 设置新的资源ID\n","                    element.addAttribute(attrName, Long.toString(newResId));\n","                }\n","            }\n","        }\n","\n","        // 修改DOM中原有的对象ID为新页面的对象ID\n","        final List<Node> objArr = dom.selectNodes(\"//*[@ID]\");\n","        for (Node node : objArr) {\n","            if (node instanceof Element) {\n","                Element element = (Element) node;\n","                // 设置新的对象ID\n","                element.addAttribute(\"ID\", Integer.toString(ofdDoc.MaxUnitID.incrementAndGet()));\n","            }\n","        }\n","    }\n","\n","    /**\n","     * 从原文当迁移资源到新页面\n","     *\n","     * @param docCtx   被迁移的页面文档上下文\n","     * @param oldResId 资源ID\n","     * @return 资源在新文档中的ID, 0标识没有找到资源\n","     * @throws IOException 文件读取或复制错误\n","     */\n","    private long resMigrate(DocContext docCtx, String oldResId) throws IOException {\n","        final OFDElement resObj = docCtx.resMgt.get(oldResId);\n","        if (resObj == null) {\n","            return 0;\n","        }\n","        final ResourceLocator rl = docCtx.reader.getResourceLocator();\n","\n","        // 检查缓存，防止重复迁移\n","        final OFDElement cache = docCtx.resOldNewMap.get(oldResId);\n","        if (cache != null) {\n","            return cache.getObjID().getId();\n","        }\n","        // 缓存对象\n","        docCtx.resOldNewMap.put(oldResId, resObj);\n","        resObj.setParent(null);\n","        if (resObj instanceof CT_ColorSpace) {\n","            CT_ColorSpace cs = (CT_ColorSpace) resObj;\n","            ST_Loc profile = cs.getProfile();\n","            if (profile != null) {\n","                // 复制资源到新的文档中\n","                Path filepath = rl.getFile(profile);\n","                profile = copyResFile(filepath);\n","                cs.setProfile(profile);\n","            }\n","            ofdDoc.prm.addRawWithCache(cs);\n","        } else if (resObj instanceof CT_DrawParam) {\n","            CT_DrawParam dp = (CT_DrawParam) resObj;\n","            ofdDoc.prm.addRawWithCache(dp);\n","        } else if (resObj instanceof CT_Font) {\n","            CT_Font f = (CT_Font) resObj;\n","            ST_Loc fontFileLoc = f.getFontFile();\n","            if (fontFileLoc != null) {\n","                // 复制资源到新的文档中\n","                Path filepath = rl.getFile(fontFileLoc);\n","                fontFileLoc = copyResFile(filepath);\n","                f.setFontFile(fontFileLoc);\n","            }\n","            ofdDoc.prm.addRawWithCache(f);\n","        } else if (resObj instanceof CT_MultiMedia) {\n","            CT_MultiMedia mm = (CT_MultiMedia) resObj;\n","            ST_Loc mediaFileLoc = mm.getMediaFile();\n","            if (mediaFileLoc != null) {\n","                // 复制资源到新的文档中\n","                Path filepath = rl.getFile(mediaFileLoc);\n","                mediaFileLoc = copyResFile(filepath);\n","                mm.setMediaFile(mediaFileLoc);\n","            }\n","\n","            ofdDoc.prm.addRawWithCache(mm);\n","        } else if (resObj instanceof CT_VectorG) {\n","            CT_VectorG vg = (CT_VectorG) resObj;\n","            final Document d = DocumentHelper.createDocument();\n","            d.add(vg);\n","\n","            // 矢量图像，等于一个DOM 运行迁移程序，向迁移矢量图像内部的资源，再迁该资源本身。\n","            domMigrate(docCtx, vg);\n","            ofdDoc.prm.addRawWithCache(vg);\n","        } else {\n","            // 未知的资源类型不进行迁移\n","            return 0;\n","        }\n","\n","        return resObj.getObjID().getId();\n","    }\n","\n","    /**\n","     * 复制资源到新文档\n","     * <p>\n","     * 复制前将会计算文档的Hash并缓存防止重复\n","     * <p>\n","     * 复制后的文档名称为文件的Hash值\n","     *\n","     * @param filepath 文件路径\n","     * @return 复制后基于资源容器的相对路径\n","     * @throws IOException 文件读取复制异常\n","     */\n","    private ST_Loc copyResFile(Path filepath) throws IOException {\n","        // 计算文件的摘要值\n","        SM3.Digest digest = new SM3.Digest();\n","        byte[] buff = new byte[4096];\n","        int n = 0;\n","        try (final InputStream in = Files.newInputStream(filepath)) {\n","            while ((n = in.read(buff)) != -1) {\n","                digest.update(buff, 0, n);\n","            }\n","        }\n","        String hash = Hex.toHexString(digest.digest());\n","\n","        // 检查该文件是否已经被迁移过\n","        final ST_Loc resLoc = resFileHashTable.get(hash);\n","        if (resLoc != null) {\n","            return resLoc;\n","        }\n","\n","        // 重命名文件为文件计数器，保留后缀名\n","        String fileName = filepath.getFileName().toString();\n","        int off = fileName.lastIndexOf('.');\n","        if (off != -1) {\n","            fileName = resFileCounter.incrementAndGet() + fileName.substring(off);\n","        } else {\n","            fileName = Integer.toString(resFileCounter.incrementAndGet());\n","        }\n","\n","        final ResDir resDir = ofdDoc.docDir.obtainRes();\n","        // 复制文件到新文件容的资源容器中\n","        try (final InputStream in = Files.newInputStream(filepath)) {\n","            resDir.addRaw(fileName, in);\n","        }\n","        final ST_Loc res = new ST_Loc(fileName);\n","        // 缓存，返回文件名称（基于Res容器的相对路径）\n","        resFileHashTable.put(hash, res);\n","        return res;\n","    }\n","\n","    @Override\n","    public void close() throws IOException {\n","        // 只有在新文档中含有页面时才允许运行合并进程\n","        if (!pageArr.isEmpty()) {\n","            try {\n","                doMerge();\n","            } catch (DocumentException e) {\n","                throw new IOException(e);\n","            }\n","        }\n","        // 关闭已经打开的文档上下文\n","        for (DocContext docContext : docCtxMap.values()) {\n","            docContext.close();\n","        }\n","    }\n","\n","\n","}\n"],"test_content":["package org.ofdrw.tool.merge;\n","\n","import org.dom4j.DocumentHelper;\n","import org.junit.jupiter.api.Test;\n","\n","import java.io.IOException;\n","import java.nio.file.Path;\n","import java.nio.file.Paths;\n","\n","import static org.junit.jupiter.api.Assertions.*;\n","\n","/**\n"," * 页面迁移测试\n"," *\n"," * @author 权观宇\n"," * @since 2021-11-10 21:15:31\n"," */\n","class OFDMergerTest {\n","\n","    /**\n","     * 测试水印迁移\n","     */\n","    @Test\n","    void testMergerWatermark() throws IOException {\n","        Path dst = Paths.get(\"target/merge_watermark.ofd\");\n","        Path d1Path = Paths.get(\"src/test/resources\", \"hello_watermark.ofd\");\n","        Path d2Path = Paths.get(\"src/test/resources\", \"Page5.ofd\");\n","\n","        try (OFDMerger ofdMerger = new OFDMerger(dst)) {\n","            ofdMerger.add(d1Path);\n","            ofdMerger.add(d2Path);\n","            ofdMerger.add(d1Path);\n","        }\n","        System.out.println(dst.toAbsolutePath());\n","    }\n","\n","\n","    @Test\n","    void add() throws IOException {\n","        Path dst = Paths.get(\"target/n1.ofd\");\n","        Path d1Path = Paths.get(\"../ofdrw-converter/src/test/resources/\", \"y.ofd\");\n","        Path d2Path = Paths.get(\"../ofdrw-converter/src/test/resources/\", \"发票示例.ofd\");\n","\n","        try (OFDMerger ofdMerger = new OFDMerger(dst)) {\n","            ofdMerger.add(d1Path, 2);\n","            ofdMerger.add(d2Path, 1);\n","            ofdMerger.add(d1Path, 1);\n","        }\n","    }\n","\n","    @Test\n","    void add2() throws IOException {\n","        Path dst = Paths.get(\"target/n2.ofd\");\n","        Path d1Path = Paths.get(\"../ofdrw-converter/src/test/resources/\", \"y.ofd\");\n","        Path d2Path = Paths.get(\"../ofdrw-converter/src/test/resources/\", \"发票示例.ofd\");\n","\n","        try (OFDMerger ofdMerger = new OFDMerger(dst)) {\n","            ofdMerger.add(d1Path, 1, 1);\n","            ofdMerger.add(d2Path);\n","            ofdMerger.add(d1Path);\n","        }\n","    }\n","}"],"method_lines_dic":{"OFDMerger::::add(java.nio.file.Path,int[])":[144,166],"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])":[176,194],"OFDMerger::::doMerge()":[199,267],"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)":[437,500],"OFDMerger::::copyResFile(java.nio.file.Path)":[513,549],"OFDMerger::::close()":[551,565]},"test_method_lines_dic":{"OFDMergerTest::::testMergerWatermark()":[23,35],"OFDMergerTest::::add()":[38,49],"OFDMergerTest::::add2()":[51,62]},"reverse_method_lines_dic":{"144":"OFDMerger::::add(java.nio.file.Path,int[])","145":"OFDMerger::::add(java.nio.file.Path,int[])","146":"OFDMerger::::add(java.nio.file.Path,int[])","147":"OFDMerger::::add(java.nio.file.Path,int[])","148":"OFDMerger::::add(java.nio.file.Path,int[])","149":"OFDMerger::::add(java.nio.file.Path,int[])","150":"OFDMerger::::add(java.nio.file.Path,int[])","151":"OFDMerger::::add(java.nio.file.Path,int[])","152":"OFDMerger::::add(java.nio.file.Path,int[])","153":"OFDMerger::::add(java.nio.file.Path,int[])","154":"OFDMerger::::add(java.nio.file.Path,int[])","155":"OFDMerger::::add(java.nio.file.Path,int[])","156":"OFDMerger::::add(java.nio.file.Path,int[])","157":"OFDMerger::::add(java.nio.file.Path,int[])","158":"OFDMerger::::add(java.nio.file.Path,int[])","159":"OFDMerger::::add(java.nio.file.Path,int[])","160":"OFDMerger::::add(java.nio.file.Path,int[])","161":"OFDMerger::::add(java.nio.file.Path,int[])","162":"OFDMerger::::add(java.nio.file.Path,int[])","163":"OFDMerger::::add(java.nio.file.Path,int[])","164":"OFDMerger::::add(java.nio.file.Path,int[])","165":"OFDMerger::::add(java.nio.file.Path,int[])","166":"OFDMerger::::add(java.nio.file.Path,int[])","176":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","177":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","178":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","179":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","180":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","181":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","182":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","183":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","184":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","185":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","186":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","187":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","188":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","189":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","190":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","191":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","192":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","193":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","194":"OFDMerger::::add(org.ofdrw.tool.merge.PageEntry[])","199":"OFDMerger::::doMerge()","200":"OFDMerger::::doMerge()","201":"OFDMerger::::doMerge()","202":"OFDMerger::::doMerge()","203":"OFDMerger::::doMerge()","204":"OFDMerger::::doMerge()","205":"OFDMerger::::doMerge()","206":"OFDMerger::::doMerge()","207":"OFDMerger::::doMerge()","208":"OFDMerger::::doMerge()","209":"OFDMerger::::doMerge()","210":"OFDMerger::::doMerge()","211":"OFDMerger::::doMerge()","212":"OFDMerger::::doMerge()","213":"OFDMerger::::doMerge()","214":"OFDMerger::::doMerge()","215":"OFDMerger::::doMerge()","216":"OFDMerger::::doMerge()","217":"OFDMerger::::doMerge()","218":"OFDMerger::::doMerge()","219":"OFDMerger::::doMerge()","220":"OFDMerger::::doMerge()","221":"OFDMerger::::doMerge()","222":"OFDMerger::::doMerge()","223":"OFDMerger::::doMerge()","224":"OFDMerger::::doMerge()","225":"OFDMerger::::doMerge()","226":"OFDMerger::::doMerge()","227":"OFDMerger::::doMerge()","228":"OFDMerger::::doMerge()","229":"OFDMerger::::doMerge()","230":"OFDMerger::::doMerge()","231":"OFDMerger::::doMerge()","232":"OFDMerger::::doMerge()","233":"OFDMerger::::doMerge()","234":"OFDMerger::::doMerge()","235":"OFDMerger::::doMerge()","236":"OFDMerger::::doMerge()","237":"OFDMerger::::doMerge()","238":"OFDMerger::::doMerge()","239":"OFDMerger::::doMerge()","240":"OFDMerger::::doMerge()","241":"OFDMerger::::doMerge()","242":"OFDMerger::::doMerge()","243":"OFDMerger::::doMerge()","244":"OFDMerger::::doMerge()","245":"OFDMerger::::doMerge()","246":"OFDMerger::::doMerge()","247":"OFDMerger::::doMerge()","248":"OFDMerger::::doMerge()","249":"OFDMerger::::doMerge()","250":"OFDMerger::::doMerge()","251":"OFDMerger::::doMerge()","252":"OFDMerger::::doMerge()","253":"OFDMerger::::doMerge()","254":"OFDMerger::::doMerge()","255":"OFDMerger::::doMerge()","256":"OFDMerger::::doMerge()","257":"OFDMerger::::doMerge()","258":"OFDMerger::::doMerge()","259":"OFDMerger::::doMerge()","260":"OFDMerger::::doMerge()","261":"OFDMerger::::doMerge()","262":"OFDMerger::::doMerge()","263":"OFDMerger::::doMerge()","264":"OFDMerger::::doMerge()","265":"OFDMerger::::doMerge()","266":"OFDMerger::::doMerge()","267":"OFDMerger::::doMerge()","437":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","438":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","439":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","440":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","441":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","442":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","443":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","444":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","445":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","446":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","447":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","448":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","449":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","450":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","451":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","452":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","453":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","454":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","455":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","456":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","457":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","458":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","459":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","460":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","461":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","462":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","463":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","464":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","465":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","466":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","467":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","468":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","469":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","470":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","471":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","472":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","473":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","474":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","475":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","476":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","477":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","478":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","479":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","480":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","481":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","482":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","483":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","484":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","485":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","486":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","487":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","488":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","489":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","490":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","491":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","492":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","493":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","494":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","495":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","496":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","497":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","498":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","499":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","500":"OFDMerger::::resMigrate(org.ofdrw.tool.merge.DocContext,java.lang.String)","513":"OFDMerger::::copyResFile(java.nio.file.Path)","514":"OFDMerger::::copyResFile(java.nio.file.Path)","515":"OFDMerger::::copyResFile(java.nio.file.Path)","516":"OFDMerger::::copyResFile(java.nio.file.Path)","517":"OFDMerger::::copyResFile(java.nio.file.Path)","518":"OFDMerger::::copyResFile(java.nio.file.Path)","519":"OFDMerger::::copyResFile(java.nio.file.Path)","520":"OFDMerger::::copyResFile(java.nio.file.Path)","521":"OFDMerger::::copyResFile(java.nio.file.Path)","522":"OFDMerger::::copyResFile(java.nio.file.Path)","523":"OFDMerger::::copyResFile(java.nio.file.Path)","524":"OFDMerger::::copyResFile(java.nio.file.Path)","525":"OFDMerger::::copyResFile(java.nio.file.Path)","526":"OFDMerger::::copyResFile(java.nio.file.Path)","527":"OFDMerger::::copyResFile(java.nio.file.Path)","528":"OFDMerger::::copyResFile(java.nio.file.Path)","529":"OFDMerger::::copyResFile(java.nio.file.Path)","530":"OFDMerger::::copyResFile(java.nio.file.Path)","531":"OFDMerger::::copyResFile(java.nio.file.Path)","532":"OFDMerger::::copyResFile(java.nio.file.Path)","533":"OFDMerger::::copyResFile(java.nio.file.Path)","534":"OFDMerger::::copyResFile(java.nio.file.Path)","535":"OFDMerger::::copyResFile(java.nio.file.Path)","536":"OFDMerger::::copyResFile(java.nio.file.Path)","537":"OFDMerger::::copyResFile(java.nio.file.Path)","538":"OFDMerger::::copyResFile(java.nio.file.Path)","539":"OFDMerger::::copyResFile(java.nio.file.Path)","540":"OFDMerger::::copyResFile(java.nio.file.Path)","541":"OFDMerger::::copyResFile(java.nio.file.Path)","542":"OFDMerger::::copyResFile(java.nio.file.Path)","543":"OFDMerger::::copyResFile(java.nio.file.Path)","544":"OFDMerger::::copyResFile(java.nio.file.Path)","545":"OFDMerger::::copyResFile(java.nio.file.Path)","546":"OFDMerger::::copyResFile(java.nio.file.Path)","547":"OFDMerger::::copyResFile(java.nio.file.Path)","548":"OFDMerger::::copyResFile(java.nio.file.Path)","549":"OFDMerger::::copyResFile(java.nio.file.Path)","551":"OFDMerger::::close()","552":"OFDMerger::::close()","553":"OFDMerger::::close()","554":"OFDMerger::::close()","555":"OFDMerger::::close()","556":"OFDMerger::::close()","557":"OFDMerger::::close()","558":"OFDMerger::::close()","559":"OFDMerger::::close()","560":"OFDMerger::::close()","561":"OFDMerger::::close()","562":"OFDMerger::::close()","563":"OFDMerger::::close()","564":"OFDMerger::::close()","565":"OFDMerger::::close()"},"test_reverse_method_lines_dic":{"23":"OFDMergerTest::::testMergerWatermark()","24":"OFDMergerTest::::testMergerWatermark()","25":"OFDMergerTest::::testMergerWatermark()","26":"OFDMergerTest::::testMergerWatermark()","27":"OFDMergerTest::::testMergerWatermark()","28":"OFDMergerTest::::testMergerWatermark()","29":"OFDMergerTest::::testMergerWatermark()","30":"OFDMergerTest::::testMergerWatermark()","31":"OFDMergerTest::::testMergerWatermark()","32":"OFDMergerTest::::testMergerWatermark()","33":"OFDMergerTest::::testMergerWatermark()","34":"OFDMergerTest::::testMergerWatermark()","35":"OFDMergerTest::::testMergerWatermark()","38":"OFDMergerTest::::add()","39":"OFDMergerTest::::add()","40":"OFDMergerTest::::add()","41":"OFDMergerTest::::add()","42":"OFDMergerTest::::add()","43":"OFDMergerTest::::add()","44":"OFDMergerTest::::add()","45":"OFDMergerTest::::add()","46":"OFDMergerTest::::add()","47":"OFDMergerTest::::add()","48":"OFDMergerTest::::add()","49":"OFDMergerTest::::add()","51":"OFDMergerTest::::add2()","52":"OFDMergerTest::::add2()","53":"OFDMergerTest::::add2()","54":"OFDMergerTest::::add2()","55":"OFDMergerTest::::add2()","56":"OFDMergerTest::::add2()","57":"OFDMergerTest::::add2()","58":"OFDMergerTest::::add2()","59":"OFDMergerTest::::add2()","60":"OFDMergerTest::::add2()","61":"OFDMergerTest::::add2()","62":"OFDMergerTest::::add2()"},"tests":[{"test_lines":[23,35],"covered_lines":[74,78,109,110,111,112,113,114,115,116,117,119,120,123,124,125,126,127,130,131,132,133,145,146,148,150,151,154,155,156,157,158,162,163,165,201,205,206,207,209,210,212,213,214,215,219,221,222,223,224,228,231,232,236,237,239,240,242,245,247,248,256,258,261,262,263,265,266,267,278,280,281,283,284,285,287,288,292,293,297,299,300,303,304,305,306,308,310,312,313,314,318,320,322,323,326,331,332,333,399,400,401,402,404,405,406,407,409,411,413,415,416,419,420,421,422,424,426,427,438,439,442,445,446,447,450,451,452,462,463,464,465,466,467,468,474,475,499,554,556,559,562,563,564,565],"label":"OFDMerger::::add(java.nio.file.Path,int[])"}]}}