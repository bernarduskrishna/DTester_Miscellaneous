{"/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/TrueTypeFont.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.font.constants.TrueTypeCodePages;\n", "import com.itextpdf.io.font.otf.Glyph;\n", "import com.itextpdf.io.font.otf.GlyphPositioningTableReader;\n", "import com.itextpdf.io.font.otf.GlyphSubstitutionTableReader;\n", "import com.itextpdf.io.font.otf.OpenTypeGdefTableReader;\n", "import com.itextpdf.io.logs.IoLogMessageConstant;\n", "import com.itextpdf.io.util.IntHashtable;\n", "\n", "import java.util.ArrayList;\n", "import java.util.LinkedHashMap;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Objects;\n", "import java.util.Set;\n", "import java.util.SortedSet;\n", "import java.util.stream.Collectors;\n", "import org.slf4j.Logger;\n", "import org.slf4j.LoggerFactory;\n", "\n", "public class TrueTypeFont extends FontProgram {\n", "\n", "\n", "\tprivate OpenTypeParser fontParser;\n", "\n", "    protected int[][] bBoxes;\n", "\n", "    protected boolean isVertical;\n", "\n", "    private GlyphSubstitutionTableReader gsubTable;\n", "    private GlyphPositioningTableReader gposTable;\n", "    private OpenTypeGdefTableReader gdefTable;\n", "\n", "    /**\n", "     * The map containing the kerning information. It represents the content of\n", "     * table 'kern'. The key is an <CODE>Integer</CODE> where the top 16 bits\n", "     * are the glyph number for the first character and the lower 16 bits are the\n", "     * glyph number for the second character. The value is the amount of kerning in\n", "     * normalized 1000 units as an <CODE>Integer</CODE>. This value is usually negative.\n", "     */\n", "    protected IntHashtable kerning = new IntHashtable();\n", "\n", "    private byte[] fontStreamBytes;\n", "\n", "    private TrueTypeFont(OpenTypeParser fontParser) throws java.io.IOException {\n", "        this.fontParser = fontParser;\n", "        this.fontParser.loadTables(true);\n", "        initializeFontProperties();\n", "    }\n", "\n", "    protected TrueTypeFont() {\n", "        fontNames = new FontNames();\n", "    }\n", "\n", "    public TrueTypeFont(String path) throws java.io.IOException {\n", "        this(new OpenTypeParser(path));\n", "    }\n", "\n", "    public TrueTypeFont(byte[] ttf) throws java.io.IOException {\n", "        this(new OpenTypeParser(ttf));\n", "    }\n", "\n", "    TrueTypeFont(String ttcPath, int ttcIndex) throws java.io.IOException {\n", "        this(new OpenTypeParser(ttcPath, ttcIndex));\n", "    }\n", "\n", "    TrueTypeFont(byte[] ttc, int ttcIndex) throws java.io.IOException {\n", "        this(new OpenTypeParser(ttc, ttcIndex));\n", "    }\n", "\n", "    @Override\n", "    public boolean hasKernPairs() {\n", "        return kerning.size() > 0;\n", "    }\n", "\n", "    /**\n", "     * Gets the kerning between two glyphs.\n", "     *\n", "     * @param first the first glyph\n", "     * @param second the second glyph\n", "     * @return the kerning to be applied\n", "     */\n", "    @Override\n", "    public int getKerning(Glyph first, Glyph second) {\n", "        if (first == null || second == null) {\n", "            return 0;\n", "        }\n", "        return kerning.get((first.getCode() << 16) + second.getCode());\n", "    }\n", "\n", "    public boolean isCff() {\n", "        return fontParser.isCff();\n", "    }\n", "\n", "    public Map<Integer, int[]> getActiveCmap() {\n", "        OpenTypeParser.CmapTable cmaps = fontParser.getCmapTable();\n", "        if (cmaps.cmapExt != null) {\n", "            return cmaps.cmapExt;\n", "        } else if (!cmaps.fontSpecific && cmaps.cmap31 != null) {\n", "            return cmaps.cmap31;\n", "        } else if (cmaps.fontSpecific && cmaps.cmap10 != null) {\n", "            return cmaps.cmap10;\n", "        } else if (cmaps.cmap31 != null) {\n", "            return cmaps.cmap31;\n", "        } else {\n", "            return cmaps.cmap10;\n", "        }\n", "    }\n", "\n", "    public byte[] getFontStreamBytes() {\n", "        if (fontStreamBytes != null)\n", "            return fontStreamBytes;\n", "        try {\n", "            if (fontParser.isCff()) {\n", "                fontStreamBytes = fontParser.readCffFont();\n", "            } else {\n", "                fontStreamBytes = fontParser.getFullFont();\n", "            }\n", "        } catch (java.io.IOException e) {\n", "            fontStreamBytes = null;\n", "            throw new IOException(IoExceptionMessageConstant.IO_EXCEPTION, e);\n", "        }\n", "        return fontStreamBytes;\n", "    }\n", "\n", "    @Override\n", "    public int getPdfFontFlags() {\n", "        int flags = 0;\n", "        if (fontMetrics.isFixedPitch()) {\n", "            flags |= 1;\n", "        }\n", "        flags |= isFontSpecific() ? 4 : 32;\n", "        if (fontNames.isItalic()) {\n", "            flags |= 64;\n", "        }\n", "        if (fontNames.isBold() || fontNames.getFontWeight() > 500) {\n", "            flags |= 262144;\n", "        }\n", "        return flags;\n", "    }\n", "\n", "    /**\n", "     * The offset from the start of the file to the table directory.\n", "     * It is 0 for TTF and may vary for TTC depending on the chosen font.\n", "     *\n", "     * @return directory Offset\n", "     */\n", "    public int getDirectoryOffset() {\n", "        return fontParser.directoryOffset;\n", "    }\n", "\n", "    public GlyphSubstitutionTableReader getGsubTable() {\n", "        return gsubTable;\n", "    }\n", "\n", "    public GlyphPositioningTableReader getGposTable() {\n", "        return gposTable;\n", "    }\n", "\n", "    public OpenTypeGdefTableReader getGdefTable() {\n", "        return gdefTable;\n", "    }\n", "\n", "    public byte[] getSubset(Set<Integer> glyphs, boolean subset) {\n", "        try {\n", "            return fontParser.getSubset(glyphs, subset);\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.IO_EXCEPTION, e);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Maps a set of glyph CIDs (as used in PDF file) to corresponding GID values\n", "     * (as a glyph primary identifier in the font file).\n", "     * This call is only meaningful for fonts that return true for {@link #isCff()}.\n", "     * For other types of fonts, GID and CID are always the same, so that call would essentially\n", "     * return a set of the same values.\n", "     *\n", "     * @param glyphs a set of glyph CIDs\n", "     *\n", "     * @return a set of glyph ids corresponding to the passed glyph CIDs\n", "     */\n", "    public Set<Integer> mapGlyphsCidsToGids(Set<Integer> glyphs) {\n", "        return glyphs.stream()\n", "                .map((Integer i) -> {\n", "                    Glyph usedGlyph = getGlyphByCode(i);\n", "                    if (usedGlyph instanceof GidAwareGlyph) {\n", "                        return ((GidAwareGlyph) usedGlyph).getGid();\n", "                    }\n", "                    return i;\n", "                })\n", "                .collect(Collectors.toSet());\n", "    }\n", "\n", "    protected void readGdefTable() throws java.io.IOException {\n", "        int[] gdef = fontParser.tables.get(\"GDEF\");\n", "        if (gdef != null) {\n", "            gdefTable = new OpenTypeGdefTableReader(fontParser.raf, gdef[0]);\n", "        } else {\n", "            gdefTable = new OpenTypeGdefTableReader(fontParser.raf, 0);\n", "        }\n", "        gdefTable.readTable();\n", "    }\n", "\n", "    protected void readGsubTable() throws java.io.IOException {\n", "        int[] gsub = fontParser.tables.get(\"GSUB\");\n", "        if (gsub != null) {\n", "            gsubTable = new GlyphSubstitutionTableReader(fontParser.raf, gsub[0], gdefTable, codeToGlyph, fontMetrics.getUnitsPerEm());\n", "        }\n", "    }\n", "\n", "    protected void readGposTable() throws java.io.IOException {\n", "        int[] gpos = fontParser.tables.get(\"GPOS\");\n", "        if (gpos != null) {\n", "            gposTable = new GlyphPositioningTableReader(fontParser.raf, gpos[0], gdefTable, codeToGlyph,  fontMetrics.getUnitsPerEm());\n", "        }\n", "    }\n", "\n", "    private void initializeFontProperties() throws java.io.IOException {\n", "        // initialize sfnt tables\n", "        OpenTypeParser.HeaderTable head = fontParser.getHeadTable();\n", "        OpenTypeParser.HorizontalHeader hhea = fontParser.getHheaTable();\n", "        OpenTypeParser.WindowsMetrics os_2 = fontParser.getOs_2Table();\n", "        OpenTypeParser.PostTable post = fontParser.getPostTable();\n", "        isFontSpecific = fontParser.getCmapTable().fontSpecific;\n", "        kerning = fontParser.readKerning(head.unitsPerEm);\n", "        bBoxes = fontParser.readBbox(head.unitsPerEm);\n", "\n", "        // font names group\n", "        fontNames = fontParser.getFontNames();\n", "\n", "        // font metrics group\n", "        fontMetrics.setUnitsPerEm(head.unitsPerEm);\n", "        fontMetrics.updateBbox(head.xMin, head.yMin, head.xMax, head.yMax);\n", "        fontMetrics.setNumberOfGlyphs(fontParser.readNumGlyphs());\n", "        fontMetrics.setGlyphWidths(fontParser.getGlyphWidthsByIndex());\n", "        fontMetrics.setTypoAscender(os_2.sTypoAscender);\n", "        fontMetrics.setTypoDescender(os_2.sTypoDescender);\n", "        fontMetrics.setCapHeight(os_2.sCapHeight);\n", "        fontMetrics.setXHeight(os_2.sxHeight);\n", "        fontMetrics.setItalicAngle(post.italicAngle);\n", "        fontMetrics.setAscender(hhea.Ascender);\n", "        fontMetrics.setDescender(hhea.Descender);\n", "        fontMetrics.setLineGap(hhea.LineGap);\n", "        fontMetrics.setWinAscender(os_2.usWinAscent);\n", "        fontMetrics.setWinDescender(os_2.usWinDescent);\n", "        fontMetrics.setAdvanceWidthMax(hhea.advanceWidthMax);\n", "        fontMetrics.setUnderlinePosition((post.underlinePosition - post.underlineThickness) / 2);\n", "        fontMetrics.setUnderlineThickness(post.underlineThickness);\n", "        fontMetrics.setStrikeoutPosition(os_2.yStrikeoutPosition);\n", "        fontMetrics.setStrikeoutSize(os_2.yStrikeoutSize);\n", "        fontMetrics.setSubscriptOffset(-os_2.ySubscriptYOffset);\n", "        fontMetrics.setSubscriptSize(os_2.ySubscriptYSize);\n", "        fontMetrics.setSuperscriptOffset(os_2.ySuperscriptYOffset);\n", "        fontMetrics.setSuperscriptSize(os_2.ySuperscriptYSize);\n", "        fontMetrics.setIsFixedPitch(post.isFixedPitch);\n", "\n", "        // font identification group\n", "        String[][] ttfVersion = fontNames.getNames(5);\n", "        if (ttfVersion != null) {\n", "            fontIdentification.setTtfVersion(ttfVersion[0][3]);\n", "        }\n", "        String[][] ttfUniqueId = fontNames.getNames(3);\n", "        if (ttfUniqueId != null) {\n", "            fontIdentification.setTtfVersion(ttfUniqueId[0][3]);\n", "        }\n", "\n", "        byte[] pdfPanose = new byte[12];\n", "        pdfPanose[1] = (byte) (os_2.sFamilyClass);\n", "        pdfPanose[0] = (byte) (os_2.sFamilyClass >> 8);\n", "        System.arraycopy(os_2.panose, 0, pdfPanose, 2, 10);\n", "        fontIdentification.setPanose(pdfPanose);\n", "\n", "        Map<Integer, int[]> cmap = getActiveCmap();\n", "        int[] glyphWidths = fontParser.getGlyphWidthsByIndex();\n", "        int numOfGlyphs = fontMetrics.getNumberOfGlyphs();\n", "        unicodeToGlyph = new LinkedHashMap<>(cmap.size());\n", "        codeToGlyph = new LinkedHashMap<>(numOfGlyphs);\n", "        avgWidth = 0;\n", "        CFFFontSubset cffFontSubset = null;\n", "        if (isCff()) {\n", "            cffFontSubset = new CFFFontSubset(getFontStreamBytes());\n", "        }\n", "        for (int charCode : cmap.keySet()) {\n", "            int index = cmap.get(charCode)[0];\n", "            if (index >= numOfGlyphs) {\n", "                Logger LOGGER = LoggerFactory.getLogger(TrueTypeFont.class);\n", "                LOGGER.warn(MessageFormatUtil.format(IoLogMessageConstant.FONT_HAS_INVALID_GLYPH,\n", "                        getFontNames().getFontName(), index));\n", "                continue;\n", "            }\n", "            int cid;\n", "            Glyph glyph;\n", "            int[] glyphBBox = bBoxes != null ? bBoxes[index] : null;\n", "            if (cffFontSubset != null && cffFontSubset.isCID()) {\n", "                cid = cffFontSubset.getCidForGlyphId(index);\n", "                GidAwareGlyph cffGlyph = new GidAwareGlyph(cid, glyphWidths[index], charCode, glyphBBox);\n", "                cffGlyph.setGid(index);\n", "                glyph = cffGlyph;\n", "            } else {\n", "                cid = index;\n", "                glyph = new Glyph(cid, glyphWidths[index], charCode, glyphBBox);\n", "            }\n", "\n", "            unicodeToGlyph.put(charCode, glyph);\n", "            // This is done on purpose to keep the mapping to glyphs with smaller unicode values, in contrast with\n", "            // larger values which often represent different forms of other characters.\n", "            if (!codeToGlyph.containsKey(cid)) {\n", "                codeToGlyph.put(cid, glyph);\n", "            }\n", "            avgWidth += glyph.getWidth();\n", "        }\n", "        fixSpaceIssue();\n", "        for (int index = 0; index < glyphWidths.length; index++) {\n", "            if (codeToGlyph.containsKey(index)) {\n", "                continue;\n", "            }\n", "            Glyph glyph = new Glyph(index, glyphWidths[index], -1);\n", "            codeToGlyph.put(index, glyph);\n", "            avgWidth += glyph.getWidth();\n", "        }\n", "\n", "        if (codeToGlyph.size() != 0) {\n", "            avgWidth /= codeToGlyph.size();\n", "        }\n", "\n", "        readGdefTable();\n", "        readGsubTable();\n", "        readGposTable();\n", "\n", "        isVertical = false;\n", "    }\n", "\n", "    /**\n", "     * Gets the code pages supported by the font.\n", "     *\n", "     * @return the code pages supported by the font\n", "     */\n", "    public String[] getCodePagesSupported() {\n", "        long cp = ((long) fontParser.getOs_2Table().ulCodePageRange2 << 32) + (fontParser.getOs_2Table().ulCodePageRange1 & 0xffffffffL);\n", "        int count = 0;\n", "        long bit = 1;\n", "        for (int k = 0; k < 64; ++k) {\n", "            if ((cp & bit) != 0 && TrueTypeCodePages.get(k) != null)\n", "                ++count;\n", "            bit <<= 1;\n", "        }\n", "        String[] ret = new String[count];\n", "        count = 0;\n", "        bit = 1;\n", "        for (int k = 0; k < 64; ++k) {\n", "            if ((cp & bit) != 0 && TrueTypeCodePages.get(k) != null)\n", "                ret[count++] = TrueTypeCodePages.get(k);\n", "            bit <<= 1;\n", "        }\n", "        return ret;\n", "    }\n", "\n", "    @Override\n", "    public boolean isBuiltWith(String fontProgram) {\n", "        return Objects.equals(fontParser.fileName, fontProgram);\n", "    }\n", "\n", "    public void close() throws java.io.IOException {\n", "        if (fontParser != null) {\n", "            fontParser.close();\n", "        }\n", "        fontParser = null;\n", "    }\n", "\n", "    /**\n", "     * The method will update usedGlyphs with additional range or with all glyphs if there is no subset.\n", "     * This set of used glyphs can be used for building width array and ToUnicode CMAP.\n", "     *\n", "     * @param usedGlyphs a set of integers, which are glyph ids that denote used glyphs.\n", "     *                   This set is updated inside of the method if needed.\n", "     * @param subset subset status\n", "     * @param subsetRanges additional subset ranges\n", "     */\n", "    public void updateUsedGlyphs(SortedSet<Integer> usedGlyphs, boolean subset, List<int[]> subsetRanges) {\n", "        int[] compactRange;\n", "        if (subsetRanges != null) {\n", "            compactRange = toCompactRange(subsetRanges);\n", "        } else if (!subset) {\n", "            compactRange = new int[] {0, 0xFFFF};\n", "        } else {\n", "            compactRange = new int[] {};\n", "        }\n", "\n", "        for (int k = 0; k < compactRange.length; k += 2) {\n", "            int from = compactRange[k];\n", "            int to = compactRange[k + 1];\n", "            for (int glyphId = from; glyphId <= to; glyphId++) {\n", "                if (getGlyphByCode(glyphId) != null) {\n", "                    usedGlyphs.add(glyphId);\n", "                }\n", "            }\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Normalizes given ranges by making sure that first values in pairs are lower than second values and merges overlapping\n", "     * ranges in one.\n", "     * @param ranges a {@link List} of integer arrays, which are constituted by pairs of ints that denote\n", "     *               each range limits. Each integer array size shall be a multiple of two.\n", "     * @return single merged array consisting of pairs of integers, each of them denoting a range.\n", "     */\n", "    private static int[] toCompactRange(List<int[]> ranges) {\n", "        List<int[]> simp = new ArrayList<>();\n", "        for (int[] range : ranges) {\n", "            for (int j = 0; j < range.length; j += 2) {\n", "                simp.add(new int[]{Math.max(0, Math.min(range[j], range[j + 1])), Math.min(0xffff, Math.max(range[j], range[j + 1]))});\n", "            }\n", "        }\n", "        for (int k1 = 0; k1 < simp.size() - 1; ++k1) {\n", "            for (int k2 = k1 + 1; k2 < simp.size(); ++k2) {\n", "                int[] r1 = simp.get(k1);\n", "                int[] r2 = simp.get(k2);\n", "                if (r1[0] >= r2[0] && r1[0] <= r2[1] || r1[1] >= r2[0] && r1[0] <= r2[1]) {\n", "                    r1[0] = Math.min(r1[0], r2[0]);\n", "                    r1[1] = Math.max(r1[1], r2[1]);\n", "                    simp.remove(k2);\n", "                    --k2;\n", "                }\n", "            }\n", "        }\n", "        int[] s = new int[simp.size() * 2];\n", "        for (int k = 0; k < simp.size(); ++k) {\n", "            int[] r = simp.get(k);\n", "            s[k * 2] = r[0];\n", "            s[k * 2 + 1] = r[1];\n", "        }\n", "        return s;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.font.otf.Glyph;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.Collections;\n", "import java.util.HashSet;\n", "import java.util.List;\n", "import java.util.Set;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class TrueTypeFontTest extends ExtendedITextTest {\n", "    private static final String SOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/sharedFontsResourceFiles/\";\n", "\n", "    @Test\n", "    public void notoSansJpCmapTest() throws IOException, InterruptedException {\n", "        // \u4fe1\n", "        char jpChar = '\\u4FE1';\n", "\n", "        FontProgram fontProgram = FontProgramFactory.createFont(SOURCE_FOLDER + \"NotoSansJP-Regular_charsetDataFormat0.otf\");\n", "        Glyph glyph = fontProgram.getGlyph(jpChar);\n", "\n", "        Assert.assertArrayEquals(new char[] {jpChar}, glyph.getUnicodeChars());\n", "        Assert.assertEquals(20449, glyph.getUnicode());\n", "        Assert.assertEquals(10195, glyph.getCode());\n", "    }\n", "\n", "    @Test\n", "    public void notoSansScCmapTest() throws IOException {\n", "        // \u6613\n", "        char chChar = '\\u6613';\n", "\n", "        FontProgram fontProgram = FontProgramFactory.createFont(SOURCE_FOLDER + \"NotoSansSC-Regular.otf\");\n", "        Glyph glyph = fontProgram.getGlyph(chChar);\n", "\n", "        Assert.assertArrayEquals(new char[] {chChar}, glyph.getUnicodeChars());\n", "        Assert.assertEquals(26131, glyph.getUnicode());\n", "        Assert.assertEquals(20292, glyph.getCode());\n", "    }\n", "\n", "    @Test\n", "    public void notoSansTcCmapTest() throws IOException {\n", "        // \u6613\n", "        char chChar = '\\u6613';\n", "\n", "        FontProgram fontProgram = FontProgramFactory.createFont(SOURCE_FOLDER + \"NotoSansTC-Regular.otf\");\n", "        Glyph glyph = fontProgram.getGlyph(chChar);\n", "\n", "        Assert.assertArrayEquals(new char[] {chChar}, glyph.getUnicodeChars());\n", "        Assert.assertEquals(26131, glyph.getUnicode());\n", "        Assert.assertEquals(20292, glyph.getCode());\n", "    }\n", "\n", "    @Test\n", "    public void notoSansScMapGlyphsCidsToGidsTest() throws IOException {\n", "        // \u6613\n", "        char chChar = '\\u6613';\n", "        int charCidInFont = 20292;\n", "        int charGidInFont = 14890;\n", "\n", "        TrueTypeFont trueTypeFontProgram = (TrueTypeFont) FontProgramFactory.createFont(SOURCE_FOLDER + \"NotoSansSC-Regular.otf\");\n", "\n", "        HashSet<Integer> glyphs = new HashSet<>(Collections.singletonList(charCidInFont));\n", "        Set<Integer> actualResult = trueTypeFontProgram.mapGlyphsCidsToGids(glyphs);\n", "\n", "        Assert.assertEquals(1, actualResult.size());\n", "        Assert.assertTrue(actualResult.contains(charGidInFont));\n", "    }\n", "}\n"], "method_lines_dic": {"TrueTypeFont::::hasKernPairs()": [97, 100], "TrueTypeFont::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)": [109, 115], "TrueTypeFont::::isCff()": [117, 119], "TrueTypeFont::::getActiveCmap()": [121, 134], "TrueTypeFont::::getFontStreamBytes()": [136, 150], "TrueTypeFont::::getPdfFontFlags()": [152, 166], "TrueTypeFont::::getDirectoryOffset()": [174, 176], "TrueTypeFont::::getGsubTable()": [178, 180], "TrueTypeFont::::getGposTable()": [182, 184], "TrueTypeFont::::getGdefTable()": [186, 188], "TrueTypeFont::::getSubset(java.util.Set<java.lang.Integer>,boolean)": [190, 196], "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)": [209, 219], "TrueTypeFont::::readGdefTable()": [221, 229], "TrueTypeFont::::readGsubTable()": [231, 236], "TrueTypeFont::::readGposTable()": [238, 243], "TrueTypeFont::::initializeFontProperties()": [245, 358], "TrueTypeFont::::getCodePagesSupported()": [365, 383], "TrueTypeFont::::isBuiltWith(java.lang.String)": [385, 388], "TrueTypeFont::::close()": [390, 395], "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)": [406, 425], "TrueTypeFont::::toCompactRange(java.util.List<int[]>)": [434, 460]}, "test_method_lines_dic": {"TrueTypeFontTest::::notoSansJpCmapTest()": [44, 55], "TrueTypeFontTest::::notoSansScCmapTest()": [57, 68], "TrueTypeFontTest::::notoSansTcCmapTest()": [70, 81], "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()": [83, 97]}, "reverse_method_lines_dic": {"97": "TrueTypeFont::::hasKernPairs()", "98": "TrueTypeFont::::hasKernPairs()", "99": "TrueTypeFont::::hasKernPairs()", "100": "TrueTypeFont::::hasKernPairs()", "109": "TrueTypeFont::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "110": "TrueTypeFont::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "111": "TrueTypeFont::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "112": "TrueTypeFont::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "113": "TrueTypeFont::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "114": "TrueTypeFont::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "115": "TrueTypeFont::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "117": "TrueTypeFont::::isCff()", "118": "TrueTypeFont::::isCff()", "119": "TrueTypeFont::::isCff()", "121": "TrueTypeFont::::getActiveCmap()", "122": "TrueTypeFont::::getActiveCmap()", "123": "TrueTypeFont::::getActiveCmap()", "124": "TrueTypeFont::::getActiveCmap()", "125": "TrueTypeFont::::getActiveCmap()", "126": "TrueTypeFont::::getActiveCmap()", "127": "TrueTypeFont::::getActiveCmap()", "128": "TrueTypeFont::::getActiveCmap()", "129": "TrueTypeFont::::getActiveCmap()", "130": "TrueTypeFont::::getActiveCmap()", "131": "TrueTypeFont::::getActiveCmap()", "132": "TrueTypeFont::::getActiveCmap()", "133": "TrueTypeFont::::getActiveCmap()", "134": "TrueTypeFont::::getActiveCmap()", "136": "TrueTypeFont::::getFontStreamBytes()", "137": "TrueTypeFont::::getFontStreamBytes()", "138": "TrueTypeFont::::getFontStreamBytes()", "139": "TrueTypeFont::::getFontStreamBytes()", "140": "TrueTypeFont::::getFontStreamBytes()", "141": "TrueTypeFont::::getFontStreamBytes()", "142": "TrueTypeFont::::getFontStreamBytes()", "143": "TrueTypeFont::::getFontStreamBytes()", "144": "TrueTypeFont::::getFontStreamBytes()", "145": "TrueTypeFont::::getFontStreamBytes()", "146": "TrueTypeFont::::getFontStreamBytes()", "147": "TrueTypeFont::::getFontStreamBytes()", "148": "TrueTypeFont::::getFontStreamBytes()", "149": "TrueTypeFont::::getFontStreamBytes()", "150": "TrueTypeFont::::getFontStreamBytes()", "152": "TrueTypeFont::::getPdfFontFlags()", "153": "TrueTypeFont::::getPdfFontFlags()", "154": "TrueTypeFont::::getPdfFontFlags()", "155": "TrueTypeFont::::getPdfFontFlags()", "156": "TrueTypeFont::::getPdfFontFlags()", "157": "TrueTypeFont::::getPdfFontFlags()", "158": "TrueTypeFont::::getPdfFontFlags()", "159": "TrueTypeFont::::getPdfFontFlags()", "160": "TrueTypeFont::::getPdfFontFlags()", "161": "TrueTypeFont::::getPdfFontFlags()", "162": "TrueTypeFont::::getPdfFontFlags()", "163": "TrueTypeFont::::getPdfFontFlags()", "164": "TrueTypeFont::::getPdfFontFlags()", "165": "TrueTypeFont::::getPdfFontFlags()", "166": "TrueTypeFont::::getPdfFontFlags()", "174": "TrueTypeFont::::getDirectoryOffset()", "175": "TrueTypeFont::::getDirectoryOffset()", "176": "TrueTypeFont::::getDirectoryOffset()", "178": "TrueTypeFont::::getGsubTable()", "179": "TrueTypeFont::::getGsubTable()", "180": "TrueTypeFont::::getGsubTable()", "182": "TrueTypeFont::::getGposTable()", "183": "TrueTypeFont::::getGposTable()", "184": "TrueTypeFont::::getGposTable()", "186": "TrueTypeFont::::getGdefTable()", "187": "TrueTypeFont::::getGdefTable()", "188": "TrueTypeFont::::getGdefTable()", "190": "TrueTypeFont::::getSubset(java.util.Set<java.lang.Integer>,boolean)", "191": "TrueTypeFont::::getSubset(java.util.Set<java.lang.Integer>,boolean)", "192": "TrueTypeFont::::getSubset(java.util.Set<java.lang.Integer>,boolean)", "193": "TrueTypeFont::::getSubset(java.util.Set<java.lang.Integer>,boolean)", "194": "TrueTypeFont::::getSubset(java.util.Set<java.lang.Integer>,boolean)", "195": "TrueTypeFont::::getSubset(java.util.Set<java.lang.Integer>,boolean)", "196": "TrueTypeFont::::getSubset(java.util.Set<java.lang.Integer>,boolean)", "209": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "210": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "211": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "212": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "213": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "214": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "215": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "216": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "217": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "218": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "219": "TrueTypeFont::::mapGlyphsCidsToGids(java.util.Set<java.lang.Integer>)", "221": "TrueTypeFont::::readGdefTable()", "222": "TrueTypeFont::::readGdefTable()", "223": "TrueTypeFont::::readGdefTable()", "224": "TrueTypeFont::::readGdefTable()", "225": "TrueTypeFont::::readGdefTable()", "226": "TrueTypeFont::::readGdefTable()", "227": "TrueTypeFont::::readGdefTable()", "228": "TrueTypeFont::::readGdefTable()", "229": "TrueTypeFont::::readGdefTable()", "231": "TrueTypeFont::::readGsubTable()", "232": "TrueTypeFont::::readGsubTable()", "233": "TrueTypeFont::::readGsubTable()", "234": "TrueTypeFont::::readGsubTable()", "235": "TrueTypeFont::::readGsubTable()", "236": "TrueTypeFont::::readGsubTable()", "238": "TrueTypeFont::::readGposTable()", "239": "TrueTypeFont::::readGposTable()", "240": "TrueTypeFont::::readGposTable()", "241": "TrueTypeFont::::readGposTable()", "242": "TrueTypeFont::::readGposTable()", "243": "TrueTypeFont::::readGposTable()", "245": "TrueTypeFont::::initializeFontProperties()", "246": "TrueTypeFont::::initializeFontProperties()", "247": "TrueTypeFont::::initializeFontProperties()", "248": "TrueTypeFont::::initializeFontProperties()", "249": "TrueTypeFont::::initializeFontProperties()", "250": "TrueTypeFont::::initializeFontProperties()", "251": "TrueTypeFont::::initializeFontProperties()", "252": "TrueTypeFont::::initializeFontProperties()", "253": "TrueTypeFont::::initializeFontProperties()", "254": "TrueTypeFont::::initializeFontProperties()", "255": "TrueTypeFont::::initializeFontProperties()", "256": "TrueTypeFont::::initializeFontProperties()", "257": "TrueTypeFont::::initializeFontProperties()", "258": "TrueTypeFont::::initializeFontProperties()", "259": "TrueTypeFont::::initializeFontProperties()", "260": "TrueTypeFont::::initializeFontProperties()", "261": "TrueTypeFont::::initializeFontProperties()", "262": "TrueTypeFont::::initializeFontProperties()", "263": "TrueTypeFont::::initializeFontProperties()", "264": "TrueTypeFont::::initializeFontProperties()", "265": "TrueTypeFont::::initializeFontProperties()", "266": "TrueTypeFont::::initializeFontProperties()", "267": "TrueTypeFont::::initializeFontProperties()", "268": "TrueTypeFont::::initializeFontProperties()", "269": "TrueTypeFont::::initializeFontProperties()", "270": "TrueTypeFont::::initializeFontProperties()", "271": "TrueTypeFont::::initializeFontProperties()", "272": "TrueTypeFont::::initializeFontProperties()", "273": "TrueTypeFont::::initializeFontProperties()", "274": "TrueTypeFont::::initializeFontProperties()", "275": "TrueTypeFont::::initializeFontProperties()", "276": "TrueTypeFont::::initializeFontProperties()", "277": "TrueTypeFont::::initializeFontProperties()", "278": "TrueTypeFont::::initializeFontProperties()", "279": "TrueTypeFont::::initializeFontProperties()", "280": "TrueTypeFont::::initializeFontProperties()", "281": "TrueTypeFont::::initializeFontProperties()", "282": "TrueTypeFont::::initializeFontProperties()", "283": "TrueTypeFont::::initializeFontProperties()", "284": "TrueTypeFont::::initializeFontProperties()", "285": "TrueTypeFont::::initializeFontProperties()", "286": "TrueTypeFont::::initializeFontProperties()", "287": "TrueTypeFont::::initializeFontProperties()", "288": "TrueTypeFont::::initializeFontProperties()", "289": "TrueTypeFont::::initializeFontProperties()", "290": "TrueTypeFont::::initializeFontProperties()", "291": "TrueTypeFont::::initializeFontProperties()", "292": "TrueTypeFont::::initializeFontProperties()", "293": "TrueTypeFont::::initializeFontProperties()", "294": "TrueTypeFont::::initializeFontProperties()", "295": "TrueTypeFont::::initializeFontProperties()", "296": "TrueTypeFont::::initializeFontProperties()", "297": "TrueTypeFont::::initializeFontProperties()", "298": "TrueTypeFont::::initializeFontProperties()", "299": "TrueTypeFont::::initializeFontProperties()", "300": "TrueTypeFont::::initializeFontProperties()", "301": "TrueTypeFont::::initializeFontProperties()", "302": "TrueTypeFont::::initializeFontProperties()", "303": "TrueTypeFont::::initializeFontProperties()", "304": "TrueTypeFont::::initializeFontProperties()", "305": "TrueTypeFont::::initializeFontProperties()", "306": "TrueTypeFont::::initializeFontProperties()", "307": "TrueTypeFont::::initializeFontProperties()", "308": "TrueTypeFont::::initializeFontProperties()", "309": "TrueTypeFont::::initializeFontProperties()", "310": "TrueTypeFont::::initializeFontProperties()", "311": "TrueTypeFont::::initializeFontProperties()", "312": "TrueTypeFont::::initializeFontProperties()", "313": "TrueTypeFont::::initializeFontProperties()", "314": "TrueTypeFont::::initializeFontProperties()", "315": "TrueTypeFont::::initializeFontProperties()", "316": "TrueTypeFont::::initializeFontProperties()", "317": "TrueTypeFont::::initializeFontProperties()", "318": "TrueTypeFont::::initializeFontProperties()", "319": "TrueTypeFont::::initializeFontProperties()", "320": "TrueTypeFont::::initializeFontProperties()", "321": "TrueTypeFont::::initializeFontProperties()", "322": "TrueTypeFont::::initializeFontProperties()", "323": "TrueTypeFont::::initializeFontProperties()", "324": "TrueTypeFont::::initializeFontProperties()", "325": "TrueTypeFont::::initializeFontProperties()", "326": "TrueTypeFont::::initializeFontProperties()", "327": "TrueTypeFont::::initializeFontProperties()", "328": "TrueTypeFont::::initializeFontProperties()", "329": "TrueTypeFont::::initializeFontProperties()", "330": "TrueTypeFont::::initializeFontProperties()", "331": "TrueTypeFont::::initializeFontProperties()", "332": "TrueTypeFont::::initializeFontProperties()", "333": "TrueTypeFont::::initializeFontProperties()", "334": "TrueTypeFont::::initializeFontProperties()", "335": "TrueTypeFont::::initializeFontProperties()", "336": "TrueTypeFont::::initializeFontProperties()", "337": "TrueTypeFont::::initializeFontProperties()", "338": "TrueTypeFont::::initializeFontProperties()", "339": "TrueTypeFont::::initializeFontProperties()", "340": "TrueTypeFont::::initializeFontProperties()", "341": "TrueTypeFont::::initializeFontProperties()", "342": "TrueTypeFont::::initializeFontProperties()", "343": "TrueTypeFont::::initializeFontProperties()", "344": "TrueTypeFont::::initializeFontProperties()", "345": "TrueTypeFont::::initializeFontProperties()", "346": "TrueTypeFont::::initializeFontProperties()", "347": "TrueTypeFont::::initializeFontProperties()", "348": "TrueTypeFont::::initializeFontProperties()", "349": "TrueTypeFont::::initializeFontProperties()", "350": "TrueTypeFont::::initializeFontProperties()", "351": "TrueTypeFont::::initializeFontProperties()", "352": "TrueTypeFont::::initializeFontProperties()", "353": "TrueTypeFont::::initializeFontProperties()", "354": "TrueTypeFont::::initializeFontProperties()", "355": "TrueTypeFont::::initializeFontProperties()", "356": "TrueTypeFont::::initializeFontProperties()", "357": "TrueTypeFont::::initializeFontProperties()", "358": "TrueTypeFont::::initializeFontProperties()", "365": "TrueTypeFont::::getCodePagesSupported()", "366": "TrueTypeFont::::getCodePagesSupported()", "367": "TrueTypeFont::::getCodePagesSupported()", "368": "TrueTypeFont::::getCodePagesSupported()", "369": "TrueTypeFont::::getCodePagesSupported()", "370": "TrueTypeFont::::getCodePagesSupported()", "371": "TrueTypeFont::::getCodePagesSupported()", "372": "TrueTypeFont::::getCodePagesSupported()", "373": "TrueTypeFont::::getCodePagesSupported()", "374": "TrueTypeFont::::getCodePagesSupported()", "375": "TrueTypeFont::::getCodePagesSupported()", "376": "TrueTypeFont::::getCodePagesSupported()", "377": "TrueTypeFont::::getCodePagesSupported()", "378": "TrueTypeFont::::getCodePagesSupported()", "379": "TrueTypeFont::::getCodePagesSupported()", "380": "TrueTypeFont::::getCodePagesSupported()", "381": "TrueTypeFont::::getCodePagesSupported()", "382": "TrueTypeFont::::getCodePagesSupported()", "383": "TrueTypeFont::::getCodePagesSupported()", "385": "TrueTypeFont::::isBuiltWith(java.lang.String)", "386": "TrueTypeFont::::isBuiltWith(java.lang.String)", "387": "TrueTypeFont::::isBuiltWith(java.lang.String)", "388": "TrueTypeFont::::isBuiltWith(java.lang.String)", "390": "TrueTypeFont::::close()", "391": "TrueTypeFont::::close()", "392": "TrueTypeFont::::close()", "393": "TrueTypeFont::::close()", "394": "TrueTypeFont::::close()", "395": "TrueTypeFont::::close()", "406": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "407": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "408": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "409": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "410": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "411": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "412": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "413": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "414": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "415": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "416": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "417": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "418": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "419": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "420": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "421": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "422": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "423": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "424": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "425": "TrueTypeFont::::updateUsedGlyphs(java.util.SortedSet<java.lang.Integer>,boolean,java.util.List<int[]>)", "434": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "435": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "436": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "437": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "438": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "439": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "440": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "441": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "442": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "443": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "444": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "445": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "446": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "447": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "448": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "449": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "450": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "451": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "452": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "453": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "454": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "455": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "456": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "457": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "458": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "459": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)", "460": "TrueTypeFont::::toCompactRange(java.util.List<int[]>)"}, "test_reverse_method_lines_dic": {"44": "TrueTypeFontTest::::notoSansJpCmapTest()", "45": "TrueTypeFontTest::::notoSansJpCmapTest()", "46": "TrueTypeFontTest::::notoSansJpCmapTest()", "47": "TrueTypeFontTest::::notoSansJpCmapTest()", "48": "TrueTypeFontTest::::notoSansJpCmapTest()", "49": "TrueTypeFontTest::::notoSansJpCmapTest()", "50": "TrueTypeFontTest::::notoSansJpCmapTest()", "51": "TrueTypeFontTest::::notoSansJpCmapTest()", "52": "TrueTypeFontTest::::notoSansJpCmapTest()", "53": "TrueTypeFontTest::::notoSansJpCmapTest()", "54": "TrueTypeFontTest::::notoSansJpCmapTest()", "55": "TrueTypeFontTest::::notoSansJpCmapTest()", "57": "TrueTypeFontTest::::notoSansScCmapTest()", "58": "TrueTypeFontTest::::notoSansScCmapTest()", "59": "TrueTypeFontTest::::notoSansScCmapTest()", "60": "TrueTypeFontTest::::notoSansScCmapTest()", "61": "TrueTypeFontTest::::notoSansScCmapTest()", "62": "TrueTypeFontTest::::notoSansScCmapTest()", "63": "TrueTypeFontTest::::notoSansScCmapTest()", "64": "TrueTypeFontTest::::notoSansScCmapTest()", "65": "TrueTypeFontTest::::notoSansScCmapTest()", "66": "TrueTypeFontTest::::notoSansScCmapTest()", "67": "TrueTypeFontTest::::notoSansScCmapTest()", "68": "TrueTypeFontTest::::notoSansScCmapTest()", "70": "TrueTypeFontTest::::notoSansTcCmapTest()", "71": "TrueTypeFontTest::::notoSansTcCmapTest()", "72": "TrueTypeFontTest::::notoSansTcCmapTest()", "73": "TrueTypeFontTest::::notoSansTcCmapTest()", "74": "TrueTypeFontTest::::notoSansTcCmapTest()", "75": "TrueTypeFontTest::::notoSansTcCmapTest()", "76": "TrueTypeFontTest::::notoSansTcCmapTest()", "77": "TrueTypeFontTest::::notoSansTcCmapTest()", "78": "TrueTypeFontTest::::notoSansTcCmapTest()", "79": "TrueTypeFontTest::::notoSansTcCmapTest()", "80": "TrueTypeFontTest::::notoSansTcCmapTest()", "81": "TrueTypeFontTest::::notoSansTcCmapTest()", "83": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "84": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "85": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "86": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "87": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "88": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "89": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "90": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "91": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "92": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "93": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "94": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "95": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "96": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()", "97": "TrueTypeFontTest::::notoSansScMapGlyphsCidsToGidsTest()"}, "tests": [{"test_lines": [44, 55], "covered_lines": [67, 71, 72, 73, 74, 75, 82, 83, 118, 122, 123, 124, 137, 140, 141, 148, 149, 222, 223, 224, 228, 229, 232, 233, 234, 236, 239, 240, 241, 243, 247, 248, 249, 250, 251, 252, 253, 256, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 285, 286, 287, 289, 290, 291, 294, 295, 296, 297, 298, 300, 301, 302, 303, 304, 305, 306, 307, 308, 310, 311, 312, 320, 321, 322, 323, 324, 325, 326, 331, 334, 335, 337, 338, 339, 340, 341, 342, 344, 345, 346, 349, 350, 353, 354, 355, 357, 358]}, {"test_lines": [57, 68], "covered_lines": [67, 71, 72, 73, 74, 75, 82, 83, 118, 122, 123, 124, 137, 140, 141, 148, 149, 222, 223, 224, 228, 229, 232, 233, 234, 236, 239, 240, 241, 243, 247, 248, 249, 250, 251, 252, 253, 256, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 285, 286, 287, 289, 290, 291, 294, 295, 296, 297, 298, 300, 301, 302, 303, 304, 305, 306, 307, 308, 310, 311, 312, 320, 321, 322, 323, 324, 325, 326, 331, 334, 335, 337, 338, 339, 340, 341, 342, 344, 345, 346, 349, 350, 353, 354, 355, 357, 358]}, {"test_lines": [70, 81], "covered_lines": [67, 71, 72, 73, 74, 75, 82, 83, 118, 122, 123, 124, 137, 140, 141, 148, 149, 222, 223, 224, 228, 229, 232, 233, 234, 236, 239, 240, 241, 243, 247, 248, 249, 250, 251, 252, 253, 256, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 285, 286, 287, 289, 290, 291, 294, 295, 296, 297, 298, 300, 301, 302, 303, 304, 305, 306, 307, 308, 310, 311, 312, 320, 321, 322, 323, 324, 325, 326, 331, 334, 335, 337, 338, 339, 340, 341, 342, 344, 345, 346, 349, 350, 353, 354, 355, 357, 358]}, {"test_lines": [83, 97], "covered_lines": [67, 71, 72, 73, 74, 75, 82, 83, 118, 122, 123, 124, 137, 140, 141, 148, 149, 210, 211, 212, 213, 214, 218, 222, 223, 224, 228, 229, 232, 233, 234, 236, 239, 240, 241, 243, 247, 248, 249, 250, 251, 252, 253, 256, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 285, 286, 287, 289, 290, 291, 294, 295, 296, 297, 298, 300, 301, 302, 303, 304, 305, 306, 307, 308, 310, 311, 312, 320, 321, 322, 323, 324, 325, 326, 331, 334, 335, 337, 338, 339, 340, 341, 342, 344, 345, 346, 349, 350, 353, 354, 355, 357, 358]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/FontCache.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.font.cmap.CMapByteCid;\n", "import com.itextpdf.io.font.cmap.CMapCidToCodepoint;\n", "import com.itextpdf.io.font.cmap.CMapCidUni;\n", "import com.itextpdf.io.font.cmap.CMapCodepointToCid;\n", "import com.itextpdf.io.font.cmap.CMapUniCid;\n", "\n", "import java.util.Map;\n", "import java.util.Set;\n", "import java.util.concurrent.ConcurrentHashMap;\n", "\n", "public class FontCache {\n", "\n", "    private static Map<FontCacheKey, FontProgram> fontCache = new ConcurrentHashMap<>();\n", "\n", "    /**\n", "     * Checks if the font with the given name and encoding is one\n", "     * of the predefined CID fonts.\n", "     *\n", "     * @param fontName the font name.\n", "     * @return {@code true} if it is CJKFont.\n", "     * @deprecated in favour of {@link CjkResourceLoader}.\n", "     */\n", "    @Deprecated\n", "    protected static boolean isPredefinedCidFont(String fontName) {\n", "        return CjkResourceLoader.isPredefinedCidFont(fontName);\n", "    }\n", "\n", "    /**\n", "     * Finds a CJK font family which is compatible to the given CMap.\n", "     *\n", "     * @param cmap a name of the CMap for which compatible font is searched.\n", "     * @return a CJK font name if there's known compatible font for the given cmap name, or null otherwise.\n", "     * @deprecated in favour of {@link CjkResourceLoader}.\n", "     */\n", "    @Deprecated\n", "    public static String getCompatibleCidFont(String cmap) {\n", "        return CjkResourceLoader.getCompatibleCidFont(cmap);\n", "    }\n", "\n", "    /**\n", "     * Finds all CMap names that belong to the same registry to which a given\n", "     * font belongs.\n", "     *\n", "     * @param fontName a name of the font for which CMap's are searched.\n", "     * @return a set of CMap names corresponding to the given font.\n", "     * @deprecated in favour of {@link CjkResourceLoader}.\n", "     */\n", "    @Deprecated\n", "    public static Set<String> getCompatibleCmaps(String fontName) {\n", "        return CjkResourceLoader.getCompatibleCmaps(fontName);\n", "    }\n", "\n", "    @Deprecated\n", "    public static Map<String, Map<String, Object>> getAllPredefinedCidFonts() {\n", "        return CjkResourceLoader.getAllPredefinedCidFonts();\n", "    }\n", "\n", "    @Deprecated\n", "    public static Map<String, Set<String>> getRegistryNames() {\n", "        return CjkResourceLoader.getRegistryNames();\n", "    }\n", "\n", "    /**\n", "     * Parses CMap with a given name producing it in a form of cid to unicode mapping.\n", "     *\n", "     * @param uniMap a CMap name. It is expected that CMap identified by this name defines unicode to cid mapping.\n", "     * @return an object for convenient mapping from cid to unicode. If no CMap was found for provided name an exception is thrown.\n", "     * @deprecated in favour of {@link CjkResourceLoader}.\n", "     */\n", "    @Deprecated\n", "    public static CMapCidUni getCid2UniCmap(String uniMap) {\n", "        return CjkResourceLoader.getCid2UniCmap(uniMap);\n", "    }\n", "\n", "    @Deprecated\n", "    public static CMapUniCid getUni2CidCmap(String uniMap) {\n", "        return CjkResourceLoader.getUni2CidCmap(uniMap);\n", "    }\n", "\n", "    @Deprecated\n", "    public static CMapByteCid getByte2CidCmap(String cmap) {\n", "        return CjkResourceLoader.getByte2CidCmap(cmap);\n", "    }\n", "\n", "    @Deprecated\n", "    public static CMapCidToCodepoint getCidToCodepointCmap(String cmap) {\n", "        return CjkResourceLoader.getCidToCodepointCmap(cmap);\n", "    }\n", "\n", "    @Deprecated\n", "    public static CMapCodepointToCid getCodepointToCidCmap(String uniMap) {\n", "        return CjkResourceLoader.getCodepointToCidCmap(uniMap);\n", "    }\n", "\n", "    /**\n", "     * Clears the cache by removing fonts that were added via {@link #saveFont(FontProgram, String)}.\n", "     * <p>\n", "     * Be aware that in multithreading environment this method call will affect the result of {@link #getFont(String)}.\n", "     * This in its turn affects creation of fonts via factories when {@code cached} argument is set to true (which is by default).\n", "     */\n", "    public static void clearSavedFonts() {\n", "        fontCache.clear();\n", "    }\n", "\n", "    public static FontProgram getFont(String fontName) {\n", "        return fontCache.get(FontCacheKey.create(fontName));\n", "    }\n", "\n", "    static FontProgram getFont(FontCacheKey key) {\n", "        return fontCache.get(key);\n", "    }\n", "\n", "    public static FontProgram saveFont(FontProgram font, String fontName) {\n", "        return saveFont(font, FontCacheKey.create(fontName));\n", "    }\n", "\n", "    static FontProgram saveFont(FontProgram font, FontCacheKey key) {\n", "        FontProgram fontFound = fontCache.get(key);\n", "        if (fontFound != null) {\n", "            return fontFound;\n", "        }\n", "        fontCache.put(key, font);\n", "        return font;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.font.otf.Glyph;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.nio.charset.StandardCharsets;\n", "import org.junit.Assert;\n", "import org.junit.Before;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class FontCacheTest extends ExtendedITextTest {\n", "\n", "    @Before\n", "    public void before() {\n", "        FontCache.clearSavedFonts();\n", "    }\n", "\n", "    @Test\n", "    public void clearFontCacheTest() {\n", "        String fontName = \"FreeSans.ttf\";\n", "        Assert.assertNull(FontCache.getFont(fontName));\n", "\n", "        FontProgram fontProgram = new FontProgramMock();\n", "        FontCache.saveFont(fontProgram, fontName);\n", "        Assert.assertEquals(fontProgram, FontCache.getFont(fontName));\n", "\n", "        FontCache.clearSavedFonts();\n", "        Assert.assertNull(FontCache.getFont(fontName));\n", "    }\n", "\n", "    @Test\n", "    public void fontStringTtcCacheKeyTest() {\n", "        String fontName = \"Font.ttc\";\n", "\n", "        FontCacheKey ttc0 = FontCacheKey.create(fontName, 0);\n", "        FontCacheKey ttc1 = FontCacheKey.create(fontName, 1);\n", "\n", "        Assert.assertNull(FontCache.getFont(ttc0));\n", "        Assert.assertNull(FontCache.getFont(ttc1));\n", "\n", "        FontProgram fontProgram = new FontProgramMock();\n", "        FontCache.saveFont(fontProgram, ttc1);\n", "\n", "        Assert.assertNull(FontCache.getFont(ttc0));\n", "        Assert.assertEquals(fontProgram, FontCache.getFont(ttc1));\n", "    }\n", "\n", "    @Test\n", "    public void fontBytesTtcCacheKeyTest() {\n", "        byte[] fontBytes = \"SupposedTtcFontData\".getBytes(StandardCharsets.UTF_8);\n", "        byte[] otherFontBytes = \"DifferentTtcFontBytes\".getBytes(StandardCharsets.UTF_8);\n", "        byte[] normalFontBytes = \"NormalFontBytes\".getBytes(StandardCharsets.UTF_8);\n", "\n", "        FontCacheKey ttc0 = FontCacheKey.create(fontBytes, 1);\n", "        FontCacheKey otherTtc0 = FontCacheKey.create(otherFontBytes, 1);\n", "        FontCacheKey normal = FontCacheKey.create(normalFontBytes);\n", "\n", "        Assert.assertNull(FontCache.getFont(ttc0));\n", "        Assert.assertNull(FontCache.getFont(otherTtc0));\n", "        Assert.assertNull(FontCache.getFont(normal));\n", "\n", "        FontProgram otherTtc0MockFontProgram = new FontProgramMock();\n", "        FontProgram normalMockFontProgram = new FontProgramMock();\n", "        FontCache.saveFont(otherTtc0MockFontProgram, otherTtc0);\n", "        FontCache.saveFont(normalMockFontProgram, normal);\n", "\n", "        Assert.assertNull(FontCache.getFont(ttc0));\n", "        Assert.assertEquals(otherTtc0MockFontProgram, FontCache.getFont(otherTtc0));\n", "        Assert.assertEquals(normalMockFontProgram, FontCache.getFont(normal));\n", "    }\n", "\n", "    private static class FontProgramMock extends FontProgram {\n", "\n", "        @Override\n", "        public int getPdfFontFlags() {\n", "            return 0;\n", "        }\n", "\n", "        @Override\n", "        public int getKerning(Glyph first, Glyph second) {\n", "            return 0;\n", "        }\n", "    }\n", "}\n"], "method_lines_dic": {"FontCache::::isPredefinedCidFont(java.lang.String)": [47, 50], "FontCache::::getCompatibleCidFont(java.lang.String)": [59, 62], "FontCache::::getCompatibleCmaps(java.lang.String)": [72, 75], "FontCache::::getAllPredefinedCidFonts()": [77, 80], "FontCache::::getRegistryNames()": [82, 85], "FontCache::::getCid2UniCmap(java.lang.String)": [94, 97], "FontCache::::getUni2CidCmap(java.lang.String)": [99, 102], "FontCache::::getByte2CidCmap(java.lang.String)": [104, 107], "FontCache::::getCidToCodepointCmap(java.lang.String)": [109, 112], "FontCache::::getCodepointToCidCmap(java.lang.String)": [114, 117], "FontCache::::clearSavedFonts()": [125, 127], "FontCache::::getFont(java.lang.String)": [129, 131], "FontCache::::getFont(com.itextpdf.io.font.FontCacheKey)": [133, 135], "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,java.lang.String)": [137, 139], "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.FontCacheKey)": [141, 148]}, "test_method_lines_dic": {"FontCacheTest::::before()": [38, 41], "FontCacheTest::::clearFontCacheTest()": [43, 54], "FontCacheTest::::fontStringTtcCacheKeyTest()": [56, 71], "FontCacheTest::::fontBytesTtcCacheKeyTest()": [73, 95], "FontCacheTest.FontProgramMock::::getPdfFontFlags()": [99, 102]}, "reverse_method_lines_dic": {"47": "FontCache::::isPredefinedCidFont(java.lang.String)", "48": "FontCache::::isPredefinedCidFont(java.lang.String)", "49": "FontCache::::isPredefinedCidFont(java.lang.String)", "50": "FontCache::::isPredefinedCidFont(java.lang.String)", "59": "FontCache::::getCompatibleCidFont(java.lang.String)", "60": "FontCache::::getCompatibleCidFont(java.lang.String)", "61": "FontCache::::getCompatibleCidFont(java.lang.String)", "62": "FontCache::::getCompatibleCidFont(java.lang.String)", "72": "FontCache::::getCompatibleCmaps(java.lang.String)", "73": "FontCache::::getCompatibleCmaps(java.lang.String)", "74": "FontCache::::getCompatibleCmaps(java.lang.String)", "75": "FontCache::::getCompatibleCmaps(java.lang.String)", "77": "FontCache::::getAllPredefinedCidFonts()", "78": "FontCache::::getAllPredefinedCidFonts()", "79": "FontCache::::getAllPredefinedCidFonts()", "80": "FontCache::::getAllPredefinedCidFonts()", "82": "FontCache::::getRegistryNames()", "83": "FontCache::::getRegistryNames()", "84": "FontCache::::getRegistryNames()", "85": "FontCache::::getRegistryNames()", "94": "FontCache::::getCid2UniCmap(java.lang.String)", "95": "FontCache::::getCid2UniCmap(java.lang.String)", "96": "FontCache::::getCid2UniCmap(java.lang.String)", "97": "FontCache::::getCid2UniCmap(java.lang.String)", "99": "FontCache::::getUni2CidCmap(java.lang.String)", "100": "FontCache::::getUni2CidCmap(java.lang.String)", "101": "FontCache::::getUni2CidCmap(java.lang.String)", "102": "FontCache::::getUni2CidCmap(java.lang.String)", "104": "FontCache::::getByte2CidCmap(java.lang.String)", "105": "FontCache::::getByte2CidCmap(java.lang.String)", "106": "FontCache::::getByte2CidCmap(java.lang.String)", "107": "FontCache::::getByte2CidCmap(java.lang.String)", "109": "FontCache::::getCidToCodepointCmap(java.lang.String)", "110": "FontCache::::getCidToCodepointCmap(java.lang.String)", "111": "FontCache::::getCidToCodepointCmap(java.lang.String)", "112": "FontCache::::getCidToCodepointCmap(java.lang.String)", "114": "FontCache::::getCodepointToCidCmap(java.lang.String)", "115": "FontCache::::getCodepointToCidCmap(java.lang.String)", "116": "FontCache::::getCodepointToCidCmap(java.lang.String)", "117": "FontCache::::getCodepointToCidCmap(java.lang.String)", "125": "FontCache::::clearSavedFonts()", "126": "FontCache::::clearSavedFonts()", "127": "FontCache::::clearSavedFonts()", "129": "FontCache::::getFont(java.lang.String)", "130": "FontCache::::getFont(java.lang.String)", "131": "FontCache::::getFont(java.lang.String)", "133": "FontCache::::getFont(com.itextpdf.io.font.FontCacheKey)", "134": "FontCache::::getFont(com.itextpdf.io.font.FontCacheKey)", "135": "FontCache::::getFont(com.itextpdf.io.font.FontCacheKey)", "137": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,java.lang.String)", "138": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,java.lang.String)", "139": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,java.lang.String)", "141": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.FontCacheKey)", "142": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.FontCacheKey)", "143": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.FontCacheKey)", "144": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.FontCacheKey)", "145": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.FontCacheKey)", "146": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.FontCacheKey)", "147": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.FontCacheKey)", "148": "FontCache::::saveFont(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.FontCacheKey)"}, "test_reverse_method_lines_dic": {"38": "FontCacheTest::::before()", "39": "FontCacheTest::::before()", "40": "FontCacheTest::::before()", "41": "FontCacheTest::::before()", "43": "FontCacheTest::::clearFontCacheTest()", "44": "FontCacheTest::::clearFontCacheTest()", "45": "FontCacheTest::::clearFontCacheTest()", "46": "FontCacheTest::::clearFontCacheTest()", "47": "FontCacheTest::::clearFontCacheTest()", "48": "FontCacheTest::::clearFontCacheTest()", "49": "FontCacheTest::::clearFontCacheTest()", "50": "FontCacheTest::::clearFontCacheTest()", "51": "FontCacheTest::::clearFontCacheTest()", "52": "FontCacheTest::::clearFontCacheTest()", "53": "FontCacheTest::::clearFontCacheTest()", "54": "FontCacheTest::::clearFontCacheTest()", "56": "FontCacheTest::::fontStringTtcCacheKeyTest()", "57": "FontCacheTest::::fontStringTtcCacheKeyTest()", "58": "FontCacheTest::::fontStringTtcCacheKeyTest()", "59": "FontCacheTest::::fontStringTtcCacheKeyTest()", "60": "FontCacheTest::::fontStringTtcCacheKeyTest()", "61": "FontCacheTest::::fontStringTtcCacheKeyTest()", "62": "FontCacheTest::::fontStringTtcCacheKeyTest()", "63": "FontCacheTest::::fontStringTtcCacheKeyTest()", "64": "FontCacheTest::::fontStringTtcCacheKeyTest()", "65": "FontCacheTest::::fontStringTtcCacheKeyTest()", "66": "FontCacheTest::::fontStringTtcCacheKeyTest()", "67": "FontCacheTest::::fontStringTtcCacheKeyTest()", "68": "FontCacheTest::::fontStringTtcCacheKeyTest()", "69": "FontCacheTest::::fontStringTtcCacheKeyTest()", "70": "FontCacheTest::::fontStringTtcCacheKeyTest()", "71": "FontCacheTest::::fontStringTtcCacheKeyTest()", "73": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "74": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "75": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "76": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "77": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "78": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "79": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "80": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "81": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "82": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "83": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "84": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "85": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "86": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "87": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "88": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "89": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "90": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "91": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "92": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "93": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "94": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "95": "FontCacheTest::::fontBytesTtcCacheKeyTest()", "99": "FontCacheTest.FontProgramMock::::getPdfFontFlags()", "100": "FontCacheTest.FontProgramMock::::getPdfFontFlags()", "101": "FontCacheTest.FontProgramMock::::getPdfFontFlags()", "102": "FontCacheTest.FontProgramMock::::getPdfFontFlags()"}, "tests": [{"test_lines": [43, 54], "covered_lines": [37, 126, 127, 130, 138, 142, 143, 146, 147]}, {"test_lines": [56, 71], "covered_lines": [37, 126, 127, 134, 142, 143, 146, 147]}, {"test_lines": [73, 95], "covered_lines": [37, 126, 127, 134, 142, 143, 146, 147]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/FontProgram.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.font.constants.FontMacStyleFlags;\n", "import com.itextpdf.io.font.constants.FontStretches;\n", "import com.itextpdf.io.font.constants.FontWeights;\n", "import com.itextpdf.io.font.otf.Glyph;\n", "\n", "import java.util.HashMap;\n", "import java.util.Map;\n", "\n", "public abstract class FontProgram {\n", "\n", "    public static final int HORIZONTAL_SCALING_FACTOR = 100;\n", "    public static final int DEFAULT_WIDTH = 1000;\n", "    public static final int UNITS_NORMALIZATION = 1000;\n", "\n", "\n", "    public static float convertTextSpaceToGlyphSpace(float value) {\n", "        return value / UNITS_NORMALIZATION;\n", "    }\n", "\n", "    public static float convertGlyphSpaceToTextSpace(float value) {\n", "        return value * UNITS_NORMALIZATION;\n", "    }\n", "\n", "    public static double convertGlyphSpaceToTextSpace(double value) {\n", "        return value * UNITS_NORMALIZATION;\n", "    }\n", "\n", "    public static int convertGlyphSpaceToTextSpace(int value) {\n", "        return value * UNITS_NORMALIZATION;\n", "    }\n", "\n", "    // In case Type1: char code to glyph.\n", "    // In case TrueType: glyph index to glyph.\n", "    protected Map<Integer, Glyph> codeToGlyph = new HashMap<>();\n", "    protected Map<Integer, Glyph> unicodeToGlyph = new HashMap<>();\n", "    protected boolean isFontSpecific;\n", "\n", "    protected FontNames fontNames;\n", "    protected FontMetrics fontMetrics = new FontMetrics();\n", "    protected FontIdentification fontIdentification = new FontIdentification();\n", "\n", "    protected int avgWidth;\n", "\n", "    /**\n", "     * The font's encoding name. This encoding is 'StandardEncoding' or 'AdobeStandardEncoding' for a font\n", "     * that can be totally encoded according to the characters names. For all other names the font is treated as\n", "     * symbolic.\n", "     */\n", "    protected String encodingScheme = FontEncoding.FONT_SPECIFIC;\n", "\n", "    protected String registry;\n", "\n", "    public int countOfGlyphs() {\n", "        return Math.max(codeToGlyph.size(), unicodeToGlyph.size());\n", "    }\n", "\n", "    public FontNames getFontNames() {\n", "        return fontNames;\n", "    }\n", "\n", "    public FontMetrics getFontMetrics() {\n", "        return fontMetrics;\n", "    }\n", "\n", "    public FontIdentification getFontIdentification() {\n", "        return fontIdentification;\n", "    }\n", "\n", "    public String getRegistry() {\n", "        return registry;\n", "    }\n", "\n", "    public abstract int getPdfFontFlags();\n", "\n", "    public boolean isFontSpecific() {\n", "        return isFontSpecific;\n", "    }\n", "\n", "    /**\n", "     * Get glyph's width.\n", "     *\n", "     * @param unicode a unicode symbol or FontSpecif code.\n", "     *\n", "     * @return Gets width in normalized 1000 units.\n", "     */\n", "    public int getWidth(int unicode) {\n", "        Glyph glyph = getGlyph(unicode);\n", "        return glyph != null ? glyph.getWidth() : 0;\n", "    }\n", "\n", "    public int getAvgWidth() {\n", "        return avgWidth;\n", "    }\n", "\n", "    /**\n", "     * Get glyph's bbox.\n", "     *\n", "     * @param unicode a unicode symbol or FontSpecif code.\n", "     *\n", "     * @return Gets bbox in normalized 1000 units.\n", "     */\n", "    public int[] getCharBBox(int unicode) {\n", "        Glyph glyph = getGlyph(unicode);\n", "        return glyph != null ? glyph.getBbox() : null;\n", "    }\n", "\n", "    public Glyph getGlyph(int unicode) {\n", "        return unicodeToGlyph.get(unicode);\n", "    }\n", "\n", "    // char code in case Type1 or index in case OpenType\n", "    public Glyph getGlyphByCode(int charCode) {\n", "        return codeToGlyph.get(charCode);\n", "    }\n", "\n", "    public boolean hasKernPairs() {\n", "        return false;\n", "    }\n", "\n", "    /**\n", "     * Gets the kerning between two glyphs.\n", "     *\n", "     * @param first  the first unicode value\n", "     * @param second the second unicode value\n", "     *\n", "     * @return the kerning to be applied\n", "     */\n", "    public int getKerning(int first, int second) {\n", "        return getKerning(unicodeToGlyph.get(first), unicodeToGlyph.get(second));\n", "    }\n", "\n", "    /**\n", "     * Gets the kerning between two glyphs.\n", "     *\n", "     * @param first  the first glyph\n", "     * @param second the second glyph\n", "     *\n", "     * @return the kerning to be applied\n", "     */\n", "    public abstract int getKerning(Glyph first, Glyph second);\n", "\n", "    /**\n", "     * Checks whether the {@link FontProgram} was built with corresponding fontName.\n", "     * Default value is false unless overridden.\n", "     *\n", "     * @param fontName a font name or path to a font program\n", "     *\n", "     * @return true, if the FontProgram was built with the fontProgram. Otherwise false.\n", "     */\n", "    public boolean isBuiltWith(String fontName) {\n", "        return false;\n", "    }\n", "\n", "    protected void setRegistry(String registry) {\n", "        this.registry = registry;\n", "    }\n", "\n", "    /**\n", "     * Gets the name without the modifiers Bold, Italic or BoldItalic.\n", "     *\n", "     * @param name the full name of the font\n", "     *\n", "     * @return the name without the modifiers Bold, Italic or BoldItalic\n", "     */\n", "    static String trimFontStyle(String name) {\n", "        if (name == null) {\n", "            return null;\n", "        }\n", "        if (name.endsWith(\",Bold\")) {\n", "            return name.substring(0, name.length() - 5);\n", "        } else if (name.endsWith(\",Italic\")) {\n", "            return name.substring(0, name.length() - 7);\n", "        } else if (name.endsWith(\",BoldItalic\")) {\n", "            return name.substring(0, name.length() - 11);\n", "        } else {\n", "            return name;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Sets typo ascender. See also {@link FontMetrics#setTypoAscender(int)}.\n", "     *\n", "     * @param ascender typo ascender value in 1000-units\n", "     */\n", "    protected void setTypoAscender(int ascender) {\n", "        fontMetrics.setTypoAscender(ascender);\n", "    }\n", "\n", "    /**\n", "     * Sets typo descender. See also {@link FontMetrics#setTypoDescender(int)}.\n", "     *\n", "     * @param descender typo descender value in 1000-units\n", "     */\n", "    protected void setTypoDescender(int descender) {\n", "        fontMetrics.setTypoDescender(descender);\n", "    }\n", "\n", "    /**\n", "     * Sets the capital letters height. See also {@link FontMetrics#setCapHeight(int)}.\n", "     *\n", "     * @param capHeight cap height in 1000-units\n", "     */\n", "    protected void setCapHeight(int capHeight) {\n", "        fontMetrics.setCapHeight(capHeight);\n", "    }\n", "\n", "    protected void setXHeight(int xHeight) {\n", "        fontMetrics.setXHeight(xHeight);\n", "    }\n", "\n", "    /**\n", "     * Sets the PostScript italic angle.\n", "     *\n", "     * <p>\n", "     * Italic angle in counter-clockwise degrees from the vertical. Zero for upright text, negative for text that leans\n", "     * to the right (forward).\n", "     *\n", "     * @param italicAngle in counter-clockwise degrees from the vertical\n", "     */\n", "    protected void setItalicAngle(int italicAngle) {\n", "        fontMetrics.setItalicAngle(italicAngle);\n", "    }\n", "\n", "    protected void setStemV(int stemV) {\n", "        fontMetrics.setStemV(stemV);\n", "    }\n", "\n", "    protected void setStemH(int stemH) {\n", "        fontMetrics.setStemH(stemH);\n", "    }\n", "\n", "    /**\n", "     * Sets font weight.\n", "     *\n", "     * @param fontWeight integer form 100 to 900. See {@link FontWeights}.\n", "     */\n", "    protected void setFontWeight(int fontWeight) {\n", "        fontNames.setFontWeight(fontWeight);\n", "    }\n", "\n", "    /**\n", "     * Sets font width in css notation (font-stretch property)\n", "     *\n", "     * @param fontWidth {@link FontStretches}.\n", "     */\n", "    protected void setFontStretch(String fontWidth) {\n", "        fontNames.setFontStretch(fontWidth);\n", "    }\n", "\n", "    protected void setFixedPitch(boolean isFixedPitch) {\n", "        fontMetrics.setIsFixedPitch(isFixedPitch);\n", "    }\n", "\n", "    protected void setBold(boolean isBold) {\n", "        if (isBold) {\n", "            fontNames.setMacStyle(fontNames.getMacStyle() | FontMacStyleFlags.BOLD);\n", "        } else {\n", "            fontNames.setMacStyle(fontNames.getMacStyle() & (~FontMacStyleFlags.BOLD));\n", "        }\n", "    }\n", "\n", "    protected void setBbox(int[] bbox) {\n", "        fontMetrics.setBbox(bbox[0], bbox[1], bbox[2], bbox[3]);\n", "    }\n", "\n", "    /**\n", "     * Sets a preferred font family name.\n", "     *\n", "     * @param fontFamily a preferred font family name.\n", "     */\n", "    protected void setFontFamily(String fontFamily) {\n", "        fontNames.setFamilyName(fontFamily);\n", "    }\n", "\n", "    /**\n", "     * Sets the PostScript name of the font.\n", "     * <p>\n", "     * If full name is null, it will be set as well.\n", "     *\n", "     * @param fontName the PostScript name of the font, shall not be null or empty.\n", "     */\n", "    protected void setFontName(String fontName) {\n", "        fontNames.setFontName(fontName);\n", "        if (fontNames.getFullName() == null) {\n", "            fontNames.setFullName(fontName);\n", "        }\n", "    }\n", "\n", "    protected void fixSpaceIssue() {\n", "        Glyph space = unicodeToGlyph.get(32);\n", "        if (space != null) {\n", "            codeToGlyph.put(space.getCode(), space);\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "        String name = getFontNames().getFontName();\n", "        return name != null && name.length() > 0 ? name : super.toString();\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.font.constants.StandardFonts;\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "import com.itextpdf.io.font.otf.Glyph;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "import java.io.IOException;\n", "\n", "\n", "@Category(UnitTest.class)\n", "public class FontProgramTest extends ExtendedITextTest {\n", "    private static final String notExistingFont = \"some-font.ttf\";\n", "\n", "    @Test\n", "    public void exceptionMessageTest() throws IOException {\n", "        Exception e = Assert.assertThrows(java.io.IOException.class,\n", "                () -> FontProgramFactory.createFont(notExistingFont)\n", "        );\n", "        Assert.assertEquals(MessageFormatUtil.format(IoExceptionMessageConstant.NOT_FOUND_AS_FILE_OR_RESOURCE, notExistingFont), e.getMessage());\n", "    }\n", "\n", "    @Test\n", "    public void boldTest() throws IOException {\n", "        FontProgram fp = FontProgramFactory.createFont(StandardFonts.HELVETICA);\n", "        fp.setBold(true);\n", "        Assert.assertTrue(\"Bold expected\", (fp.getPdfFontFlags() & (1 << 18)) != 0);\n", "        fp.setBold(false);\n", "        Assert.assertTrue(\"Not Bold expected\", (fp.getPdfFontFlags() & (1 << 18)) == 0);\n", "    }\n", "\n", "    @Test\n", "    public void registerDirectoryOpenTypeTest() {\n", "        FontProgramFactory.clearRegisteredFonts();\n", "        FontProgramFactory.clearRegisteredFontFamilies();\n", "        FontCache.clearSavedFonts();\n", "        FontProgramFactory.registerFontDirectory(\"./src/test/resources/com/itextpdf/io/font/otf/\");\n", "\n", "        Assert.assertEquals(43, FontProgramFactory.getRegisteredFonts().size());\n", "        Assert.assertNull(FontCache.getFont(\"./src/test/resources/com/itextpdf/io/font/otf/FreeSansBold.ttf\"));\n", "        Assert.assertTrue(FontProgramFactory.getRegisteredFonts().contains(\"free sans lihavoitu\"));\n", "    }\n", "\n", "    @Test\n", "    public void registerDirectoryType1Test() throws IOException {\n", "        FontProgramFactory.registerFontDirectory(\"./src/test/resources/com/itextpdf/io/font/type1/\");\n", "        FontProgram computerModern = FontProgramFactory.createRegisteredFont(\"computer modern\");\n", "        FontProgram cmr10 = FontProgramFactory.createRegisteredFont(\"cmr10\");\n", "        Assert.assertNotNull(computerModern);\n", "        Assert.assertNotNull(cmr10);\n", "    }\n", "\n", "    @Test\n", "    public void cidFontWithCmapTest() throws IOException {\n", "        char space = ' ';\n", "\n", "        FontProgram fp = FontProgramFactory.createFont(\"KozMinPro-Regular\", \"UniJIS-UCS2-HW-H\", true);\n", "        Glyph glyph = fp.getGlyph(space);\n", "\n", "        Assert.assertArrayEquals(new char[] {space}, glyph.getUnicodeChars());\n", "        Assert.assertEquals(32, glyph.getUnicode());\n", "        Assert.assertEquals(231, glyph.getCode());\n", "        Assert.assertEquals(500, glyph.getWidth());\n", "\n", "        fp = FontProgramFactory.createFont(\"KozMinPro-Regular\", null, true);\n", "        glyph = fp.getGlyph(space);\n", "\n", "        Assert.assertArrayEquals(new char[] {space}, glyph.getUnicodeChars());\n", "        Assert.assertEquals(32, glyph.getUnicode());\n", "        Assert.assertEquals(1, glyph.getCode());\n", "        Assert.assertEquals(278, glyph.getWidth());\n", "    }\n", "}\n"], "method_lines_dic": {"FontProgram::::convertTextSpaceToGlyphSpace(float)": [40, 42], "FontProgram::::convertGlyphSpaceToTextSpace(float)": [44, 46], "FontProgram::::convertGlyphSpaceToTextSpace(double)": [48, 50], "FontProgram::::convertGlyphSpaceToTextSpace(int)": [52, 54], "FontProgram::::countOfGlyphs()": [77, 79], "FontProgram::::getFontNames()": [81, 83], "FontProgram::::getFontMetrics()": [85, 87], "FontProgram::::getFontIdentification()": [89, 91], "FontProgram::::getRegistry()": [93, 95], "FontProgram::::getPdfFontFlags()": [97, 97], "FontProgram::::isFontSpecific()": [99, 101], "FontProgram::::getWidth(int)": [110, 113], "FontProgram::::getAvgWidth()": [115, 117], "FontProgram::::getCharBBox(int)": [126, 129], "FontProgram::::getGlyph(int)": [131, 133], "FontProgram::::getGlyphByCode(int)": [136, 138], "FontProgram::::hasKernPairs()": [140, 142], "FontProgram::::getKerning(int,int)": [152, 154], "FontProgram::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)": [164, 164], "FontProgram::::isBuiltWith(java.lang.String)": [174, 176], "FontProgram::::setRegistry(java.lang.String)": [178, 180], "FontProgram::::trimFontStyle(java.lang.String)": [189, 202], "FontProgram::::setTypoAscender(int)": [209, 211], "FontProgram::::setTypoDescender(int)": [218, 220], "FontProgram::::setCapHeight(int)": [227, 229], "FontProgram::::setXHeight(int)": [231, 233], "FontProgram::::setItalicAngle(int)": [244, 246], "FontProgram::::setStemV(int)": [248, 250], "FontProgram::::setStemH(int)": [252, 254], "FontProgram::::setFontWeight(int)": [261, 263], "FontProgram::::setFontStretch(java.lang.String)": [270, 272], "FontProgram::::setFixedPitch(boolean)": [274, 276], "FontProgram::::setBold(boolean)": [278, 284], "FontProgram::::setBbox(int[])": [286, 288], "FontProgram::::setFontFamily(java.lang.String)": [295, 297], "FontProgram::::setFontName(java.lang.String)": [306, 311], "FontProgram::::fixSpaceIssue()": [313, 318], "FontProgram::::toString()": [320, 324]}, "test_method_lines_dic": {"FontProgramTest::::exceptionMessageTest()": [42, 48], "FontProgramTest::::boldTest()": [50, 57], "FontProgramTest::::registerDirectoryOpenTypeTest()": [59, 69], "FontProgramTest::::registerDirectoryType1Test()": [71, 78], "FontProgramTest::::cidFontWithCmapTest()": [80, 99]}, "reverse_method_lines_dic": {"40": "FontProgram::::convertTextSpaceToGlyphSpace(float)", "41": "FontProgram::::convertTextSpaceToGlyphSpace(float)", "42": "FontProgram::::convertTextSpaceToGlyphSpace(float)", "44": "FontProgram::::convertGlyphSpaceToTextSpace(float)", "45": "FontProgram::::convertGlyphSpaceToTextSpace(float)", "46": "FontProgram::::convertGlyphSpaceToTextSpace(float)", "48": "FontProgram::::convertGlyphSpaceToTextSpace(double)", "49": "FontProgram::::convertGlyphSpaceToTextSpace(double)", "50": "FontProgram::::convertGlyphSpaceToTextSpace(double)", "52": "FontProgram::::convertGlyphSpaceToTextSpace(int)", "53": "FontProgram::::convertGlyphSpaceToTextSpace(int)", "54": "FontProgram::::convertGlyphSpaceToTextSpace(int)", "77": "FontProgram::::countOfGlyphs()", "78": "FontProgram::::countOfGlyphs()", "79": "FontProgram::::countOfGlyphs()", "81": "FontProgram::::getFontNames()", "82": "FontProgram::::getFontNames()", "83": "FontProgram::::getFontNames()", "85": "FontProgram::::getFontMetrics()", "86": "FontProgram::::getFontMetrics()", "87": "FontProgram::::getFontMetrics()", "89": "FontProgram::::getFontIdentification()", "90": "FontProgram::::getFontIdentification()", "91": "FontProgram::::getFontIdentification()", "93": "FontProgram::::getRegistry()", "94": "FontProgram::::getRegistry()", "95": "FontProgram::::getRegistry()", "97": "FontProgram::::getPdfFontFlags()", "99": "FontProgram::::isFontSpecific()", "100": "FontProgram::::isFontSpecific()", "101": "FontProgram::::isFontSpecific()", "110": "FontProgram::::getWidth(int)", "111": "FontProgram::::getWidth(int)", "112": "FontProgram::::getWidth(int)", "113": "FontProgram::::getWidth(int)", "115": "FontProgram::::getAvgWidth()", "116": "FontProgram::::getAvgWidth()", "117": "FontProgram::::getAvgWidth()", "126": "FontProgram::::getCharBBox(int)", "127": "FontProgram::::getCharBBox(int)", "128": "FontProgram::::getCharBBox(int)", "129": "FontProgram::::getCharBBox(int)", "131": "FontProgram::::getGlyph(int)", "132": "FontProgram::::getGlyph(int)", "133": "FontProgram::::getGlyph(int)", "136": "FontProgram::::getGlyphByCode(int)", "137": "FontProgram::::getGlyphByCode(int)", "138": "FontProgram::::getGlyphByCode(int)", "140": "FontProgram::::hasKernPairs()", "141": "FontProgram::::hasKernPairs()", "142": "FontProgram::::hasKernPairs()", "152": "FontProgram::::getKerning(int,int)", "153": "FontProgram::::getKerning(int,int)", "154": "FontProgram::::getKerning(int,int)", "164": "FontProgram::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "174": "FontProgram::::isBuiltWith(java.lang.String)", "175": "FontProgram::::isBuiltWith(java.lang.String)", "176": "FontProgram::::isBuiltWith(java.lang.String)", "178": "FontProgram::::setRegistry(java.lang.String)", "179": "FontProgram::::setRegistry(java.lang.String)", "180": "FontProgram::::setRegistry(java.lang.String)", "189": "FontProgram::::trimFontStyle(java.lang.String)", "190": "FontProgram::::trimFontStyle(java.lang.String)", "191": "FontProgram::::trimFontStyle(java.lang.String)", "192": "FontProgram::::trimFontStyle(java.lang.String)", "193": "FontProgram::::trimFontStyle(java.lang.String)", "194": "FontProgram::::trimFontStyle(java.lang.String)", "195": "FontProgram::::trimFontStyle(java.lang.String)", "196": "FontProgram::::trimFontStyle(java.lang.String)", "197": "FontProgram::::trimFontStyle(java.lang.String)", "198": "FontProgram::::trimFontStyle(java.lang.String)", "199": "FontProgram::::trimFontStyle(java.lang.String)", "200": "FontProgram::::trimFontStyle(java.lang.String)", "201": "FontProgram::::trimFontStyle(java.lang.String)", "202": "FontProgram::::trimFontStyle(java.lang.String)", "209": "FontProgram::::setTypoAscender(int)", "210": "FontProgram::::setTypoAscender(int)", "211": "FontProgram::::setTypoAscender(int)", "218": "FontProgram::::setTypoDescender(int)", "219": "FontProgram::::setTypoDescender(int)", "220": "FontProgram::::setTypoDescender(int)", "227": "FontProgram::::setCapHeight(int)", "228": "FontProgram::::setCapHeight(int)", "229": "FontProgram::::setCapHeight(int)", "231": "FontProgram::::setXHeight(int)", "232": "FontProgram::::setXHeight(int)", "233": "FontProgram::::setXHeight(int)", "244": "FontProgram::::setItalicAngle(int)", "245": "FontProgram::::setItalicAngle(int)", "246": "FontProgram::::setItalicAngle(int)", "248": "FontProgram::::setStemV(int)", "249": "FontProgram::::setStemV(int)", "250": "FontProgram::::setStemV(int)", "252": "FontProgram::::setStemH(int)", "253": "FontProgram::::setStemH(int)", "254": "FontProgram::::setStemH(int)", "261": "FontProgram::::setFontWeight(int)", "262": "FontProgram::::setFontWeight(int)", "263": "FontProgram::::setFontWeight(int)", "270": "FontProgram::::setFontStretch(java.lang.String)", "271": "FontProgram::::setFontStretch(java.lang.String)", "272": "FontProgram::::setFontStretch(java.lang.String)", "274": "FontProgram::::setFixedPitch(boolean)", "275": "FontProgram::::setFixedPitch(boolean)", "276": "FontProgram::::setFixedPitch(boolean)", "278": "FontProgram::::setBold(boolean)", "279": "FontProgram::::setBold(boolean)", "280": "FontProgram::::setBold(boolean)", "281": "FontProgram::::setBold(boolean)", "282": "FontProgram::::setBold(boolean)", "283": "FontProgram::::setBold(boolean)", "284": "FontProgram::::setBold(boolean)", "286": "FontProgram::::setBbox(int[])", "287": "FontProgram::::setBbox(int[])", "288": "FontProgram::::setBbox(int[])", "295": "FontProgram::::setFontFamily(java.lang.String)", "296": "FontProgram::::setFontFamily(java.lang.String)", "297": "FontProgram::::setFontFamily(java.lang.String)", "306": "FontProgram::::setFontName(java.lang.String)", "307": "FontProgram::::setFontName(java.lang.String)", "308": "FontProgram::::setFontName(java.lang.String)", "309": "FontProgram::::setFontName(java.lang.String)", "310": "FontProgram::::setFontName(java.lang.String)", "311": "FontProgram::::setFontName(java.lang.String)", "313": "FontProgram::::fixSpaceIssue()", "314": "FontProgram::::fixSpaceIssue()", "315": "FontProgram::::fixSpaceIssue()", "316": "FontProgram::::fixSpaceIssue()", "317": "FontProgram::::fixSpaceIssue()", "318": "FontProgram::::fixSpaceIssue()", "320": "FontProgram::::toString()", "321": "FontProgram::::toString()", "322": "FontProgram::::toString()", "323": "FontProgram::::toString()", "324": "FontProgram::::toString()"}, "test_reverse_method_lines_dic": {"42": "FontProgramTest::::exceptionMessageTest()", "43": "FontProgramTest::::exceptionMessageTest()", "44": "FontProgramTest::::exceptionMessageTest()", "45": "FontProgramTest::::exceptionMessageTest()", "46": "FontProgramTest::::exceptionMessageTest()", "47": "FontProgramTest::::exceptionMessageTest()", "48": "FontProgramTest::::exceptionMessageTest()", "50": "FontProgramTest::::boldTest()", "51": "FontProgramTest::::boldTest()", "52": "FontProgramTest::::boldTest()", "53": "FontProgramTest::::boldTest()", "54": "FontProgramTest::::boldTest()", "55": "FontProgramTest::::boldTest()", "56": "FontProgramTest::::boldTest()", "57": "FontProgramTest::::boldTest()", "59": "FontProgramTest::::registerDirectoryOpenTypeTest()", "60": "FontProgramTest::::registerDirectoryOpenTypeTest()", "61": "FontProgramTest::::registerDirectoryOpenTypeTest()", "62": "FontProgramTest::::registerDirectoryOpenTypeTest()", "63": "FontProgramTest::::registerDirectoryOpenTypeTest()", "64": "FontProgramTest::::registerDirectoryOpenTypeTest()", "65": "FontProgramTest::::registerDirectoryOpenTypeTest()", "66": "FontProgramTest::::registerDirectoryOpenTypeTest()", "67": "FontProgramTest::::registerDirectoryOpenTypeTest()", "68": "FontProgramTest::::registerDirectoryOpenTypeTest()", "69": "FontProgramTest::::registerDirectoryOpenTypeTest()", "71": "FontProgramTest::::registerDirectoryType1Test()", "72": "FontProgramTest::::registerDirectoryType1Test()", "73": "FontProgramTest::::registerDirectoryType1Test()", "74": "FontProgramTest::::registerDirectoryType1Test()", "75": "FontProgramTest::::registerDirectoryType1Test()", "76": "FontProgramTest::::registerDirectoryType1Test()", "77": "FontProgramTest::::registerDirectoryType1Test()", "78": "FontProgramTest::::registerDirectoryType1Test()", "80": "FontProgramTest::::cidFontWithCmapTest()", "81": "FontProgramTest::::cidFontWithCmapTest()", "82": "FontProgramTest::::cidFontWithCmapTest()", "83": "FontProgramTest::::cidFontWithCmapTest()", "84": "FontProgramTest::::cidFontWithCmapTest()", "85": "FontProgramTest::::cidFontWithCmapTest()", "86": "FontProgramTest::::cidFontWithCmapTest()", "87": "FontProgramTest::::cidFontWithCmapTest()", "88": "FontProgramTest::::cidFontWithCmapTest()", "89": "FontProgramTest::::cidFontWithCmapTest()", "90": "FontProgramTest::::cidFontWithCmapTest()", "91": "FontProgramTest::::cidFontWithCmapTest()", "92": "FontProgramTest::::cidFontWithCmapTest()", "93": "FontProgramTest::::cidFontWithCmapTest()", "94": "FontProgramTest::::cidFontWithCmapTest()", "95": "FontProgramTest::::cidFontWithCmapTest()", "96": "FontProgramTest::::cidFontWithCmapTest()", "97": "FontProgramTest::::cidFontWithCmapTest()", "98": "FontProgramTest::::cidFontWithCmapTest()", "99": "FontProgramTest::::cidFontWithCmapTest()"}, "tests": [{"test_lines": [42, 48], "covered_lines": [190, 193, 195, 197, 200]}, {"test_lines": [50, 57], "covered_lines": [33, 58, 59, 63, 64, 73, 100, 190, 193, 195, 197, 200, 279, 280, 282, 284]}, {"test_lines": [59, 69], "covered_lines": [190, 193, 195, 197, 200]}, {"test_lines": [71, 78], "covered_lines": [33, 58, 59, 63, 64, 73, 82, 86, 190, 193, 195, 197, 200]}, {"test_lines": [80, 99], "covered_lines": [33, 58, 59, 63, 64, 73, 132, 190, 193, 195, 197, 200, 314, 315, 316, 318]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/PdfEncodings.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.commons.utils.EncodingUtil;\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.util.IntHashtable;\n", "\n", "import java.io.UnsupportedEncodingException;\n", "import java.util.HashMap;\n", "import java.util.Map;\n", "\n", "public class PdfEncodings {\n", "\n", "    //-Encodings--------------------------------------------------------------------------------------------------------\n", "\n", "    /** The Unicode encoding with horizontal writing. */\n", "    public static final String IDENTITY_H = \"Identity-H\";\n", "    /** The Unicode encoding with vertical writing. */\n", "    public static final String IDENTITY_V = \"Identity-V\";\n", "    /** A possible encoding. */\n", "    public static final String CP1250 = \"Cp1250\";\n", "    /** A possible encoding. */\n", "    public static final String CP1252 = \"Cp1252\";\n", "    /** A possible encoding. */\n", "    public static final String CP1253 = \"Cp1253\";\n", "    /** A possible encoding. */\n", "    public static final String CP1257 = \"Cp1257\";\n", "    /** A possible encoding. */\n", "    public static final String WINANSI = \"Cp1252\";\n", "    /** A possible encoding. */\n", "    public static final String MACROMAN = \"MacRoman\";\n", "    /** A possible encoding. */\n", "    public static final String SYMBOL = \"Symbol\";\n", "    /** A possible encoding. */\n", "    public static final String ZAPFDINGBATS = \"ZapfDingbats\";\n", "    /** This is the encoding to be used to output text in Unicode. */\n", "    public static final String UNICODE_BIG = \"UnicodeBig\";\n", "    /** This is the encoding to be used to output text for Identity-H/V CMaps. */\n", "    public static final String UNICODE_BIG_UNMARKED = \"UnicodeBigUnmarked\";\n", "    /** This is the default encoding to be used for converting Strings into\n", "     * bytes and vice versa. The default encoding is PDF_DOC_ENCODING. */\n", "    public static final String PDF_DOC_ENCODING = \"PDF\";\n", "    public static final String UTF8 = \"UTF-8\";\n", "\n", "    private static final String EMPTY_STRING = \"\";\n", "\n", "    private static final char[] winansiByteToChar = {\n", "            (char) 0, (char) 1, (char) 2, (char) 3, (char) 4, (char) 5, (char) 6, (char) 7, (char) 8, (char) 9, (char) 10, (char) 11, (char) 12, (char) 13, (char) 14, (char) 15,\n", "            (char) 16, (char) 17, (char) 18, (char) 19, (char) 20, (char) 21, (char) 22, (char) 23, (char) 24, (char) 25, (char) 26, (char) 27, (char) 28, (char) 29, (char) 30, (char) 31,\n", "            (char) 32, (char) 33, (char) 34, (char) 35, (char) 36, (char) 37, (char) 38, (char) 39, (char) 40, (char) 41, (char) 42, (char) 43, (char) 44, (char) 45, (char) 46, (char) 47,\n", "            (char) 48, (char) 49, (char) 50, (char) 51, (char) 52, (char) 53, (char) 54, (char) 55, (char) 56, (char) 57, (char) 58, (char) 59, (char) 60, (char) 61, (char) 62, (char) 63,\n", "            (char) 64, (char) 65, (char) 66, (char) 67, (char) 68, (char) 69, (char) 70, (char) 71, (char) 72, (char) 73, (char) 74, (char) 75, (char) 76, (char) 77, (char) 78, (char) 79,\n", "            (char) 80, (char) 81, (char) 82, (char) 83, (char) 84, (char) 85, (char) 86, (char) 87, (char) 88, (char) 89, (char) 90, (char) 91, (char) 92, (char) 93, (char) 94, (char) 95,\n", "            (char) 96, (char) 97, (char) 98, (char) 99, (char) 100, (char) 101, (char) 102, (char) 103, (char) 104, (char) 105, (char) 106, (char) 107, (char) 108, (char) 109, (char) 110, (char) 111,\n", "            (char) 112, (char) 113, (char) 114, (char) 115, (char) 116, (char) 117, (char) 118, (char) 119, (char) 120, (char) 121, (char) 122, (char) 123, (char) 124, (char) 125, (char) 126, (char) 127,\n", "            (char) 8364, (char) 65533, (char) 8218, (char) 402, (char) 8222, (char) 8230, (char) 8224, (char) 8225, (char) 710, (char) 8240, (char) 352, (char) 8249, (char) 338, (char) 65533, (char) 381, (char) 65533,\n", "            (char) 65533, (char) 8216, (char) 8217, (char) 8220, (char) 8221, (char) 8226, (char) 8211, (char) 8212, (char) 732, (char) 8482, (char) 353, (char) 8250, (char) 339, (char) 65533, (char) 382, (char) 376,\n", "            (char) 160, (char) 161, (char) 162, (char) 163, (char) 164, (char) 165, (char) 166, (char) 167, (char) 168, (char) 169, (char) 170, (char) 171, (char) 172, (char) 173, (char) 174, (char) 175,\n", "            (char) 176, (char) 177, (char) 178, (char) 179, (char) 180, (char) 181, (char) 182, (char) 183, (char) 184, (char) 185, (char) 186, (char) 187, (char) 188, (char) 189, (char) 190, (char) 191,\n", "            (char) 192, (char) 193, (char) 194, (char) 195, (char) 196, (char) 197, (char) 198, (char) 199, (char) 200, (char) 201, (char) 202, (char) 203, (char) 204, (char) 205, (char) 206, (char) 207,\n", "            (char) 208, (char) 209, (char) 210, (char) 211, (char) 212, (char) 213, (char) 214, (char) 215, (char) 216, (char) 217, (char) 218, (char) 219, (char) 220, (char) 221, (char) 222, (char) 223,\n", "            (char) 224, (char) 225, (char) 226, (char) 227, (char) 228, (char) 229, (char) 230, (char) 231, (char) 232, (char) 233, (char) 234, (char) 235, (char) 236, (char) 237, (char) 238, (char) 239,\n", "            (char) 240, (char) 241, (char) 242, (char) 243, (char) 244, (char) 245, (char) 246, (char) 247, (char) 248, (char) 249, (char) 250, (char) 251, (char) 252, (char) 253, (char) 254, (char) 255\n", "    };\n", "\n", "    private static final char[] pdfEncodingByteToChar = {\n", "            (char) 0, (char) 1, (char) 2, (char) 3, (char) 4, (char) 5, (char) 6, (char) 7, (char) 8, (char) 9, (char) 10, (char) 11, (char) 12, (char) 13, (char) 14, (char) 15,\n", "            (char) 16, (char) 17, (char) 18, (char) 19, (char) 20, (char) 21, (char) 22, (char) 23, (char) 24, (char) 25, (char) 26, (char) 27, (char) 28, (char) 29, (char) 30, (char) 31,\n", "            (char) 32, (char) 33, (char) 34, (char) 35, (char) 36, (char) 37, (char) 38, (char) 39, (char) 40, (char) 41, (char) 42, (char) 43, (char) 44, (char) 45, (char) 46, (char) 47,\n", "            (char) 48, (char) 49, (char) 50, (char) 51, (char) 52, (char) 53, (char) 54, (char) 55, (char) 56, (char) 57, (char) 58, (char) 59, (char) 60, (char) 61, (char) 62, (char) 63,\n", "            (char) 64, (char) 65, (char) 66, (char) 67, (char) 68, (char) 69, (char) 70, (char) 71, (char) 72, (char) 73, (char) 74, (char) 75, (char) 76, (char) 77, (char) 78, (char) 79,\n", "            (char) 80, (char) 81, (char) 82, (char) 83, (char) 84, (char) 85, (char) 86, (char) 87, (char) 88, (char) 89, (char) 90, (char) 91, (char) 92, (char) 93, (char) 94, (char) 95,\n", "            (char) 96, (char) 97, (char) 98, (char) 99, (char) 100, (char) 101, (char) 102, (char) 103, (char) 104, (char) 105, (char) 106, (char) 107, (char) 108, (char) 109, (char) 110, (char) 111,\n", "            (char) 112, (char) 113, (char) 114, (char) 115, (char) 116, (char) 117, (char) 118, (char) 119, (char) 120, (char) 121, (char) 122, (char) 123, (char) 124, (char) 125, (char) 126, (char) 127,\n", "            (char) 0x2022, (char) 0x2020, (char) 0x2021, (char) 0x2026, (char) 0x2014, (char) 0x2013, (char) 0x0192, (char) 0x2044, (char) 0x2039, (char) 0x203a, (char) 0x2212, (char) 0x2030, (char) 0x201e, (char) 0x201c, (char) 0x201d, (char) 0x2018,\n", "            (char) 0x2019, (char) 0x201a, (char) 0x2122, (char) 0xfb01, (char) 0xfb02, (char) 0x0141, (char) 0x0152, (char) 0x0160, (char) 0x0178, (char) 0x017d, (char) 0x0131, (char) 0x0142, (char) 0x0153, (char) 0x0161, (char) 0x017e, (char) 65533,\n", "            (char) 0x20ac, (char) 161, (char) 162, (char) 163, (char) 164, (char) 165, (char) 166, (char) 167, (char) 168, (char) 169, (char) 170, (char) 171, (char) 172, (char) 173, (char) 174, (char) 175,\n", "            (char) 176, (char) 177, (char) 178, (char) 179, (char) 180, (char) 181, (char) 182, (char) 183, (char) 184, (char) 185, (char) 186, (char) 187, (char) 188, (char) 189, (char) 190, (char) 191,\n", "            (char) 192, (char) 193, (char) 194, (char) 195, (char) 196, (char) 197, (char) 198, (char) 199, (char) 200, (char) 201, (char) 202, (char) 203, (char) 204, (char) 205, (char) 206, (char) 207,\n", "            (char) 208, (char) 209, (char) 210, (char) 211, (char) 212, (char) 213, (char) 214, (char) 215, (char) 216, (char) 217, (char) 218, (char) 219, (char) 220, (char) 221, (char) 222, (char) 223,\n", "            (char) 224, (char) 225, (char) 226, (char) 227, (char) 228, (char) 229, (char) 230, (char) 231, (char) 232, (char) 233, (char) 234, (char) 235, (char) 236, (char) 237, (char) 238, (char) 239,\n", "            (char) 240, (char) 241, (char) 242, (char) 243, (char) 244, (char) 245, (char) 246, (char) 247, (char) 248, (char) 249, (char) 250, (char) 251, (char) 252, (char) 253, (char) 254, (char) 255 };\n", "\n", "    static final int[] standardEncoding = {\n", "            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "            32, 33, 34, 35, 36, 37, 38, 8217, 40, 41, 42, 43, 44, 45, 46, 47,\n", "            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n", "            64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n", "            80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\n", "            8216, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n", "            112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 0,\n", "            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "            0, 161, 162, 163, 8260, 165, 402, 167, 164, 39, 8220, 171, 8249, 8250, 64257, 64258,\n", "            0, 8211, 8224, 8225, 183, 0, 182, 8226, 8218, 8222, 8221, 187, 8230, 8240, 0, 191,\n", "            0, 96, 180, 710, 732, 175, 728, 729, 168, 0, 730, 184, 0, 733, 731, 711,\n", "            8212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "            0, 198, 0, 170, 0, 0, 0, 0, 321, 216, 338, 186, 0, 0, 0, 0,\n", "            0, 230, 0, 0, 0, 305, 0, 0, 322, 248, 339, 223, 0, 0, 0, 0\n", "    };\n", "\n", "    private static final IntHashtable winansi = new IntHashtable();\n", "\n", "    private static final IntHashtable pdfEncoding = new IntHashtable();\n", "\n", "    private static final Map<String, IExtraEncoding> extraEncodings = new HashMap<>();\n", "\n", "    static {\n", "        for (int k = 128; k < 161; ++k) {\n", "            char c = winansiByteToChar[k];\n", "            if (c != 65533)\n", "                winansi.put((int) c, k);\n", "        }\n", "\n", "        for (int k = 128; k < 161; ++k) {\n", "            char c = pdfEncodingByteToChar[k];\n", "            if (c != 65533)\n", "                pdfEncoding.put((int) c, k);\n", "        }\n", "\n", "\n", "        addExtraEncoding(\"Wingdings\", new WingdingsConversion());\n", "        addExtraEncoding(\"Symbol\", new SymbolConversion(true));\n", "        addExtraEncoding(\"ZapfDingbats\", new SymbolConversion(false));\n", "        addExtraEncoding(\"SymbolTT\", new SymbolTTConversion());\n", "        addExtraEncoding(\"Cp437\", new Cp437Conversion());\n", "    }\n", "\n", "    /**\n", "     * Converts a {@code String} to a {@code byte} array according\n", "     * to the font's encoding.\n", "     *\n", "     * @param encoding the encoding\n", "     * @param text     the {@code String} to be converted\n", "     * @return an array of {@code byte} representing the conversion according to the font's encoding\n", "     */\n", "    public static byte[] convertToBytes(String text, String encoding) {\n", "        if (text == null)\n", "            return new byte[0];\n", "        if (encoding == null || encoding.length() == 0) {\n", "            int len = text.length();\n", "            byte[] b = new byte[len];\n", "            for (int k = 0; k < len; ++k) {\n", "                b[k] = (byte) text.charAt(k);\n", "            }\n", "            return b;\n", "        }\n", "        IExtraEncoding extra = extraEncodings.get(encoding.toLowerCase());\n", "        if (extra != null) {\n", "            byte[] b = extra.charToByte(text, encoding);\n", "            if (b != null)\n", "                return b;\n", "        }\n", "        IntHashtable hash = null;\n", "        if (encoding.equals(WINANSI)) {\n", "            hash = winansi;\n", "        } else if (encoding.equals(PDF_DOC_ENCODING)) {\n", "            hash = pdfEncoding;\n", "        }\n", "        if (hash != null) {\n", "            char[] cc = text.toCharArray();\n", "            int len = cc.length;\n", "            int ptr = 0;\n", "            byte[] b = new byte[len];\n", "            int c;\n", "            for (int k = 0; k < len; ++k) {\n", "                char ch = cc[k];\n", "                if (ch < 128 || ch > 160 && ch <= 255) {\n", "                    c = ch;\n", "                } else {\n", "                    c = hash.get((int) ch);\n", "                }\n", "                if (c != 0) {\n", "                    b[ptr++] = (byte) c;\n", "                }\n", "            }\n", "            if (ptr == len)\n", "                return b;\n", "            byte[] b2 = new byte[ptr];\n", "            System.arraycopy(b, 0, b2, 0, ptr);\n", "            return b2;\n", "        }\n", "        try {\n", "            return EncodingUtil.convertToBytes(text.toCharArray(), encoding);\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.CHARACTER_CODE_EXCEPTION, e);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Converts a {@code char} to a {@code byte} array according\n", "     * to the font's encoding.\n", "     *\n", "     * @param encoding the encoding\n", "     * @param ch    the {@code char} to be converted\n", "     * @return an array of {@code byte} representing the conversion according to the font's encoding\n", "     */\n", "    public static byte[] convertToBytes(char ch, String encoding) {\n", "        if (encoding == null || encoding.length() == 0 || \"symboltt\".equals(encoding)) {\n", "            return new byte[]{(byte) ch};\n", "        }\n", "\n", "        IntHashtable hash = null;\n", "        if (encoding.equals(WINANSI))\n", "            hash = winansi;\n", "        else if (encoding.equals(PDF_DOC_ENCODING))\n", "            hash = pdfEncoding;\n", "        if (hash != null) {\n", "            int c;\n", "            if (ch < 128 || ch > 160 && ch <= 255) {\n", "                c = ch;\n", "            } else {\n", "                c = hash.get((int) ch);\n", "            }\n", "            if (c != 0) {\n", "                return new byte[]{(byte) c};\n", "            } else {\n", "                return new byte[0];\n", "            }\n", "        }\n", "        try {\n", "            return EncodingUtil.convertToBytes(new char[]{ch}, encoding);\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.CHARACTER_CODE_EXCEPTION, e);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Converts a {@code byte} array to a {@code String} according\n", "     * to the some encoding.\n", "     *\n", "     * @param bytes    the bytes to convert\n", "     * @param encoding the encoding\n", "     * @return the converted {@code String}\n", "     */\n", "    public static String convertToString(byte[] bytes, String encoding) {\n", "        if (bytes == null)\n", "            return EMPTY_STRING;\n", "        if (encoding == null || encoding.length() == 0) {\n", "            char[] c = new char[bytes.length];\n", "            for (int k = 0; k < bytes.length; ++k) {\n", "                c[k] = (char) (bytes[k] & 0xff);\n", "            }\n", "            return new String(c);\n", "        }\n", "        IExtraEncoding extra = extraEncodings.get(encoding.toLowerCase());\n", "        if (extra != null) {\n", "            String text = extra.byteToChar(bytes, encoding);\n", "            if (text != null) {\n", "                return text;\n", "            }\n", "        }\n", "        char[] ch = null;\n", "        if (encoding.equals(WINANSI))\n", "            ch = winansiByteToChar;\n", "        else if (encoding.equals(PDF_DOC_ENCODING))\n", "            ch = pdfEncodingByteToChar;\n", "        if (ch != null) {\n", "            int len = bytes.length;\n", "            char[] c = new char[len];\n", "            for (int k = 0; k < len; ++k) {\n", "                c[k] = ch[bytes[k] & 0xff];\n", "            }\n", "            return new String(c);\n", "        }\n", "        try {\n", "            return EncodingUtil.convertToString(bytes, encoding);\n", "        } catch (UnsupportedEncodingException e) {\n", "            throw new IOException(IoExceptionMessageConstant.UNSUPPORTED_ENCODING_EXCEPTION, e);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Checks is {@code text} only has PDF_DOC_ENCODING characters.\n", "     *\n", "     * @param text the {@code String} to test\n", "     * @return {@code true} if only PDF_DOC_ENCODING characters are present\n", "     */\n", "    public static boolean isPdfDocEncoding(String text) {\n", "        if (text == null)\n", "            return true;\n", "        int len = text.length();\n", "        for (int k = 0; k < len; k++) {\n", "            char ch = text.charAt(k);\n", "            if (ch < 128 || ch > 160 && ch <= 255)\n", "                continue;\n", "            if (!pdfEncoding.containsKey((int) ch))\n", "                return false;\n", "        }\n", "        return true;\n", "    }\n", "\n", "\n", "    /** Adds an extra encoding.\n", "     * @param name the name of the encoding. The encoding recognition is case insensitive\n", "     * @param enc the conversion class\n", "     */\n", "    @SuppressWarnings(\"unchecked\")\n", "    public static void addExtraEncoding(String name, IExtraEncoding enc) {\n", "        synchronized (extraEncodings) {\n", "            extraEncodings.put(name.toLowerCase(), enc);\n", "        }\n", "    }\n", "\n", "    private static class WingdingsConversion implements IExtraEncoding {\n", "\n", "        public byte[] charToByte(char char1, String encoding) {\n", "            if (char1 == ' ')\n", "                return new byte[]{(byte)char1};\n", "            else if (char1 >= '\\u2701' && char1 <= '\\u27BE') {\n", "                byte v = table[char1 - 0x2700];\n", "                if (v != 0)\n", "                    return new byte[]{v};\n", "            }\n", "            return new byte[0];\n", "        }\n", "\n", "        public byte[] charToByte(String text, String encoding) {\n", "            char[] cc = text.toCharArray();\n", "            byte[] b = new byte[cc.length];\n", "            int ptr = 0;\n", "            int len = cc.length;\n", "            for (int k = 0; k < len; ++k) {\n", "                char c = cc[k];\n", "                if (c == ' ')\n", "                    b[ptr++] = (byte)c;\n", "                else if (c >= '\\u2701' && c <= '\\u27BE') {\n", "                    byte v = table[c - 0x2700];\n", "                    if (v != 0)\n", "                        b[ptr++] = v;\n", "                }\n", "            }\n", "            if (ptr == len)\n", "                return b;\n", "            byte[] b2 = new byte[ptr];\n", "            System.arraycopy(b, 0, b2, 0, ptr);\n", "            return b2;\n", "        }\n", "\n", "        public String byteToChar(byte[] b, String encoding) {\n", "            return null;\n", "        }\n", "\n", "        private static final byte[] table = {\n", "                (byte) 0x00, (byte) 0x23, (byte) 0x22, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x29, (byte) 0x3e, (byte) 0x51, (byte) 0x2a,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0x3f, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xfc,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xfb, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n", "                (byte) 0x56, (byte) 0x00, (byte) 0x58, (byte) 0x59, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0xb5, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xb6, (byte) 0x00,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0xad, (byte) 0xaf, (byte) 0xac, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x7c, (byte) 0x7b, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x54, (byte) 0x00,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xa6, (byte) 0x00, (byte) 0x00,\n", "                (byte) 0x00, (byte) 0x71, (byte) 0x72, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x75, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x7d, (byte) 0x7e, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x8c, (byte) 0x8d,\n", "                (byte) 0x8e, (byte) 0x8f, (byte) 0x90, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x81, (byte) 0x82,\n", "                (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x8a, (byte) 0x8c, (byte) 0x8d,\n", "                (byte) 0x8e, (byte) 0x8f, (byte) 0x90, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0xe8, (byte) 0x00,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n", "                (byte) 0x00, (byte) 0xe8, (byte) 0xd8, (byte) 0x00, (byte) 0x00, (byte) 0xc4, (byte) 0xc6, (byte) 0x00, (byte) 0x00, (byte) 0xf0,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0xdc,\n", "                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n", "                (byte) 0x00\n", "        };\n", "    }\n", "\n", "    private static class Cp437Conversion implements IExtraEncoding {\n", "        private static IntHashtable c2b = new IntHashtable();\n", "\n", "        public byte[] charToByte(String text, String encoding) {\n", "            char[] cc = text.toCharArray();\n", "            byte[] b = new byte[cc.length];\n", "            int ptr = 0;\n", "            int len = cc.length;\n", "            for (int k = 0; k < len; ++k) {\n", "                char c = cc[k];\n", "                if (c < 128)\n", "                    b[ptr++] = (byte)c;\n", "                else {\n", "                    byte v = (byte)c2b.get(c);\n", "                    if (v != 0)\n", "                        b[ptr++] = v;\n", "                }\n", "            }\n", "            if (ptr == len)\n", "                return b;\n", "            byte[] b2 = new byte[ptr];\n", "            System.arraycopy(b, 0, b2, 0, ptr);\n", "            return b2;\n", "        }\n", "\n", "        public byte[] charToByte(char char1, String encoding) {\n", "            if (char1 < 128)\n", "                return new byte[]{(byte)char1};\n", "            else {\n", "                byte v = (byte)c2b.get(char1);\n", "                if (v != 0)\n", "                    return new byte[]{v};\n", "                else\n", "                    return new byte[0];\n", "            }\n", "        }\n", "\n", "        public String byteToChar(byte[] b, String encoding) {\n", "            int len = b.length;\n", "            char[] cc = new char[len];\n", "            int ptr = 0;\n", "            for (int k = 0; k < len; ++k) {\n", "                int c = b[k] & 0xff;\n", "                if (c < ' ')\n", "                    continue;\n", "                if (c < 128)\n", "                    cc[ptr++] = (char)c;\n", "                else {\n", "                    char v = table[c - 128];\n", "                    cc[ptr++] = v;\n", "                }\n", "            }\n", "            return new String(cc, 0, ptr);\n", "        }\n", "\n", "        private static final char[] table = {\n", "                '\\u00C7', '\\u00FC', '\\u00E9', '\\u00E2', '\\u00E4', '\\u00E0', '\\u00E5', '\\u00E7', '\\u00EA', '\\u00EB', '\\u00E8', '\\u00EF', '\\u00EE', '\\u00EC', '\\u00C4', '\\u00C5',\n", "                '\\u00C9', '\\u00E6', '\\u00C6', '\\u00F4', '\\u00F6', '\\u00F2', '\\u00FB', '\\u00F9', '\\u00FF', '\\u00D6', '\\u00DC', '\\u00A2', '\\u00A3', '\\u00A5', '\\u20A7', '\\u0192',\n", "                '\\u00E1', '\\u00ED', '\\u00F3', '\\u00FA', '\\u00F1', '\\u00D1', '\\u00AA', '\\u00BA', '\\u00BF', '\\u2310', '\\u00AC', '\\u00BD', '\\u00BC', '\\u00A1', '\\u00AB', '\\u00BB',\n", "                '\\u2591', '\\u2592', '\\u2593', '\\u2502', '\\u2524', '\\u2561', '\\u2562', '\\u2556', '\\u2555', '\\u2563', '\\u2551', '\\u2557', '\\u255D', '\\u255C', '\\u255B', '\\u2510',\n", "                '\\u2514', '\\u2534', '\\u252C', '\\u251C', '\\u2500', '\\u253C', '\\u255E', '\\u255F', '\\u255A', '\\u2554', '\\u2569', '\\u2566', '\\u2560', '\\u2550', '\\u256C', '\\u2567',\n", "                '\\u2568', '\\u2564', '\\u2565', '\\u2559', '\\u2558', '\\u2552', '\\u2553', '\\u256B', '\\u256A', '\\u2518', '\\u250C', '\\u2588', '\\u2584', '\\u258C', '\\u2590', '\\u2580',\n", "                '\\u03B1', '\\u00DF', '\\u0393', '\\u03C0', '\\u03A3', '\\u03C3', '\\u00B5', '\\u03C4', '\\u03A6', '\\u0398', '\\u03A9', '\\u03B4', '\\u221E', '\\u03C6', '\\u03B5', '\\u2229',\n", "                '\\u2261', '\\u00B1', '\\u2265', '\\u2264', '\\u2320', '\\u2321', '\\u00F7', '\\u2248', '\\u00B0', '\\u2219', '\\u00B7', '\\u221A', '\\u207F', '\\u00B2', '\\u25A0', '\\u00A0'\n", "        };\n", "\n", "        static {\n", "            for (int k = 0; k < table.length; ++k)\n", "                c2b.put(table[k], k + 128);\n", "        }\n", "    }\n", "\n", "    private static class SymbolConversion implements IExtraEncoding {\n", "\n", "        private static final IntHashtable t1 = new IntHashtable();\n", "        private static final IntHashtable t2 = new IntHashtable();\n", "        private IntHashtable translation;\n", "        private final char[] byteToChar;\n", "\n", "        SymbolConversion(boolean symbol) {\n", "            if (symbol) {\n", "                translation = t1;\n", "                byteToChar = table1;\n", "            } else {\n", "                translation = t2;\n", "                byteToChar = table2;\n", "            }\n", "        }\n", "\n", "        public byte[] charToByte(String text, String encoding) {\n", "            char[] cc = text.toCharArray();\n", "            byte[] b = new byte[cc.length];\n", "            int ptr = 0;\n", "            int len = cc.length;\n", "            for (int k = 0; k < len; ++k) {\n", "                char c = cc[k];\n", "                byte v = (byte)translation.get(c);\n", "                if (v != 0)\n", "                    b[ptr++] = v;\n", "            }\n", "            if (ptr == len)\n", "                return b;\n", "            byte[] b2 = new byte[ptr];\n", "            System.arraycopy(b, 0, b2, 0, ptr);\n", "            return b2;\n", "        }\n", "\n", "        public byte[] charToByte(char char1, String encoding) {\n", "            byte v = (byte)translation.get(char1);\n", "            if (v != 0)\n", "                return new byte[]{v};\n", "            else\n", "                return new byte[0];\n", "        }\n", "\n", "        public String byteToChar(byte[] b, String encoding) {\n", "            int len = b.length;\n", "            char[] cc = new char[len];\n", "            int ptr = 0;\n", "            for (int k = 0; k < len; ++k) {\n", "                int c = b[k] & 0xff;\n", "                char v = byteToChar[c];\n", "                cc[ptr++] = v;\n", "            }\n", "            return new String(cc, 0, ptr);\n", "        }\n", "\n", "        private static final char[] table1 = {\n", "                '\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n", "                '\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n", "                ' ','!','\\u2200','#','\\u2203','%','&','\\u220b','(',')','*','+',',','-','.','/',\n", "                '0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?',\n", "                '\\u2245','\\u0391','\\u0392','\\u03a7','\\u0394','\\u0395','\\u03a6','\\u0393','\\u0397','\\u0399','\\u03d1','\\u039a','\\u039b','\\u039c','\\u039d','\\u039f',\n", "                '\\u03a0','\\u0398','\\u03a1','\\u03a3','\\u03a4','\\u03a5','\\u03c2','\\u03a9','\\u039e','\\u03a8','\\u0396','[','\\u2234',']','\\u22a5','_',\n", "                '\\u0305','\\u03b1','\\u03b2','\\u03c7','\\u03b4','\\u03b5','\\u03d5','\\u03b3','\\u03b7','\\u03b9','\\u03c6','\\u03ba','\\u03bb','\\u03bc','\\u03bd','\\u03bf',\n", "                '\\u03c0','\\u03b8','\\u03c1','\\u03c3','\\u03c4','\\u03c5','\\u03d6','\\u03c9','\\u03be','\\u03c8','\\u03b6','{','|','}','~','\\0',\n", "                '\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n", "                '\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n", "                '\\u20ac','\\u03d2','\\u2032','\\u2264','\\u2044','\\u221e','\\u0192','\\u2663','\\u2666','\\u2665','\\u2660','\\u2194','\\u2190','\\u2191','\\u2192','\\u2193',\n", "                '\\u00b0','\\u00b1','\\u2033','\\u2265','\\u00d7','\\u221d','\\u2202','\\u2022','\\u00f7','\\u2260','\\u2261','\\u2248','\\u2026','\\u2502','\\u2500','\\u21b5',\n", "                '\\u2135','\\u2111','\\u211c','\\u2118','\\u2297','\\u2295','\\u2205','\\u2229','\\u222a','\\u2283','\\u2287','\\u2284','\\u2282','\\u2286','\\u2208','\\u2209',\n", "                '\\u2220','\\u2207','\\u00ae','\\u00a9','\\u2122','\\u220f','\\u221a','\\u22c5','\\u00ac','\\u2227','\\u2228','\\u21d4','\\u21d0','\\u21d1','\\u21d2','\\u21d3',\n", "                '\\u25ca','\\u2329','\\0','\\0','\\0','\\u2211','\\u239b','\\u239c','\\u239d','\\u23a1','\\u23a2','\\u23a3','\\u23a7','\\u23a8','\\u23a9','\\u23aa',\n", "                '\\0','\\u232a','\\u222b','\\u2320','\\u23ae','\\u2321','\\u239e','\\u239f','\\u23a0','\\u23a4','\\u23a5','\\u23a6','\\u23ab','\\u23ac','\\u23ad','\\0'\n", "        };\n", "\n", "        private static final char[] table2 = {\n", "                '\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n", "                '\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n", "                '\\u0020','\\u2701','\\u2702','\\u2703','\\u2704','\\u260e','\\u2706','\\u2707','\\u2708','\\u2709','\\u261b','\\u261e','\\u270C','\\u270D','\\u270E','\\u270F',\n", "                '\\u2710','\\u2711','\\u2712','\\u2713','\\u2714','\\u2715','\\u2716','\\u2717','\\u2718','\\u2719','\\u271A','\\u271B','\\u271C','\\u271D','\\u271E','\\u271F',\n", "                '\\u2720','\\u2721','\\u2722','\\u2723','\\u2724','\\u2725','\\u2726','\\u2727','\\u2605','\\u2729','\\u272A','\\u272B','\\u272C','\\u272D','\\u272E','\\u272F',\n", "                '\\u2730','\\u2731','\\u2732','\\u2733','\\u2734','\\u2735','\\u2736','\\u2737','\\u2738','\\u2739','\\u273A','\\u273B','\\u273C','\\u273D','\\u273E','\\u273F',\n", "                '\\u2740','\\u2741','\\u2742','\\u2743','\\u2744','\\u2745','\\u2746','\\u2747','\\u2748','\\u2749','\\u274A','\\u274B','\\u25cf','\\u274D','\\u25a0','\\u274F',\n", "                '\\u2750','\\u2751','\\u2752','\\u25b2','\\u25bc','\\u25c6','\\u2756','\\u25d7','\\u2758','\\u2759','\\u275A','\\u275B','\\u275C','\\u275D','\\u275E','\\u0000',\n", "                '\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n", "                '\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n", "                '\\u0000','\\u2761','\\u2762','\\u2763','\\u2764','\\u2765','\\u2766','\\u2767','\\u2663','\\u2666','\\u2665','\\u2660','\\u2460','\\u2461','\\u2462','\\u2463',\n", "                '\\u2464','\\u2465','\\u2466','\\u2467','\\u2468','\\u2469','\\u2776','\\u2777','\\u2778','\\u2779','\\u277A','\\u277B','\\u277C','\\u277D','\\u277E','\\u277F',\n", "                '\\u2780','\\u2781','\\u2782','\\u2783','\\u2784','\\u2785','\\u2786','\\u2787','\\u2788','\\u2789','\\u278A','\\u278B','\\u278C','\\u278D','\\u278E','\\u278F',\n", "                '\\u2790','\\u2791','\\u2792','\\u2793','\\u2794','\\u2192','\\u2194','\\u2195','\\u2798','\\u2799','\\u279A','\\u279B','\\u279C','\\u279D','\\u279E','\\u279F',\n", "                '\\u27A0','\\u27A1','\\u27A2','\\u27A3','\\u27A4','\\u27A5','\\u27A6','\\u27A7','\\u27A8','\\u27A9','\\u27AA','\\u27AB','\\u27AC','\\u27AD','\\u27AE','\\u27AF',\n", "                '\\u0000','\\u27B1','\\u27B2','\\u27B3','\\u27B4','\\u27B5','\\u27B6','\\u27B7','\\u27B8','\\u27B9','\\u27BA','\\u27BB','\\u27BC','\\u27BD','\\u27BE','\\u0000'\n", "        };\n", "\n", "        static {\n", "            for (int k = 0; k < 256; ++k) {\n", "                int v = table1[k];\n", "                if (v != 0)\n", "                    t1.put(v, k);\n", "            }\n", "            for (int k = 0; k < 256; ++k) {\n", "                int v = table2[k];\n", "                if (v != 0)\n", "                    t2.put(v, k);\n", "            }\n", "        }\n", "    }\n", "\n", "    private static class SymbolTTConversion implements IExtraEncoding {\n", "\n", "        public byte[] charToByte(char char1, String encoding) {\n", "            if ((char1 & 0xff00) == 0 || (char1 & 0xff00) == 0xf000)\n", "                return new byte[]{(byte)char1};\n", "            else\n", "                return new byte[0];\n", "        }\n", "\n", "        public byte[] charToByte(String text, String encoding) {\n", "            char[] ch = text.toCharArray();\n", "            byte[] b = new byte[ch.length];\n", "            int ptr = 0;\n", "            int len = ch.length;\n", "            for (int k = 0; k < len; ++k) {\n", "                char c = ch[k];\n", "                if ((c & 0xff00) == 0 || (c & 0xff00) == 0xf000)\n", "                    b[ptr++] = (byte)c;\n", "            }\n", "            if (ptr == len)\n", "                return b;\n", "            byte[] b2 = new byte[ptr];\n", "            System.arraycopy(b, 0, b2, 0, ptr);\n", "            return b2;\n", "        }\n", "\n", "        public String byteToChar(byte[] b, String encoding) {\n", "            return null;\n", "        }\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class PdfEncodingsTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void convertToBytesNoEncodingTest() {\n", "        Assert.assertArrayEquals(new byte[]{(byte) 194}, PdfEncodings.convertToBytes('\u00c2', null));\n", "        Assert.assertArrayEquals(new byte[]{(byte) 194}, PdfEncodings.convertToBytes('\u00c2', \"\"));\n", "        Assert.assertArrayEquals(new byte[]{(byte) 194}, PdfEncodings.convertToBytes('\u00c2', \"symboltt\"));\n", "    }\n", "}\n"], "method_lines_dic": {"PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)": [160, 211], "PdfEncodings::::convertToBytes(char,java.lang.String)": [221, 249], "PdfEncodings::::convertToString(byte[],java.lang.String)": [259, 294], "PdfEncodings::::isPdfDocEncoding(java.lang.String)": [302, 314], "PdfEncodings::::addExtraEncoding(java.lang.String,com.itextpdf.io.font.IExtraEncoding)": [321, 326], "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)": [330, 339], "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)": [341, 361], "PdfEncodings.WingdingsConversion::::byteToChar(byte[],java.lang.String)": [363, 365], "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)": [394, 414], "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)": [416, 426], "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)": [428, 444], "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)": [480, 496], "PdfEncodings.SymbolConversion::::charToByte(char,java.lang.String)": [498, 504], "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)": [506, 516], "PdfEncodings.SymbolTTConversion::::charToByte(char,java.lang.String)": [572, 577], "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)": [579, 594], "PdfEncodings.SymbolTTConversion::::byteToChar(byte[],java.lang.String)": [596, 598]}, "test_method_lines_dic": {"PdfEncodingsTest::::convertToBytesNoEncodingTest()": [35, 40]}, "reverse_method_lines_dic": {"160": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "161": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "162": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "163": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "164": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "165": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "166": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "167": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "168": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "169": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "170": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "171": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "172": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "173": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "174": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "175": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "176": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "177": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "178": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "179": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "180": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "181": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "182": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "183": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "184": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "185": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "186": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "187": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "188": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "189": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "190": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "191": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "192": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "193": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "194": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "195": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "196": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "197": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "198": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "199": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "200": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "201": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "202": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "203": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "204": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "205": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "206": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "207": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "208": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "209": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "210": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "211": "PdfEncodings::::convertToBytes(java.lang.String,java.lang.String)", "221": "PdfEncodings::::convertToBytes(char,java.lang.String)", "222": "PdfEncodings::::convertToBytes(char,java.lang.String)", "223": "PdfEncodings::::convertToBytes(char,java.lang.String)", "224": "PdfEncodings::::convertToBytes(char,java.lang.String)", "225": "PdfEncodings::::convertToBytes(char,java.lang.String)", "226": "PdfEncodings::::convertToBytes(char,java.lang.String)", "227": "PdfEncodings::::convertToBytes(char,java.lang.String)", "228": "PdfEncodings::::convertToBytes(char,java.lang.String)", "229": "PdfEncodings::::convertToBytes(char,java.lang.String)", "230": "PdfEncodings::::convertToBytes(char,java.lang.String)", "231": "PdfEncodings::::convertToBytes(char,java.lang.String)", "232": "PdfEncodings::::convertToBytes(char,java.lang.String)", "233": "PdfEncodings::::convertToBytes(char,java.lang.String)", "234": "PdfEncodings::::convertToBytes(char,java.lang.String)", "235": "PdfEncodings::::convertToBytes(char,java.lang.String)", "236": "PdfEncodings::::convertToBytes(char,java.lang.String)", "237": "PdfEncodings::::convertToBytes(char,java.lang.String)", "238": "PdfEncodings::::convertToBytes(char,java.lang.String)", "239": "PdfEncodings::::convertToBytes(char,java.lang.String)", "240": "PdfEncodings::::convertToBytes(char,java.lang.String)", "241": "PdfEncodings::::convertToBytes(char,java.lang.String)", "242": "PdfEncodings::::convertToBytes(char,java.lang.String)", "243": "PdfEncodings::::convertToBytes(char,java.lang.String)", "244": "PdfEncodings::::convertToBytes(char,java.lang.String)", "245": "PdfEncodings::::convertToBytes(char,java.lang.String)", "246": "PdfEncodings::::convertToBytes(char,java.lang.String)", "247": "PdfEncodings::::convertToBytes(char,java.lang.String)", "248": "PdfEncodings::::convertToBytes(char,java.lang.String)", "249": "PdfEncodings::::convertToBytes(char,java.lang.String)", "259": "PdfEncodings::::convertToString(byte[],java.lang.String)", "260": "PdfEncodings::::convertToString(byte[],java.lang.String)", "261": "PdfEncodings::::convertToString(byte[],java.lang.String)", "262": "PdfEncodings::::convertToString(byte[],java.lang.String)", "263": "PdfEncodings::::convertToString(byte[],java.lang.String)", "264": "PdfEncodings::::convertToString(byte[],java.lang.String)", "265": "PdfEncodings::::convertToString(byte[],java.lang.String)", "266": "PdfEncodings::::convertToString(byte[],java.lang.String)", "267": "PdfEncodings::::convertToString(byte[],java.lang.String)", "268": "PdfEncodings::::convertToString(byte[],java.lang.String)", "269": "PdfEncodings::::convertToString(byte[],java.lang.String)", "270": "PdfEncodings::::convertToString(byte[],java.lang.String)", "271": "PdfEncodings::::convertToString(byte[],java.lang.String)", "272": "PdfEncodings::::convertToString(byte[],java.lang.String)", "273": "PdfEncodings::::convertToString(byte[],java.lang.String)", "274": "PdfEncodings::::convertToString(byte[],java.lang.String)", "275": "PdfEncodings::::convertToString(byte[],java.lang.String)", "276": "PdfEncodings::::convertToString(byte[],java.lang.String)", "277": "PdfEncodings::::convertToString(byte[],java.lang.String)", "278": "PdfEncodings::::convertToString(byte[],java.lang.String)", "279": "PdfEncodings::::convertToString(byte[],java.lang.String)", "280": "PdfEncodings::::convertToString(byte[],java.lang.String)", "281": "PdfEncodings::::convertToString(byte[],java.lang.String)", "282": "PdfEncodings::::convertToString(byte[],java.lang.String)", "283": "PdfEncodings::::convertToString(byte[],java.lang.String)", "284": "PdfEncodings::::convertToString(byte[],java.lang.String)", "285": "PdfEncodings::::convertToString(byte[],java.lang.String)", "286": "PdfEncodings::::convertToString(byte[],java.lang.String)", "287": "PdfEncodings::::convertToString(byte[],java.lang.String)", "288": "PdfEncodings::::convertToString(byte[],java.lang.String)", "289": "PdfEncodings::::convertToString(byte[],java.lang.String)", "290": "PdfEncodings::::convertToString(byte[],java.lang.String)", "291": "PdfEncodings::::convertToString(byte[],java.lang.String)", "292": "PdfEncodings::::convertToString(byte[],java.lang.String)", "293": "PdfEncodings::::convertToString(byte[],java.lang.String)", "294": "PdfEncodings::::convertToString(byte[],java.lang.String)", "302": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "303": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "304": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "305": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "306": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "307": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "308": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "309": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "310": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "311": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "312": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "313": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "314": "PdfEncodings::::isPdfDocEncoding(java.lang.String)", "321": "PdfEncodings::::addExtraEncoding(java.lang.String,com.itextpdf.io.font.IExtraEncoding)", "322": "PdfEncodings::::addExtraEncoding(java.lang.String,com.itextpdf.io.font.IExtraEncoding)", "323": "PdfEncodings::::addExtraEncoding(java.lang.String,com.itextpdf.io.font.IExtraEncoding)", "324": "PdfEncodings::::addExtraEncoding(java.lang.String,com.itextpdf.io.font.IExtraEncoding)", "325": "PdfEncodings::::addExtraEncoding(java.lang.String,com.itextpdf.io.font.IExtraEncoding)", "326": "PdfEncodings::::addExtraEncoding(java.lang.String,com.itextpdf.io.font.IExtraEncoding)", "330": "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)", "331": "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)", "332": "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)", "333": "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)", "334": "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)", "335": "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)", "336": "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)", "337": "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)", "338": "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)", "339": "PdfEncodings.WingdingsConversion::::charToByte(char,java.lang.String)", "341": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "342": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "343": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "344": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "345": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "346": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "347": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "348": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "349": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "350": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "351": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "352": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "353": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "354": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "355": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "356": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "357": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "358": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "359": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "360": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "361": "PdfEncodings.WingdingsConversion::::charToByte(java.lang.String,java.lang.String)", "363": "PdfEncodings.WingdingsConversion::::byteToChar(byte[],java.lang.String)", "364": "PdfEncodings.WingdingsConversion::::byteToChar(byte[],java.lang.String)", "365": "PdfEncodings.WingdingsConversion::::byteToChar(byte[],java.lang.String)", "394": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "395": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "396": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "397": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "398": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "399": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "400": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "401": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "402": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "403": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "404": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "405": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "406": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "407": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "408": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "409": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "410": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "411": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "412": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "413": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "414": "PdfEncodings.Cp437Conversion::::charToByte(java.lang.String,java.lang.String)", "416": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "417": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "418": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "419": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "420": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "421": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "422": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "423": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "424": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "425": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "426": "PdfEncodings.Cp437Conversion::::charToByte(char,java.lang.String)", "428": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "429": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "430": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "431": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "432": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "433": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "434": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "435": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "436": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "437": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "438": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "439": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "440": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "441": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "442": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "443": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "444": "PdfEncodings.Cp437Conversion::::byteToChar(byte[],java.lang.String)", "480": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "481": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "482": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "483": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "484": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "485": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "486": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "487": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "488": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "489": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "490": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "491": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "492": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "493": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "494": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "495": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "496": "PdfEncodings.SymbolConversion::::charToByte(java.lang.String,java.lang.String)", "498": "PdfEncodings.SymbolConversion::::charToByte(char,java.lang.String)", "499": "PdfEncodings.SymbolConversion::::charToByte(char,java.lang.String)", "500": "PdfEncodings.SymbolConversion::::charToByte(char,java.lang.String)", "501": "PdfEncodings.SymbolConversion::::charToByte(char,java.lang.String)", "502": "PdfEncodings.SymbolConversion::::charToByte(char,java.lang.String)", "503": "PdfEncodings.SymbolConversion::::charToByte(char,java.lang.String)", "504": "PdfEncodings.SymbolConversion::::charToByte(char,java.lang.String)", "506": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "507": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "508": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "509": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "510": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "511": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "512": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "513": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "514": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "515": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "516": "PdfEncodings.SymbolConversion::::byteToChar(byte[],java.lang.String)", "572": "PdfEncodings.SymbolTTConversion::::charToByte(char,java.lang.String)", "573": "PdfEncodings.SymbolTTConversion::::charToByte(char,java.lang.String)", "574": "PdfEncodings.SymbolTTConversion::::charToByte(char,java.lang.String)", "575": "PdfEncodings.SymbolTTConversion::::charToByte(char,java.lang.String)", "576": "PdfEncodings.SymbolTTConversion::::charToByte(char,java.lang.String)", "577": "PdfEncodings.SymbolTTConversion::::charToByte(char,java.lang.String)", "579": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "580": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "581": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "582": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "583": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "584": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "585": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "586": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "587": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "588": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "589": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "590": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "591": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "592": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "593": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "594": "PdfEncodings.SymbolTTConversion::::charToByte(java.lang.String,java.lang.String)", "596": "PdfEncodings.SymbolTTConversion::::byteToChar(byte[],java.lang.String)", "597": "PdfEncodings.SymbolTTConversion::::byteToChar(byte[],java.lang.String)", "598": "PdfEncodings.SymbolTTConversion::::byteToChar(byte[],java.lang.String)"}, "test_reverse_method_lines_dic": {"35": "PdfEncodingsTest::::convertToBytesNoEncodingTest()", "36": "PdfEncodingsTest::::convertToBytesNoEncodingTest()", "37": "PdfEncodingsTest::::convertToBytesNoEncodingTest()", "38": "PdfEncodingsTest::::convertToBytesNoEncodingTest()", "39": "PdfEncodingsTest::::convertToBytesNoEncodingTest()", "40": "PdfEncodingsTest::::convertToBytesNoEncodingTest()"}, "tests": [{"test_lines": [35, 40], "covered_lines": [69, 88, 106, 125, 127, 129, 132, 133, 134, 135, 138, 139, 140, 141, 145, 146, 147, 148, 149, 150, 222, 223, 323, 324, 325, 326, 328, 367, 391, 392, 446, 458, 459, 460, 465, 466, 470, 471, 472, 473, 475, 476, 478, 518, 537, 557, 558, 559, 560, 562, 563, 564, 565, 567, 570]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/Type1Font.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.logs.IoLogMessageConstant;\n", "import com.itextpdf.io.font.constants.FontWeights;\n", "import com.itextpdf.io.font.constants.StandardFonts;\n", "import com.itextpdf.io.font.otf.Glyph;\n", "import com.itextpdf.io.source.RandomAccessFileOrArray;\n", "import org.slf4j.Logger;\n", "import org.slf4j.LoggerFactory;\n", "\n", "import java.util.HashMap;\n", "import java.util.Map;\n", "import java.util.Objects;\n", "import java.util.StringTokenizer;\n", "\n", "public class Type1Font extends FontProgram {\n", "\n", "\n", "    private Type1Parser fontParser;\n", "\n", "    private String characterSet;\n", "\n", "    /**\n", "     * Represents the section KernPairs in the AFM file.\n", "     * Key is uni1 &lt;&lt; 32 + uni2. Value is kerning value.\n", "     */\n", "    private Map<Long, Integer> kernPairs = new HashMap<>();\n", "\n", "    /**\n", "     * Types of records in a PFB file. ASCII is 1 and BINARY is 2. They have to appear in the PFB file in this sequence.\n", "     */\n", "    private static final int[] PFB_TYPES = {1, 2, 1};\n", "\n", "    private byte[] fontStreamBytes;\n", "    private int[] fontStreamLengths;\n", "\n", "    protected static Type1Font createStandardFont(String name) throws java.io.IOException {\n", "        if (StandardFonts.isStandardFont(name)) {\n", "            return new Type1Font(name, null, null, null);\n", "        } else {\n", "            throw new IOException(\"{0} is not a standard type1 font.\").setMessageParams(name);\n", "        }\n", "    }\n", "\n", "    protected Type1Font() {\n", "        fontNames = new FontNames();\n", "    }\n", "\n", "    protected Type1Font(String metricsPath, String binaryPath, byte[] afm, byte[] pfb) throws java.io.IOException {\n", "        this();\n", "\n", "        fontParser = new Type1Parser(metricsPath, binaryPath, afm, pfb);\n", "        process();\n", "    }\n", "\n", "    protected Type1Font(String baseFont) {\n", "        this();\n", "        getFontNames().setFontName(baseFont);\n", "    }\n", "\n", "    /**\n", "     * Fills missing character codes in {@code codeToGlyph} map.\n", "     *\n", "     * @param fontEncoding to be used to map unicode values to character codes.\n", "     */\n", "    public void initializeGlyphs(FontEncoding fontEncoding) {\n", "        for (int i = 0; i < 256; i++) {\n", "            final int unicode = fontEncoding.getUnicode(i);\n", "            // Original unicodeToGlyph will be the source of widths here\n", "            Glyph fontGlyph = unicodeToGlyph.get(unicode);\n", "            if (fontGlyph == null) {\n", "                continue;\n", "            }\n", "\n", "            Glyph glyph = new Glyph(i, fontGlyph.getWidth(), unicode, fontGlyph.getChars(), false);\n", "            codeToGlyph.put(i, glyph);\n", "            unicodeToGlyph.put(glyph.getUnicode(), glyph);\n", "        }\n", "    }\n", "\n", "    public boolean isBuiltInFont() {\n", "        return fontParser != null && fontParser.isBuiltInFont();\n", "    }\n", "\n", "    @Override\n", "    public int getPdfFontFlags() {\n", "        int flags = 0;\n", "        if (fontMetrics.isFixedPitch()) {\n", "            flags |= 1;\n", "        }\n", "        flags |= isFontSpecific() ? 4 : 32;\n", "        if (fontMetrics.getItalicAngle() < 0) {\n", "            flags |= 64;\n", "        }\n", "        if (fontNames.getFontName().contains(\"Caps\") || fontNames.getFontName().endsWith(\"SC\")) {\n", "            flags |= 131072;\n", "        }\n", "        if (fontNames.isBold() || fontNames.getFontWeight() > 500) {\n", "            flags |= 262144;\n", "        }\n", "        return flags;\n", "    }\n", "\n", "    public String getCharacterSet() {\n", "        return characterSet;\n", "    }\n", "\n", "    /**\n", "     * Checks if the font has any kerning pairs.\n", "     *\n", "     * @return {@code true} if the font has any kerning pairs.\n", "     */\n", "    @Override\n", "    public boolean hasKernPairs() {\n", "        return kernPairs.size() > 0;\n", "    }\n", "\n", "    @Override\n", "    public int getKerning(Glyph first, Glyph second) {\n", "        if (first.hasValidUnicode() && second.hasValidUnicode()) {\n", "            long record = ((long)first.getUnicode() << 32) + second.getUnicode();\n", "            if (kernPairs.containsKey(record)) {\n", "                return (int) kernPairs.get(record);\n", "            } else {\n", "                return 0;\n", "            }\n", "        }\n", "        return 0;\n", "    }\n", "\n", "    /**\n", "     * Sets the kerning between two Unicode chars.\n", "     *\n", "     * @param first the first unicode char.\n", "     * @param second the second unicode char.\n", "     * @param kern  the kerning to apply in normalized 1000 units.\n", "     * @return {@code true} if the kerning was applied, {@code false} otherwise.\n", "     */\n", "    public boolean setKerning(int first, int second, int kern) {\n", "        long record = ((long)first << 32) + second;\n", "        kernPairs.put(record, kern);\n", "        return true;\n", "    }\n", "\n", "    /**\n", "     * Find glyph by glyph name.\n", "     * @param name Glyph name\n", "     * @return Glyph instance if found, otherwise null.\n", "     */\n", "    public Glyph getGlyph(String name) {\n", "        int unicode = AdobeGlyphList.nameToUnicode(name);\n", "        if (unicode != -1) {\n", "            return getGlyph((int) unicode);\n", "        } else {\n", "            return null;\n", "        }\n", "    }\n", "\n", "    public byte[] getFontStreamBytes() {\n", "        if (fontParser.isBuiltInFont())\n", "            return null;\n", "        if (fontStreamBytes != null)\n", "            return fontStreamBytes;\n", "        RandomAccessFileOrArray raf = null;\n", "        try {\n", "            raf = fontParser.getPostscriptBinary();\n", "            int fileLength = (int) raf.length();\n", "            fontStreamBytes = new byte[fileLength - 18];\n", "            fontStreamLengths = new int[3];\n", "            int bytePtr = 0;\n", "            for (int k = 0; k < 3; ++k) {\n", "                if (raf.read() != 0x80) {\n", "                    Logger logger = LoggerFactory.getLogger(Type1Font.class);\n", "                    logger.error(IoLogMessageConstant.START_MARKER_MISSING_IN_PFB_FILE);\n", "                    return null;\n", "                }\n", "                if (raf.read() != PFB_TYPES[k]) {\n", "                    Logger logger = LoggerFactory.getLogger(Type1Font.class);\n", "                    logger.error(\"incorrect.segment.type.in.pfb.file\");\n", "                    return null;\n", "                }\n", "                int size = raf.read();\n", "                size += raf.read() << 8;\n", "                size += raf.read() << 16;\n", "                size += raf.read() << 24;\n", "                fontStreamLengths[k] = size;\n", "                while (size != 0) {\n", "                    int got = raf.read(fontStreamBytes, bytePtr, size);\n", "                    if (got < 0) {\n", "                        Logger logger = LoggerFactory.getLogger(Type1Font.class);\n", "                        logger.error(\"premature.end.in.pfb.file\");\n", "                        return null;\n", "                    }\n", "                    bytePtr += got;\n", "                    size -= got;\n", "                }\n", "            }\n", "            return fontStreamBytes;\n", "        } catch (Exception e) {\n", "            Logger logger = LoggerFactory.getLogger(Type1Font.class);\n", "            logger.error(\"type1.font.file.exception\");\n", "            return null;\n", "        } finally {\n", "            if (raf != null) {\n", "                try {\n", "                    raf.close();\n", "                } catch (Exception ignored) {\n", "                }\n", "            }\n", "        }\n", "    }\n", "\n", "    public int[] getFontStreamLengths() {\n", "        return fontStreamLengths;\n", "    }\n", "\n", "    public boolean isBuiltWith(String fontProgram) {\n", "        return Objects.equals(fontParser.getAfmPath(), fontProgram);\n", "    }\n", "\n", "    protected void process() throws java.io.IOException {\n", "        RandomAccessFileOrArray raf = fontParser.getMetricsFile();\n", "        String line;\n", "        boolean startKernPairs = false;\n", "        while (!startKernPairs && (line = raf.readLine()) != null) {\n", "            StringTokenizer tok = new StringTokenizer(line, \" ,\\n\\r\\t\\f\");\n", "            if (!tok.hasMoreTokens())\n", "                continue;\n", "            String ident = tok.nextToken();\n", "            switch (ident) {\n", "                case \"FontName\":\n", "                    fontNames.setFontName(tok.nextToken(\"\\u00ff\").substring(1));\n", "                    break;\n", "                case \"FullName\":\n", "                    String fullName = tok.nextToken(\"\\u00ff\").substring(1);\n", "                    fontNames.setFullName(new String[][]{new String[]{\"\", \"\", \"\", fullName}});\n", "                    break;\n", "                case \"FamilyName\":\n", "                    String familyName = tok.nextToken(\"\\u00ff\").substring(1);\n", "                    fontNames.setFamilyName(new String[][]{new String[]{\"\", \"\", \"\", familyName}});\n", "                    break;\n", "                case \"Weight\":\n", "                    fontNames.setFontWeight(FontWeights.fromType1FontWeight(tok.nextToken(\"\\u00ff\").substring(1)));\n", "                    break;\n", "                case \"ItalicAngle\":\n", "                    fontMetrics.setItalicAngle(Float.parseFloat(tok.nextToken()));\n", "                    break;\n", "                case \"IsFixedPitch\":\n", "                    fontMetrics.setIsFixedPitch(tok.nextToken().equals(\"true\"));\n", "                    break;\n", "                case \"CharacterSet\":\n", "                    characterSet = tok.nextToken(\"\\u00ff\").substring(1);\n", "                    break;\n", "                case \"FontBBox\":\n", "                    int llx = (int) Float.parseFloat(tok.nextToken());\n", "                    int lly = (int) Float.parseFloat(tok.nextToken());\n", "                    int urx = (int) Float.parseFloat(tok.nextToken());\n", "                    int ury = (int) Float.parseFloat(tok.nextToken());\n", "                    fontMetrics.setBbox(llx, lly, urx, ury);\n", "                    break;\n", "                case \"UnderlinePosition\":\n", "                    fontMetrics.setUnderlinePosition((int) Float.parseFloat(tok.nextToken()));\n", "                    break;\n", "                case \"UnderlineThickness\":\n", "                    fontMetrics.setUnderlineThickness((int) Float.parseFloat(tok.nextToken()));\n", "                    break;\n", "                case \"EncodingScheme\":\n", "                    encodingScheme = tok.nextToken(\"\\u00ff\").substring(1).trim();\n", "                    break;\n", "                case \"CapHeight\":\n", "                    fontMetrics.setCapHeight((int) Float.parseFloat(tok.nextToken()));\n", "                    break;\n", "                case \"XHeight\":\n", "                    fontMetrics.setXHeight((int) Float.parseFloat(tok.nextToken()));\n", "                    break;\n", "                case \"Ascender\":\n", "                    fontMetrics.setTypoAscender((int) Float.parseFloat(tok.nextToken()));\n", "                    break;\n", "                case \"Descender\":\n", "                    fontMetrics.setTypoDescender((int) Float.parseFloat(tok.nextToken()));\n", "                    break;\n", "                case \"StdHW\":\n", "                    fontMetrics.setStemH((int) Float.parseFloat(tok.nextToken()));\n", "                    break;\n", "                case \"StdVW\":\n", "                    fontMetrics.setStemV((int) Float.parseFloat(tok.nextToken()));\n", "                    break;\n", "                case \"StartCharMetrics\":\n", "                    startKernPairs = true;\n", "                    break;\n", "            }\n", "        }\n", "        if (!startKernPairs) {\n", "            String metricsPath = fontParser.getAfmPath();\n", "            if (metricsPath != null) {\n", "                throw new IOException(\"startcharmetrics is missing in {0}.\").setMessageParams(metricsPath);\n", "            } else {\n", "                throw new IOException(\"startcharmetrics is missing in the metrics file.\");\n", "            }\n", "        }\n", "        avgWidth = 0;\n", "        int widthCount = 0;\n", "        while ((line = raf.readLine()) != null) {\n", "            StringTokenizer tok = new StringTokenizer(line);\n", "            if (!tok.hasMoreTokens()) {\n", "                continue;\n", "            }\n", "            String ident = tok.nextToken();\n", "            if (ident.equals(\"EndCharMetrics\")) {\n", "                startKernPairs = false;\n", "                break;\n", "            }\n", "            int C = -1;\n", "            int WX = 250;\n", "            String N = \"\";\n", "            int[] B = null;\n", "            tok = new StringTokenizer(line, \";\");\n", "            while (tok.hasMoreTokens()) {\n", "                StringTokenizer tokc = new StringTokenizer(tok.nextToken());\n", "                if (!tokc.hasMoreTokens()) {\n", "                    continue;\n", "                }\n", "                ident = tokc.nextToken();\n", "                switch (ident) {\n", "                    case \"C\":\n", "                        C = Integer.parseInt(tokc.nextToken());\n", "                        break;\n", "                    case \"WX\":\n", "                        WX = (int) Float.parseFloat(tokc.nextToken());\n", "                        break;\n", "                    case \"N\":\n", "                        N = tokc.nextToken();\n", "                        break;\n", "                    case \"B\":\n", "                        B = new int[]{\n", "                                Integer.parseInt(tokc.nextToken()),\n", "                                Integer.parseInt(tokc.nextToken()),\n", "                                Integer.parseInt(tokc.nextToken()),\n", "                                Integer.parseInt(tokc.nextToken())\n", "                        };\n", "                        break;\n", "                }\n", "            }\n", "            int unicode = AdobeGlyphList.nameToUnicode(N);\n", "            Glyph glyph = new Glyph(C, WX, unicode, B);\n", "            if (C >= 0) {\n", "                codeToGlyph.put(C, glyph);\n", "            }\n", "            if (unicode != -1) {\n", "                unicodeToGlyph.put(unicode, glyph);\n", "            }\n", "            avgWidth += WX;\n", "            widthCount++;\n", "        }\n", "        if (widthCount != 0) {\n", "            avgWidth /= widthCount;\n", "        }\n", "        if (startKernPairs) {\n", "            String metricsPath = fontParser.getAfmPath();\n", "            if (metricsPath != null) {\n", "                throw new IOException(\"endcharmetrics is missing in {0}.\").setMessageParams(metricsPath);\n", "            } else {\n", "                throw new IOException(\"endcharmetrics is missing in the metrics file.\");\n", "            }\n", "        }\n", "\n", "        // From AdobeGlyphList:\n", "        // nonbreakingspace;00A0\n", "        // space;0020\n", "        if (!unicodeToGlyph.containsKey(0x00A0)) {\n", "            Glyph space = unicodeToGlyph.get(0x0020);\n", "            if (space != null) {\n", "                unicodeToGlyph.put(0x00A0, new Glyph(space.getCode(), space.getWidth(), 0x00A0, space.getBbox()));\n", "            }\n", "        }\n", "        boolean endOfMetrics = false;\n", "        while ((line = raf.readLine()) != null) {\n", "            StringTokenizer tok = new StringTokenizer(line);\n", "            if (!tok.hasMoreTokens()) {\n", "                continue;\n", "            }\n", "            String ident = tok.nextToken();\n", "            if (ident.equals(\"EndFontMetrics\")) {\n", "                endOfMetrics = true;\n", "                break;\n", "            } else if (ident.equals(\"StartKernPairs\")) {\n", "                startKernPairs = true;\n", "                break;\n", "            }\n", "        }\n", "        if (startKernPairs) {\n", "            while ((line = raf.readLine()) != null) {\n", "                StringTokenizer tok = new StringTokenizer(line);\n", "                if (!tok.hasMoreTokens()) {\n", "                    continue;\n", "                }\n", "                String ident = tok.nextToken();\n", "                if (ident.equals(\"KPX\")) {\n", "                    String first = tok.nextToken();\n", "                    String second = tok.nextToken();\n", "                    Integer width = (int) Float.parseFloat(tok.nextToken());\n", "\n", "                    int firstUni = AdobeGlyphList.nameToUnicode(first);\n", "                    int secondUni = AdobeGlyphList.nameToUnicode(second);\n", "\n", "                    if (firstUni != -1 && secondUni != -1) {\n", "                        long record = ((long)firstUni << 32) + secondUni;\n", "                        kernPairs.put(record, width);\n", "                    }\n", "                } else if (ident.equals(\"EndKernPairs\")) {\n", "                    startKernPairs = false;\n", "                    break;\n", "                }\n", "            }\n", "        } else if (!endOfMetrics) {\n", "            String metricsPath = fontParser.getAfmPath();\n", "            if (metricsPath != null) {\n", "                throw new IOException(\"endfontmetrics is missing in {0}.\").setMessageParams(metricsPath);\n", "            } else {\n", "                throw new IOException(\"endfontmetrics is missing in the metrics file.\");\n", "            }\n", "        }\n", "\n", "        if (startKernPairs) {\n", "            String metricsPath = fontParser.getAfmPath();\n", "            if (metricsPath != null) {\n", "                throw new IOException(\"endkernpairs is missing in {0}.\").setMessageParams(metricsPath);\n", "            } else {\n", "                throw new IOException(\"endkernpairs is missing in the metrics file.\");\n", "            }\n", "        }\n", "        raf.close();\n", "\n", "        isFontSpecific = !(encodingScheme.equals(\"AdobeStandardEncoding\") || encodingScheme.equals(\"StandardEncoding\"));\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class Type1FontTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void fillUsingEncodingTest() throws IOException {\n", "        FontEncoding fontEncoding = FontEncoding.createFontEncoding(\"WinAnsiEncoding\");\n", "        Type1Font type1StdFont = (Type1Font) FontProgramFactory.createFont(\"Helvetica\", true);\n", "        Assert.assertEquals(149, type1StdFont.codeToGlyph.size());\n", "        type1StdFont.initializeGlyphs(fontEncoding);\n", "        Assert.assertEquals(217, type1StdFont.codeToGlyph.size());\n", "        Assert.assertEquals(0x2013, type1StdFont.codeToGlyph.get(150).getUnicode());\n", "        Assert.assertArrayEquals(new char[]{(char)0x2013}, type1StdFont.codeToGlyph.get(150).getChars());\n", "    }\n", "}\n"], "method_lines_dic": {"Type1Font::::createStandardFont(java.lang.String)": [60, 66], "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)": [89, 102], "Type1Font::::isBuiltInFont()": [104, 106], "Type1Font::::getPdfFontFlags()": [108, 125], "Type1Font::::getCharacterSet()": [127, 129], "Type1Font::::hasKernPairs()": [136, 139], "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)": [141, 152], "Type1Font::::setKerning(int,int,int)": [162, 166], "Type1Font::::getGlyph(java.lang.String)": [173, 180], "Type1Font::::getFontStreamBytes()": [182, 234], "Type1Font::::getFontStreamLengths()": [236, 238], "Type1Font::::isBuiltWith(java.lang.String)": [240, 242], "Type1Font::::process()": [244, 458]}, "test_method_lines_dic": {"Type1FontTest::::fillUsingEncodingTest()": [36, 45]}, "reverse_method_lines_dic": {"60": "Type1Font::::createStandardFont(java.lang.String)", "61": "Type1Font::::createStandardFont(java.lang.String)", "62": "Type1Font::::createStandardFont(java.lang.String)", "63": "Type1Font::::createStandardFont(java.lang.String)", "64": "Type1Font::::createStandardFont(java.lang.String)", "65": "Type1Font::::createStandardFont(java.lang.String)", "66": "Type1Font::::createStandardFont(java.lang.String)", "89": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "90": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "91": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "92": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "93": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "94": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "95": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "96": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "97": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "98": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "99": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "100": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "101": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "102": "Type1Font::::initializeGlyphs(com.itextpdf.io.font.FontEncoding)", "104": "Type1Font::::isBuiltInFont()", "105": "Type1Font::::isBuiltInFont()", "106": "Type1Font::::isBuiltInFont()", "108": "Type1Font::::getPdfFontFlags()", "109": "Type1Font::::getPdfFontFlags()", "110": "Type1Font::::getPdfFontFlags()", "111": "Type1Font::::getPdfFontFlags()", "112": "Type1Font::::getPdfFontFlags()", "113": "Type1Font::::getPdfFontFlags()", "114": "Type1Font::::getPdfFontFlags()", "115": "Type1Font::::getPdfFontFlags()", "116": "Type1Font::::getPdfFontFlags()", "117": "Type1Font::::getPdfFontFlags()", "118": "Type1Font::::getPdfFontFlags()", "119": "Type1Font::::getPdfFontFlags()", "120": "Type1Font::::getPdfFontFlags()", "121": "Type1Font::::getPdfFontFlags()", "122": "Type1Font::::getPdfFontFlags()", "123": "Type1Font::::getPdfFontFlags()", "124": "Type1Font::::getPdfFontFlags()", "125": "Type1Font::::getPdfFontFlags()", "127": "Type1Font::::getCharacterSet()", "128": "Type1Font::::getCharacterSet()", "129": "Type1Font::::getCharacterSet()", "136": "Type1Font::::hasKernPairs()", "137": "Type1Font::::hasKernPairs()", "138": "Type1Font::::hasKernPairs()", "139": "Type1Font::::hasKernPairs()", "141": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "142": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "143": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "144": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "145": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "146": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "147": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "148": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "149": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "150": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "151": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "152": "Type1Font::::getKerning(com.itextpdf.io.font.otf.Glyph,com.itextpdf.io.font.otf.Glyph)", "162": "Type1Font::::setKerning(int,int,int)", "163": "Type1Font::::setKerning(int,int,int)", "164": "Type1Font::::setKerning(int,int,int)", "165": "Type1Font::::setKerning(int,int,int)", "166": "Type1Font::::setKerning(int,int,int)", "173": "Type1Font::::getGlyph(java.lang.String)", "174": "Type1Font::::getGlyph(java.lang.String)", "175": "Type1Font::::getGlyph(java.lang.String)", "176": "Type1Font::::getGlyph(java.lang.String)", "177": "Type1Font::::getGlyph(java.lang.String)", "178": "Type1Font::::getGlyph(java.lang.String)", "179": "Type1Font::::getGlyph(java.lang.String)", "180": "Type1Font::::getGlyph(java.lang.String)", "182": "Type1Font::::getFontStreamBytes()", "183": "Type1Font::::getFontStreamBytes()", "184": "Type1Font::::getFontStreamBytes()", "185": "Type1Font::::getFontStreamBytes()", "186": "Type1Font::::getFontStreamBytes()", "187": "Type1Font::::getFontStreamBytes()", "188": "Type1Font::::getFontStreamBytes()", "189": "Type1Font::::getFontStreamBytes()", "190": "Type1Font::::getFontStreamBytes()", "191": "Type1Font::::getFontStreamBytes()", "192": "Type1Font::::getFontStreamBytes()", "193": "Type1Font::::getFontStreamBytes()", "194": "Type1Font::::getFontStreamBytes()", "195": "Type1Font::::getFontStreamBytes()", "196": "Type1Font::::getFontStreamBytes()", "197": "Type1Font::::getFontStreamBytes()", "198": "Type1Font::::getFontStreamBytes()", "199": "Type1Font::::getFontStreamBytes()", "200": "Type1Font::::getFontStreamBytes()", "201": "Type1Font::::getFontStreamBytes()", "202": "Type1Font::::getFontStreamBytes()", "203": "Type1Font::::getFontStreamBytes()", "204": "Type1Font::::getFontStreamBytes()", "205": "Type1Font::::getFontStreamBytes()", "206": "Type1Font::::getFontStreamBytes()", "207": "Type1Font::::getFontStreamBytes()", "208": "Type1Font::::getFontStreamBytes()", "209": "Type1Font::::getFontStreamBytes()", "210": "Type1Font::::getFontStreamBytes()", "211": "Type1Font::::getFontStreamBytes()", "212": "Type1Font::::getFontStreamBytes()", "213": "Type1Font::::getFontStreamBytes()", "214": "Type1Font::::getFontStreamBytes()", "215": "Type1Font::::getFontStreamBytes()", "216": "Type1Font::::getFontStreamBytes()", "217": "Type1Font::::getFontStreamBytes()", "218": "Type1Font::::getFontStreamBytes()", "219": "Type1Font::::getFontStreamBytes()", "220": "Type1Font::::getFontStreamBytes()", "221": "Type1Font::::getFontStreamBytes()", "222": "Type1Font::::getFontStreamBytes()", "223": "Type1Font::::getFontStreamBytes()", "224": "Type1Font::::getFontStreamBytes()", "225": "Type1Font::::getFontStreamBytes()", "226": "Type1Font::::getFontStreamBytes()", "227": "Type1Font::::getFontStreamBytes()", "228": "Type1Font::::getFontStreamBytes()", "229": "Type1Font::::getFontStreamBytes()", "230": "Type1Font::::getFontStreamBytes()", "231": "Type1Font::::getFontStreamBytes()", "232": "Type1Font::::getFontStreamBytes()", "233": "Type1Font::::getFontStreamBytes()", "234": "Type1Font::::getFontStreamBytes()", "236": "Type1Font::::getFontStreamLengths()", "237": "Type1Font::::getFontStreamLengths()", "238": "Type1Font::::getFontStreamLengths()", "240": "Type1Font::::isBuiltWith(java.lang.String)", "241": "Type1Font::::isBuiltWith(java.lang.String)", "242": "Type1Font::::isBuiltWith(java.lang.String)", "244": "Type1Font::::process()", "245": "Type1Font::::process()", "246": "Type1Font::::process()", "247": "Type1Font::::process()", "248": "Type1Font::::process()", "249": "Type1Font::::process()", "250": "Type1Font::::process()", "251": "Type1Font::::process()", "252": "Type1Font::::process()", "253": "Type1Font::::process()", "254": "Type1Font::::process()", "255": "Type1Font::::process()", "256": "Type1Font::::process()", "257": "Type1Font::::process()", "258": "Type1Font::::process()", "259": "Type1Font::::process()", "260": "Type1Font::::process()", "261": "Type1Font::::process()", "262": "Type1Font::::process()", "263": "Type1Font::::process()", "264": "Type1Font::::process()", "265": "Type1Font::::process()", "266": "Type1Font::::process()", "267": "Type1Font::::process()", "268": "Type1Font::::process()", "269": "Type1Font::::process()", "270": "Type1Font::::process()", "271": "Type1Font::::process()", "272": "Type1Font::::process()", "273": "Type1Font::::process()", "274": "Type1Font::::process()", "275": "Type1Font::::process()", "276": "Type1Font::::process()", "277": "Type1Font::::process()", "278": "Type1Font::::process()", "279": "Type1Font::::process()", "280": "Type1Font::::process()", "281": "Type1Font::::process()", "282": "Type1Font::::process()", "283": "Type1Font::::process()", "284": "Type1Font::::process()", "285": "Type1Font::::process()", "286": "Type1Font::::process()", "287": "Type1Font::::process()", "288": "Type1Font::::process()", "289": "Type1Font::::process()", "290": "Type1Font::::process()", "291": "Type1Font::::process()", "292": "Type1Font::::process()", "293": "Type1Font::::process()", "294": "Type1Font::::process()", "295": "Type1Font::::process()", "296": "Type1Font::::process()", "297": "Type1Font::::process()", "298": "Type1Font::::process()", "299": "Type1Font::::process()", "300": "Type1Font::::process()", "301": "Type1Font::::process()", "302": "Type1Font::::process()", "303": "Type1Font::::process()", "304": "Type1Font::::process()", "305": "Type1Font::::process()", "306": "Type1Font::::process()", "307": "Type1Font::::process()", "308": "Type1Font::::process()", "309": "Type1Font::::process()", "310": "Type1Font::::process()", "311": "Type1Font::::process()", "312": "Type1Font::::process()", "313": "Type1Font::::process()", "314": "Type1Font::::process()", "315": "Type1Font::::process()", "316": "Type1Font::::process()", "317": "Type1Font::::process()", "318": "Type1Font::::process()", "319": "Type1Font::::process()", "320": "Type1Font::::process()", "321": "Type1Font::::process()", "322": "Type1Font::::process()", "323": "Type1Font::::process()", "324": "Type1Font::::process()", "325": "Type1Font::::process()", "326": "Type1Font::::process()", "327": "Type1Font::::process()", "328": "Type1Font::::process()", "329": "Type1Font::::process()", "330": "Type1Font::::process()", "331": "Type1Font::::process()", "332": "Type1Font::::process()", "333": "Type1Font::::process()", "334": "Type1Font::::process()", "335": "Type1Font::::process()", "336": "Type1Font::::process()", "337": "Type1Font::::process()", "338": "Type1Font::::process()", "339": "Type1Font::::process()", "340": "Type1Font::::process()", "341": "Type1Font::::process()", "342": "Type1Font::::process()", "343": "Type1Font::::process()", "344": "Type1Font::::process()", "345": "Type1Font::::process()", "346": "Type1Font::::process()", "347": "Type1Font::::process()", "348": "Type1Font::::process()", "349": "Type1Font::::process()", "350": "Type1Font::::process()", "351": "Type1Font::::process()", "352": "Type1Font::::process()", "353": "Type1Font::::process()", "354": "Type1Font::::process()", "355": "Type1Font::::process()", "356": "Type1Font::::process()", "357": "Type1Font::::process()", "358": "Type1Font::::process()", "359": "Type1Font::::process()", "360": "Type1Font::::process()", "361": "Type1Font::::process()", "362": "Type1Font::::process()", "363": "Type1Font::::process()", "364": "Type1Font::::process()", "365": "Type1Font::::process()", "366": "Type1Font::::process()", "367": "Type1Font::::process()", "368": "Type1Font::::process()", "369": "Type1Font::::process()", "370": "Type1Font::::process()", "371": "Type1Font::::process()", "372": "Type1Font::::process()", "373": "Type1Font::::process()", "374": "Type1Font::::process()", "375": "Type1Font::::process()", "376": "Type1Font::::process()", "377": "Type1Font::::process()", "378": "Type1Font::::process()", "379": "Type1Font::::process()", "380": "Type1Font::::process()", "381": "Type1Font::::process()", "382": "Type1Font::::process()", "383": "Type1Font::::process()", "384": "Type1Font::::process()", "385": "Type1Font::::process()", "386": "Type1Font::::process()", "387": "Type1Font::::process()", "388": "Type1Font::::process()", "389": "Type1Font::::process()", "390": "Type1Font::::process()", "391": "Type1Font::::process()", "392": "Type1Font::::process()", "393": "Type1Font::::process()", "394": "Type1Font::::process()", "395": "Type1Font::::process()", "396": "Type1Font::::process()", "397": "Type1Font::::process()", "398": "Type1Font::::process()", "399": "Type1Font::::process()", "400": "Type1Font::::process()", "401": "Type1Font::::process()", "402": "Type1Font::::process()", "403": "Type1Font::::process()", "404": "Type1Font::::process()", "405": "Type1Font::::process()", "406": "Type1Font::::process()", "407": "Type1Font::::process()", "408": "Type1Font::::process()", "409": "Type1Font::::process()", "410": "Type1Font::::process()", "411": "Type1Font::::process()", "412": "Type1Font::::process()", "413": "Type1Font::::process()", "414": "Type1Font::::process()", "415": "Type1Font::::process()", "416": "Type1Font::::process()", "417": "Type1Font::::process()", "418": "Type1Font::::process()", "419": "Type1Font::::process()", "420": "Type1Font::::process()", "421": "Type1Font::::process()", "422": "Type1Font::::process()", "423": "Type1Font::::process()", "424": "Type1Font::::process()", "425": "Type1Font::::process()", "426": "Type1Font::::process()", "427": "Type1Font::::process()", "428": "Type1Font::::process()", "429": "Type1Font::::process()", "430": "Type1Font::::process()", "431": "Type1Font::::process()", "432": "Type1Font::::process()", "433": "Type1Font::::process()", "434": "Type1Font::::process()", "435": "Type1Font::::process()", "436": "Type1Font::::process()", "437": "Type1Font::::process()", "438": "Type1Font::::process()", "439": "Type1Font::::process()", "440": "Type1Font::::process()", "441": "Type1Font::::process()", "442": "Type1Font::::process()", "443": "Type1Font::::process()", "444": "Type1Font::::process()", "445": "Type1Font::::process()", "446": "Type1Font::::process()", "447": "Type1Font::::process()", "448": "Type1Font::::process()", "449": "Type1Font::::process()", "450": "Type1Font::::process()", "451": "Type1Font::::process()", "452": "Type1Font::::process()", "453": "Type1Font::::process()", "454": "Type1Font::::process()", "455": "Type1Font::::process()", "456": "Type1Font::::process()", "457": "Type1Font::::process()", "458": "Type1Font::::process()"}, "test_reverse_method_lines_dic": {"36": "Type1FontTest::::fillUsingEncodingTest()", "37": "Type1FontTest::::fillUsingEncodingTest()", "38": "Type1FontTest::::fillUsingEncodingTest()", "39": "Type1FontTest::::fillUsingEncodingTest()", "40": "Type1FontTest::::fillUsingEncodingTest()", "41": "Type1FontTest::::fillUsingEncodingTest()", "42": "Type1FontTest::::fillUsingEncodingTest()", "43": "Type1FontTest::::fillUsingEncodingTest()", "44": "Type1FontTest::::fillUsingEncodingTest()", "45": "Type1FontTest::::fillUsingEncodingTest()"}, "tests": [{"test_lines": [36, 45], "covered_lines": [50, 55, 68, 69, 70, 73, 75, 76, 77, 90, 91, 93, 94, 95, 98, 99, 100, 102, 245, 247, 248, 249, 250, 252, 253, 255, 256, 258, 259, 260, 262, 263, 264, 266, 267, 269, 270, 272, 273, 275, 276, 278, 279, 280, 281, 282, 283, 285, 286, 288, 289, 291, 292, 294, 295, 297, 298, 300, 301, 303, 304, 306, 307, 309, 310, 312, 315, 316, 324, 325, 326, 327, 328, 331, 332, 333, 334, 336, 337, 338, 339, 340, 341, 342, 343, 346, 347, 349, 350, 352, 353, 355, 356, 358, 359, 360, 361, 362, 366, 367, 368, 369, 370, 372, 373, 375, 376, 377, 378, 379, 381, 393, 394, 395, 396, 399, 400, 401, 402, 405, 406, 409, 410, 411, 413, 414, 415, 416, 417, 420, 421, 422, 423, 424, 426, 427, 429, 430, 431, 433, 434, 435, 437, 447, 455, 457, 458]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/FontProgramDescriptorFactory.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.font.constants.StandardFonts;\n", "import com.itextpdf.io.font.woff2.Woff2Converter;\n", "\n", "public final class FontProgramDescriptorFactory {\n", "    private static boolean FETCH_CACHED_FIRST = true;\n", "\n", "    public static FontProgramDescriptor fetchDescriptor(String fontName) {\n", "        if (fontName == null || fontName.length() == 0) {\n", "            return null;\n", "        }\n", "\n", "        String baseName = FontProgram.trimFontStyle(fontName);\n", "        //yes, we trying to find built-in standard font with original name, not baseName.\n", "        boolean isBuiltinFonts14 = StandardFonts.isStandardFont(fontName);\n", "        boolean isCidFont = !isBuiltinFonts14 && CjkResourceLoader.isPredefinedCidFont(baseName);\n", "\n", "        FontProgramDescriptor fontDescriptor = null;\n", "        if (FETCH_CACHED_FIRST) {\n", "            fontDescriptor = fetchCachedDescriptor(fontName, null);\n", "            if (fontDescriptor != null) {\n", "                return fontDescriptor;\n", "            }\n", "        }\n", "\n", "        try {\n", "            String fontNameLowerCase = baseName.toLowerCase();\n", "            if (isBuiltinFonts14 || fontNameLowerCase.endsWith(\".afm\") || fontNameLowerCase.endsWith(\".pfm\")) {\n", "                fontDescriptor = fetchType1FontDescriptor(fontName, null);\n", "            } else if (isCidFont) {\n", "                fontDescriptor = fetchCidFontDescriptor(fontName);\n", "            } else if (fontNameLowerCase.endsWith(\".ttf\") || fontNameLowerCase.endsWith(\".otf\")) {\n", "                fontDescriptor = fetchTrueTypeFontDescriptor(fontName);\n", "            } else if (fontNameLowerCase.endsWith(\".woff\") || fontNameLowerCase.endsWith(\".woff2\")) {\n", "                byte[] fontProgram;\n", "                if (fontNameLowerCase.endsWith(\".woff\")) {\n", "                    fontProgram = WoffConverter.convert(FontProgramFactory.readFontBytesFromPath(baseName));\n", "                } else {\n", "                    fontProgram = Woff2Converter.convert(FontProgramFactory.readFontBytesFromPath(baseName));\n", "                }\n", "                fontDescriptor = fetchTrueTypeFontDescriptor(fontProgram);\n", "            } else {\n", "                fontDescriptor = fetchTTCDescriptor(baseName);\n", "            }\n", "        } catch (Exception ignored) {\n", "            fontDescriptor = null;\n", "        }\n", "\n", "        return fontDescriptor;\n", "    }\n", "\n", "    public static FontProgramDescriptor fetchDescriptor(byte[] fontProgram) {\n", "        if (fontProgram == null || fontProgram.length == 0) {\n", "            return null;\n", "        }\n", "\n", "        FontProgramDescriptor fontDescriptor = null;\n", "        if (FETCH_CACHED_FIRST) {\n", "            fontDescriptor = fetchCachedDescriptor(null, fontProgram);\n", "            if (fontDescriptor != null) {\n", "                return fontDescriptor;\n", "            }\n", "        }\n", "\n", "        try {\n", "            fontDescriptor = fetchTrueTypeFontDescriptor(fontProgram);\n", "        } catch (Exception ignored) {\n", "        }\n", "        if (fontDescriptor == null) {\n", "            try {\n", "                fontDescriptor = fetchType1FontDescriptor(null, fontProgram);\n", "            } catch (Exception ignored) {\n", "            }\n", "        }\n", "        return fontDescriptor;\n", "    }\n", "\n", "    public static FontProgramDescriptor fetchDescriptor(FontProgram fontProgram) {\n", "        return fetchDescriptorFromFontProgram(fontProgram);\n", "    }\n", "\n", "    private static FontProgramDescriptor fetchCachedDescriptor(String fontName, byte[] fontProgram) {\n", "        FontProgram fontFound;\n", "        FontCacheKey key;\n", "        if (fontName != null) {\n", "            key = FontCacheKey.create(fontName);\n", "        } else {\n", "            key = FontCacheKey.create(fontProgram);\n", "        }\n", "        fontFound = FontCache.getFont(key);\n", "        return fontFound != null ? fetchDescriptorFromFontProgram(fontFound) : null;\n", "    }\n", "\n", "    private static FontProgramDescriptor fetchTTCDescriptor(String baseName) throws java.io.IOException {\n", "        int ttcSplit = baseName.toLowerCase().indexOf(\".ttc,\");\n", "        if (ttcSplit > 0) {\n", "            String ttcName;\n", "            int ttcIndex;\n", "            try {\n", "                // count(.ttc) = 4\n", "                ttcName = baseName.substring(0, ttcSplit + 4);\n", "                // count(.ttc,) = 5)\n", "                ttcIndex = Integer.parseInt(baseName.substring(ttcSplit + 5));\n", "            } catch (NumberFormatException nfe) {\n", "                throw new IOException(nfe.getMessage(), nfe);\n", "            }\n", "            OpenTypeParser parser = new OpenTypeParser(ttcName, ttcIndex);\n", "            FontProgramDescriptor descriptor = fetchOpenTypeFontDescriptor(parser);\n", "            parser.close();\n", "            return descriptor;\n", "        } else {\n", "            return null;\n", "        }\n", "    }\n", "\n", "    private static FontProgramDescriptor fetchTrueTypeFontDescriptor(String fontName) throws java.io.IOException {\n", "        try (OpenTypeParser parser = new OpenTypeParser(fontName)) {\n", "            return fetchOpenTypeFontDescriptor(parser);\n", "        }\n", "    }\n", "\n", "    private static FontProgramDescriptor fetchTrueTypeFontDescriptor(byte[] fontProgram) throws java.io.IOException {\n", "        try (OpenTypeParser parser = new OpenTypeParser(fontProgram)) {\n", "            return fetchOpenTypeFontDescriptor(parser);\n", "        }\n", "    }\n", "\n", "    private static FontProgramDescriptor fetchOpenTypeFontDescriptor(OpenTypeParser fontParser) throws java.io.IOException {\n", "        fontParser.loadTables(false);\n", "        return new FontProgramDescriptor(fontParser.getFontNames(), fontParser.getPostTable().italicAngle,\n", "                fontParser.getPostTable().isFixedPitch);\n", "    }\n", "\n", "    private static FontProgramDescriptor fetchType1FontDescriptor(String fontName, byte[] afm) throws java.io.IOException {\n", "        Type1Font fp = new Type1Font(fontName, null, afm, null);\n", "        return new FontProgramDescriptor(fp.getFontNames(), fp.getFontMetrics());\n", "    }\n", "\n", "    private static FontProgramDescriptor fetchCidFontDescriptor(String fontName) {\n", "        CidFont font = new CidFont(fontName, null, null);\n", "        return new FontProgramDescriptor(font.getFontNames(), font.getFontMetrics());\n", "    }\n", "\n", "    private static FontProgramDescriptor fetchDescriptorFromFontProgram(FontProgram fontProgram) {\n", "        return new FontProgramDescriptor(fontProgram.getFontNames(), fontProgram.getFontMetrics());\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "\n", "@Category(UnitTest.class)\n", "public class FontProgramDescriptorFactoryTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void kozminNamesTest() {\n", "        FontProgramDescriptor descriptor = FontProgramDescriptorFactory.fetchDescriptor(\"KozMinPro-Regular\");\n", "        Assert.assertEquals(\"KozMinPro-Regular\", descriptor.getFontName());\n", "        Assert.assertEquals(\"KozMinPro-Regular\".toLowerCase(), descriptor.getFullNameLowerCase());\n", "        Assert.assertEquals(400, descriptor.getFontWeight());\n", "    }\n", "\n", "    @Test\n", "    public void helveticaNamesTest() {\n", "        FontProgramDescriptor descriptor = FontProgramDescriptorFactory.fetchDescriptor(\"Helvetica\");\n", "        Assert.assertEquals(\"Helvetica\", descriptor.getFontName());\n", "        Assert.assertEquals(\"helvetica\", descriptor.getFullNameLowerCase());\n", "        Assert.assertEquals(\"helvetica\", descriptor.getFullNameLowerCase());\n", "        Assert.assertEquals(500, descriptor.getFontWeight());\n", "    }\n", "}\n"], "method_lines_dic": {"FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)": [32, 74], "FontProgramDescriptorFactory::::fetchDescriptor(byte[])": [76, 100], "FontProgramDescriptorFactory::::fetchDescriptor(com.itextpdf.io.font.FontProgram)": [102, 104], "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])": [106, 116], "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)": [118, 138], "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(java.lang.String)": [140, 144], "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(byte[])": [146, 150], "FontProgramDescriptorFactory::::fetchOpenTypeFontDescriptor(com.itextpdf.io.font.OpenTypeParser)": [152, 156], "FontProgramDescriptorFactory::::fetchType1FontDescriptor(java.lang.String,byte[])": [158, 161], "FontProgramDescriptorFactory::::fetchCidFontDescriptor(java.lang.String)": [163, 166], "FontProgramDescriptorFactory::::fetchDescriptorFromFontProgram(com.itextpdf.io.font.FontProgram)": [168, 170]}, "test_method_lines_dic": {"FontProgramDescriptorFactoryTest::::kozminNamesTest()": [36, 42], "FontProgramDescriptorFactoryTest::::helveticaNamesTest()": [44, 51]}, "reverse_method_lines_dic": {"32": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "33": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "34": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "35": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "36": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "37": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "38": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "39": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "40": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "41": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "42": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "43": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "44": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "45": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "46": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "47": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "48": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "49": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "50": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "51": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "52": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "53": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "54": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "55": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "56": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "57": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "58": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "59": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "60": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "61": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "62": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "63": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "64": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "65": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "66": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "67": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "68": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "69": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "70": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "71": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "72": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "73": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "74": "FontProgramDescriptorFactory::::fetchDescriptor(java.lang.String)", "76": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "77": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "78": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "79": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "80": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "81": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "82": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "83": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "84": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "85": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "86": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "87": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "88": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "89": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "90": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "91": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "92": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "93": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "94": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "95": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "96": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "97": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "98": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "99": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "100": "FontProgramDescriptorFactory::::fetchDescriptor(byte[])", "102": "FontProgramDescriptorFactory::::fetchDescriptor(com.itextpdf.io.font.FontProgram)", "103": "FontProgramDescriptorFactory::::fetchDescriptor(com.itextpdf.io.font.FontProgram)", "104": "FontProgramDescriptorFactory::::fetchDescriptor(com.itextpdf.io.font.FontProgram)", "106": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "107": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "108": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "109": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "110": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "111": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "112": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "113": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "114": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "115": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "116": "FontProgramDescriptorFactory::::fetchCachedDescriptor(java.lang.String,byte[])", "118": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "119": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "120": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "121": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "122": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "123": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "124": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "125": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "126": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "127": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "128": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "129": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "130": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "131": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "132": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "133": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "134": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "135": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "136": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "137": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "138": "FontProgramDescriptorFactory::::fetchTTCDescriptor(java.lang.String)", "140": "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(java.lang.String)", "141": "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(java.lang.String)", "142": "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(java.lang.String)", "143": "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(java.lang.String)", "144": "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(java.lang.String)", "146": "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(byte[])", "147": "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(byte[])", "148": "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(byte[])", "149": "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(byte[])", "150": "FontProgramDescriptorFactory::::fetchTrueTypeFontDescriptor(byte[])", "152": "FontProgramDescriptorFactory::::fetchOpenTypeFontDescriptor(com.itextpdf.io.font.OpenTypeParser)", "153": "FontProgramDescriptorFactory::::fetchOpenTypeFontDescriptor(com.itextpdf.io.font.OpenTypeParser)", "154": "FontProgramDescriptorFactory::::fetchOpenTypeFontDescriptor(com.itextpdf.io.font.OpenTypeParser)", "155": "FontProgramDescriptorFactory::::fetchOpenTypeFontDescriptor(com.itextpdf.io.font.OpenTypeParser)", "156": "FontProgramDescriptorFactory::::fetchOpenTypeFontDescriptor(com.itextpdf.io.font.OpenTypeParser)", "158": "FontProgramDescriptorFactory::::fetchType1FontDescriptor(java.lang.String,byte[])", "159": "FontProgramDescriptorFactory::::fetchType1FontDescriptor(java.lang.String,byte[])", "160": "FontProgramDescriptorFactory::::fetchType1FontDescriptor(java.lang.String,byte[])", "161": "FontProgramDescriptorFactory::::fetchType1FontDescriptor(java.lang.String,byte[])", "163": "FontProgramDescriptorFactory::::fetchCidFontDescriptor(java.lang.String)", "164": "FontProgramDescriptorFactory::::fetchCidFontDescriptor(java.lang.String)", "165": "FontProgramDescriptorFactory::::fetchCidFontDescriptor(java.lang.String)", "166": "FontProgramDescriptorFactory::::fetchCidFontDescriptor(java.lang.String)", "168": "FontProgramDescriptorFactory::::fetchDescriptorFromFontProgram(com.itextpdf.io.font.FontProgram)", "169": "FontProgramDescriptorFactory::::fetchDescriptorFromFontProgram(com.itextpdf.io.font.FontProgram)", "170": "FontProgramDescriptorFactory::::fetchDescriptorFromFontProgram(com.itextpdf.io.font.FontProgram)"}, "test_reverse_method_lines_dic": {"36": "FontProgramDescriptorFactoryTest::::kozminNamesTest()", "37": "FontProgramDescriptorFactoryTest::::kozminNamesTest()", "38": "FontProgramDescriptorFactoryTest::::kozminNamesTest()", "39": "FontProgramDescriptorFactoryTest::::kozminNamesTest()", "40": "FontProgramDescriptorFactoryTest::::kozminNamesTest()", "41": "FontProgramDescriptorFactoryTest::::kozminNamesTest()", "42": "FontProgramDescriptorFactoryTest::::kozminNamesTest()", "44": "FontProgramDescriptorFactoryTest::::helveticaNamesTest()", "45": "FontProgramDescriptorFactoryTest::::helveticaNamesTest()", "46": "FontProgramDescriptorFactoryTest::::helveticaNamesTest()", "47": "FontProgramDescriptorFactoryTest::::helveticaNamesTest()", "48": "FontProgramDescriptorFactoryTest::::helveticaNamesTest()", "49": "FontProgramDescriptorFactoryTest::::helveticaNamesTest()", "50": "FontProgramDescriptorFactoryTest::::helveticaNamesTest()", "51": "FontProgramDescriptorFactoryTest::::helveticaNamesTest()"}, "tests": [{"test_lines": [36, 42], "covered_lines": [30, 33, 37, 39, 40, 42, 43, 44, 45, 51, 52, 54, 55, 71, 73, 109, 110, 114, 115, 164, 165]}, {"test_lines": [44, 51], "covered_lines": [30, 33, 37, 39, 40, 42, 43, 44, 45, 51, 52, 53, 71, 73, 109, 110, 114, 115, 159, 160]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/CFFFont.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.source.RandomAccessFileOrArray;\n", "import com.itextpdf.io.source.RandomAccessSourceFactory;\n", "\n", "import java.util.LinkedList;\n", "\n", "public class CFFFont {\n", "\n", "    static final String[] operatorNames = {\n", "            \"version\", \"Notice\", \"FullName\", \"FamilyName\",\n", "            \"Weight\", \"FontBBox\", \"BlueValues\", \"OtherBlues\",\n", "            \"FamilyBlues\", \"FamilyOtherBlues\", \"StdHW\", \"StdVW\",\n", "            \"UNKNOWN_12\", \"UniqueID\", \"XUID\", \"charset\",\n", "            \"Encoding\", \"CharStrings\", \"Private\", \"Subrs\",\n", "            \"defaultWidthX\", \"nominalWidthX\", \"UNKNOWN_22\", \"UNKNOWN_23\",\n", "            \"UNKNOWN_24\", \"UNKNOWN_25\", \"UNKNOWN_26\", \"UNKNOWN_27\",\n", "            \"UNKNOWN_28\", \"UNKNOWN_29\", \"UNKNOWN_30\", \"UNKNOWN_31\",\n", "            \"Copyright\", \"isFixedPitch\", \"ItalicAngle\", \"UnderlinePosition\",\n", "            \"UnderlineThickness\", \"PaintType\", \"CharstringType\", \"FontMatrix\",\n", "            \"StrokeWidth\", \"BlueScale\", \"BlueShift\", \"BlueFuzz\",\n", "            \"StemSnapH\", \"StemSnapV\", \"ForceBold\", \"UNKNOWN_12_15\",\n", "            \"UNKNOWN_12_16\", \"LanguageGroup\", \"ExpansionFactor\", \"initialRandomSeed\",\n", "            \"SyntheticBase\", \"PostScript\", \"BaseFontName\", \"BaseFontBlend\",\n", "            \"UNKNOWN_12_24\", \"UNKNOWN_12_25\", \"UNKNOWN_12_26\", \"UNKNOWN_12_27\",\n", "            \"UNKNOWN_12_28\", \"UNKNOWN_12_29\", \"ROS\", \"CIDFontVersion\",\n", "            \"CIDFontRevision\", \"CIDFontType\", \"CIDCount\", \"UIDBase\",\n", "            \"FDArray\", \"FDSelect\", \"FontName\"\n", "    };\n", "\n", "    static final String[] standardStrings = {\n", "            // Automatically generated from Appendix A of the CFF specification; do\n", "            // not edit. Size should be 391.\n", "            \".notdef\", \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\",\n", "            \"percent\", \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\",\n", "            \"asterisk\", \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\", \"zero\", \"one\",\n", "            \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"colon\",\n", "            \"semicolon\", \"less\", \"equal\", \"greater\", \"question\", \"at\", \"A\", \"B\", \"C\",\n", "            \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\",\n", "            \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\", \"backslash\",\n", "            \"bracketright\", \"asciicircum\", \"underscore\", \"quoteleft\", \"a\", \"b\", \"c\",\n", "            \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\",\n", "            \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\", \"braceright\",\n", "            \"asciitilde\", \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\",\n", "            \"florin\", \"section\", \"currency\", \"quotesingle\", \"quotedblleft\",\n", "            \"guillemotleft\", \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\", \"endash\",\n", "            \"dagger\", \"daggerdbl\", \"periodcentered\", \"paragraph\", \"bullet\",\n", "            \"quotesinglbase\", \"quotedblbase\", \"quotedblright\", \"guillemotright\",\n", "            \"ellipsis\", \"perthousand\", \"questiondown\", \"grave\", \"acute\", \"circumflex\",\n", "            \"tilde\", \"macron\", \"breve\", \"dotaccent\", \"dieresis\", \"ring\", \"cedilla\",\n", "            \"hungarumlaut\", \"ogonek\", \"caron\", \"emdash\", \"AE\", \"ordfeminine\", \"Lslash\",\n", "            \"Oslash\", \"OE\", \"ordmasculine\", \"ae\", \"dotlessi\", \"lslash\", \"oslash\", \"oe\",\n", "            \"germandbls\", \"onesuperior\", \"logicalnot\", \"mu\", \"trademark\", \"Eth\",\n", "            \"onehalf\", \"plusminus\", \"Thorn\", \"onequarter\", \"divide\", \"brokenbar\",\n", "            \"degree\", \"thorn\", \"threequarters\", \"twosuperior\", \"registered\", \"minus\",\n", "            \"eth\", \"multiply\", \"threesuperior\", \"copyright\", \"Aacute\", \"Acircumflex\",\n", "            \"Adieresis\", \"Agrave\", \"Aring\", \"Atilde\", \"Ccedilla\", \"Eacute\",\n", "            \"Ecircumflex\", \"Edieresis\", \"Egrave\", \"Iacute\", \"Icircumflex\", \"Idieresis\",\n", "            \"Igrave\", \"Ntilde\", \"Oacute\", \"Ocircumflex\", \"Odieresis\", \"Ograve\",\n", "            \"Otilde\", \"Scaron\", \"Uacute\", \"Ucircumflex\", \"Udieresis\", \"Ugrave\",\n", "            \"Yacute\", \"Ydieresis\", \"Zcaron\", \"aacute\", \"acircumflex\", \"adieresis\",\n", "            \"agrave\", \"aring\", \"atilde\", \"ccedilla\", \"eacute\", \"ecircumflex\",\n", "            \"edieresis\", \"egrave\", \"iacute\", \"icircumflex\", \"idieresis\", \"igrave\",\n", "            \"ntilde\", \"oacute\", \"ocircumflex\", \"odieresis\", \"ograve\", \"otilde\",\n", "            \"scaron\", \"uacute\", \"ucircumflex\", \"udieresis\", \"ugrave\", \"yacute\",\n", "            \"ydieresis\", \"zcaron\", \"exclamsmall\", \"Hungarumlautsmall\",\n", "            \"dollaroldstyle\", \"dollarsuperior\", \"ampersandsmall\", \"Acutesmall\",\n", "            \"parenleftsuperior\", \"parenrightsuperior\", \"twodotenleader\",\n", "            \"onedotenleader\", \"zerooldstyle\", \"oneoldstyle\", \"twooldstyle\",\n", "            \"threeoldstyle\", \"fouroldstyle\", \"fiveoldstyle\", \"sixoldstyle\",\n", "            \"sevenoldstyle\", \"eightoldstyle\", \"nineoldstyle\", \"commasuperior\",\n", "            \"threequartersemdash\", \"periodsuperior\", \"questionsmall\", \"asuperior\",\n", "            \"bsuperior\", \"centsuperior\", \"dsuperior\", \"esuperior\", \"isuperior\",\n", "            \"lsuperior\", \"msuperior\", \"nsuperior\", \"osuperior\", \"rsuperior\",\n", "            \"ssuperior\", \"tsuperior\", \"ff\", \"ffi\", \"ffl\", \"parenleftinferior\",\n", "            \"parenrightinferior\", \"Circumflexsmall\", \"hyphensuperior\", \"Gravesmall\",\n", "            \"Asmall\", \"Bsmall\", \"Csmall\", \"Dsmall\", \"Esmall\", \"Fsmall\", \"Gsmall\",\n", "            \"Hsmall\", \"Ismall\", \"Jsmall\", \"Ksmall\", \"Lsmall\", \"Msmall\", \"Nsmall\",\n", "            \"Osmall\", \"Psmall\", \"Qsmall\", \"Rsmall\", \"Ssmall\", \"Tsmall\", \"Usmall\",\n", "            \"Vsmall\", \"Wsmall\", \"Xsmall\", \"Ysmall\", \"Zsmall\", \"colonmonetary\",\n", "            \"onefitted\", \"rupiah\", \"Tildesmall\", \"exclamdownsmall\", \"centoldstyle\",\n", "            \"Lslashsmall\", \"Scaronsmall\", \"Zcaronsmall\", \"Dieresissmall\", \"Brevesmall\",\n", "            \"Caronsmall\", \"Dotaccentsmall\", \"Macronsmall\", \"figuredash\",\n", "            \"hypheninferior\", \"Ogoneksmall\", \"Ringsmall\", \"Cedillasmall\",\n", "            \"questiondownsmall\", \"oneeighth\", \"threeeighths\", \"fiveeighths\",\n", "            \"seveneighths\", \"onethird\", \"twothirds\", \"zerosuperior\", \"foursuperior\",\n", "            \"fivesuperior\", \"sixsuperior\", \"sevensuperior\", \"eightsuperior\",\n", "            \"ninesuperior\", \"zeroinferior\", \"oneinferior\", \"twoinferior\",\n", "            \"threeinferior\", \"fourinferior\", \"fiveinferior\", \"sixinferior\",\n", "            \"seveninferior\", \"eightinferior\", \"nineinferior\", \"centinferior\",\n", "            \"dollarinferior\", \"periodinferior\", \"commainferior\", \"Agravesmall\",\n", "            \"Aacutesmall\", \"Acircumflexsmall\", \"Atildesmall\", \"Adieresissmall\",\n", "            \"Aringsmall\", \"AEsmall\", \"Ccedillasmall\", \"Egravesmall\", \"Eacutesmall\",\n", "            \"Ecircumflexsmall\", \"Edieresissmall\", \"Igravesmall\", \"Iacutesmall\",\n", "            \"Icircumflexsmall\", \"Idieresissmall\", \"Ethsmall\", \"Ntildesmall\",\n", "            \"Ogravesmall\", \"Oacutesmall\", \"Ocircumflexsmall\", \"Otildesmall\",\n", "            \"Odieresissmall\", \"OEsmall\", \"Oslashsmall\", \"Ugravesmall\", \"Uacutesmall\",\n", "            \"Ucircumflexsmall\", \"Udieresissmall\", \"Yacutesmall\", \"Thornsmall\",\n", "            \"Ydieresissmall\", \"001.000\", \"001.001\", \"001.002\", \"001.003\", \"Black\",\n", "            \"Bold\", \"Book\", \"Light\", \"Medium\", \"Regular\", \"Roman\", \"Semibold\"\n", "    };\n", "\n", "    //private String[] strings;\n", "    public String getString(char sid) {\n", "        if (sid < standardStrings.length) return standardStrings[sid];\n", "        if (sid >= standardStrings.length+stringOffsets.length-1) return null;\n", "        int j = sid - standardStrings.length;\n", "        //java.lang.System.err.println(\"going for \"+j);\n", "        int p = getPosition();\n", "        seek(stringOffsets[j]);\n", "        StringBuffer s = new StringBuffer();\n", "        for (int k=stringOffsets[j]; k<stringOffsets[j+1]; k++) {\n", "            s.append(getCard8());\n", "        }\n", "        seek(p);\n", "        return s.toString();\n", "    }\n", "\n", "    char getCard8() {\n", "        try {\n", "            byte i = buf.readByte();\n", "            return (char)(i & 0xff);\n", "        }\n", "        catch (Exception e) {\n", "            throw new IOException(IoExceptionMessageConstant.IO_EXCEPTION, e);\n", "        }\n", "    }\n", "\n", "    char getCard16() {\n", "        try {\n", "            return buf.readChar();\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.IO_EXCEPTION, e);\n", "        }\n", "    }\n", "\n", "    int getOffset(int offSize) {\n", "        int offset = 0;\n", "        for (int i=0; i<offSize; i++) {\n", "            offset *= 256;\n", "            offset += getCard8();\n", "        }\n", "        return offset;\n", "    }\n", "\n", "    void seek(int offset) {\n", "        buf.seek(offset);\n", "    }\n", "\n", "    short getShort() {\n", "        try {\n", "            return buf.readShort();\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.IO_EXCEPTION, e);\n", "        }\n", "    }\n", "\n", "    int getInt() {\n", "        try {\n", "            return buf.readInt();\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.IO_EXCEPTION, e);\n", "        }\n", "    }\n", "\n", "    int getPosition() {\n", "        return (int)buf.getPosition();\n", "    }\n", "    // read the offsets in the next index\n", "    // data structure, convert to global\n", "    // offsets, and return them.\n", "    // Sets the nextIndexOffset.\n", "    int[] getIndex(int nextIndexOffset) {\n", "        int count, indexOffSize;\n", "\n", "        seek(nextIndexOffset);\n", "        count = getCard16();\n", "        int[] offsets = new int[count+1];\n", "\n", "        if (count == 0) {\n", "            offsets[0] = -1;\n", "            return offsets;\n", "        }\n", "\n", "        indexOffSize = getCard8();\n", "\n", "        for (int j = 0; j <= count; j++) {\n", "            //nextIndexOffset = ofset to relative segment\n", "            offsets[j] = nextIndexOffset\n", "                    //2-> count in the index header. 1->offset size in index header\n", "                    + 2 + 1\n", "                    //offset array size * offset size\n", "                    + (count + 1) * indexOffSize\n", "                    //???zero <-> one base\n", "                    - 1\n", "                    // read object offset relative to object array base\n", "                    + getOffset(indexOffSize);\n", "        }\n", "        //nextIndexOffset = offsets[count];\n", "        return offsets;\n", "    }\n", "\n", "    protected String   key;\n", "    protected Object[] args      = new Object[48];\n", "    protected int      arg_count = 0;\n", "\n", "    protected void getDictItem() {\n", "        for (int i=0; i<arg_count; i++) args[i]=null;\n", "        arg_count = 0;\n", "        key = null;\n", "        boolean gotKey = false;\n", "\n", "        while (!gotKey) {\n", "            char b0 = getCard8();\n", "            if (b0 == 29) {\n", "                int item = getInt();\n", "                args[arg_count] = item;\n", "                arg_count++;\n", "                //System.err.println(item+\" \");\n", "                continue;\n", "            }\n", "            if (b0 == 28) {\n", "                short item = getShort();\n", "                args[arg_count] = (int) item;\n", "                arg_count++;\n", "                //System.err.println(item+\" \");\n", "                continue;\n", "            }\n", "            if (b0 >= 32 && b0 <= 246) {\n", "                args[arg_count] = b0-139;\n", "                arg_count++;\n", "                //System.err.println(item+\" \");\n", "                continue;\n", "            }\n", "            if (b0 >= 247 && b0 <= 250) {\n", "                char b1 = getCard8();\n", "                short item = (short) ((b0-247)*256+b1+108);\n", "                args[arg_count] = (int) item;\n", "                arg_count++;\n", "                //System.err.println(item+\" \");\n", "                continue;\n", "            }\n", "            if (b0 >= 251 && b0 <= 254) {\n", "                char b1 = getCard8();\n", "                short item = (short) (-(b0-251)*256-b1-108);\n", "                args[arg_count] = (int) item;\n", "                arg_count++;\n", "                //System.err.println(item+\" \");\n", "                continue;\n", "            }\n", "            if (b0 == 30) {\n", "                StringBuilder item = new StringBuilder(\"\");\n", "                boolean done = false;\n", "                char buffer = (char) 0;\n", "                byte avail = 0;\n", "                int  nibble = 0;\n", "                while (!done) {\n", "                    // get a nibble\n", "                    if (avail==0) { buffer = getCard8(); avail=2; }\n", "                    if (avail==1) { nibble = buffer / 16; avail--; }\n", "                    if (avail==2) { nibble = buffer % 16; avail--; }\n", "                    switch (nibble) {\n", "                        case 0xa: item.append(\".\") ; break;\n", "                        case 0xb: item.append(\"E\") ; break;\n", "                        case 0xc: item.append(\"E-\"); break;\n", "                        case 0xe: item.append(\"-\") ; break;\n", "                        case 0xf: done=true   ; break;\n", "                        default:\n", "                            if (nibble >= 0 && nibble <= 9)\n", "                                item.append(nibble);\n", "                            else {\n", "                                item.append(\"<NIBBLE ERROR: \").append(nibble).append('>');\n", "                                done = true;\n", "                            }\n", "                            break;\n", "                    }\n", "                }\n", "                args[arg_count] = item.toString();\n", "                arg_count++;\n", "                //System.err.println(\" real=[\"+item+\"]\");\n", "                continue;\n", "            }\n", "            if (b0 <= 21) {\n", "                gotKey=true;\n", "                if (b0 != 12) key = operatorNames[b0];\n", "                else key = operatorNames[32 + getCard8()];\n", "                //for (int i=0; i<arg_count; i++)\n", "                //  System.err.print(args[i].toString()+\" \");\n", "                //System.err.println(key+\" ;\");\n", "                continue;\n", "            }\n", "        }\n", "    }\n", "\n", "    /** List items for the linked list that builds the new CID font.\n", "     */\n", "\n", "    protected static abstract class Item {\n", "        protected int myOffset = -1;\n", "\n", "        /**\n", "         * Remember the current offset and increment by item's size in bytes.\n", "         *\n", "         * @param currentOffset increment offset by item's size\n", "         */\n", "        public void increment(int[] currentOffset) {\n", "            myOffset = currentOffset[0];\n", "        }\n", "\n", "        /**\n", "         * Emit the byte stream for this item.\n", "         *\n", "         * @param buffer byte array\n", "         */\n", "        public void emit(byte[] buffer) {}\n", "\n", "        /**\n", "         *  Fix up cross references to this item (applies only to markers).\n", "         */\n", "        public void xref() {}\n", "    }\n", "\n", "    protected static abstract class OffsetItem extends Item {\n", "        public int value;\n", "\n", "        /**\n", "         * Set the value of an offset item that was initially unknown.\n", "         * It will be fixed up latex by a call to xref on some marker.\n", "         *\n", "         * @param offset offset to set\n", "         */\n", "        public void set(int offset) { this.value = offset; }\n", "    }\n", "\n", "\n", "    /** A range item.\n", "     */\n", "\n", "    protected static final class RangeItem extends Item {\n", "        public int offset, length;\n", "        private RandomAccessFileOrArray buf;\n", "        public RangeItem(RandomAccessFileOrArray buf, int offset, int length) {\n", "            this.offset = offset;\n", "            this.length = length;\n", "            this.buf = buf;\n", "        }\n", "        @Override\n", "        public void increment(int[] currentOffset) {\n", "            super.increment(currentOffset);\n", "            currentOffset[0] += length;\n", "        }\n", "        @Override\n", "        public void emit(byte[] buffer) {\n", "            //System.err.println(\"range emit offset \"+offset+\" size=\"+length);\n", "            try {\n", "                buf.seek(offset);\n", "                for (int i=myOffset; i<myOffset+length; i++)\n", "                    buffer[i] = buf.readByte();\n", "            } catch (java.io.IOException e) {\n", "                throw new IOException(IoExceptionMessageConstant.IO_EXCEPTION, e);\n", "            }\n", "            //System.err.println(\"finished range emit\");\n", "        }\n", "    }\n", "\n", "    /** An index-offset item for the list.\n", "     * The size denotes the required size in the CFF. A positive\n", "     * value means that we need a specific size in bytes (for offset arrays)\n", "     * and a negative value means that this is a dict item that uses a\n", "     * variable-size representation.\n", "     */\n", "    protected static final class IndexOffsetItem extends OffsetItem {\n", "        public final int size;\n", "        public IndexOffsetItem(int size, int value) {this.size=size; this.value=value;}\n", "        public IndexOffsetItem(int size) {this.size=size; }\n", "\n", "        @Override\n", "        public void increment(int[] currentOffset) {\n", "            super.increment(currentOffset);\n", "            currentOffset[0] += size;\n", "        }\n", "        @Override\n", "        public void emit(byte[] buffer) {\n", "            if (size >= 1 && size <= 4) {\n", "                for (int i = 0; i < size; i++) {\n", "                    buffer[myOffset + i] = (byte) (value >>> ((size - 1 - i) << 3) & 0xFF);\n", "                }\n", "            }\n", "        }\n", "    }\n", "\n", "    protected static final class IndexBaseItem extends Item {\n", "        public IndexBaseItem() {}\n", "    }\n", "\n", "    protected static final class IndexMarkerItem extends Item {\n", "        private OffsetItem offItem;\n", "        private IndexBaseItem indexBase;\n", "        public IndexMarkerItem(OffsetItem offItem, IndexBaseItem indexBase) {\n", "            this.offItem   = offItem;\n", "            this.indexBase = indexBase;\n", "        }\n", "        @Override\n", "        public void xref() {\n", "            //System.err.println(\"index marker item, base=\"+indexBase.myOffset+\" my=\"+this.myOffset);\n", "            offItem.set(this.myOffset-indexBase.myOffset+1);\n", "        }\n", "    }\n", "\n", "    protected static final class SubrMarkerItem extends Item {\n", "        private OffsetItem offItem;\n", "        private IndexBaseItem indexBase;\n", "        public SubrMarkerItem(OffsetItem offItem, IndexBaseItem indexBase) {\n", "            this.offItem   = offItem;\n", "            this.indexBase = indexBase;\n", "        }\n", "        @Override\n", "        public void xref() {\n", "            //System.err.println(\"index marker item, base=\"+indexBase.myOffset+\" my=\"+this.myOffset);\n", "            offItem.set(this.myOffset-indexBase.myOffset);\n", "        }\n", "    }\n", "\n", "\n", "    /** an unknown offset in a dictionary for the list.\n", "     * We will fix up the offset later; for now, assume it's large.\n", "     */\n", "    protected static final class DictOffsetItem extends OffsetItem {\n", "        public final int size;\n", "        public DictOffsetItem() {this.size=5; }\n", "\n", "        @Override\n", "        public void increment(int[] currentOffset) {\n", "            super.increment(currentOffset);\n", "            currentOffset[0] += size;\n", "        }\n", "        // this is incomplete!\n", "        @Override\n", "        public void emit(byte[] buffer) {\n", "            if (size==5) {\n", "                buffer[myOffset]   = 29;\n", "                buffer[myOffset+1] = (byte) (value >>> 24 & 0xff);\n", "                buffer[myOffset+2] = (byte) (value >>> 16 & 0xff);\n", "                buffer[myOffset+3] = (byte) (value >>>  8 & 0xff);\n", "                buffer[myOffset+4] = (byte) (value >>>  0 & 0xff);\n", "            }\n", "        }\n", "    }\n", "\n", "    /** Card24 item.\n", "     */\n", "\n", "    protected static final class UInt24Item extends Item {\n", "        public int value;\n", "        public UInt24Item(int value) {this.value=value;}\n", "\n", "        @Override\n", "        public void increment(int[] currentOffset) {\n", "            super.increment(currentOffset);\n", "            currentOffset[0] += 3;\n", "        }\n", "        // this is incomplete!\n", "        @Override\n", "        public void emit(byte[] buffer) {\n", "            buffer[myOffset+0] = (byte) (value >>> 16 & 0xff);\n", "            buffer[myOffset+1] = (byte) (value >>> 8 & 0xff);\n", "            buffer[myOffset+2] = (byte) (value >>> 0 & 0xff);\n", "        }\n", "    }\n", "\n", "    /** Card32 item.\n", "     */\n", "\n", "    protected static final class UInt32Item extends Item {\n", "        public int value;\n", "        public UInt32Item(int value) {this.value=value;}\n", "\n", "        @Override\n", "        public void increment(int[] currentOffset) {\n", "            super.increment(currentOffset);\n", "            currentOffset[0] += 4;\n", "        }\n", "        // this is incomplete!\n", "        @Override\n", "        public void emit(byte[] buffer) {\n", "            buffer[myOffset+0] = (byte) (value >>> 24 & 0xff);\n", "            buffer[myOffset+1] = (byte) (value >>> 16 & 0xff);\n", "            buffer[myOffset+2] = (byte) (value >>> 8 & 0xff);\n", "            buffer[myOffset+3] = (byte) (value >>> 0 & 0xff);\n", "        }\n", "    }\n", "\n", "    /** A SID or Card16 item.\n", "     */\n", "\n", "    protected static final class UInt16Item extends Item {\n", "        public char value;\n", "        public UInt16Item(char value) {this.value = value;}\n", "\n", "        @Override\n", "        public void increment(int[] currentOffset) {\n", "            super.increment(currentOffset);\n", "            currentOffset[0] += 2;\n", "        }\n", "        // this is incomplete!\n", "        @Override\n", "        public void emit(byte[] buffer) {\n", "//            Simplify from: there is no sense in >>> for unsigned char.\n", "//            buffer[myOffset+0] = (byte) (value >>> 8 & 0xff);\n", "//            buffer[myOffset+1] = (byte) (value >>> 0 & 0xff);\n", "            buffer[myOffset+0] = (byte) (value >> 8 & 0xff);\n", "            buffer[myOffset+1] = (byte) (value >> 0 & 0xff);\n", "        }\n", "    }\n", "\n", "    /** A Card8 item.\n", "     */\n", "\n", "    protected static final class UInt8Item extends Item {\n", "        public char value;\n", "        public UInt8Item(char value) {this.value=value;}\n", "\n", "        @Override\n", "        public void increment(int[] currentOffset) {\n", "            super.increment(currentOffset);\n", "            currentOffset[0] += 1;\n", "        }\n", "        // this is incomplete!\n", "        @Override\n", "        public void emit(byte[] buffer) {\n", "            //buffer[myOffset+0] = (byte) (value >>> 0 & 0xff);\n", "            buffer[myOffset+0] = (byte) (value & 0xff);\n", "        }\n", "    }\n", "\n", "    protected static final class StringItem extends Item {\n", "        public String s;\n", "        public StringItem(String s) {this.s=s;}\n", "\n", "        @Override\n", "        public void increment(int[] currentOffset) {\n", "            super.increment(currentOffset);\n", "            currentOffset[0] += s.length();\n", "        }\n", "        @Override\n", "        public void emit(byte[] buffer) {\n", "            for (int i=0; i<s.length(); i++)\n", "                buffer[myOffset+i] = (byte) (s.charAt(i) & 0xff);\n", "        }\n", "    }\n", "\n", "\n", "    /** A dictionary number on the list.\n", "     * This implementation is inefficient: it doesn't use the variable-length\n", "     * representation.\n", "     */\n", "\n", "    protected static final class DictNumberItem extends Item {\n", "        public final int value;\n", "        public int size = 5;\n", "        public DictNumberItem(int value) {this.value=value;}\n", "        @Override\n", "        public void increment(int[] currentOffset) {\n", "            super.increment(currentOffset);\n", "            currentOffset[0] += size;\n", "        }\n", "        // this is incomplete!\n", "        @Override\n", "        public void emit(byte[] buffer) {\n", "            if (size==5) {\n", "                buffer[myOffset]   = 29;\n", "                buffer[myOffset+1] = (byte) (value >>> 24 & 0xff);\n", "                buffer[myOffset+2] = (byte) (value >>> 16 & 0xff);\n", "                buffer[myOffset+3] = (byte) (value >>>  8 & 0xff);\n", "                buffer[myOffset+4] = (byte) (value >>>  0 & 0xff);\n", "            }\n", "        }\n", "    }\n", "\n", "    /** An offset-marker item for the list.\n", "     * It is used to mark an offset and to set the offset list item.\n", "     */\n", "\n", "    protected static final class MarkerItem extends Item {\n", "        OffsetItem p;\n", "        public MarkerItem(OffsetItem pointerToMarker) {p=pointerToMarker;}\n", "        @Override\n", "        public void xref() {\n", "            p.set(this.myOffset);\n", "        }\n", "    }\n", "\n", "    /** a utility that creates a range item for an entire index\n", "     *\n", "     * @param indexOffset where the index is\n", "     * @return a range item representing the entire index\n", "     */\n", "\n", "    protected RangeItem getEntireIndexRange(int indexOffset) {\n", "        seek(indexOffset);\n", "        int count = getCard16();\n", "        if (count==0) {\n", "            return new RangeItem(buf,indexOffset,2);\n", "        } else {\n", "            int indexOffSize = getCard8();\n", "            seek(indexOffset+2+1+count*indexOffSize);\n", "            int size = getOffset(indexOffSize)-1;\n", "            return new RangeItem(buf,indexOffset,\n", "                    2+1+(count+1)*indexOffSize+size);\n", "        }\n", "    }\n", "\n", "\n", "    /** get a single CID font. The PDF architecture (1.4)\n", "     * supports 16-bit strings only with CID CFF fonts, not\n", "     * in Type-1 CFF fonts, so we convert the font to CID if\n", "     * it is in the Type-1 format.\n", "     * Two other tasks that we need to do are to select\n", "     * only a single font from the CFF package (this again is\n", "     * a PDF restriction) and to subset the CharStrings glyph\n", "     * description.\n", "     *\n", "     * @param fontName name of the font\n", "     * @return byte array represents the CID font\n", "     */\n", "    public byte[] getCID(String fontName)\n", "    //throws java.io.FileNotFoundException\n", "    {\n", "        int j;\n", "        for (j=0; j<fonts.length; j++)\n", "            if (fontName.equals(fonts[j].name)) break;\n", "        if (j==fonts.length) return null;\n", "\n", "        LinkedList<Item> l = new LinkedList<Item>();\n", "\n", "        // copy the header\n", "\n", "        seek(0);\n", "\n", "        int major = getCard8();\n", "        int minor = getCard8();\n", "        int hdrSize = getCard8();\n", "        int offSize = getCard8();\n", "\n", "        l.addLast(new RangeItem(buf,0,hdrSize));\n", "\n", "        int nglyphs=-1, nstrings=-1;\n", "        if ( ! fonts[j].isCID ) {\n", "            // count the glyphs\n", "            seek(fonts[j].charstringsOffset);\n", "            nglyphs = getCard16();\n", "            seek(stringIndexOffset);\n", "            nstrings = getCard16()+standardStrings.length;\n", "            //System.err.println(\"number of glyphs = \"+nglyphs);\n", "        }\n", "\n", "        // create a name index\n", "\n", "        // count\n", "        l.addLast(new UInt16Item((char)1));\n", "        // offSize\n", "        l.addLast(new UInt8Item((char)1));\n", "        // first offset\n", "        l.addLast(new UInt8Item((char)1));\n", "        l.addLast(new UInt8Item((char)( 1+fonts[j].name.length() )));\n", "        l.addLast(new StringItem(fonts[j].name));\n", "\n", "        // create the topdict Index\n", "\n", "        // count\n", "        l.addLast(new UInt16Item((char)1));\n", "        // offSize\n", "        l.addLast(new UInt8Item((char)2));\n", "        // first offset\n", "        l.addLast(new UInt16Item((char)1));\n", "        OffsetItem topdictIndex1Ref = new IndexOffsetItem(2);\n", "        l.addLast(topdictIndex1Ref);\n", "        IndexBaseItem topdictBase = new IndexBaseItem();\n", "        l.addLast(topdictBase);\n", "\n", "        /*\n", "        int maxTopdictLen = (topdictOffsets[j+1]-topdictOffsets[j])\n", "                            + 9*2 // at most 9 new keys\n", "                            + 8*5 // 8 new integer arguments\n", "                            + 3*2;// 3 new SID arguments\n", "         */\n", "\n", "        //int    topdictNext = 0;\n", "        //byte[] topdict = new byte[maxTopdictLen];\n", "\n", "        OffsetItem charsetRef     = new DictOffsetItem();\n", "        OffsetItem charstringsRef = new DictOffsetItem();\n", "        OffsetItem fdarrayRef     = new DictOffsetItem();\n", "        OffsetItem fdselectRef    = new DictOffsetItem();\n", "\n", "        if ( !fonts[j].isCID ) {\n", "\n", "            // create a ROS key\n", "            l.addLast(new DictNumberItem(nstrings));\n", "            l.addLast(new DictNumberItem(nstrings+1));\n", "            l.addLast(new DictNumberItem(0));\n", "            l.addLast(new UInt8Item((char)12));\n", "            l.addLast(new UInt8Item((char)30));\n", "\n", "            // create a CIDCount key\n", "            l.addLast(new DictNumberItem(nglyphs));\n", "            l.addLast(new UInt8Item((char)12));\n", "            l.addLast(new UInt8Item((char)34));\n", "\n", "            // What about UIDBase (12,35)? Don't know what is it.\n", "            // I don't think we need FontName; the font I looked at didn't have it.\n", "        }\n", "\n", "        // create an FDArray key\n", "        l.addLast(fdarrayRef);\n", "        l.addLast(new UInt8Item((char)12));\n", "        l.addLast(new UInt8Item((char)36));\n", "\n", "        // create an FDSelect key\n", "        l.addLast(fdselectRef);\n", "        l.addLast(new UInt8Item((char)12));\n", "        l.addLast(new UInt8Item((char)37));\n", "\n", "        // create an charset key\n", "        l.addLast(charsetRef);\n", "        l.addLast(new UInt8Item((char)15));\n", "\n", "        // create a CharStrings key\n", "        l.addLast(charstringsRef);\n", "        l.addLast(new UInt8Item((char)17));\n", "\n", "        seek(topdictOffsets[j]);\n", "        while (getPosition() < topdictOffsets[j+1]) {\n", "            int p1 = getPosition();\n", "            getDictItem();\n", "            int p2 = getPosition();\n", "            if (\"Encoding\".equals(key)\n", "                    || \"Private\".equals(key)\n", "                    || \"FDSelect\".equals(key)\n", "                    || \"FDArray\".equals(key)\n", "                    || \"charset\".equals(key)\n", "                    || \"CharStrings\".equals(key)\n", "                    ) {\n", "\n", "            // just drop them\n", "            } else {\n", "                l.addLast(new RangeItem(buf,p1,p2-p1));\n", "            }\n", "        }\n", "\n", "        l.addLast(new IndexMarkerItem(topdictIndex1Ref,topdictBase));\n", "\n", "        // Copy the string index and append new strings.\n", "        // We need 3 more strings: Registry, Ordering, and a FontName for one FD.\n", "        // The total length is at most \"Adobe\"+\"Identity\"+63 = 76\n", "\n", "        if (fonts[j].isCID) {\n", "            l.addLast(getEntireIndexRange(stringIndexOffset));\n", "        } else {\n", "            String fdFontName = fonts[j].name+\"-OneRange\";\n", "            if (fdFontName.length() > 127)\n", "                fdFontName = fdFontName.substring(0,127);\n", "            String extraStrings = \"Adobe\"+\"Identity\"+fdFontName;\n", "\n", "            int origStringsLen = stringOffsets[stringOffsets.length-1]\n", "                    - stringOffsets[0];\n", "            int stringsBaseOffset = stringOffsets[0]-1;\n", "\n", "            byte stringsIndexOffSize;\n", "            if (origStringsLen+extraStrings.length() <= 0xff) stringsIndexOffSize = 1;\n", "            else if (origStringsLen+extraStrings.length() <= 0xffff) stringsIndexOffSize = 2;\n", "            else if (origStringsLen+extraStrings.length() <= 0xffffff) stringsIndexOffSize = 3;\n", "            else stringsIndexOffSize = 4;\n", "\n", "            // count\n", "            l.addLast(new UInt16Item((char)(stringOffsets.length-1+3)));\n", "            // offSize\n", "            l.addLast(new UInt8Item((char)stringsIndexOffSize));\n", "            for (int stringOffset : stringOffsets)\n", "                l.addLast(new IndexOffsetItem(stringsIndexOffSize,\n", "                        stringOffset-stringsBaseOffset));\n", "            int currentStringsOffset = stringOffsets[stringOffsets.length-1]\n", "                    - stringsBaseOffset;\n", "            // l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));\n", "            currentStringsOffset += \"Adobe\".length();\n", "            l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));\n", "            currentStringsOffset += \"Identity\".length();\n", "            l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));\n", "            currentStringsOffset += fdFontName.length();\n", "            l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));\n", "\n", "            l.addLast(new RangeItem(buf,stringOffsets[0],origStringsLen));\n", "            l.addLast(new StringItem(extraStrings));\n", "        }\n", "\n", "        // copy the global subroutine index\n", "\n", "        l.addLast(getEntireIndexRange(gsubrIndexOffset));\n", "\n", "        // deal with fdarray, fdselect, and the font descriptors\n", "\n", "        if (fonts[j].isCID) {\n", "            // copy the FDArray, FDSelect, charset\n", "        } else {\n", "            // create FDSelect\n", "            l.addLast(new MarkerItem(fdselectRef));\n", "            // format identifier\n", "            l.addLast(new UInt8Item((char)3));\n", "            // nRanges\n", "            l.addLast(new UInt16Item((char)1));\n", "\n", "            // Range[0].firstGlyph\n", "            l.addLast(new UInt16Item((char)0));\n", "            // Range[0].fd\n", "            l.addLast(new UInt8Item((char)0));\n", "\n", "            // sentinel\n", "            l.addLast(new UInt16Item((char)nglyphs));\n", "\n", "            // recreate a new charset\n", "            // This format is suitable only for fonts without subsetting\n", "\n", "            l.addLast(new MarkerItem(charsetRef));\n", "            // format identifier\n", "            l.addLast(new UInt8Item((char)2));\n", "\n", "            // first glyph in range (ignore .notdef)\n", "            l.addLast(new UInt16Item((char)1));\n", "            // nLeft\n", "            l.addLast(new UInt16Item((char)(nglyphs-1)));\n", "\n", "            // now all are covered, the data structure is complete.\n", "            // create a font dict index (fdarray)\n", "\n", "            l.addLast(new MarkerItem(fdarrayRef));\n", "            l.addLast(new UInt16Item((char)1));\n", "            // offSize\n", "            l.addLast(new UInt8Item((char)1));\n", "            // first offset\n", "            l.addLast(new UInt8Item((char)1));\n", "\n", "            OffsetItem privateIndex1Ref = new IndexOffsetItem(1);\n", "            l.addLast(privateIndex1Ref);\n", "            IndexBaseItem privateBase = new IndexBaseItem();\n", "            l.addLast(privateBase);\n", "\n", "            // looking at the PS that acrobat generates from a PDF with\n", "            // a CFF opentype font embedded with an identity-H encoding,\n", "            // it seems that it does not need a FontName.\n", "            //l.addLast(new DictNumberItem((standardStrings.length+(stringOffsets.length-1)+2)));\n", "            //l.addLast(new UInt8Item((char)12));\n", "            //l.addLast(new UInt8Item((char)38)); // FontName\n", "\n", "            l.addLast(new DictNumberItem(fonts[j].privateLength));\n", "            OffsetItem privateRef = new DictOffsetItem();\n", "            l.addLast(privateRef);\n", "            // Private\n", "            l.addLast(new UInt8Item((char)18));\n", "\n", "            l.addLast(new IndexMarkerItem(privateIndex1Ref,privateBase));\n", "\n", "            // copy the private index & local subroutines\n", "\n", "            l.addLast(new MarkerItem(privateRef));\n", "            // copy the private dict and the local subroutines.\n", "            // the length of the private dict seems to NOT include\n", "            // the local subroutines.\n", "            l.addLast(new RangeItem(buf,fonts[j].privateOffset,fonts[j].privateLength));\n", "            if (fonts[j].privateSubrs >= 0) {\n", "                //System.err.println(\"has subrs=\"+fonts[j].privateSubrs+\" ,len=\"+fonts[j].privateLength);\n", "                l.addLast(getEntireIndexRange(fonts[j].privateSubrs));\n", "            }\n", "        }\n", "\n", "        // copy the charstring index\n", "\n", "        l.addLast(new MarkerItem(charstringsRef));\n", "        l.addLast(getEntireIndexRange(fonts[j].charstringsOffset));\n", "\n", "        // now create the new CFF font\n", "\n", "        int[] currentOffset = new int[1];\n", "        currentOffset[0] = 0;\n", "\n", "        for (Item item : l) {\n", "            item.increment(currentOffset);\n", "        }\n", "\n", "        for (Item item : l) {\n", "            item.xref();\n", "        }\n", "\n", "        int size = currentOffset[0];\n", "        byte[] b = new byte[size];\n", "\n", "        for (Item item : l) {\n", "            item.emit(b);\n", "        }\n", "\n", "        return b;\n", "    }\n", "\n", "    public boolean isCID() {\n", "        return isCID(getNames()[0]);\n", "    }\n", "\n", "    public boolean isCID(String fontName) {\n", "        int j;\n", "        for (j=0; j<fonts.length; j++)\n", "            if (fontName.equals(fonts[j].name)) return fonts[j].isCID;\n", "        return false;\n", "    }\n", "\n", "    public boolean exists(String fontName) {\n", "        int j;\n", "        for (j=0; j<fonts.length; j++)\n", "            if (fontName.equals(fonts[j].name)) return true;\n", "        return false;\n", "    }\n", "\n", "\n", "    public String[] getNames() {\n", "        String[] names = new String[ fonts.length ];\n", "        for (int i=0; i<fonts.length; i++)\n", "            names[i] = fonts[i].name;\n", "        return names;\n", "    }\n", "    /**\n", "     * A random Access File or an array\n", "     */\n", "    protected RandomAccessFileOrArray buf;\n", "    private int offSize;\n", "\n", "    protected int nameIndexOffset;\n", "    protected int topdictIndexOffset;\n", "    protected int stringIndexOffset;\n", "    protected int gsubrIndexOffset;\n", "    protected int[] nameOffsets;\n", "    protected int[] topdictOffsets;\n", "    protected int[] stringOffsets;\n", "    protected int[] gsubrOffsets;\n", "\n", "    protected final class Font {\n", "        public String    name;\n", "        public String    fullName;\n", "        public boolean   isCID = false;\n", "        // only if not CID\n", "        public int       privateOffset     = -1;\n", "        // only if not CID\n", "        public int       privateLength     = -1;\n", "        public int       privateSubrs      = -1;\n", "        public int       charstringsOffset = -1;\n", "        public int       encodingOffset    = -1;\n", "        public int       charsetOffset     = -1;\n", "        // only if CID\n", "        public int       fdarrayOffset     = -1;\n", "        // only if CID\n", "        public int       fdselectOffset    = -1;\n", "        public int[]     fdprivateOffsets;\n", "        public int[]     fdprivateLengths;\n", "        public int[]     fdprivateSubrs;\n", "\n", "        // Added by Oren & Ygal\n", "        public int nglyphs;\n", "        public int nstrings;\n", "        public int CharsetLength;\n", "        public int[]    charstringsOffsets;\n", "        public int[]    charset;\n", "        public int[] \tFDSelect;\n", "        public int FDSelectLength;\n", "        public int FDSelectFormat;\n", "        public int \t\tCharstringType = 2;\n", "        public int FDArrayCount;\n", "        public int FDArrayOffsize;\n", "        public int[] FDArrayOffsets;\n", "        public int[] PrivateSubrsOffset;\n", "        public int[][] PrivateSubrsOffsetsArray;\n", "        public int[]       SubrsOffsets;\n", "\n", "        public int[] gidToCid;\n", "    }\n", "    // Changed from private to protected by Ygal&Oren\n", "    protected Font[] fonts;\n", "\n", "    RandomAccessSourceFactory rasFactory = new RandomAccessSourceFactory();\n", "\n", "    public CFFFont(byte[] cff) {\n", "        //System.err.println(\"CFF: nStdString = \"+standardStrings.length);\n", "        buf = new RandomAccessFileOrArray(rasFactory.createSource(cff));\n", "        seek(0);\n", "\n", "        int major, minor;\n", "        major = getCard8();\n", "        minor = getCard8();\n", "\n", "        //System.err.println(\"CFF Major-Minor = \"+major+\"-\"+minor);\n", "\n", "        int hdrSize = getCard8();\n", "\n", "        offSize = getCard8();\n", "\n", "        //System.err.println(\"offSize = \"+offSize);\n", "\n", "        //int count, indexOffSize, indexOffset, nextOffset;\n", "\n", "        nameIndexOffset    = hdrSize;\n", "        nameOffsets        = getIndex(nameIndexOffset);\n", "        topdictIndexOffset = nameOffsets[nameOffsets.length-1];\n", "        topdictOffsets     = getIndex(topdictIndexOffset);\n", "        stringIndexOffset  = topdictOffsets[topdictOffsets.length-1];\n", "        stringOffsets      = getIndex(stringIndexOffset);\n", "        gsubrIndexOffset   = stringOffsets[stringOffsets.length-1];\n", "        gsubrOffsets       = getIndex(gsubrIndexOffset);\n", "\n", "        fonts = new Font[nameOffsets.length-1];\n", "\n", "        // now get the name index\n", "\n", "        /*\n", "        names             = new String[nfonts];\n", "        privateOffset     = new int[nfonts];\n", "        charsetOffset     = new int[nfonts];\n", "        encodingOffset    = new int[nfonts];\n", "        charstringsOffset = new int[nfonts];\n", "        fdarrayOffset     = new int[nfonts];\n", "        fdselectOffset    = new int[nfonts];\n", "         */\n", "\n", "        for (int j=0; j<nameOffsets.length-1; j++) {\n", "            fonts[j] = new Font();\n", "            seek(nameOffsets[j]);\n", "            fonts[j].name = \"\";\n", "            for (int k=nameOffsets[j]; k<nameOffsets[j+1]; k++) {\n", "                fonts[j].name += getCard8();\n", "            }\n", "            //System.err.println(\"name[\"+j+\"]=<\"+fonts[j].name+\">\");\n", "        }\n", "\n", "        // string index\n", "\n", "        //strings = new String[stringOffsets.length-1];\n", "        /*\n", "        System.err.println(\"std strings = \"+standardStrings.length);\n", "        System.err.println(\"fnt strings = \"+(stringOffsets.length-1));\n", "        for (char j=0; j<standardStrings.length+(stringOffsets.length-1); j++) {\n", "            //seek(stringOffsets[j]);\n", "            //strings[j] = \"\";\n", "            //for (int k=stringOffsets[j]; k<stringOffsets[j+1]; k++) {\n", "            //\tstrings[j] += (char)getCard8();\n", "            //}\n", "            System.err.println(\"j=\"+(int)j+\" <? \"+(standardStrings.length+(stringOffsets.length-1)));\n", "            System.err.println(\"strings[\"+(int)j+\"]=<\"+getString(j)+\">\");\n", "        }\n", "         */\n", "\n", "        // top dict\n", "\n", "        for (int j=0; j<topdictOffsets.length-1; j++) {\n", "            seek(topdictOffsets[j]);\n", "            while (getPosition() < topdictOffsets[j+1]) {\n", "                getDictItem();\n", "                if (key==\"FullName\") {\n", "                    //System.err.println(\"getting fullname sid = \"+((Integer)args[0]).intValue());\n", "                    fonts[j].fullName = getString((char)((Integer)args[0]).intValue());\n", "                    //System.err.println(\"got it\");\n", "                } else if (key==\"ROS\")\n", "                    fonts[j].isCID = true;\n", "                else if (key==\"Private\") {\n", "                    fonts[j].privateLength  = (int) ((Integer)args[0]).intValue();\n", "                    fonts[j].privateOffset  = (int) ((Integer)args[1]).intValue();\n", "                }\n", "                else if (key==\"charset\"){\n", "                    fonts[j].charsetOffset = (int) ((Integer)args[0]).intValue();\n", "\n", "                }\n", "//                else if (key==\"Encoding\"){\n", "//                    int encOffset = ((Integer)args[0]).intValue();\n", "//                    if (encOffset > 0) {\n", "//                        fonts[j].encodingOffset = encOffset;\n", "//                        ReadEncoding(fonts[j].encodingOffset);\n", "//                    }\n", "//                }\n", "                else if (key==\"CharStrings\") {\n", "                    fonts[j].charstringsOffset = (int) ((Integer)args[0]).intValue();\n", "                    //System.err.println(\"charstrings \"+fonts[j].charstringsOffset);\n", "                    // Added by Oren & Ygal\n", "                    int p = getPosition();\n", "                    fonts[j].charstringsOffsets = getIndex(fonts[j].charstringsOffset);\n", "                    seek(p);\n", "                } else if (key==\"FDArray\")\n", "                    fonts[j].fdarrayOffset = (int) ((Integer)args[0]).intValue();\n", "                else if (key==\"FDSelect\")\n", "                    fonts[j].fdselectOffset = (int) ((Integer)args[0]).intValue();\n", "                else if (key==\"CharstringType\")\n", "                    fonts[j].CharstringType = (int) ((Integer)args[0]).intValue();\n", "            }\n", "\n", "            // private dict\n", "            if (fonts[j].privateOffset >= 0) {\n", "                //System.err.println(\"PRIVATE::\");\n", "                seek(fonts[j].privateOffset);\n", "                while (getPosition() < fonts[j].privateOffset+fonts[j].privateLength) {\n", "                    getDictItem();\n", "                    if (key==\"Subrs\")\n", "                        //Add the private offset to the lsubrs since the offset is\n", "                        // relative to the beginning of the PrivateDict\n", "                        fonts[j].privateSubrs = (int) ((Integer)args[0]).intValue()+fonts[j].privateOffset;\n", "                }\n", "            }\n", "\n", "            // fdarray index\n", "            if (fonts[j].fdarrayOffset >= 0) {\n", "                int[] fdarrayOffsets = getIndex(fonts[j].fdarrayOffset);\n", "\n", "                fonts[j].fdprivateOffsets = new int[fdarrayOffsets.length-1];\n", "                fonts[j].fdprivateLengths = new int[fdarrayOffsets.length-1];\n", "\n", "                //System.err.println(\"FD Font::\");\n", "\n", "                for (int k=0; k<fdarrayOffsets.length-1; k++) {\n", "                    seek(fdarrayOffsets[k]);\n", "                    while (getPosition() < fdarrayOffsets[k+1]) {\n", "                        getDictItem();\n", "                        if (key==\"Private\") {\n", "                            fonts[j].fdprivateLengths[k]  = (int) ((Integer)args[0]).intValue();\n", "                            fonts[j].fdprivateOffsets[k]  = (int) ((Integer)args[1]).intValue();\n", "                        }\n", "                    }\n", "                }\n", "            }\n", "        }\n", "        //System.err.println(\"CFF: done\");\n", "    }\n", "\n", "    // ADDED BY Oren & Ygal\n", "\n", "    void ReadEncoding(int nextIndexOffset){\n", "        int format;\n", "        seek(nextIndexOffset);\n", "        format = getCard8();\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.source.RandomAccessFileOrArray;\n", "import com.itextpdf.io.source.RandomAccessSourceFactory;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class CFFFontTest extends ExtendedITextTest {\n", "\n", "    private static final String SOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/sharedFontsResourceFiles/\";\n", "\n", "    @Test\n", "    public void seekTest() throws IOException {\n", "        RandomAccessFileOrArray raf = new RandomAccessFileOrArray(new RandomAccessSourceFactory()\n", "                .createBestSource(SOURCE_FOLDER + \"NotoSansCJKjp-Bold.otf\"));\n", "\n", "        int offsetToCff = 259880;\n", "        int cffLength = 16023217;\n", "        byte[] cff = new byte[cffLength];\n", "        try {\n", "            raf.seek(offsetToCff);\n", "            raf.readFully(cff);\n", "        } finally {\n", "            raf.close();\n", "        }\n", "        CFFFont cffFont = new CFFFont(cff);\n", "\n", "        cffFont.seek(0);\n", "        // Get int (bin 0000 0001 0000 0000  0000 0100 0000 0011)\n", "        Assert.assertEquals(16778243, cffFont.getInt());\n", "        cffFont.seek(0);\n", "        // Gets the first short (bin 0000 0001 0000 0000)\n", "        Assert.assertEquals(256, cffFont.getShort());\n", "        cffFont.seek(2);\n", "        // Gets the second short (bin 0000 0100 0000 0011)\n", "        Assert.assertEquals(1027, cffFont.getShort());\n", "    }\n", "\n", "    @Test\n", "    public void getPositionTest() throws IOException {\n", "        RandomAccessFileOrArray raf = new RandomAccessFileOrArray(new RandomAccessSourceFactory()\n", "                .createBestSource(SOURCE_FOLDER + \"NotoSansCJKjp-Bold.otf\"));\n", "\n", "        int offsetToCff = 259880;\n", "        int cffLength = 16023217;\n", "        byte[] cff = new byte[cffLength];\n", "        try {\n", "            raf.seek(offsetToCff);\n", "            raf.readFully(cff);\n", "        } finally {\n", "            raf.close();\n", "        }\n", "        CFFFont cffFont = new CFFFont(cff);\n", "\n", "\n", "        cffFont.seek(0);\n", "        Assert.assertEquals(0, cffFont.getPosition());\n", "        cffFont.seek(16);\n", "        Assert.assertEquals(16, cffFont.getPosition());\n", "    }\n", "}\n"], "method_lines_dic": {"CFFFont::::getString(char)": [128, 141], "CFFFont::::getCard8()": [143, 151], "CFFFont::::getCard16()": [153, 159], "CFFFont::::getOffset(int)": [161, 168], "CFFFont::::seek(int)": [170, 172], "CFFFont::::getShort()": [174, 180], "CFFFont::::getInt()": [182, 188], "CFFFont::::getPosition()": [190, 192], "CFFFont::::getIndex(int)": [197, 225], "CFFFont::::getDictItem()": [231, 317], "CFFFont.Item::::increment(int[])": [330, 332], "CFFFont.Item::::emit(byte[])": [339, 339], "CFFFont.Item::::xref()": [344, 344], "CFFFont.OffsetItem::::set(int)": [356, 356], "CFFFont.RangeItem::::increment(int[])": [371, 375], "CFFFont.RangeItem::::emit(byte[])": [376, 387], "CFFFont.IndexOffsetItem::::increment(int[])": [401, 405], "CFFFont.IndexOffsetItem::::emit(byte[])": [406, 413], "CFFFont.IndexMarkerItem::::xref()": [427, 431], "CFFFont.SubrMarkerItem::::xref()": [441, 445], "CFFFont.DictOffsetItem::::increment(int[])": [456, 460], "CFFFont.DictOffsetItem::::emit(byte[])": [462, 471], "CFFFont.UInt24Item::::increment(int[])": [481, 485], "CFFFont.UInt24Item::::emit(byte[])": [487, 492], "CFFFont.UInt32Item::::increment(int[])": [502, 506], "CFFFont.UInt32Item::::emit(byte[])": [508, 514], "CFFFont.UInt16Item::::increment(int[])": [524, 528], "CFFFont.UInt16Item::::emit(byte[])": [530, 537], "CFFFont.UInt8Item::::increment(int[])": [547, 551], "CFFFont.UInt8Item::::emit(byte[])": [553, 557], "CFFFont.StringItem::::increment(int[])": [564, 568], "CFFFont.StringItem::::emit(byte[])": [569, 573], "CFFFont.DictNumberItem::::increment(int[])": [586, 590], "CFFFont.DictNumberItem::::emit(byte[])": [592, 601], "CFFFont.MarkerItem::::xref()": [611, 614], "CFFFont::::getEntireIndexRange(int)": [623, 635], "CFFFont::::getCID(java.lang.String)": [650, 925], "CFFFont::::isCID()": [927, 929], "CFFFont::::isCID(java.lang.String)": [931, 936], "CFFFont::::exists(java.lang.String)": [938, 943], "CFFFont::::getNames()": [946, 951], "CFFFont::::ReadEncoding(int)": [1161, 1165]}, "test_method_lines_dic": {"CFFFontTest::::seekTest()": [40, 65], "CFFFontTest::::getPositionTest()": [67, 88]}, "reverse_method_lines_dic": {"128": "CFFFont::::getString(char)", "129": "CFFFont::::getString(char)", "130": "CFFFont::::getString(char)", "131": "CFFFont::::getString(char)", "132": "CFFFont::::getString(char)", "133": "CFFFont::::getString(char)", "134": "CFFFont::::getString(char)", "135": "CFFFont::::getString(char)", "136": "CFFFont::::getString(char)", "137": "CFFFont::::getString(char)", "138": "CFFFont::::getString(char)", "139": "CFFFont::::getString(char)", "140": "CFFFont::::getString(char)", "141": "CFFFont::::getString(char)", "143": "CFFFont::::getCard8()", "144": "CFFFont::::getCard8()", "145": "CFFFont::::getCard8()", "146": "CFFFont::::getCard8()", "147": "CFFFont::::getCard8()", "148": "CFFFont::::getCard8()", "149": "CFFFont::::getCard8()", "150": "CFFFont::::getCard8()", "151": "CFFFont::::getCard8()", "153": "CFFFont::::getCard16()", "154": "CFFFont::::getCard16()", "155": "CFFFont::::getCard16()", "156": "CFFFont::::getCard16()", "157": "CFFFont::::getCard16()", "158": "CFFFont::::getCard16()", "159": "CFFFont::::getCard16()", "161": "CFFFont::::getOffset(int)", "162": "CFFFont::::getOffset(int)", "163": "CFFFont::::getOffset(int)", "164": "CFFFont::::getOffset(int)", "165": "CFFFont::::getOffset(int)", "166": "CFFFont::::getOffset(int)", "167": "CFFFont::::getOffset(int)", "168": "CFFFont::::getOffset(int)", "170": "CFFFont::::seek(int)", "171": "CFFFont::::seek(int)", "172": "CFFFont::::seek(int)", "174": "CFFFont::::getShort()", "175": "CFFFont::::getShort()", "176": "CFFFont::::getShort()", "177": "CFFFont::::getShort()", "178": "CFFFont::::getShort()", "179": "CFFFont::::getShort()", "180": "CFFFont::::getShort()", "182": "CFFFont::::getInt()", "183": "CFFFont::::getInt()", "184": "CFFFont::::getInt()", "185": "CFFFont::::getInt()", "186": "CFFFont::::getInt()", "187": "CFFFont::::getInt()", "188": "CFFFont::::getInt()", "190": "CFFFont::::getPosition()", "191": "CFFFont::::getPosition()", "192": "CFFFont::::getPosition()", "197": "CFFFont::::getIndex(int)", "198": "CFFFont::::getIndex(int)", "199": "CFFFont::::getIndex(int)", "200": "CFFFont::::getIndex(int)", "201": "CFFFont::::getIndex(int)", "202": "CFFFont::::getIndex(int)", "203": "CFFFont::::getIndex(int)", "204": "CFFFont::::getIndex(int)", "205": "CFFFont::::getIndex(int)", "206": "CFFFont::::getIndex(int)", "207": "CFFFont::::getIndex(int)", "208": "CFFFont::::getIndex(int)", "209": "CFFFont::::getIndex(int)", "210": "CFFFont::::getIndex(int)", "211": "CFFFont::::getIndex(int)", "212": "CFFFont::::getIndex(int)", "213": "CFFFont::::getIndex(int)", "214": "CFFFont::::getIndex(int)", "215": "CFFFont::::getIndex(int)", "216": "CFFFont::::getIndex(int)", "217": "CFFFont::::getIndex(int)", "218": "CFFFont::::getIndex(int)", "219": "CFFFont::::getIndex(int)", "220": "CFFFont::::getIndex(int)", "221": "CFFFont::::getIndex(int)", "222": "CFFFont::::getIndex(int)", "223": "CFFFont::::getIndex(int)", "224": "CFFFont::::getIndex(int)", "225": "CFFFont::::getIndex(int)", "231": "CFFFont::::getDictItem()", "232": "CFFFont::::getDictItem()", "233": "CFFFont::::getDictItem()", "234": "CFFFont::::getDictItem()", "235": "CFFFont::::getDictItem()", "236": "CFFFont::::getDictItem()", "237": "CFFFont::::getDictItem()", "238": "CFFFont::::getDictItem()", "239": "CFFFont::::getDictItem()", "240": "CFFFont::::getDictItem()", "241": "CFFFont::::getDictItem()", "242": "CFFFont::::getDictItem()", "243": "CFFFont::::getDictItem()", "244": "CFFFont::::getDictItem()", "245": "CFFFont::::getDictItem()", "246": "CFFFont::::getDictItem()", "247": "CFFFont::::getDictItem()", "248": "CFFFont::::getDictItem()", "249": "CFFFont::::getDictItem()", "250": "CFFFont::::getDictItem()", "251": "CFFFont::::getDictItem()", "252": "CFFFont::::getDictItem()", "253": "CFFFont::::getDictItem()", "254": "CFFFont::::getDictItem()", "255": "CFFFont::::getDictItem()", "256": "CFFFont::::getDictItem()", "257": "CFFFont::::getDictItem()", "258": "CFFFont::::getDictItem()", "259": "CFFFont::::getDictItem()", "260": "CFFFont::::getDictItem()", "261": "CFFFont::::getDictItem()", "262": "CFFFont::::getDictItem()", "263": "CFFFont::::getDictItem()", "264": "CFFFont::::getDictItem()", "265": "CFFFont::::getDictItem()", "266": "CFFFont::::getDictItem()", "267": "CFFFont::::getDictItem()", "268": "CFFFont::::getDictItem()", "269": "CFFFont::::getDictItem()", "270": "CFFFont::::getDictItem()", "271": "CFFFont::::getDictItem()", "272": "CFFFont::::getDictItem()", "273": "CFFFont::::getDictItem()", "274": "CFFFont::::getDictItem()", "275": "CFFFont::::getDictItem()", "276": "CFFFont::::getDictItem()", "277": "CFFFont::::getDictItem()", "278": "CFFFont::::getDictItem()", "279": "CFFFont::::getDictItem()", "280": "CFFFont::::getDictItem()", "281": "CFFFont::::getDictItem()", "282": "CFFFont::::getDictItem()", "283": "CFFFont::::getDictItem()", "284": "CFFFont::::getDictItem()", "285": "CFFFont::::getDictItem()", "286": "CFFFont::::getDictItem()", "287": "CFFFont::::getDictItem()", "288": "CFFFont::::getDictItem()", "289": "CFFFont::::getDictItem()", "290": "CFFFont::::getDictItem()", "291": "CFFFont::::getDictItem()", "292": "CFFFont::::getDictItem()", "293": "CFFFont::::getDictItem()", "294": "CFFFont::::getDictItem()", "295": "CFFFont::::getDictItem()", "296": "CFFFont::::getDictItem()", "297": "CFFFont::::getDictItem()", "298": "CFFFont::::getDictItem()", "299": "CFFFont::::getDictItem()", "300": "CFFFont::::getDictItem()", "301": "CFFFont::::getDictItem()", "302": "CFFFont::::getDictItem()", "303": "CFFFont::::getDictItem()", "304": "CFFFont::::getDictItem()", "305": "CFFFont::::getDictItem()", "306": "CFFFont::::getDictItem()", "307": "CFFFont::::getDictItem()", "308": "CFFFont::::getDictItem()", "309": "CFFFont::::getDictItem()", "310": "CFFFont::::getDictItem()", "311": "CFFFont::::getDictItem()", "312": "CFFFont::::getDictItem()", "313": "CFFFont::::getDictItem()", "314": "CFFFont::::getDictItem()", "315": "CFFFont::::getDictItem()", "316": "CFFFont::::getDictItem()", "317": "CFFFont::::getDictItem()", "330": "CFFFont.Item::::increment(int[])", "331": "CFFFont.Item::::increment(int[])", "332": "CFFFont.Item::::increment(int[])", "339": "CFFFont.Item::::emit(byte[])", "344": "CFFFont.Item::::xref()", "356": "CFFFont.OffsetItem::::set(int)", "371": "CFFFont.RangeItem::::increment(int[])", "372": "CFFFont.RangeItem::::increment(int[])", "373": "CFFFont.RangeItem::::increment(int[])", "374": "CFFFont.RangeItem::::increment(int[])", "375": "CFFFont.RangeItem::::increment(int[])", "376": "CFFFont.RangeItem::::emit(byte[])", "377": "CFFFont.RangeItem::::emit(byte[])", "378": "CFFFont.RangeItem::::emit(byte[])", "379": "CFFFont.RangeItem::::emit(byte[])", "380": "CFFFont.RangeItem::::emit(byte[])", "381": "CFFFont.RangeItem::::emit(byte[])", "382": "CFFFont.RangeItem::::emit(byte[])", "383": "CFFFont.RangeItem::::emit(byte[])", "384": "CFFFont.RangeItem::::emit(byte[])", "385": "CFFFont.RangeItem::::emit(byte[])", "386": "CFFFont.RangeItem::::emit(byte[])", "387": "CFFFont.RangeItem::::emit(byte[])", "401": "CFFFont.IndexOffsetItem::::increment(int[])", "402": "CFFFont.IndexOffsetItem::::increment(int[])", "403": "CFFFont.IndexOffsetItem::::increment(int[])", "404": "CFFFont.IndexOffsetItem::::increment(int[])", "405": "CFFFont.IndexOffsetItem::::increment(int[])", "406": "CFFFont.IndexOffsetItem::::emit(byte[])", "407": "CFFFont.IndexOffsetItem::::emit(byte[])", "408": "CFFFont.IndexOffsetItem::::emit(byte[])", "409": "CFFFont.IndexOffsetItem::::emit(byte[])", "410": "CFFFont.IndexOffsetItem::::emit(byte[])", "411": "CFFFont.IndexOffsetItem::::emit(byte[])", "412": "CFFFont.IndexOffsetItem::::emit(byte[])", "413": "CFFFont.IndexOffsetItem::::emit(byte[])", "427": "CFFFont.IndexMarkerItem::::xref()", "428": "CFFFont.IndexMarkerItem::::xref()", "429": "CFFFont.IndexMarkerItem::::xref()", "430": "CFFFont.IndexMarkerItem::::xref()", "431": "CFFFont.IndexMarkerItem::::xref()", "441": "CFFFont.SubrMarkerItem::::xref()", "442": "CFFFont.SubrMarkerItem::::xref()", "443": "CFFFont.SubrMarkerItem::::xref()", "444": "CFFFont.SubrMarkerItem::::xref()", "445": "CFFFont.SubrMarkerItem::::xref()", "456": "CFFFont.DictOffsetItem::::increment(int[])", "457": "CFFFont.DictOffsetItem::::increment(int[])", "458": "CFFFont.DictOffsetItem::::increment(int[])", "459": "CFFFont.DictOffsetItem::::increment(int[])", "460": "CFFFont.DictOffsetItem::::increment(int[])", "462": "CFFFont.DictOffsetItem::::emit(byte[])", "463": "CFFFont.DictOffsetItem::::emit(byte[])", "464": "CFFFont.DictOffsetItem::::emit(byte[])", "465": "CFFFont.DictOffsetItem::::emit(byte[])", "466": "CFFFont.DictOffsetItem::::emit(byte[])", "467": "CFFFont.DictOffsetItem::::emit(byte[])", "468": "CFFFont.DictOffsetItem::::emit(byte[])", "469": "CFFFont.DictOffsetItem::::emit(byte[])", "470": "CFFFont.DictOffsetItem::::emit(byte[])", "471": "CFFFont.DictOffsetItem::::emit(byte[])", "481": "CFFFont.UInt24Item::::increment(int[])", "482": "CFFFont.UInt24Item::::increment(int[])", "483": "CFFFont.UInt24Item::::increment(int[])", "484": "CFFFont.UInt24Item::::increment(int[])", "485": "CFFFont.UInt24Item::::increment(int[])", "487": "CFFFont.UInt24Item::::emit(byte[])", "488": "CFFFont.UInt24Item::::emit(byte[])", "489": "CFFFont.UInt24Item::::emit(byte[])", "490": "CFFFont.UInt24Item::::emit(byte[])", "491": "CFFFont.UInt24Item::::emit(byte[])", "492": "CFFFont.UInt24Item::::emit(byte[])", "502": "CFFFont.UInt32Item::::increment(int[])", "503": "CFFFont.UInt32Item::::increment(int[])", "504": "CFFFont.UInt32Item::::increment(int[])", "505": "CFFFont.UInt32Item::::increment(int[])", "506": "CFFFont.UInt32Item::::increment(int[])", "508": "CFFFont.UInt32Item::::emit(byte[])", "509": "CFFFont.UInt32Item::::emit(byte[])", "510": "CFFFont.UInt32Item::::emit(byte[])", "511": "CFFFont.UInt32Item::::emit(byte[])", "512": "CFFFont.UInt32Item::::emit(byte[])", "513": "CFFFont.UInt32Item::::emit(byte[])", "514": "CFFFont.UInt32Item::::emit(byte[])", "524": "CFFFont.UInt16Item::::increment(int[])", "525": "CFFFont.UInt16Item::::increment(int[])", "526": "CFFFont.UInt16Item::::increment(int[])", "527": "CFFFont.UInt16Item::::increment(int[])", "528": "CFFFont.UInt16Item::::increment(int[])", "530": "CFFFont.UInt16Item::::emit(byte[])", "531": "CFFFont.UInt16Item::::emit(byte[])", "532": "CFFFont.UInt16Item::::emit(byte[])", "533": "CFFFont.UInt16Item::::emit(byte[])", "534": "CFFFont.UInt16Item::::emit(byte[])", "535": "CFFFont.UInt16Item::::emit(byte[])", "536": "CFFFont.UInt16Item::::emit(byte[])", "537": "CFFFont.UInt16Item::::emit(byte[])", "547": "CFFFont.UInt8Item::::increment(int[])", "548": "CFFFont.UInt8Item::::increment(int[])", "549": "CFFFont.UInt8Item::::increment(int[])", "550": "CFFFont.UInt8Item::::increment(int[])", "551": "CFFFont.UInt8Item::::increment(int[])", "553": "CFFFont.UInt8Item::::emit(byte[])", "554": "CFFFont.UInt8Item::::emit(byte[])", "555": "CFFFont.UInt8Item::::emit(byte[])", "556": "CFFFont.UInt8Item::::emit(byte[])", "557": "CFFFont.UInt8Item::::emit(byte[])", "564": "CFFFont.StringItem::::increment(int[])", "565": "CFFFont.StringItem::::increment(int[])", "566": "CFFFont.StringItem::::increment(int[])", "567": "CFFFont.StringItem::::increment(int[])", "568": "CFFFont.StringItem::::increment(int[])", "569": "CFFFont.StringItem::::emit(byte[])", "570": "CFFFont.StringItem::::emit(byte[])", "571": "CFFFont.StringItem::::emit(byte[])", "572": "CFFFont.StringItem::::emit(byte[])", "573": "CFFFont.StringItem::::emit(byte[])", "586": "CFFFont.DictNumberItem::::increment(int[])", "587": "CFFFont.DictNumberItem::::increment(int[])", "588": "CFFFont.DictNumberItem::::increment(int[])", "589": "CFFFont.DictNumberItem::::increment(int[])", "590": "CFFFont.DictNumberItem::::increment(int[])", "592": "CFFFont.DictNumberItem::::emit(byte[])", "593": "CFFFont.DictNumberItem::::emit(byte[])", "594": "CFFFont.DictNumberItem::::emit(byte[])", "595": "CFFFont.DictNumberItem::::emit(byte[])", "596": "CFFFont.DictNumberItem::::emit(byte[])", "597": "CFFFont.DictNumberItem::::emit(byte[])", "598": "CFFFont.DictNumberItem::::emit(byte[])", "599": "CFFFont.DictNumberItem::::emit(byte[])", "600": "CFFFont.DictNumberItem::::emit(byte[])", "601": "CFFFont.DictNumberItem::::emit(byte[])", "611": "CFFFont.MarkerItem::::xref()", "612": "CFFFont.MarkerItem::::xref()", "613": "CFFFont.MarkerItem::::xref()", "614": "CFFFont.MarkerItem::::xref()", "623": "CFFFont::::getEntireIndexRange(int)", "624": "CFFFont::::getEntireIndexRange(int)", "625": "CFFFont::::getEntireIndexRange(int)", "626": "CFFFont::::getEntireIndexRange(int)", "627": "CFFFont::::getEntireIndexRange(int)", "628": "CFFFont::::getEntireIndexRange(int)", "629": "CFFFont::::getEntireIndexRange(int)", "630": "CFFFont::::getEntireIndexRange(int)", "631": "CFFFont::::getEntireIndexRange(int)", "632": "CFFFont::::getEntireIndexRange(int)", "633": "CFFFont::::getEntireIndexRange(int)", "634": "CFFFont::::getEntireIndexRange(int)", "635": "CFFFont::::getEntireIndexRange(int)", "650": "CFFFont::::getCID(java.lang.String)", "651": "CFFFont::::getCID(java.lang.String)", "652": "CFFFont::::getCID(java.lang.String)", "653": "CFFFont::::getCID(java.lang.String)", "654": "CFFFont::::getCID(java.lang.String)", "655": "CFFFont::::getCID(java.lang.String)", "656": "CFFFont::::getCID(java.lang.String)", "657": "CFFFont::::getCID(java.lang.String)", "658": "CFFFont::::getCID(java.lang.String)", "659": "CFFFont::::getCID(java.lang.String)", "660": "CFFFont::::getCID(java.lang.String)", "661": "CFFFont::::getCID(java.lang.String)", "662": "CFFFont::::getCID(java.lang.String)", "663": "CFFFont::::getCID(java.lang.String)", "664": "CFFFont::::getCID(java.lang.String)", "665": "CFFFont::::getCID(java.lang.String)", "666": "CFFFont::::getCID(java.lang.String)", "667": "CFFFont::::getCID(java.lang.String)", "668": "CFFFont::::getCID(java.lang.String)", "669": "CFFFont::::getCID(java.lang.String)", "670": "CFFFont::::getCID(java.lang.String)", "671": "CFFFont::::getCID(java.lang.String)", "672": "CFFFont::::getCID(java.lang.String)", "673": "CFFFont::::getCID(java.lang.String)", "674": "CFFFont::::getCID(java.lang.String)", "675": "CFFFont::::getCID(java.lang.String)", "676": "CFFFont::::getCID(java.lang.String)", "677": "CFFFont::::getCID(java.lang.String)", "678": "CFFFont::::getCID(java.lang.String)", "679": "CFFFont::::getCID(java.lang.String)", "680": "CFFFont::::getCID(java.lang.String)", "681": "CFFFont::::getCID(java.lang.String)", "682": "CFFFont::::getCID(java.lang.String)", "683": "CFFFont::::getCID(java.lang.String)", "684": "CFFFont::::getCID(java.lang.String)", "685": "CFFFont::::getCID(java.lang.String)", "686": "CFFFont::::getCID(java.lang.String)", "687": "CFFFont::::getCID(java.lang.String)", "688": "CFFFont::::getCID(java.lang.String)", "689": "CFFFont::::getCID(java.lang.String)", "690": "CFFFont::::getCID(java.lang.String)", "691": "CFFFont::::getCID(java.lang.String)", "692": "CFFFont::::getCID(java.lang.String)", "693": "CFFFont::::getCID(java.lang.String)", "694": "CFFFont::::getCID(java.lang.String)", "695": "CFFFont::::getCID(java.lang.String)", "696": "CFFFont::::getCID(java.lang.String)", "697": "CFFFont::::getCID(java.lang.String)", "698": "CFFFont::::getCID(java.lang.String)", "699": "CFFFont::::getCID(java.lang.String)", "700": "CFFFont::::getCID(java.lang.String)", "701": "CFFFont::::getCID(java.lang.String)", "702": "CFFFont::::getCID(java.lang.String)", "703": "CFFFont::::getCID(java.lang.String)", "704": "CFFFont::::getCID(java.lang.String)", "705": "CFFFont::::getCID(java.lang.String)", "706": "CFFFont::::getCID(java.lang.String)", "707": "CFFFont::::getCID(java.lang.String)", "708": "CFFFont::::getCID(java.lang.String)", "709": "CFFFont::::getCID(java.lang.String)", "710": "CFFFont::::getCID(java.lang.String)", "711": "CFFFont::::getCID(java.lang.String)", "712": "CFFFont::::getCID(java.lang.String)", "713": "CFFFont::::getCID(java.lang.String)", "714": "CFFFont::::getCID(java.lang.String)", "715": "CFFFont::::getCID(java.lang.String)", "716": "CFFFont::::getCID(java.lang.String)", "717": "CFFFont::::getCID(java.lang.String)", "718": "CFFFont::::getCID(java.lang.String)", "719": "CFFFont::::getCID(java.lang.String)", "720": "CFFFont::::getCID(java.lang.String)", "721": "CFFFont::::getCID(java.lang.String)", "722": "CFFFont::::getCID(java.lang.String)", "723": "CFFFont::::getCID(java.lang.String)", "724": "CFFFont::::getCID(java.lang.String)", "725": "CFFFont::::getCID(java.lang.String)", "726": "CFFFont::::getCID(java.lang.String)", "727": "CFFFont::::getCID(java.lang.String)", "728": "CFFFont::::getCID(java.lang.String)", "729": "CFFFont::::getCID(java.lang.String)", "730": "CFFFont::::getCID(java.lang.String)", "731": "CFFFont::::getCID(java.lang.String)", "732": "CFFFont::::getCID(java.lang.String)", "733": "CFFFont::::getCID(java.lang.String)", "734": "CFFFont::::getCID(java.lang.String)", "735": "CFFFont::::getCID(java.lang.String)", "736": "CFFFont::::getCID(java.lang.String)", "737": "CFFFont::::getCID(java.lang.String)", "738": "CFFFont::::getCID(java.lang.String)", "739": "CFFFont::::getCID(java.lang.String)", "740": "CFFFont::::getCID(java.lang.String)", "741": "CFFFont::::getCID(java.lang.String)", "742": "CFFFont::::getCID(java.lang.String)", "743": "CFFFont::::getCID(java.lang.String)", "744": "CFFFont::::getCID(java.lang.String)", "745": "CFFFont::::getCID(java.lang.String)", "746": "CFFFont::::getCID(java.lang.String)", "747": "CFFFont::::getCID(java.lang.String)", "748": "CFFFont::::getCID(java.lang.String)", "749": "CFFFont::::getCID(java.lang.String)", "750": "CFFFont::::getCID(java.lang.String)", "751": "CFFFont::::getCID(java.lang.String)", "752": "CFFFont::::getCID(java.lang.String)", "753": "CFFFont::::getCID(java.lang.String)", "754": "CFFFont::::getCID(java.lang.String)", "755": "CFFFont::::getCID(java.lang.String)", "756": "CFFFont::::getCID(java.lang.String)", "757": "CFFFont::::getCID(java.lang.String)", "758": "CFFFont::::getCID(java.lang.String)", "759": "CFFFont::::getCID(java.lang.String)", "760": "CFFFont::::getCID(java.lang.String)", "761": "CFFFont::::getCID(java.lang.String)", "762": "CFFFont::::getCID(java.lang.String)", "763": "CFFFont::::getCID(java.lang.String)", "764": "CFFFont::::getCID(java.lang.String)", "765": "CFFFont::::getCID(java.lang.String)", "766": "CFFFont::::getCID(java.lang.String)", "767": "CFFFont::::getCID(java.lang.String)", "768": "CFFFont::::getCID(java.lang.String)", "769": "CFFFont::::getCID(java.lang.String)", "770": "CFFFont::::getCID(java.lang.String)", "771": "CFFFont::::getCID(java.lang.String)", "772": "CFFFont::::getCID(java.lang.String)", "773": "CFFFont::::getCID(java.lang.String)", "774": "CFFFont::::getCID(java.lang.String)", "775": "CFFFont::::getCID(java.lang.String)", "776": "CFFFont::::getCID(java.lang.String)", "777": "CFFFont::::getCID(java.lang.String)", "778": "CFFFont::::getCID(java.lang.String)", "779": "CFFFont::::getCID(java.lang.String)", "780": "CFFFont::::getCID(java.lang.String)", "781": "CFFFont::::getCID(java.lang.String)", "782": "CFFFont::::getCID(java.lang.String)", "783": "CFFFont::::getCID(java.lang.String)", "784": "CFFFont::::getCID(java.lang.String)", "785": "CFFFont::::getCID(java.lang.String)", "786": "CFFFont::::getCID(java.lang.String)", "787": "CFFFont::::getCID(java.lang.String)", "788": "CFFFont::::getCID(java.lang.String)", "789": "CFFFont::::getCID(java.lang.String)", "790": "CFFFont::::getCID(java.lang.String)", "791": "CFFFont::::getCID(java.lang.String)", "792": "CFFFont::::getCID(java.lang.String)", "793": "CFFFont::::getCID(java.lang.String)", "794": "CFFFont::::getCID(java.lang.String)", "795": "CFFFont::::getCID(java.lang.String)", "796": "CFFFont::::getCID(java.lang.String)", "797": "CFFFont::::getCID(java.lang.String)", "798": "CFFFont::::getCID(java.lang.String)", "799": "CFFFont::::getCID(java.lang.String)", "800": "CFFFont::::getCID(java.lang.String)", "801": "CFFFont::::getCID(java.lang.String)", "802": "CFFFont::::getCID(java.lang.String)", "803": "CFFFont::::getCID(java.lang.String)", "804": "CFFFont::::getCID(java.lang.String)", "805": "CFFFont::::getCID(java.lang.String)", "806": "CFFFont::::getCID(java.lang.String)", "807": "CFFFont::::getCID(java.lang.String)", "808": "CFFFont::::getCID(java.lang.String)", "809": "CFFFont::::getCID(java.lang.String)", "810": "CFFFont::::getCID(java.lang.String)", "811": "CFFFont::::getCID(java.lang.String)", "812": "CFFFont::::getCID(java.lang.String)", "813": "CFFFont::::getCID(java.lang.String)", "814": "CFFFont::::getCID(java.lang.String)", "815": "CFFFont::::getCID(java.lang.String)", "816": "CFFFont::::getCID(java.lang.String)", "817": "CFFFont::::getCID(java.lang.String)", "818": "CFFFont::::getCID(java.lang.String)", "819": "CFFFont::::getCID(java.lang.String)", "820": "CFFFont::::getCID(java.lang.String)", "821": "CFFFont::::getCID(java.lang.String)", "822": "CFFFont::::getCID(java.lang.String)", "823": "CFFFont::::getCID(java.lang.String)", "824": "CFFFont::::getCID(java.lang.String)", "825": "CFFFont::::getCID(java.lang.String)", "826": "CFFFont::::getCID(java.lang.String)", "827": "CFFFont::::getCID(java.lang.String)", "828": "CFFFont::::getCID(java.lang.String)", "829": "CFFFont::::getCID(java.lang.String)", "830": "CFFFont::::getCID(java.lang.String)", "831": "CFFFont::::getCID(java.lang.String)", "832": "CFFFont::::getCID(java.lang.String)", "833": "CFFFont::::getCID(java.lang.String)", "834": "CFFFont::::getCID(java.lang.String)", "835": "CFFFont::::getCID(java.lang.String)", "836": "CFFFont::::getCID(java.lang.String)", "837": "CFFFont::::getCID(java.lang.String)", "838": "CFFFont::::getCID(java.lang.String)", "839": "CFFFont::::getCID(java.lang.String)", "840": "CFFFont::::getCID(java.lang.String)", "841": "CFFFont::::getCID(java.lang.String)", "842": "CFFFont::::getCID(java.lang.String)", "843": "CFFFont::::getCID(java.lang.String)", "844": "CFFFont::::getCID(java.lang.String)", "845": "CFFFont::::getCID(java.lang.String)", "846": "CFFFont::::getCID(java.lang.String)", "847": "CFFFont::::getCID(java.lang.String)", "848": "CFFFont::::getCID(java.lang.String)", "849": "CFFFont::::getCID(java.lang.String)", "850": "CFFFont::::getCID(java.lang.String)", "851": "CFFFont::::getCID(java.lang.String)", "852": "CFFFont::::getCID(java.lang.String)", "853": "CFFFont::::getCID(java.lang.String)", "854": "CFFFont::::getCID(java.lang.String)", "855": "CFFFont::::getCID(java.lang.String)", "856": "CFFFont::::getCID(java.lang.String)", "857": "CFFFont::::getCID(java.lang.String)", "858": "CFFFont::::getCID(java.lang.String)", "859": "CFFFont::::getCID(java.lang.String)", "860": "CFFFont::::getCID(java.lang.String)", "861": "CFFFont::::getCID(java.lang.String)", "862": "CFFFont::::getCID(java.lang.String)", "863": "CFFFont::::getCID(java.lang.String)", "864": "CFFFont::::getCID(java.lang.String)", "865": "CFFFont::::getCID(java.lang.String)", "866": "CFFFont::::getCID(java.lang.String)", "867": "CFFFont::::getCID(java.lang.String)", "868": "CFFFont::::getCID(java.lang.String)", "869": "CFFFont::::getCID(java.lang.String)", "870": "CFFFont::::getCID(java.lang.String)", "871": "CFFFont::::getCID(java.lang.String)", "872": "CFFFont::::getCID(java.lang.String)", "873": "CFFFont::::getCID(java.lang.String)", "874": "CFFFont::::getCID(java.lang.String)", "875": "CFFFont::::getCID(java.lang.String)", "876": "CFFFont::::getCID(java.lang.String)", "877": "CFFFont::::getCID(java.lang.String)", "878": "CFFFont::::getCID(java.lang.String)", "879": "CFFFont::::getCID(java.lang.String)", "880": "CFFFont::::getCID(java.lang.String)", "881": "CFFFont::::getCID(java.lang.String)", "882": "CFFFont::::getCID(java.lang.String)", "883": "CFFFont::::getCID(java.lang.String)", "884": "CFFFont::::getCID(java.lang.String)", "885": "CFFFont::::getCID(java.lang.String)", "886": "CFFFont::::getCID(java.lang.String)", "887": "CFFFont::::getCID(java.lang.String)", "888": "CFFFont::::getCID(java.lang.String)", "889": "CFFFont::::getCID(java.lang.String)", "890": "CFFFont::::getCID(java.lang.String)", "891": "CFFFont::::getCID(java.lang.String)", "892": "CFFFont::::getCID(java.lang.String)", "893": "CFFFont::::getCID(java.lang.String)", "894": "CFFFont::::getCID(java.lang.String)", "895": "CFFFont::::getCID(java.lang.String)", "896": "CFFFont::::getCID(java.lang.String)", "897": "CFFFont::::getCID(java.lang.String)", "898": "CFFFont::::getCID(java.lang.String)", "899": "CFFFont::::getCID(java.lang.String)", "900": "CFFFont::::getCID(java.lang.String)", "901": "CFFFont::::getCID(java.lang.String)", "902": "CFFFont::::getCID(java.lang.String)", "903": "CFFFont::::getCID(java.lang.String)", "904": "CFFFont::::getCID(java.lang.String)", "905": "CFFFont::::getCID(java.lang.String)", "906": "CFFFont::::getCID(java.lang.String)", "907": "CFFFont::::getCID(java.lang.String)", "908": "CFFFont::::getCID(java.lang.String)", "909": "CFFFont::::getCID(java.lang.String)", "910": "CFFFont::::getCID(java.lang.String)", "911": "CFFFont::::getCID(java.lang.String)", "912": "CFFFont::::getCID(java.lang.String)", "913": "CFFFont::::getCID(java.lang.String)", "914": "CFFFont::::getCID(java.lang.String)", "915": "CFFFont::::getCID(java.lang.String)", "916": "CFFFont::::getCID(java.lang.String)", "917": "CFFFont::::getCID(java.lang.String)", "918": "CFFFont::::getCID(java.lang.String)", "919": "CFFFont::::getCID(java.lang.String)", "920": "CFFFont::::getCID(java.lang.String)", "921": "CFFFont::::getCID(java.lang.String)", "922": "CFFFont::::getCID(java.lang.String)", "923": "CFFFont::::getCID(java.lang.String)", "924": "CFFFont::::getCID(java.lang.String)", "925": "CFFFont::::getCID(java.lang.String)", "927": "CFFFont::::isCID()", "928": "CFFFont::::isCID()", "929": "CFFFont::::isCID()", "931": "CFFFont::::isCID(java.lang.String)", "932": "CFFFont::::isCID(java.lang.String)", "933": "CFFFont::::isCID(java.lang.String)", "934": "CFFFont::::isCID(java.lang.String)", "935": "CFFFont::::isCID(java.lang.String)", "936": "CFFFont::::isCID(java.lang.String)", "938": "CFFFont::::exists(java.lang.String)", "939": "CFFFont::::exists(java.lang.String)", "940": "CFFFont::::exists(java.lang.String)", "941": "CFFFont::::exists(java.lang.String)", "942": "CFFFont::::exists(java.lang.String)", "943": "CFFFont::::exists(java.lang.String)", "946": "CFFFont::::getNames()", "947": "CFFFont::::getNames()", "948": "CFFFont::::getNames()", "949": "CFFFont::::getNames()", "950": "CFFFont::::getNames()", "951": "CFFFont::::getNames()", "1161": "CFFFont::::ReadEncoding(int)", "1162": "CFFFont::::ReadEncoding(int)", "1163": "CFFFont::::ReadEncoding(int)", "1164": "CFFFont::::ReadEncoding(int)", "1165": "CFFFont::::ReadEncoding(int)"}, "test_reverse_method_lines_dic": {"40": "CFFFontTest::::seekTest()", "41": "CFFFontTest::::seekTest()", "42": "CFFFontTest::::seekTest()", "43": "CFFFontTest::::seekTest()", "44": "CFFFontTest::::seekTest()", "45": "CFFFontTest::::seekTest()", "46": "CFFFontTest::::seekTest()", "47": "CFFFontTest::::seekTest()", "48": "CFFFontTest::::seekTest()", "49": "CFFFontTest::::seekTest()", "50": "CFFFontTest::::seekTest()", "51": "CFFFontTest::::seekTest()", "52": "CFFFontTest::::seekTest()", "53": "CFFFontTest::::seekTest()", "54": "CFFFontTest::::seekTest()", "55": "CFFFontTest::::seekTest()", "56": "CFFFontTest::::seekTest()", "57": "CFFFontTest::::seekTest()", "58": "CFFFontTest::::seekTest()", "59": "CFFFontTest::::seekTest()", "60": "CFFFontTest::::seekTest()", "61": "CFFFontTest::::seekTest()", "62": "CFFFontTest::::seekTest()", "63": "CFFFontTest::::seekTest()", "64": "CFFFontTest::::seekTest()", "65": "CFFFontTest::::seekTest()", "67": "CFFFontTest::::getPositionTest()", "68": "CFFFontTest::::getPositionTest()", "69": "CFFFontTest::::getPositionTest()", "70": "CFFFontTest::::getPositionTest()", "71": "CFFFontTest::::getPositionTest()", "72": "CFFFontTest::::getPositionTest()", "73": "CFFFontTest::::getPositionTest()", "74": "CFFFontTest::::getPositionTest()", "75": "CFFFontTest::::getPositionTest()", "76": "CFFFontTest::::getPositionTest()", "77": "CFFFontTest::::getPositionTest()", "78": "CFFFontTest::::getPositionTest()", "79": "CFFFontTest::::getPositionTest()", "80": "CFFFontTest::::getPositionTest()", "81": "CFFFontTest::::getPositionTest()", "82": "CFFFontTest::::getPositionTest()", "83": "CFFFontTest::::getPositionTest()", "84": "CFFFontTest::::getPositionTest()", "85": "CFFFontTest::::getPositionTest()", "86": "CFFFontTest::::getPositionTest()", "87": "CFFFontTest::::getPositionTest()", "88": "CFFFontTest::::getPositionTest()"}, "tests": [{"test_lines": [40, 65], "covered_lines": [34, 55, 129, 130, 131, 133, 134, 135, 136, 137, 139, 140, 145, 146, 155, 162, 163, 164, 165, 167, 171, 172, 176, 184, 191, 200, 201, 202, 204, 209, 211, 213, 221, 224, 228, 229, 232, 233, 234, 235, 237, 238, 239, 240, 241, 242, 244, 246, 247, 248, 249, 251, 253, 254, 255, 257, 259, 260, 261, 262, 263, 265, 267, 268, 269, 270, 271, 273, 275, 276, 277, 278, 279, 280, 281, 283, 284, 285, 286, 287, 291, 293, 294, 302, 303, 305, 307, 308, 309, 310, 314, 317, 967, 970, 972, 974, 975, 976, 977, 978, 980, 982, 996, 1009, 1011, 1013, 1014, 1017, 1018, 1022, 1024, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1039, 1053, 1054, 1055, 1056, 1057, 1058, 1082, 1083, 1084, 1085, 1086, 1088, 1090, 1091, 1092, 1096, 1097, 1107, 1108, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1123, 1136, 1137, 1139, 1140, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1157]}, {"test_lines": [67, 88], "covered_lines": [34, 55, 129, 130, 131, 133, 134, 135, 136, 137, 139, 140, 145, 146, 155, 162, 163, 164, 165, 167, 171, 172, 176, 184, 191, 200, 201, 202, 204, 209, 211, 213, 221, 224, 228, 229, 232, 233, 234, 235, 237, 238, 239, 240, 241, 242, 244, 246, 247, 248, 249, 251, 253, 254, 255, 257, 259, 260, 261, 262, 263, 265, 267, 268, 269, 270, 271, 273, 275, 276, 277, 278, 279, 280, 281, 283, 284, 285, 286, 287, 291, 293, 294, 302, 303, 305, 307, 308, 309, 310, 314, 317, 967, 970, 972, 974, 975, 976, 977, 978, 980, 982, 996, 1009, 1011, 1013, 1014, 1017, 1018, 1022, 1024, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1039, 1053, 1054, 1055, 1056, 1057, 1058, 1082, 1083, 1084, 1085, 1086, 1088, 1090, 1091, 1092, 1096, 1097, 1107, 1108, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1123, 1136, 1137, 1139, 1140, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1157]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/CjkResourceLoader.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.font.cmap.AbstractCMap;\n", "import com.itextpdf.io.font.cmap.CMapByteCid;\n", "import com.itextpdf.io.font.cmap.CMapCidToCodepoint;\n", "import com.itextpdf.io.font.cmap.CMapCidUni;\n", "import com.itextpdf.io.font.cmap.CMapCodepointToCid;\n", "import com.itextpdf.io.font.cmap.CMapLocationResource;\n", "import com.itextpdf.io.font.cmap.CMapParser;\n", "import com.itextpdf.io.font.cmap.CMapUniCid;\n", "import com.itextpdf.io.util.IntHashtable;\n", "import com.itextpdf.io.util.ResourceUtil;\n", "\n", "import java.io.InputStream;\n", "import java.util.HashMap;\n", "import java.util.HashSet;\n", "import java.util.LinkedHashMap;\n", "import java.util.Map;\n", "import java.util.Properties;\n", "import java.util.Set;\n", "import java.util.StringTokenizer;\n", "\n", "/**\n", " * This class is responsible for loading and handling CJK fonts and CMaps from font-asian package.\n", " */\n", "public final class CjkResourceLoader {\n", "\n", "    private static final Map<String, Map<String, Object>> allCidFonts = new LinkedHashMap<>();\n", "    private static final Map<String, Set<String>> registryNames = new HashMap<>();\n", "\n", "    private static final String CJK_REGISTRY_FILENAME = \"cjk_registry.properties\";\n", "    private static final String FONTS_PROP = \"fonts\";\n", "    private static final String REGISTRY_PROP = \"Registry\";\n", "    private static final String W_PROP = \"W\";\n", "    private static final String W2_PROP = \"W2\";\n", "\n", "    private static CMapLocationResource cmapLocation;\n", "\n", "    private CjkResourceLoader() {\n", "    }\n", "\n", "    static {\n", "        CjkResourceLoader.setCmapLocation(new CMapLocationResource());\n", "    }\n", "\n", "    /**\n", "     * Checks if the font with the given name and encoding is one\n", "     * of the predefined CID fonts.\n", "     *\n", "     * @param fontName the font name.\n", "     * @return {@code true} if it is CJKFont.\n", "     */\n", "    public static boolean isPredefinedCidFont(String fontName) {\n", "        if (!registryNames.containsKey(FONTS_PROP)) {\n", "            return false;\n", "        } else if (!registryNames.get(FONTS_PROP).contains(fontName)) {\n", "            return false;\n", "        }\n", "        return true;\n", "    }\n", "\n", "    /**\n", "     * Finds a CJK font family which is compatible to the given CMap.\n", "     *\n", "     * @param cmap a name of the CMap for which compatible font is searched.\n", "     * @return a CJK font name if there's known compatible font for the given cmap name, or null otherwise.\n", "     */\n", "    public static String getCompatibleCidFont(String cmap) {\n", "        for (Map.Entry<String, Set<String>> e : registryNames.entrySet()) {\n", "            if (e.getValue().contains(cmap)) {\n", "                String registry = e.getKey();\n", "                for (Map.Entry<String, Map<String, Object>> e1 : allCidFonts.entrySet()) {\n", "                    if (registry.equals(e1.getValue().get(REGISTRY_PROP))) {\n", "                        return e1.getKey();\n", "                    }\n", "                }\n", "            }\n", "        }\n", "        return null;\n", "    }\n", "\n", "    /**\n", "     * Finds all CMap names that belong to the same registry to which a given\n", "     * font belongs.\n", "     *\n", "     * @param fontName a name of the font for which CMap's are searched.\n", "     * @return a set of CMap names corresponding to the given font.\n", "     */\n", "    public static Set<String> getCompatibleCmaps(String fontName) {\n", "        Map<String, Object> cidFonts = CjkResourceLoader.getAllPredefinedCidFonts().get(fontName);\n", "        if (cidFonts == null) {\n", "            return null;\n", "        }\n", "        String registry = (String) cidFonts.get(REGISTRY_PROP);\n", "        return registryNames.get(registry);\n", "    }\n", "\n", "    /**\n", "     * Get all loaded predefined CID fonts.\n", "     *\n", "     * @return predefined CID fonts.\n", "     */\n", "    public static Map<String, Map<String, Object>> getAllPredefinedCidFonts() {\n", "        return allCidFonts;\n", "    }\n", "\n", "    /**\n", "     * Get all loaded CJK registry names mapped to a set of compatible cmaps.\n", "     *\n", "     * @return CJK registry names mapped to a set of compatible cmaps.\n", "     */\n", "    public static Map<String, Set<String>> getRegistryNames() {\n", "        return registryNames;\n", "    }\n", "\n", "    /**\n", "     * Parses CMap with a given name producing it in a form of cid to unicode mapping.\n", "     *\n", "     * @param uniMap a CMap name. It is expected that CMap identified by this name defines unicode to cid mapping.\n", "     * @return an object for convenient mapping from cid to unicode. If no CMap was found for provided name\n", "     * an exception is thrown.\n", "     */\n", "    public static CMapCidUni getCid2UniCmap(String uniMap) {\n", "        CMapCidUni cidUni = new CMapCidUni();\n", "        return parseCmap(uniMap, cidUni);\n", "    }\n", "\n", "    /**\n", "     * Parses CMap with a given name producing it in a form of unicode to cid mapping.\n", "     *\n", "     * @param uniMap a CMap name. It is expected that CMap identified by this name defines unicode to cid mapping.\n", "     * @return an object for convenient mapping from unicode to cid. If no CMap was found for provided name\n", "     * an exception is thrown.\n", "     */\n", "    public static CMapUniCid getUni2CidCmap(String uniMap) {\n", "        return parseCmap(uniMap, new CMapUniCid());\n", "    }\n", "\n", "    /**\n", "     * Parses CMap with a given name producing it in a form of byte to cid mapping.\n", "     *\n", "     * @param cmap a CMap name. It is expected that CMap identified by this name defines byte to cid mapping.\n", "     * @return an object for convenient mapping from byte to cid. If no CMap was found for provided name\n", "     * an exception is thrown.\n", "     */\n", "    public static CMapByteCid getByte2CidCmap(String cmap) {\n", "        CMapByteCid uniCid = new CMapByteCid();\n", "        return parseCmap(cmap, uniCid);\n", "    }\n", "\n", "    /**\n", "     * Parses CMap with a given name producing it in a form of cid to code point mapping.\n", "     *\n", "     * @param cmap a CMap name. It is expected that CMap identified by this name defines code point to cid mapping.\n", "     * @return an object for convenient mapping from cid to code point. If no CMap was found for provided name\n", "     * an exception is thrown.\n", "     */\n", "    public static CMapCidToCodepoint getCidToCodepointCmap(String cmap) {\n", "        CMapCidToCodepoint cidByte = new CMapCidToCodepoint();\n", "        return parseCmap(cmap, cidByte);\n", "    }\n", "\n", "    /**\n", "     * Parses CMap with a given name producing it in a form of code point to cid mapping.\n", "     *\n", "     * @param uniMap a CMap name. It is expected that CMap identified by this name defines code point to cid mapping.\n", "     * @return an object for convenient mapping from code point to cid. If no CMap was found for provided name\n", "     * an exception is thrown.\n", "     */\n", "    public static CMapCodepointToCid getCodepointToCidCmap(String uniMap) {\n", "        return parseCmap(uniMap, new CMapCodepointToCid());\n", "    }\n", "\n", "    static void setCmapLocation(CMapLocationResource cmapLocation) {\n", "        CjkResourceLoader.cmapLocation = cmapLocation;\n", "        try {\n", "            loadRegistry();\n", "        } catch (Exception ignored) {\n", "        }\n", "    }\n", "\n", "    private static void loadRegistry() throws java.io.IOException {\n", "        registryNames.clear();\n", "        allCidFonts.clear();\n", "\n", "        InputStream resource = ResourceUtil.getResourceStream(cmapLocation.getLocationPath() + CJK_REGISTRY_FILENAME);\n", "        try {\n", "            Properties p = new Properties();\n", "            p.load(resource);\n", "\n", "            for (Map.Entry<Object, Object> entry : p.entrySet()) {\n", "                String value = (String) entry.getValue();\n", "                String[] splitValue = value.split(\" \");\n", "                Set<String> set = new HashSet<>();\n", "\n", "                for (String s : splitValue) {\n", "                    if (s.length() != 0) {\n", "                        set.add(s);\n", "                    }\n", "                }\n", "\n", "                registryNames.put((String) entry.getKey(), set);\n", "            }\n", "        } finally {\n", "            if (resource != null) {\n", "                resource.close();\n", "            }\n", "        }\n", "\n", "        for (String font : registryNames.get(FONTS_PROP)) {\n", "            allCidFonts.put(font, readFontProperties(font));\n", "        }\n", "    }\n", "\n", "    private static Map<String, Object> readFontProperties(String name) throws java.io.IOException {\n", "        InputStream resource = ResourceUtil.getResourceStream(cmapLocation.getLocationPath() + name + \".properties\");\n", "\n", "        try {\n", "            Properties p = new Properties();\n", "            p.load(resource);\n", "\n", "            Map<String, Object> fontProperties = new HashMap<>();\n", "            for (Map.Entry<Object, Object> entry : p.entrySet()) {\n", "                fontProperties.put((String) entry.getKey(), entry.getValue());\n", "            }\n", "            fontProperties.put(W_PROP, createMetric((String) fontProperties.get(W_PROP)));\n", "            fontProperties.put(W2_PROP, createMetric((String) fontProperties.get(W2_PROP)));\n", "\n", "            return fontProperties;\n", "        } finally {\n", "            if (resource != null) {\n", "                resource.close();\n", "            }\n", "        }\n", "    }\n", "\n", "    private static IntHashtable createMetric(String s) {\n", "        IntHashtable h = new IntHashtable();\n", "        StringTokenizer tk = new StringTokenizer(s);\n", "\n", "        while (tk.hasMoreTokens()) {\n", "            int n1 = Integer.parseInt(tk.nextToken());\n", "            h.put(n1, Integer.parseInt(tk.nextToken()));\n", "        }\n", "\n", "        return h;\n", "    }\n", "\n", "    private static <T extends AbstractCMap> T parseCmap(String name, T cmap) {\n", "        try {\n", "            CMapParser.parseCid(name, cmap, cmapLocation);\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.IO_EXCEPTION, e);\n", "        }\n", "        return cmap;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.font.cmap.CMapByteCid;\n", "import com.itextpdf.io.font.cmap.CMapCidToCodepoint;\n", "import com.itextpdf.io.font.cmap.CMapCidUni;\n", "import com.itextpdf.io.font.cmap.CMapCodepointToCid;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.util.Map;\n", "import java.util.Set;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "public class CjkResourceLoaderTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void getCompatibleCidFont() {\n", "        String expected = \"HeiseiMin-W3\";\n", "\n", "        String compatibleCidFont = CjkResourceLoader.getCompatibleCidFont(\"78-RKSJ-V\");\n", "        Assert.assertEquals(expected, compatibleCidFont);\n", "    }\n", "\n", "    @Test\n", "    public void getCompatibleCmaps() {\n", "        Set<String> compatibleCmaps = CjkResourceLoader.getCompatibleCmaps(\"HeiseiKakuGo-W5\");\n", "        Assert.assertEquals(66, compatibleCmaps.size());\n", "        Assert.assertTrue(compatibleCmaps.contains(\"78-RKSJ-V\"));\n", "    }\n", "\n", "    @Test\n", "    public void getRegistryNames() {\n", "        Map<String, Set<String>> registryNames = CjkResourceLoader.getRegistryNames();\n", "        Assert.assertEquals(9, registryNames.size());\n", "        Assert.assertTrue(registryNames.containsKey(\"Adobe_Japan1\"));\n", "        Assert.assertTrue(registryNames.get(\"Adobe_Japan1\").contains(\"78-RKSJ-V\"));\n", "    }\n", "\n", "    @Test\n", "    public void getCid2UniCMap() {\n", "        CMapCidUni cid2UniCmap = CjkResourceLoader.getCid2UniCmap(\"UniJIS-UTF16-H\");\n", "        Assert.assertEquals(0x00b5, cid2UniCmap.lookup(159));\n", "    }\n", "\n", "    @Test\n", "    public void getUni2CidCMap() {\n", "        CMapCodepointToCid uni2CidCmap = CjkResourceLoader.getCodepointToCidCmap(\"UniJIS-UTF16-H\");\n", "        Assert.assertEquals(159, uni2CidCmap.lookup(0x00b5));\n", "    }\n", "\n", "    @Test\n", "    public void getByte2CidCMap() {\n", "        CMapByteCid byte2CidCmap = CjkResourceLoader.getByte2CidCmap(\"78ms-RKSJ-H\");\n", "        int byteCode = 0x94e0;\n", "        char cid = (char) 7779;\n", "\n", "        byte[] byteCodeBytes = {(byte) ((byteCode & 0xFF00) >> 8), (byte) (byteCode & 0xFF)};\n", "        String actual = byte2CidCmap.decodeSequence(byteCodeBytes, 0, 2);\n", "        String expected = new String(new char[]{cid});\n", "\n", "        Assert.assertEquals(expected, actual);\n", "    }\n", "\n", "    @Test\n", "    public void getCid2ByteCMap() {\n", "        CMapCidToCodepoint cid2Byte = CjkResourceLoader.getCidToCodepointCmap(\"78ms-RKSJ-H\");\n", "        int byteCode = 0x94e0;\n", "        int cid = 7779;\n", "\n", "        byte[] actual = cid2Byte.lookup(cid);\n", "        byte[] expected = {(byte) ((byteCode & 0xFF00) >> 8), (byte) (byteCode & 0xFF)};\n", "        Assert.assertArrayEquals(expected, actual);\n", "    }\n", "}\n"], "method_lines_dic": {"CjkResourceLoader::::isPredefinedCidFont(java.lang.String)": [77, 84], "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)": [92, 104], "CjkResourceLoader::::getCompatibleCmaps(java.lang.String)": [113, 120], "CjkResourceLoader::::getAllPredefinedCidFonts()": [127, 129], "CjkResourceLoader::::getRegistryNames()": [136, 138], "CjkResourceLoader::::getCid2UniCmap(java.lang.String)": [147, 150], "CjkResourceLoader::::getUni2CidCmap(java.lang.String)": [159, 161], "CjkResourceLoader::::getByte2CidCmap(java.lang.String)": [170, 173], "CjkResourceLoader::::getCidToCodepointCmap(java.lang.String)": [182, 185], "CjkResourceLoader::::getCodepointToCidCmap(java.lang.String)": [194, 196], "CjkResourceLoader::::setCmapLocation(com.itextpdf.io.font.cmap.CMapLocationResource)": [198, 204], "CjkResourceLoader::::loadRegistry()": [206, 237], "CjkResourceLoader::::readFontProperties(java.lang.String)": [239, 259], "CjkResourceLoader::::createMetric(java.lang.String)": [261, 271], "CjkResourceLoader::::parseCmap(java.lang.String,T)": [273, 280]}, "test_method_lines_dic": {"CjkResourceLoaderTest::::getCompatibleCidFont()": [41, 47], "CjkResourceLoaderTest::::getCompatibleCmaps()": [49, 54], "CjkResourceLoaderTest::::getRegistryNames()": [56, 62], "CjkResourceLoaderTest::::getCid2UniCMap()": [64, 68], "CjkResourceLoaderTest::::getUni2CidCMap()": [70, 74], "CjkResourceLoaderTest::::getByte2CidCMap()": [76, 87], "CjkResourceLoaderTest::::getCid2ByteCMap()": [89, 98]}, "reverse_method_lines_dic": {"77": "CjkResourceLoader::::isPredefinedCidFont(java.lang.String)", "78": "CjkResourceLoader::::isPredefinedCidFont(java.lang.String)", "79": "CjkResourceLoader::::isPredefinedCidFont(java.lang.String)", "80": "CjkResourceLoader::::isPredefinedCidFont(java.lang.String)", "81": "CjkResourceLoader::::isPredefinedCidFont(java.lang.String)", "82": "CjkResourceLoader::::isPredefinedCidFont(java.lang.String)", "83": "CjkResourceLoader::::isPredefinedCidFont(java.lang.String)", "84": "CjkResourceLoader::::isPredefinedCidFont(java.lang.String)", "92": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "93": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "94": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "95": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "96": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "97": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "98": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "99": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "100": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "101": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "102": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "103": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "104": "CjkResourceLoader::::getCompatibleCidFont(java.lang.String)", "113": "CjkResourceLoader::::getCompatibleCmaps(java.lang.String)", "114": "CjkResourceLoader::::getCompatibleCmaps(java.lang.String)", "115": "CjkResourceLoader::::getCompatibleCmaps(java.lang.String)", "116": "CjkResourceLoader::::getCompatibleCmaps(java.lang.String)", "117": "CjkResourceLoader::::getCompatibleCmaps(java.lang.String)", "118": "CjkResourceLoader::::getCompatibleCmaps(java.lang.String)", "119": "CjkResourceLoader::::getCompatibleCmaps(java.lang.String)", "120": "CjkResourceLoader::::getCompatibleCmaps(java.lang.String)", "127": "CjkResourceLoader::::getAllPredefinedCidFonts()", "128": "CjkResourceLoader::::getAllPredefinedCidFonts()", "129": "CjkResourceLoader::::getAllPredefinedCidFonts()", "136": "CjkResourceLoader::::getRegistryNames()", "137": "CjkResourceLoader::::getRegistryNames()", "138": "CjkResourceLoader::::getRegistryNames()", "147": "CjkResourceLoader::::getCid2UniCmap(java.lang.String)", "148": "CjkResourceLoader::::getCid2UniCmap(java.lang.String)", "149": "CjkResourceLoader::::getCid2UniCmap(java.lang.String)", "150": "CjkResourceLoader::::getCid2UniCmap(java.lang.String)", "159": "CjkResourceLoader::::getUni2CidCmap(java.lang.String)", "160": "CjkResourceLoader::::getUni2CidCmap(java.lang.String)", "161": "CjkResourceLoader::::getUni2CidCmap(java.lang.String)", "170": "CjkResourceLoader::::getByte2CidCmap(java.lang.String)", "171": "CjkResourceLoader::::getByte2CidCmap(java.lang.String)", "172": "CjkResourceLoader::::getByte2CidCmap(java.lang.String)", "173": "CjkResourceLoader::::getByte2CidCmap(java.lang.String)", "182": "CjkResourceLoader::::getCidToCodepointCmap(java.lang.String)", "183": "CjkResourceLoader::::getCidToCodepointCmap(java.lang.String)", "184": "CjkResourceLoader::::getCidToCodepointCmap(java.lang.String)", "185": "CjkResourceLoader::::getCidToCodepointCmap(java.lang.String)", "194": "CjkResourceLoader::::getCodepointToCidCmap(java.lang.String)", "195": "CjkResourceLoader::::getCodepointToCidCmap(java.lang.String)", "196": "CjkResourceLoader::::getCodepointToCidCmap(java.lang.String)", "198": "CjkResourceLoader::::setCmapLocation(com.itextpdf.io.font.cmap.CMapLocationResource)", "199": "CjkResourceLoader::::setCmapLocation(com.itextpdf.io.font.cmap.CMapLocationResource)", "200": "CjkResourceLoader::::setCmapLocation(com.itextpdf.io.font.cmap.CMapLocationResource)", "201": "CjkResourceLoader::::setCmapLocation(com.itextpdf.io.font.cmap.CMapLocationResource)", "202": "CjkResourceLoader::::setCmapLocation(com.itextpdf.io.font.cmap.CMapLocationResource)", "203": "CjkResourceLoader::::setCmapLocation(com.itextpdf.io.font.cmap.CMapLocationResource)", "204": "CjkResourceLoader::::setCmapLocation(com.itextpdf.io.font.cmap.CMapLocationResource)", "206": "CjkResourceLoader::::loadRegistry()", "207": "CjkResourceLoader::::loadRegistry()", "208": "CjkResourceLoader::::loadRegistry()", "209": "CjkResourceLoader::::loadRegistry()", "210": "CjkResourceLoader::::loadRegistry()", "211": "CjkResourceLoader::::loadRegistry()", "212": "CjkResourceLoader::::loadRegistry()", "213": "CjkResourceLoader::::loadRegistry()", "214": "CjkResourceLoader::::loadRegistry()", "215": "CjkResourceLoader::::loadRegistry()", "216": "CjkResourceLoader::::loadRegistry()", "217": "CjkResourceLoader::::loadRegistry()", "218": "CjkResourceLoader::::loadRegistry()", "219": "CjkResourceLoader::::loadRegistry()", "220": "CjkResourceLoader::::loadRegistry()", "221": "CjkResourceLoader::::loadRegistry()", "222": "CjkResourceLoader::::loadRegistry()", "223": "CjkResourceLoader::::loadRegistry()", "224": "CjkResourceLoader::::loadRegistry()", "225": "CjkResourceLoader::::loadRegistry()", "226": "CjkResourceLoader::::loadRegistry()", "227": "CjkResourceLoader::::loadRegistry()", "228": "CjkResourceLoader::::loadRegistry()", "229": "CjkResourceLoader::::loadRegistry()", "230": "CjkResourceLoader::::loadRegistry()", "231": "CjkResourceLoader::::loadRegistry()", "232": "CjkResourceLoader::::loadRegistry()", "233": "CjkResourceLoader::::loadRegistry()", "234": "CjkResourceLoader::::loadRegistry()", "235": "CjkResourceLoader::::loadRegistry()", "236": "CjkResourceLoader::::loadRegistry()", "237": "CjkResourceLoader::::loadRegistry()", "239": "CjkResourceLoader::::readFontProperties(java.lang.String)", "240": "CjkResourceLoader::::readFontProperties(java.lang.String)", "241": "CjkResourceLoader::::readFontProperties(java.lang.String)", "242": "CjkResourceLoader::::readFontProperties(java.lang.String)", "243": "CjkResourceLoader::::readFontProperties(java.lang.String)", "244": "CjkResourceLoader::::readFontProperties(java.lang.String)", "245": "CjkResourceLoader::::readFontProperties(java.lang.String)", "246": "CjkResourceLoader::::readFontProperties(java.lang.String)", "247": "CjkResourceLoader::::readFontProperties(java.lang.String)", "248": "CjkResourceLoader::::readFontProperties(java.lang.String)", "249": "CjkResourceLoader::::readFontProperties(java.lang.String)", "250": "CjkResourceLoader::::readFontProperties(java.lang.String)", "251": "CjkResourceLoader::::readFontProperties(java.lang.String)", "252": "CjkResourceLoader::::readFontProperties(java.lang.String)", "253": "CjkResourceLoader::::readFontProperties(java.lang.String)", "254": "CjkResourceLoader::::readFontProperties(java.lang.String)", "255": "CjkResourceLoader::::readFontProperties(java.lang.String)", "256": "CjkResourceLoader::::readFontProperties(java.lang.String)", "257": "CjkResourceLoader::::readFontProperties(java.lang.String)", "258": "CjkResourceLoader::::readFontProperties(java.lang.String)", "259": "CjkResourceLoader::::readFontProperties(java.lang.String)", "261": "CjkResourceLoader::::createMetric(java.lang.String)", "262": "CjkResourceLoader::::createMetric(java.lang.String)", "263": "CjkResourceLoader::::createMetric(java.lang.String)", "264": "CjkResourceLoader::::createMetric(java.lang.String)", "265": "CjkResourceLoader::::createMetric(java.lang.String)", "266": "CjkResourceLoader::::createMetric(java.lang.String)", "267": "CjkResourceLoader::::createMetric(java.lang.String)", "268": "CjkResourceLoader::::createMetric(java.lang.String)", "269": "CjkResourceLoader::::createMetric(java.lang.String)", "270": "CjkResourceLoader::::createMetric(java.lang.String)", "271": "CjkResourceLoader::::createMetric(java.lang.String)", "273": "CjkResourceLoader::::parseCmap(java.lang.String,T)", "274": "CjkResourceLoader::::parseCmap(java.lang.String,T)", "275": "CjkResourceLoader::::parseCmap(java.lang.String,T)", "276": "CjkResourceLoader::::parseCmap(java.lang.String,T)", "277": "CjkResourceLoader::::parseCmap(java.lang.String,T)", "278": "CjkResourceLoader::::parseCmap(java.lang.String,T)", "279": "CjkResourceLoader::::parseCmap(java.lang.String,T)", "280": "CjkResourceLoader::::parseCmap(java.lang.String,T)"}, "test_reverse_method_lines_dic": {"41": "CjkResourceLoaderTest::::getCompatibleCidFont()", "42": "CjkResourceLoaderTest::::getCompatibleCidFont()", "43": "CjkResourceLoaderTest::::getCompatibleCidFont()", "44": "CjkResourceLoaderTest::::getCompatibleCidFont()", "45": "CjkResourceLoaderTest::::getCompatibleCidFont()", "46": "CjkResourceLoaderTest::::getCompatibleCidFont()", "47": "CjkResourceLoaderTest::::getCompatibleCidFont()", "49": "CjkResourceLoaderTest::::getCompatibleCmaps()", "50": "CjkResourceLoaderTest::::getCompatibleCmaps()", "51": "CjkResourceLoaderTest::::getCompatibleCmaps()", "52": "CjkResourceLoaderTest::::getCompatibleCmaps()", "53": "CjkResourceLoaderTest::::getCompatibleCmaps()", "54": "CjkResourceLoaderTest::::getCompatibleCmaps()", "56": "CjkResourceLoaderTest::::getRegistryNames()", "57": "CjkResourceLoaderTest::::getRegistryNames()", "58": "CjkResourceLoaderTest::::getRegistryNames()", "59": "CjkResourceLoaderTest::::getRegistryNames()", "60": "CjkResourceLoaderTest::::getRegistryNames()", "61": "CjkResourceLoaderTest::::getRegistryNames()", "62": "CjkResourceLoaderTest::::getRegistryNames()", "64": "CjkResourceLoaderTest::::getCid2UniCMap()", "65": "CjkResourceLoaderTest::::getCid2UniCMap()", "66": "CjkResourceLoaderTest::::getCid2UniCMap()", "67": "CjkResourceLoaderTest::::getCid2UniCMap()", "68": "CjkResourceLoaderTest::::getCid2UniCMap()", "70": "CjkResourceLoaderTest::::getUni2CidCMap()", "71": "CjkResourceLoaderTest::::getUni2CidCMap()", "72": "CjkResourceLoaderTest::::getUni2CidCMap()", "73": "CjkResourceLoaderTest::::getUni2CidCMap()", "74": "CjkResourceLoaderTest::::getUni2CidCMap()", "76": "CjkResourceLoaderTest::::getByte2CidCMap()", "77": "CjkResourceLoaderTest::::getByte2CidCMap()", "78": "CjkResourceLoaderTest::::getByte2CidCMap()", "79": "CjkResourceLoaderTest::::getByte2CidCMap()", "80": "CjkResourceLoaderTest::::getByte2CidCMap()", "81": "CjkResourceLoaderTest::::getByte2CidCMap()", "82": "CjkResourceLoaderTest::::getByte2CidCMap()", "83": "CjkResourceLoaderTest::::getByte2CidCMap()", "84": "CjkResourceLoaderTest::::getByte2CidCMap()", "85": "CjkResourceLoaderTest::::getByte2CidCMap()", "86": "CjkResourceLoaderTest::::getByte2CidCMap()", "87": "CjkResourceLoaderTest::::getByte2CidCMap()", "89": "CjkResourceLoaderTest::::getCid2ByteCMap()", "90": "CjkResourceLoaderTest::::getCid2ByteCMap()", "91": "CjkResourceLoaderTest::::getCid2ByteCMap()", "92": "CjkResourceLoaderTest::::getCid2ByteCMap()", "93": "CjkResourceLoaderTest::::getCid2ByteCMap()", "94": "CjkResourceLoaderTest::::getCid2ByteCMap()", "95": "CjkResourceLoaderTest::::getCid2ByteCMap()", "96": "CjkResourceLoaderTest::::getCid2ByteCMap()", "97": "CjkResourceLoaderTest::::getCid2ByteCMap()", "98": "CjkResourceLoaderTest::::getCid2ByteCMap()"}, "tests": [{"test_lines": [41, 47], "covered_lines": [52, 53, 67, 68, 93, 94, 95, 96, 97, 98, 102, 199, 201, 203, 204, 207, 208, 210, 212, 213, 215, 216, 217, 218, 220, 221, 222, 226, 227, 229, 230, 234, 235, 236, 237, 240, 243, 244, 246, 247, 248, 249, 250, 251, 253, 255, 256, 262, 263, 265, 266, 267, 268, 270]}, {"test_lines": [49, 54], "covered_lines": [52, 53, 67, 68, 114, 115, 118, 119, 128, 199, 201, 203, 204, 207, 208, 210, 212, 213, 215, 216, 217, 218, 220, 221, 222, 226, 227, 229, 230, 234, 235, 236, 237, 240, 243, 244, 246, 247, 248, 249, 250, 251, 253, 255, 256, 262, 263, 265, 266, 267, 268, 270]}, {"test_lines": [56, 62], "covered_lines": [52, 53, 67, 68, 137, 199, 201, 203, 204, 207, 208, 210, 212, 213, 215, 216, 217, 218, 220, 221, 222, 226, 227, 229, 230, 234, 235, 236, 237, 240, 243, 244, 246, 247, 248, 249, 250, 251, 253, 255, 256, 262, 263, 265, 266, 267, 268, 270]}, {"test_lines": [64, 68], "covered_lines": [52, 53, 67, 68, 148, 149, 199, 201, 203, 204, 207, 208, 210, 212, 213, 215, 216, 217, 218, 220, 221, 222, 226, 227, 229, 230, 234, 235, 236, 237, 240, 243, 244, 246, 247, 248, 249, 250, 251, 253, 255, 256, 262, 263, 265, 266, 267, 268, 270, 275, 278, 279]}, {"test_lines": [70, 74], "covered_lines": [52, 53, 67, 68, 195, 199, 201, 203, 204, 207, 208, 210, 212, 213, 215, 216, 217, 218, 220, 221, 222, 226, 227, 229, 230, 234, 235, 236, 237, 240, 243, 244, 246, 247, 248, 249, 250, 251, 253, 255, 256, 262, 263, 265, 266, 267, 268, 270, 275, 278, 279]}, {"test_lines": [76, 87], "covered_lines": [52, 53, 67, 68, 171, 172, 199, 201, 203, 204, 207, 208, 210, 212, 213, 215, 216, 217, 218, 220, 221, 222, 226, 227, 229, 230, 234, 235, 236, 237, 240, 243, 244, 246, 247, 248, 249, 250, 251, 253, 255, 256, 262, 263, 265, 266, 267, 268, 270, 275, 278, 279]}, {"test_lines": [89, 98], "covered_lines": [52, 53, 67, 68, 183, 184, 199, 201, 203, 204, 207, 208, 210, 212, 213, 215, 216, 217, 218, 220, 221, 222, 226, 227, 229, 230, 234, 235, 236, 237, 240, 243, 244, 246, 247, 248, 249, 250, 251, 253, 255, 256, 262, 263, 265, 266, 267, 268, 270, 275, 278, 279]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/FontEncoding.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.io.util.ArrayUtil;\n", "import com.itextpdf.io.util.IntHashtable;\n", "import com.itextpdf.io.util.TextUtil;\n", "\n", "import java.util.Objects;\n", "import java.util.StringTokenizer;\n", "\n", "public class FontEncoding {\n", "\n", "\n", "    private static final byte[] emptyBytes = new byte[0];\n", "\n", "    public static final String FONT_SPECIFIC = \"FontSpecific\";\n", "    /**\n", "     * A not defined character in a custom PDF encoding.\n", "     */\n", "    public static final String NOTDEF = \".notdef\";\n", "\n", "    /**\n", "     * Base font encoding.\n", "     */\n", "    protected String baseEncoding;\n", "    /**\n", "     * {@code true} if the font must use its built in encoding. In that case\n", "     * the {@code encoding} is only used to map a char to the position inside the font, not to the expected char name.\n", "     */\n", "    protected boolean fontSpecific;\n", "\n", "    /**\n", "     * Mapping map from unicode to simple code according to the encoding.\n", "     */\n", "    protected IntHashtable unicodeToCode;\n", "\n", "    protected int[] codeToUnicode;\n", "\n", "    /**\n", "     * Encoding names.\n", "     */\n", "    protected String[] differences;\n", "    /**\n", "     * Encodings unicode differences\n", "     */\n", "    protected IntHashtable unicodeDifferences;\n", "\n", "    protected FontEncoding() {\n", "        unicodeToCode = new IntHashtable(256);\n", "        codeToUnicode = ArrayUtil.fillWithValue(new int[256], -1);\n", "        unicodeDifferences = new IntHashtable(256);\n", "        fontSpecific = false;\n", "    }\n", "\n", "    public static FontEncoding createFontEncoding(String baseEncoding) {\n", "        FontEncoding encoding = new FontEncoding();\n", "        encoding.baseEncoding = normalizeEncoding(baseEncoding);\n", "        if (encoding.baseEncoding.startsWith(\"#\")) {\n", "            encoding.fillCustomEncoding();\n", "        } else {\n", "            encoding.fillNamedEncoding();\n", "        }\n", "        return encoding;\n", "    }\n", "\n", "    public static FontEncoding createEmptyFontEncoding() {\n", "        FontEncoding encoding = new FontEncoding();\n", "        encoding.baseEncoding = null;\n", "        encoding.fontSpecific = false;\n", "        encoding.differences = new String[256];\n", "        for (int ch = 0; ch < 256; ch++) {\n", "            encoding.unicodeDifferences.put(ch, ch);\n", "        }\n", "        return encoding;\n", "    }\n", "\n", "    /**\n", "     * This encoding will base on font encoding (FontSpecific encoding in Type 1 terminology)\n", "     *\n", "     * @return created font specific encoding\n", "     */\n", "    public static FontEncoding createFontSpecificEncoding() {\n", "        FontEncoding encoding = new FontEncoding();\n", "        encoding.fontSpecific = true;\n", "        FontEncoding.fillFontEncoding(encoding);\n", "\n", "        return encoding;\n", "    }\n", "\n", "    /**\n", "     * Fill {@link FontEncoding} object with default data.\n", "     *\n", "     * @param encoding {@link FontEncoding} to fill.\n", "     */\n", "    public static void fillFontEncoding(FontEncoding encoding) {\n", "        for (int ch = 0; ch < 256; ch++) {\n", "            encoding.unicodeToCode.put(ch, ch);\n", "            encoding.codeToUnicode[ch] = ch;\n", "            encoding.unicodeDifferences.put(ch, ch);\n", "        }\n", "    }\n", "\n", "    public String getBaseEncoding() {\n", "        return baseEncoding;\n", "    }\n", "\n", "    public boolean isFontSpecific() {\n", "        return fontSpecific;\n", "    }\n", "\n", "    public boolean addSymbol(int code, int unicode) {\n", "        if (code < 0 || code > 255) {\n", "            return false;\n", "        }\n", "        String glyphName = AdobeGlyphList.unicodeToName(unicode);\n", "        if (glyphName != null) {\n", "            unicodeToCode.put(unicode, code);\n", "            codeToUnicode[code] = unicode;\n", "            differences[code] = glyphName;\n", "            unicodeDifferences.put(unicode, unicode);\n", "            return true;\n", "        } else {\n", "            return false;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Gets unicode value for corresponding font's char code.\n", "     *\n", "     * @param index font's char code\n", "     * @return -1, if the char code unsupported or valid unicode.\n", "     */\n", "    public int getUnicode(int index) {\n", "        return codeToUnicode[index];\n", "    }\n", "\n", "    public int getUnicodeDifference(int index) {\n", "        return unicodeDifferences.get(index);\n", "    }\n", "\n", "    public boolean hasDifferences() {\n", "        return differences != null;\n", "    }\n", "\n", "    public String getDifference(int index) {\n", "        return differences != null ? differences[index] : null;\n", "    }\n", "\n", "    /**\n", "     * Sets a new value in the differences array.\n", "     * See {@link #differences}.\n", "     *\n", "     * @param index position to replace\n", "     * @param difference new difference value\n", "     */\n", "    public void setDifference(int index, String difference) {\n", "        if (index >= 0 && differences != null && index < differences.length) {\n", "            differences[index] = difference;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Converts a {@code String} to a {@code byte} array according to the encoding.\n", "     * String could contain a unicode symbols or font specific codes.\n", "     *\n", "     * @param text the {@code String} to be converted.\n", "     * @return an array of {@code byte} representing the conversion according to the encoding\n", "     */\n", "    public byte[] convertToBytes(String text) {\n", "        if (text == null || text.length() == 0) {\n", "            return emptyBytes;\n", "        }\n", "        int ptr = 0;\n", "        byte[] bytes = new byte[text.length()];\n", "        for (int i = 0; i < text.length(); i++) {\n", "            if (unicodeToCode.containsKey(text.charAt(i))) {\n", "                bytes[ptr++] = (byte) convertToByte(text.charAt(i));\n", "            }\n", "        }\n", "        return ArrayUtil.shortenArray(bytes, ptr);\n", "    }\n", "\n", "    /**\n", "     * Converts a unicode symbol or font specific code\n", "     * to {@code byte} according to the encoding.\n", "     *\n", "     * @param unicode a unicode symbol or FontSpecif code to be converted.\n", "     * @return a {@code byte} representing the conversion according to the encoding\n", "     */\n", "    public int convertToByte(int unicode) {\n", "        return unicodeToCode.get(unicode);\n", "    }\n", "\n", "    /**\n", "     * Check whether a unicode symbol or font specific code can be converted\n", "     * to {@code byte} according to the encoding.\n", "     *\n", "     * @param unicode a unicode symbol or font specific code to be checked.\n", "     * @return {@code true} if {@code ch} could be encoded.\n", "     */\n", "    public boolean canEncode(int unicode) {\n", "        return unicodeToCode.containsKey(unicode) || TextUtil.isNonPrintable(unicode) || TextUtil.isNewLine(unicode);\n", "    }\n", "\n", "    /**\n", "     * Check whether a {@code byte} code can be converted\n", "     * to unicode symbol according to the encoding.\n", "     *\n", "     * @param code a byte code to be checked.\n", "     * @return {@code true} if {@code code} could be decoded.\n", "     */\n", "    public boolean canDecode(int code) {\n", "        return codeToUnicode[code] > -1;\n", "    }\n", "\n", "    /**\n", "     * Checks whether the {@link FontEncoding} was built with corresponding encoding.\n", "     *\n", "     * @param encoding an encoding\n", "     * @return true, if the FontEncoding was built with the encoding. Otherwise false.\n", "     */\n", "    public boolean isBuiltWith(String encoding) {\n", "        return Objects.equals(normalizeEncoding(encoding), baseEncoding);\n", "    }\n", "\n", "    protected void fillCustomEncoding() {\n", "        differences = new String[256];\n", "        StringTokenizer tok = new StringTokenizer(baseEncoding.substring(1), \" ,\\t\\n\\r\\f\");\n", "        if (tok.nextToken().equals(\"full\")) {\n", "            while (tok.hasMoreTokens()) {\n", "                String order = tok.nextToken();\n", "                String name = tok.nextToken();\n", "                char uni = (char) Integer.parseInt(tok.nextToken(), 16);\n", "                int uniName = AdobeGlyphList.nameToUnicode(name);\n", "                int orderK;\n", "                if (order.startsWith(\"'\")) {\n", "                    orderK = order.charAt(1);\n", "                } else {\n", "                    orderK = Integer.parseInt(order);\n", "                }\n", "                orderK %= 256;\n", "                unicodeToCode.put(uni, orderK);\n", "                codeToUnicode[orderK] = (int) uni;\n", "                differences[orderK] = name;\n", "                unicodeDifferences.put(uni, uniName);\n", "            }\n", "        } else {\n", "            int k = 0;\n", "            if (tok.hasMoreTokens()) {\n", "                k = Integer.parseInt(tok.nextToken());\n", "            }\n", "            while (tok.hasMoreTokens() && k < 256) {\n", "                String hex = tok.nextToken();\n", "                int uni = Integer.parseInt(hex, 16) % 0x10000;\n", "                String name = AdobeGlyphList.unicodeToName(uni);\n", "                if (name == null) {\n", "                    name = \"uni\" + hex;\n", "                }\n", "                unicodeToCode.put(uni, k);\n", "                codeToUnicode[k] = uni;\n", "                differences[k] = name;\n", "                unicodeDifferences.put(uni, uni);\n", "                k++;\n", "            }\n", "        }\n", "        for (int k = 0; k < 256; k++) {\n", "            if (differences[k] == null) {\n", "                differences[k] = NOTDEF;\n", "            }\n", "        }\n", "    }\n", "\n", "    protected void fillNamedEncoding() {\n", "        // check if the encoding exists\n", "        PdfEncodings.convertToBytes(\" \", baseEncoding);\n", "        boolean stdEncoding = PdfEncodings.WINANSI.equals(baseEncoding) || PdfEncodings.MACROMAN.equals(baseEncoding);\n", "        if (!stdEncoding && differences == null) {\n", "            differences = new String[256];\n", "        }\n", "\n", "        byte[] b = new byte[256];\n", "        for (int k = 0; k < 256; ++k) {\n", "            b[k] = (byte) k;\n", "        }\n", "        String str = PdfEncodings.convertToString(b, baseEncoding);\n", "        char[] encoded = str.toCharArray();\n", "        for (int ch = 0; ch < 256; ++ch) {\n", "            char uni = encoded[ch];\n", "            String name = AdobeGlyphList.unicodeToName(uni);\n", "            if (name == null) {\n", "                name = NOTDEF;\n", "            } else {\n", "                unicodeToCode.put(uni, ch);\n", "                codeToUnicode[ch] = (int) uni;\n", "                unicodeDifferences.put(uni, uni);\n", "            }\n", "            if (differences != null) {\n", "                differences[ch] = name;\n", "            }\n", "        }\n", "    }\n", "\n", "    protected void fillStandardEncoding() {\n", "        int[] encoded = PdfEncodings.standardEncoding;\n", "        for (int ch = 0; ch < 256; ++ch) {\n", "            int uni = encoded[ch];\n", "            String name = AdobeGlyphList.unicodeToName(uni);\n", "            if (name == null) {\n", "                name = NOTDEF;\n", "            } else {\n", "                unicodeToCode.put(uni, ch);\n", "                codeToUnicode[ch] = uni;\n", "                unicodeDifferences.put(uni, uni);\n", "            }\n", "            if (differences != null) {\n", "                differences[ch] = name;\n", "            }\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Normalize the encoding names. \"winansi\" is changed to \"Cp1252\" and\n", "     * \"macroman\" is changed to \"MacRoman\".\n", "     *\n", "     * @param enc the encoding to be normalized\n", "     * @return the normalized encoding\n", "     */\n", "    protected static String normalizeEncoding(String enc) {\n", "        String tmp = enc == null ? \"\" : enc.toLowerCase();\n", "        switch (tmp) {\n", "            case \"\":\n", "            case \"winansi\":\n", "            case \"winansiencoding\":\n", "                return PdfEncodings.WINANSI;\n", "            case \"macroman\":\n", "            case \"macromanencoding\":\n", "                return PdfEncodings.MACROMAN;\n", "            case \"zapfdingbatsencoding\":\n", "                return PdfEncodings.ZAPFDINGBATS;\n", "            default:\n", "                return enc;\n", "        }\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class FontEncodingTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void notSetDifferenceToMinus1IndexTest() {\n", "        FontEncoding encoding = FontEncoding.createEmptyFontEncoding();\n", "\n", "        String[] initialDifferences = (String[]) encoding.differences.clone();\n", "        encoding.setDifference(-1, \"a\");\n", "\n", "        Assert.assertArrayEquals(initialDifferences, encoding.differences);\n", "    }\n", "\n", "    @Test\n", "    public void notSetDifferenceTo256IndexTest() {\n", "        FontEncoding encoding = FontEncoding.createEmptyFontEncoding();\n", "\n", "        String[] initialDifferences = (String[]) encoding.differences.clone();\n", "        encoding.setDifference(256, \"a\");\n", "\n", "        Assert.assertArrayEquals(initialDifferences, encoding.differences);\n", "    }\n", "\n", "    @Test\n", "    public void setDifferenceToZeroIndexTest() {\n", "        FontEncoding encoding = FontEncoding.createEmptyFontEncoding();\n", "\n", "        encoding.setDifference(0, \"a\");\n", "\n", "        Assert.assertEquals(\"a\", encoding.differences[0]);\n", "    }\n", "\n", "    @Test\n", "    public void setDifferenceTo255IndexTest() {\n", "        FontEncoding encoding = FontEncoding.createEmptyFontEncoding();\n", "\n", "        encoding.setDifference(255, \"a\");\n", "\n", "        Assert.assertEquals(\"a\", encoding.differences[255]);\n", "    }\n", "\n", "    @Test\n", "    public void getNullDifferenceTest() {\n", "        FontEncoding encoding = FontEncoding.createEmptyFontEncoding();\n", "\n", "        Assert.assertNull(encoding.getDifference(0));\n", "    }\n", "\n", "    @Test\n", "    public void setDifferenceAndGetTest() {\n", "        FontEncoding encoding = FontEncoding.createEmptyFontEncoding();\n", "\n", "        encoding.setDifference(0, \"a\");\n", "\n", "        Assert.assertEquals(\"a\", encoding.getDifference(0));\n", "    }\n", "\n", "    @Test\n", "    public void fontSpecificEncodingTest() {\n", "        FontEncoding encoding = FontEncoding.createFontSpecificEncoding();\n", "        Assert.assertTrue(encoding.isFontSpecific());\n", "    }\n", "}\n"], "method_lines_dic": {"FontEncoding::::createFontEncoding(java.lang.String)": [76, 85], "FontEncoding::::createEmptyFontEncoding()": [87, 96], "FontEncoding::::createFontSpecificEncoding()": [103, 109], "FontEncoding::::fillFontEncoding(com.itextpdf.io.font.FontEncoding)": [116, 122], "FontEncoding::::getBaseEncoding()": [124, 126], "FontEncoding::::isFontSpecific()": [128, 130], "FontEncoding::::addSymbol(int,int)": [132, 146], "FontEncoding::::getUnicode(int)": [154, 156], "FontEncoding::::getUnicodeDifference(int)": [158, 160], "FontEncoding::::hasDifferences()": [162, 164], "FontEncoding::::getDifference(int)": [166, 168], "FontEncoding::::setDifference(int,java.lang.String)": [177, 181], "FontEncoding::::convertToBytes(java.lang.String)": [190, 202], "FontEncoding::::convertToByte(int)": [211, 213], "FontEncoding::::canEncode(int)": [222, 224], "FontEncoding::::canDecode(int)": [233, 235], "FontEncoding::::isBuiltWith(java.lang.String)": [243, 245], "FontEncoding::::fillCustomEncoding()": [247, 292], "FontEncoding::::fillNamedEncoding()": [294, 322], "FontEncoding::::fillStandardEncoding()": [324, 340], "FontEncoding::::normalizeEncoding(java.lang.String)": [349, 364]}, "test_method_lines_dic": {"FontEncodingTest::::notSetDifferenceToMinus1IndexTest()": [35, 43], "FontEncodingTest::::notSetDifferenceTo256IndexTest()": [45, 53], "FontEncodingTest::::setDifferenceToZeroIndexTest()": [55, 62], "FontEncodingTest::::setDifferenceTo255IndexTest()": [64, 71], "FontEncodingTest::::getNullDifferenceTest()": [73, 78], "FontEncodingTest::::setDifferenceAndGetTest()": [80, 87], "FontEncodingTest::::fontSpecificEncodingTest()": [89, 93]}, "reverse_method_lines_dic": {"76": "FontEncoding::::createFontEncoding(java.lang.String)", "77": "FontEncoding::::createFontEncoding(java.lang.String)", "78": "FontEncoding::::createFontEncoding(java.lang.String)", "79": "FontEncoding::::createFontEncoding(java.lang.String)", "80": "FontEncoding::::createFontEncoding(java.lang.String)", "81": "FontEncoding::::createFontEncoding(java.lang.String)", "82": "FontEncoding::::createFontEncoding(java.lang.String)", "83": "FontEncoding::::createFontEncoding(java.lang.String)", "84": "FontEncoding::::createFontEncoding(java.lang.String)", "85": "FontEncoding::::createFontEncoding(java.lang.String)", "87": "FontEncoding::::createEmptyFontEncoding()", "88": "FontEncoding::::createEmptyFontEncoding()", "89": "FontEncoding::::createEmptyFontEncoding()", "90": "FontEncoding::::createEmptyFontEncoding()", "91": "FontEncoding::::createEmptyFontEncoding()", "92": "FontEncoding::::createEmptyFontEncoding()", "93": "FontEncoding::::createEmptyFontEncoding()", "94": "FontEncoding::::createEmptyFontEncoding()", "95": "FontEncoding::::createEmptyFontEncoding()", "96": "FontEncoding::::createEmptyFontEncoding()", "103": "FontEncoding::::createFontSpecificEncoding()", "104": "FontEncoding::::createFontSpecificEncoding()", "105": "FontEncoding::::createFontSpecificEncoding()", "106": "FontEncoding::::createFontSpecificEncoding()", "107": "FontEncoding::::createFontSpecificEncoding()", "108": "FontEncoding::::createFontSpecificEncoding()", "109": "FontEncoding::::createFontSpecificEncoding()", "116": "FontEncoding::::fillFontEncoding(com.itextpdf.io.font.FontEncoding)", "117": "FontEncoding::::fillFontEncoding(com.itextpdf.io.font.FontEncoding)", "118": "FontEncoding::::fillFontEncoding(com.itextpdf.io.font.FontEncoding)", "119": "FontEncoding::::fillFontEncoding(com.itextpdf.io.font.FontEncoding)", "120": "FontEncoding::::fillFontEncoding(com.itextpdf.io.font.FontEncoding)", "121": "FontEncoding::::fillFontEncoding(com.itextpdf.io.font.FontEncoding)", "122": "FontEncoding::::fillFontEncoding(com.itextpdf.io.font.FontEncoding)", "124": "FontEncoding::::getBaseEncoding()", "125": "FontEncoding::::getBaseEncoding()", "126": "FontEncoding::::getBaseEncoding()", "128": "FontEncoding::::isFontSpecific()", "129": "FontEncoding::::isFontSpecific()", "130": "FontEncoding::::isFontSpecific()", "132": "FontEncoding::::addSymbol(int,int)", "133": "FontEncoding::::addSymbol(int,int)", "134": "FontEncoding::::addSymbol(int,int)", "135": "FontEncoding::::addSymbol(int,int)", "136": "FontEncoding::::addSymbol(int,int)", "137": "FontEncoding::::addSymbol(int,int)", "138": "FontEncoding::::addSymbol(int,int)", "139": "FontEncoding::::addSymbol(int,int)", "140": "FontEncoding::::addSymbol(int,int)", "141": "FontEncoding::::addSymbol(int,int)", "142": "FontEncoding::::addSymbol(int,int)", "143": "FontEncoding::::addSymbol(int,int)", "144": "FontEncoding::::addSymbol(int,int)", "145": "FontEncoding::::addSymbol(int,int)", "146": "FontEncoding::::addSymbol(int,int)", "154": "FontEncoding::::getUnicode(int)", "155": "FontEncoding::::getUnicode(int)", "156": "FontEncoding::::getUnicode(int)", "158": "FontEncoding::::getUnicodeDifference(int)", "159": "FontEncoding::::getUnicodeDifference(int)", "160": "FontEncoding::::getUnicodeDifference(int)", "162": "FontEncoding::::hasDifferences()", "163": "FontEncoding::::hasDifferences()", "164": "FontEncoding::::hasDifferences()", "166": "FontEncoding::::getDifference(int)", "167": "FontEncoding::::getDifference(int)", "168": "FontEncoding::::getDifference(int)", "177": "FontEncoding::::setDifference(int,java.lang.String)", "178": "FontEncoding::::setDifference(int,java.lang.String)", "179": "FontEncoding::::setDifference(int,java.lang.String)", "180": "FontEncoding::::setDifference(int,java.lang.String)", "181": "FontEncoding::::setDifference(int,java.lang.String)", "190": "FontEncoding::::convertToBytes(java.lang.String)", "191": "FontEncoding::::convertToBytes(java.lang.String)", "192": "FontEncoding::::convertToBytes(java.lang.String)", "193": "FontEncoding::::convertToBytes(java.lang.String)", "194": "FontEncoding::::convertToBytes(java.lang.String)", "195": "FontEncoding::::convertToBytes(java.lang.String)", "196": "FontEncoding::::convertToBytes(java.lang.String)", "197": "FontEncoding::::convertToBytes(java.lang.String)", "198": "FontEncoding::::convertToBytes(java.lang.String)", "199": "FontEncoding::::convertToBytes(java.lang.String)", "200": "FontEncoding::::convertToBytes(java.lang.String)", "201": "FontEncoding::::convertToBytes(java.lang.String)", "202": "FontEncoding::::convertToBytes(java.lang.String)", "211": "FontEncoding::::convertToByte(int)", "212": "FontEncoding::::convertToByte(int)", "213": "FontEncoding::::convertToByte(int)", "222": "FontEncoding::::canEncode(int)", "223": "FontEncoding::::canEncode(int)", "224": "FontEncoding::::canEncode(int)", "233": "FontEncoding::::canDecode(int)", "234": "FontEncoding::::canDecode(int)", "235": "FontEncoding::::canDecode(int)", "243": "FontEncoding::::isBuiltWith(java.lang.String)", "244": "FontEncoding::::isBuiltWith(java.lang.String)", "245": "FontEncoding::::isBuiltWith(java.lang.String)", "247": "FontEncoding::::fillCustomEncoding()", "248": "FontEncoding::::fillCustomEncoding()", "249": "FontEncoding::::fillCustomEncoding()", "250": "FontEncoding::::fillCustomEncoding()", "251": "FontEncoding::::fillCustomEncoding()", "252": "FontEncoding::::fillCustomEncoding()", "253": "FontEncoding::::fillCustomEncoding()", "254": "FontEncoding::::fillCustomEncoding()", "255": "FontEncoding::::fillCustomEncoding()", "256": "FontEncoding::::fillCustomEncoding()", "257": "FontEncoding::::fillCustomEncoding()", "258": "FontEncoding::::fillCustomEncoding()", "259": "FontEncoding::::fillCustomEncoding()", "260": "FontEncoding::::fillCustomEncoding()", "261": "FontEncoding::::fillCustomEncoding()", "262": "FontEncoding::::fillCustomEncoding()", "263": "FontEncoding::::fillCustomEncoding()", "264": "FontEncoding::::fillCustomEncoding()", "265": "FontEncoding::::fillCustomEncoding()", "266": "FontEncoding::::fillCustomEncoding()", "267": "FontEncoding::::fillCustomEncoding()", "268": "FontEncoding::::fillCustomEncoding()", "269": "FontEncoding::::fillCustomEncoding()", "270": "FontEncoding::::fillCustomEncoding()", "271": "FontEncoding::::fillCustomEncoding()", "272": "FontEncoding::::fillCustomEncoding()", "273": "FontEncoding::::fillCustomEncoding()", "274": "FontEncoding::::fillCustomEncoding()", "275": "FontEncoding::::fillCustomEncoding()", "276": "FontEncoding::::fillCustomEncoding()", "277": "FontEncoding::::fillCustomEncoding()", "278": "FontEncoding::::fillCustomEncoding()", "279": "FontEncoding::::fillCustomEncoding()", "280": "FontEncoding::::fillCustomEncoding()", "281": "FontEncoding::::fillCustomEncoding()", "282": "FontEncoding::::fillCustomEncoding()", "283": "FontEncoding::::fillCustomEncoding()", "284": "FontEncoding::::fillCustomEncoding()", "285": "FontEncoding::::fillCustomEncoding()", "286": "FontEncoding::::fillCustomEncoding()", "287": "FontEncoding::::fillCustomEncoding()", "288": "FontEncoding::::fillCustomEncoding()", "289": "FontEncoding::::fillCustomEncoding()", "290": "FontEncoding::::fillCustomEncoding()", "291": "FontEncoding::::fillCustomEncoding()", "292": "FontEncoding::::fillCustomEncoding()", "294": "FontEncoding::::fillNamedEncoding()", "295": "FontEncoding::::fillNamedEncoding()", "296": "FontEncoding::::fillNamedEncoding()", "297": "FontEncoding::::fillNamedEncoding()", "298": "FontEncoding::::fillNamedEncoding()", "299": "FontEncoding::::fillNamedEncoding()", "300": "FontEncoding::::fillNamedEncoding()", "301": "FontEncoding::::fillNamedEncoding()", "302": "FontEncoding::::fillNamedEncoding()", "303": "FontEncoding::::fillNamedEncoding()", "304": "FontEncoding::::fillNamedEncoding()", "305": "FontEncoding::::fillNamedEncoding()", "306": "FontEncoding::::fillNamedEncoding()", "307": "FontEncoding::::fillNamedEncoding()", "308": "FontEncoding::::fillNamedEncoding()", "309": "FontEncoding::::fillNamedEncoding()", "310": "FontEncoding::::fillNamedEncoding()", "311": "FontEncoding::::fillNamedEncoding()", "312": "FontEncoding::::fillNamedEncoding()", "313": "FontEncoding::::fillNamedEncoding()", "314": "FontEncoding::::fillNamedEncoding()", "315": "FontEncoding::::fillNamedEncoding()", "316": "FontEncoding::::fillNamedEncoding()", "317": "FontEncoding::::fillNamedEncoding()", "318": "FontEncoding::::fillNamedEncoding()", "319": "FontEncoding::::fillNamedEncoding()", "320": "FontEncoding::::fillNamedEncoding()", "321": "FontEncoding::::fillNamedEncoding()", "322": "FontEncoding::::fillNamedEncoding()", "324": "FontEncoding::::fillStandardEncoding()", "325": "FontEncoding::::fillStandardEncoding()", "326": "FontEncoding::::fillStandardEncoding()", "327": "FontEncoding::::fillStandardEncoding()", "328": "FontEncoding::::fillStandardEncoding()", "329": "FontEncoding::::fillStandardEncoding()", "330": "FontEncoding::::fillStandardEncoding()", "331": "FontEncoding::::fillStandardEncoding()", "332": "FontEncoding::::fillStandardEncoding()", "333": "FontEncoding::::fillStandardEncoding()", "334": "FontEncoding::::fillStandardEncoding()", "335": "FontEncoding::::fillStandardEncoding()", "336": "FontEncoding::::fillStandardEncoding()", "337": "FontEncoding::::fillStandardEncoding()", "338": "FontEncoding::::fillStandardEncoding()", "339": "FontEncoding::::fillStandardEncoding()", "340": "FontEncoding::::fillStandardEncoding()", "349": "FontEncoding::::normalizeEncoding(java.lang.String)", "350": "FontEncoding::::normalizeEncoding(java.lang.String)", "351": "FontEncoding::::normalizeEncoding(java.lang.String)", "352": "FontEncoding::::normalizeEncoding(java.lang.String)", "353": "FontEncoding::::normalizeEncoding(java.lang.String)", "354": "FontEncoding::::normalizeEncoding(java.lang.String)", "355": "FontEncoding::::normalizeEncoding(java.lang.String)", "356": "FontEncoding::::normalizeEncoding(java.lang.String)", "357": "FontEncoding::::normalizeEncoding(java.lang.String)", "358": "FontEncoding::::normalizeEncoding(java.lang.String)", "359": "FontEncoding::::normalizeEncoding(java.lang.String)", "360": "FontEncoding::::normalizeEncoding(java.lang.String)", "361": "FontEncoding::::normalizeEncoding(java.lang.String)", "362": "FontEncoding::::normalizeEncoding(java.lang.String)", "363": "FontEncoding::::normalizeEncoding(java.lang.String)", "364": "FontEncoding::::normalizeEncoding(java.lang.String)"}, "test_reverse_method_lines_dic": {"35": "FontEncodingTest::::notSetDifferenceToMinus1IndexTest()", "36": "FontEncodingTest::::notSetDifferenceToMinus1IndexTest()", "37": "FontEncodingTest::::notSetDifferenceToMinus1IndexTest()", "38": "FontEncodingTest::::notSetDifferenceToMinus1IndexTest()", "39": "FontEncodingTest::::notSetDifferenceToMinus1IndexTest()", "40": "FontEncodingTest::::notSetDifferenceToMinus1IndexTest()", "41": "FontEncodingTest::::notSetDifferenceToMinus1IndexTest()", "42": "FontEncodingTest::::notSetDifferenceToMinus1IndexTest()", "43": "FontEncodingTest::::notSetDifferenceToMinus1IndexTest()", "45": "FontEncodingTest::::notSetDifferenceTo256IndexTest()", "46": "FontEncodingTest::::notSetDifferenceTo256IndexTest()", "47": "FontEncodingTest::::notSetDifferenceTo256IndexTest()", "48": "FontEncodingTest::::notSetDifferenceTo256IndexTest()", "49": "FontEncodingTest::::notSetDifferenceTo256IndexTest()", "50": "FontEncodingTest::::notSetDifferenceTo256IndexTest()", "51": "FontEncodingTest::::notSetDifferenceTo256IndexTest()", "52": "FontEncodingTest::::notSetDifferenceTo256IndexTest()", "53": "FontEncodingTest::::notSetDifferenceTo256IndexTest()", "55": "FontEncodingTest::::setDifferenceToZeroIndexTest()", "56": "FontEncodingTest::::setDifferenceToZeroIndexTest()", "57": "FontEncodingTest::::setDifferenceToZeroIndexTest()", "58": "FontEncodingTest::::setDifferenceToZeroIndexTest()", "59": "FontEncodingTest::::setDifferenceToZeroIndexTest()", "60": "FontEncodingTest::::setDifferenceToZeroIndexTest()", "61": "FontEncodingTest::::setDifferenceToZeroIndexTest()", "62": "FontEncodingTest::::setDifferenceToZeroIndexTest()", "64": "FontEncodingTest::::setDifferenceTo255IndexTest()", "65": "FontEncodingTest::::setDifferenceTo255IndexTest()", "66": "FontEncodingTest::::setDifferenceTo255IndexTest()", "67": "FontEncodingTest::::setDifferenceTo255IndexTest()", "68": "FontEncodingTest::::setDifferenceTo255IndexTest()", "69": "FontEncodingTest::::setDifferenceTo255IndexTest()", "70": "FontEncodingTest::::setDifferenceTo255IndexTest()", "71": "FontEncodingTest::::setDifferenceTo255IndexTest()", "73": "FontEncodingTest::::getNullDifferenceTest()", "74": "FontEncodingTest::::getNullDifferenceTest()", "75": "FontEncodingTest::::getNullDifferenceTest()", "76": "FontEncodingTest::::getNullDifferenceTest()", "77": "FontEncodingTest::::getNullDifferenceTest()", "78": "FontEncodingTest::::getNullDifferenceTest()", "80": "FontEncodingTest::::setDifferenceAndGetTest()", "81": "FontEncodingTest::::setDifferenceAndGetTest()", "82": "FontEncodingTest::::setDifferenceAndGetTest()", "83": "FontEncodingTest::::setDifferenceAndGetTest()", "84": "FontEncodingTest::::setDifferenceAndGetTest()", "85": "FontEncodingTest::::setDifferenceAndGetTest()", "86": "FontEncodingTest::::setDifferenceAndGetTest()", "87": "FontEncodingTest::::setDifferenceAndGetTest()", "89": "FontEncodingTest::::fontSpecificEncodingTest()", "90": "FontEncodingTest::::fontSpecificEncodingTest()", "91": "FontEncodingTest::::fontSpecificEncodingTest()", "92": "FontEncodingTest::::fontSpecificEncodingTest()", "93": "FontEncodingTest::::fontSpecificEncodingTest()"}, "tests": [{"test_lines": [35, 43], "covered_lines": [35, 69, 70, 71, 72, 73, 74, 88, 89, 90, 91, 92, 93, 95, 178, 181]}, {"test_lines": [45, 53], "covered_lines": [35, 69, 70, 71, 72, 73, 74, 88, 89, 90, 91, 92, 93, 95, 178, 181]}, {"test_lines": [55, 62], "covered_lines": [35, 69, 70, 71, 72, 73, 74, 88, 89, 90, 91, 92, 93, 95, 178, 179, 181]}, {"test_lines": [64, 71], "covered_lines": [35, 69, 70, 71, 72, 73, 74, 88, 89, 90, 91, 92, 93, 95, 178, 179, 181]}, {"test_lines": [73, 78], "covered_lines": [35, 69, 70, 71, 72, 73, 74, 88, 89, 90, 91, 92, 93, 95, 167]}, {"test_lines": [80, 87], "covered_lines": [35, 69, 70, 71, 72, 73, 74, 88, 89, 90, 91, 92, 93, 95, 167, 178, 179, 181]}, {"test_lines": [89, 93], "covered_lines": [35, 69, 70, 71, 72, 73, 74, 104, 105, 106, 108, 117, 118, 119, 120, 122, 129]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/GposLookupType7.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.logs.IoLogMessageConstant;\n", "import com.itextpdf.io.font.otf.lookuptype7.PosTableLookup7Format2;\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "\n", "import java.util.ArrayList;\n", "import java.util.HashSet;\n", "import java.util.List;\n", "import java.util.Set;\n", "import org.slf4j.Logger;\n", "import org.slf4j.LoggerFactory;\n", "\n", "/**\n", " * Lookup Type 7:\n", " * Contextual Positioning Subtables\n", " */\n", "public class GposLookupType7 extends OpenTableLookup {\n", "\n", "    private static final Logger LOGGER = LoggerFactory.getLogger(GposLookupType7.class);\n", "\n", "    protected List<ContextualTable<ContextualPositionRule>> subTables;\n", "\n", "    public GposLookupType7(OpenTypeFontTableReader openReader, int lookupFlag, int[] subTableLocations)\n", "            throws java.io.IOException {\n", "        super(openReader, lookupFlag, subTableLocations);\n", "        subTables = new ArrayList<>();\n", "        readSubTables();\n", "    }\n", "\n", "    @Override\n", "    public boolean transformOne(GlyphLine line) {\n", "        boolean changed = false;\n", "        int oldLineStart = line.start;\n", "        int oldLineEnd = line.end;\n", "        int initialLineIndex = line.idx;\n", "\n", "        for (ContextualTable<ContextualPositionRule> subTable : subTables) {\n", "            ContextualPositionRule contextRule = subTable.getMatchingContextRule(line);\n", "            if (contextRule == null) {\n", "                continue;\n", "            }\n", "\n", "            int lineEndBeforeTransformations = line.end;\n", "            PosLookupRecord[] posLookupRecords = contextRule.getPosLookupRecords();\n", "            GlyphIndexer gidx = new GlyphIndexer();\n", "            gidx.line = line;\n", "            for (PosLookupRecord posRecord : posLookupRecords) {\n", "                // There could be some skipped glyphs inside the context sequence, therefore currently GlyphIndexer and\n", "                // nextGlyph method are used to get to the glyph at \"substRecord.sequenceIndex\" index\n", "                gidx.idx = initialLineIndex;\n", "                for (int i = 0; i < posRecord.sequenceIndex; ++i) {\n", "                    gidx.nextGlyph(openReader, lookupFlag);\n", "                }\n", "\n", "                line.idx = gidx.idx;\n", "                OpenTableLookup lookupTable = openReader.getLookupTable(posRecord.lookupListIndex);\n", "                changed = lookupTable.transformOne(line) || changed;\n", "            }\n", "\n", "            line.idx = line.end;\n", "            line.start = oldLineStart;\n", "            int lenDelta = lineEndBeforeTransformations - line.end;\n", "            line.end = oldLineEnd - lenDelta;\n", "            return changed;\n", "        }\n", "\n", "        line.idx++;\n", "        return changed;\n", "    }\n", "\n", "    @Override\n", "    protected void readSubTable(int subTableLocation) throws java.io.IOException {\n", "        openReader.rf.seek(subTableLocation);\n", "        int substFormat = openReader.rf.readShort();\n", "        switch (substFormat) {\n", "            case 2:\n", "                readSubTableFormat2(subTableLocation);\n", "                break;\n", "            case 1:\n", "            case 3:\n", "                LOGGER.warn(MessageFormatUtil.format(IoLogMessageConstant.GPOS_LOOKUP_SUBTABLE_FORMAT_NOT_SUPPORTED,\n", "                        substFormat, 7));\n", "                break;\n", "            default:\n", "                throw new IllegalArgumentException(\"Bad subtable format identifier: \" + substFormat);\n", "        }\n", "    }\n", "\n", "    protected void readSubTableFormat2(int subTableLocation) throws java.io.IOException {\n", "        int coverageOffset = openReader.rf.readUnsignedShort();\n", "        int classDefOffset = openReader.rf.readUnsignedShort();\n", "        int posClassSetCount = openReader.rf.readUnsignedShort();\n", "        int[] posClassSetOffsets = openReader.readUShortArray(posClassSetCount, subTableLocation);\n", "\n", "        Set<Integer> coverageGlyphIds = new HashSet<>(openReader.readCoverageFormat(subTableLocation + coverageOffset));\n", "        OtfClass classDefinition = openReader.readClassDefinition(subTableLocation + classDefOffset);\n", "\n", "        PosTableLookup7Format2 t = new PosTableLookup7Format2(openReader, lookupFlag,\n", "                coverageGlyphIds, classDefinition);\n", "\n", "        List<List<ContextualPositionRule>> subClassSets = new ArrayList<>(posClassSetCount);\n", "        for (int i = 0; i < posClassSetCount; ++i) {\n", "            List<ContextualPositionRule> subClassSet = null;\n", "            if (posClassSetOffsets[i] != 0) {\n", "                openReader.rf.seek(posClassSetOffsets[i]);\n", "                int posClassRuleCount = openReader.rf.readUnsignedShort();\n", "                int[] posClassRuleOffsets = openReader.readUShortArray(posClassRuleCount, posClassSetOffsets[i]);\n", "\n", "                subClassSet = new ArrayList<>(posClassRuleCount);\n", "                for (int j = 0; j < posClassRuleCount; ++j) {\n", "                    ContextualPositionRule rule;\n", "                    openReader.rf.seek(posClassRuleOffsets[j]);\n", "\n", "                    int glyphCount = openReader.rf.readUnsignedShort();\n", "                    int posCount = openReader.rf.readUnsignedShort();\n", "                    int[] inputClassIds = openReader.readUShortArray(glyphCount - 1);\n", "                    PosLookupRecord[] posLookupRecords = openReader.readPosLookupRecords(posCount);\n", "\n", "                    rule = new PosTableLookup7Format2.PosRuleFormat2(t, inputClassIds, posLookupRecords);\n", "                    subClassSet.add(rule);\n", "                }\n", "            }\n", "            subClassSets.add(subClassSet);\n", "        }\n", "\n", "        t.setPosClassSets(subClassSets);\n", "        subTables.add(t);\n", "    }\n", "\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgramFactory;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.io.IOException;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "public class GposLookupType7Test extends ExtendedITextTest {\n", "    private static final String RESOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/otf/GposLookupType7Test/\";\n", "\n", "    @Test\n", "    public void verifyXAdvanceIsAppliedForContextualPositioning() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"NotoSansMyanmar-Regular.ttf\");\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "        GposLookupType7 lookup = (GposLookupType7) gposTableReader.getLookupTable(28);\n", "        List<Glyph> glyphs = Arrays.asList(fontProgram.getGlyphByCode(25),\n", "                fontProgram.getGlyphByCode(174), fontProgram.getGlyphByCode(5), fontProgram.getGlyphByCode(411));\n", "\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "\n", "        Assert.assertEquals(0, gl.get(1).getXAdvance());\n", "        Assert.assertTrue(lookup.transformLine(gl));\n", "        Assert.assertEquals(219, gl.get(1).getXAdvance());\n", "    }\n", "\n", "    @Test\n", "    public void verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"NotoSansMyanmar-Regular.ttf\");\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "        GposLookupType7 lookup = (GposLookupType7) gposTableReader.getLookupTable(28);\n", "        List<Glyph> glyphs = Arrays.asList(fontProgram.getGlyphByCode(1),\n", "                fontProgram.getGlyphByCode(174), fontProgram.getGlyphByCode(5), fontProgram.getGlyphByCode(411));\n", "\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "\n", "        Assert.assertFalse(lookup.transformLine(gl));\n", "        for (int i = 0; i < gl.size(); i++) {\n", "            Assert.assertEquals(0, gl.get(i).getXAdvance());\n", "            Assert.assertEquals(0, gl.get(i).getYAdvance());\n", "        }\n", "    }\n", "\n", "}\n"], "method_lines_dic": {"GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)": [53, 92], "GposLookupType7::::readSubTable(int)": [94, 110], "GposLookupType7::::readSubTableFormat2(int)": [112, 151]}, "test_method_lines_dic": {"GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()": [41, 54], "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()": [56, 71]}, "reverse_method_lines_dic": {"53": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "54": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "55": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "56": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "57": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "58": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "59": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "60": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "61": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "62": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "63": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "64": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "65": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "66": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "67": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "68": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "69": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "70": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "71": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "72": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "73": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "74": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "75": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "76": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "77": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "78": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "79": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "80": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "81": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "82": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "83": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "84": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "85": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "86": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "87": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "88": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "89": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "90": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "91": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "92": "GposLookupType7::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "94": "GposLookupType7::::readSubTable(int)", "95": "GposLookupType7::::readSubTable(int)", "96": "GposLookupType7::::readSubTable(int)", "97": "GposLookupType7::::readSubTable(int)", "98": "GposLookupType7::::readSubTable(int)", "99": "GposLookupType7::::readSubTable(int)", "100": "GposLookupType7::::readSubTable(int)", "101": "GposLookupType7::::readSubTable(int)", "102": "GposLookupType7::::readSubTable(int)", "103": "GposLookupType7::::readSubTable(int)", "104": "GposLookupType7::::readSubTable(int)", "105": "GposLookupType7::::readSubTable(int)", "106": "GposLookupType7::::readSubTable(int)", "107": "GposLookupType7::::readSubTable(int)", "108": "GposLookupType7::::readSubTable(int)", "109": "GposLookupType7::::readSubTable(int)", "110": "GposLookupType7::::readSubTable(int)", "112": "GposLookupType7::::readSubTableFormat2(int)", "113": "GposLookupType7::::readSubTableFormat2(int)", "114": "GposLookupType7::::readSubTableFormat2(int)", "115": "GposLookupType7::::readSubTableFormat2(int)", "116": "GposLookupType7::::readSubTableFormat2(int)", "117": "GposLookupType7::::readSubTableFormat2(int)", "118": "GposLookupType7::::readSubTableFormat2(int)", "119": "GposLookupType7::::readSubTableFormat2(int)", "120": "GposLookupType7::::readSubTableFormat2(int)", "121": "GposLookupType7::::readSubTableFormat2(int)", "122": "GposLookupType7::::readSubTableFormat2(int)", "123": "GposLookupType7::::readSubTableFormat2(int)", "124": "GposLookupType7::::readSubTableFormat2(int)", "125": "GposLookupType7::::readSubTableFormat2(int)", "126": "GposLookupType7::::readSubTableFormat2(int)", "127": "GposLookupType7::::readSubTableFormat2(int)", "128": "GposLookupType7::::readSubTableFormat2(int)", "129": "GposLookupType7::::readSubTableFormat2(int)", "130": "GposLookupType7::::readSubTableFormat2(int)", "131": "GposLookupType7::::readSubTableFormat2(int)", "132": "GposLookupType7::::readSubTableFormat2(int)", "133": "GposLookupType7::::readSubTableFormat2(int)", "134": "GposLookupType7::::readSubTableFormat2(int)", "135": "GposLookupType7::::readSubTableFormat2(int)", "136": "GposLookupType7::::readSubTableFormat2(int)", "137": "GposLookupType7::::readSubTableFormat2(int)", "138": "GposLookupType7::::readSubTableFormat2(int)", "139": "GposLookupType7::::readSubTableFormat2(int)", "140": "GposLookupType7::::readSubTableFormat2(int)", "141": "GposLookupType7::::readSubTableFormat2(int)", "142": "GposLookupType7::::readSubTableFormat2(int)", "143": "GposLookupType7::::readSubTableFormat2(int)", "144": "GposLookupType7::::readSubTableFormat2(int)", "145": "GposLookupType7::::readSubTableFormat2(int)", "146": "GposLookupType7::::readSubTableFormat2(int)", "147": "GposLookupType7::::readSubTableFormat2(int)", "148": "GposLookupType7::::readSubTableFormat2(int)", "149": "GposLookupType7::::readSubTableFormat2(int)", "150": "GposLookupType7::::readSubTableFormat2(int)", "151": "GposLookupType7::::readSubTableFormat2(int)"}, "test_reverse_method_lines_dic": {"41": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "42": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "43": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "44": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "45": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "46": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "47": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "48": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "49": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "50": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "51": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "52": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "53": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "54": "GposLookupType7Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "56": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "57": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "58": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "59": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "60": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "61": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "62": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "63": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "64": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "65": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "66": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "67": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "68": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "69": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "70": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "71": "GposLookupType7Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()"}, "tests": [{"test_lines": [41, 54], "covered_lines": [42, 48, 49, 50, 51, 55, 56, 57, 58, 60, 61, 62, 66, 67, 68, 69, 70, 73, 74, 75, 78, 79, 80, 83, 84, 85, 86, 87, 96, 97, 98, 100, 101, 110, 113, 114, 115, 116, 118, 119, 121, 124, 125, 126, 127, 128, 129, 130, 132, 133, 135, 137, 138, 139, 140, 142, 143, 146, 149, 150, 151]}, {"test_lines": [56, 71], "covered_lines": [42, 48, 49, 50, 51, 55, 56, 57, 58, 60, 61, 62, 63, 90, 91, 96, 97, 98, 100, 101, 110, 113, 114, 115, 116, 118, 119, 121, 124, 125, 126, 127, 128, 129, 130, 132, 133, 135, 137, 138, 139, 140, 142, 143, 146, 149, 150, 151]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/Glyph.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.util.TextUtil;\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "\n", "import java.util.Arrays;\n", "\n", "public class Glyph {\n", "    private static final char REPLACEMENT_CHARACTER = '\\ufffd';\n", "    private static final char[] REPLACEMENT_CHARACTERS = new char[] {REPLACEMENT_CHARACTER};\n", "    private static final String REPLACEMENT_CHARACTER_STRING = String.valueOf(REPLACEMENT_CHARACTER);\n", "\n", "    // The <i>code</i> or <i>id</i> by which this is represented in the Font File.\n", "    private final int code;\n", "    // The normalized width of this Glyph.\n", "    private final int width;\n", "    // The normalized bbox of this Glyph.\n", "    private int[] bbox = null;\n", "    // utf-32 representation of glyph if appears. Correct value is > -1\n", "    private int unicode;\n", "    // The Unicode text represented by this Glyph\n", "    private char[] chars;\n", "    // true, if this Glyph is Mark\n", "    private final boolean isMark;\n", "\n", "    // placement offset\n", "    short xPlacement = 0;\n", "    short yPlacement = 0;\n", "    // advance offset\n", "    short xAdvance = 0;\n", "    short yAdvance = 0;\n", "\n", "    // Index delta to base glyph. If after a glyph there are several anchored glyphs we should know we to find base glyph.\n", "    short anchorDelta = 0;\n", "\n", "    /**\n", "     * Construct a non-mark Glyph, retrieving characters from unicode.\n", "     *\n", "     * @param code code representation of the glyph in the font file\n", "     * @param width normalized width of the glyph\n", "     * @param unicode utf-32 representation of glyph if appears. Correct value is &gt; -1\n", "     */\n", "    public Glyph(int code, int width, int unicode) {\n", "        this(code, width, unicode, null, false);\n", "    }\n", "\n", "    /**\n", "     * Construct a non-mark Glyph, using the codepoint of the characters as unicode point.\n", "     *\n", "     * @param code code representation of the glyph in the font file\n", "     * @param width normalized width of the glyph\n", "     * @param chars The Unicode text represented by this Glyph.\n", "     */\n", "    public Glyph(int code, int width, char[] chars) {\n", "        this(code, width, codePoint(chars), chars, false);\n", "    }\n", "\n", "    /**\n", "     * Construct a non-mark Glyph, retrieving characters from unicode.\n", "     *\n", "     * @param code code representation of the glyph in the font file\n", "     * @param width normalized width of the glyph\n", "     * @param unicode utf-32 representation of glyph if appears. Correct value is &gt; -1\n", "     * @param bbox The normalized bounding box of this Glyph.\n", "     */\n", "    public Glyph(int code, int width, int unicode, int[] bbox) {\n", "        this(code, width, unicode, null, false);\n", "        this.bbox = bbox;\n", "    }\n", "\n", "    /**\n", "     * Construct a non-mark Glyph object with id -1 and characters retrieved from unicode.\n", "     *\n", "     * @param width normalized width of the glyph\n", "     * @param unicode utf-32 representation of glyph if appears. Correct value is &gt; -1\n", "     */\n", "    public Glyph(int width, int unicode) {\n", "        this(-1, width, unicode, getChars(unicode), false);\n", "    }\n", "\n", "    /**\n", "     * Construct a glyph object form the passed arguments.\n", "     *\n", "     * @param code code representation of the glyph in the font file\n", "     * @param width normalized width of the glyph\n", "     * @param unicode utf-32 representation of glyph if appears. Correct value is &gt; -1\n", "     * @param chars The Unicode text represented by this Glyph.\n", "     *              if null is passed, the unicode value is used to retrieve the chars.\n", "     * @param IsMark True if the glyph is a Mark\n", "     */\n", "    public Glyph(int code, int width, int unicode, char[] chars, boolean IsMark) {\n", "        this.code = code;\n", "        this.width = width;\n", "        this.unicode = unicode;\n", "        this.isMark = IsMark;\n", "        this.chars = chars != null ? chars : getChars(unicode);\n", "    }\n", "\n", "    /**\n", "     * Copy a Glyph.\n", "     *\n", "     * @param glyph Glyph to copy\n", "     */\n", "    public Glyph(Glyph glyph) {\n", "        this.code = glyph.code;\n", "        this.width = glyph.width;\n", "        this.chars = glyph.chars;\n", "        this.unicode = glyph.unicode;\n", "        this.isMark = glyph.isMark;\n", "        this.bbox = glyph.bbox;\n", "\n", "        this.xPlacement = glyph.xPlacement;\n", "        this.yPlacement = glyph.yPlacement;\n", "        this.xAdvance = glyph.xAdvance;\n", "        this.yAdvance = glyph.yAdvance;\n", "        this.anchorDelta = glyph.anchorDelta;\n", "    }\n", "\n", "    /**\n", "     * Copy a Glyph and assign new placement and advance offsets and a new index delta to base glyph\n", "     *\n", "     * @param glyph Glyph to copy\n", "     * @param xPlacement x - placement offset\n", "     * @param yPlacement y - placement offset\n", "     * @param xAdvance x - advance offset\n", "     * @param yAdvance y - advance offset\n", "     * @param anchorDelta Index delta to base glyph. If after a glyph there are several anchored glyphs we should know we to find base glyph.\n", "     */\n", "    public Glyph(Glyph glyph, int xPlacement, int yPlacement, int xAdvance, int yAdvance, int anchorDelta) {\n", "        this(glyph);\n", "        this.xPlacement = (short) xPlacement;\n", "        this.yPlacement = (short) yPlacement;\n", "        this.xAdvance = (short) xAdvance;\n", "        this.yAdvance = (short) yAdvance;\n", "        this.anchorDelta = (short) anchorDelta;\n", "    }\n", "\n", "    /**\n", "     * Copy a glyph and assign the copied glyph a new unicode point and characters\n", "     *\n", "     * @param glyph glyph to copy\n", "     * @param unicode new unicode point\n", "     */\n", "    public Glyph(Glyph glyph, int unicode) {\n", "        this(glyph.code, glyph.width, unicode, getChars(unicode), glyph.isMark());\n", "    }\n", "\n", "    public int getCode() {\n", "        return code;\n", "    }\n", "\n", "    public int getWidth() {\n", "        return width;\n", "    }\n", "\n", "    public int[] getBbox() {\n", "        return bbox;\n", "    }\n", "\n", "    public boolean hasValidUnicode() {\n", "        return unicode > -1;\n", "    }\n", "\n", "    public int getUnicode() {\n", "        return unicode;\n", "    }\n", "\n", "    public void setUnicode(int unicode) {\n", "        this.unicode = unicode;\n", "        this.chars = getChars(unicode);\n", "    }\n", "\n", "    public char[] getChars() {\n", "        return chars;\n", "    }\n", "\n", "    public void setChars(char[] chars) {\n", "        this.chars = chars;\n", "    }\n", "\n", "    public boolean isMark() {\n", "        return isMark;\n", "    }\n", "\n", "    public short getXPlacement() {\n", "        return xPlacement;\n", "    }\n", "\n", "    public void setXPlacement(short xPlacement) {\n", "        this.xPlacement = xPlacement;\n", "    }\n", "\n", "    public short getYPlacement() {\n", "        return yPlacement;\n", "    }\n", "\n", "    public void setYPlacement(short yPlacement) {\n", "        this.yPlacement = yPlacement;\n", "    }\n", "\n", "    public short getXAdvance() {\n", "        return xAdvance;\n", "    }\n", "\n", "    public void setXAdvance(short xAdvance) {\n", "        this.xAdvance = xAdvance;\n", "    }\n", "\n", "    public short getYAdvance() {\n", "        return yAdvance;\n", "    }\n", "\n", "    public void setYAdvance(short yAdvance) {\n", "        this.yAdvance = yAdvance;\n", "    }\n", "\n", "    public short getAnchorDelta() {\n", "        return anchorDelta;\n", "    }\n", "\n", "    public void setAnchorDelta(short anchorDelta) {\n", "        this.anchorDelta = anchorDelta;\n", "    }\n", "\n", "    public boolean hasOffsets() {\n", "        return hasAdvance() || hasPlacement();\n", "    }\n", "\n", "    // In case some of placement values are not zero we always expect anchorDelta to be non-zero\n", "    public boolean hasPlacement() {\n", "        return anchorDelta != 0;\n", "    }\n", "\n", "    public boolean hasAdvance() {\n", "        return xAdvance != 0 || yAdvance != 0;\n", "    }\n", "\n", "    public int hashCode() {\n", "        final int prime = 31;\n", "        int result = 1;\n", "        result = prime * result + ((chars == null) ? 0 : Arrays.hashCode(chars));\n", "        result = prime * result + code;\n", "        result = prime * result + width;\n", "        return result;\n", "    }\n", "\n", "    /**\n", "     * Two Glyphs are equal if their unicode characters, code and normalized width are equal.\n", "     *\n", "     * @param obj The object\n", "     * @return True if this equals obj cast to Glyph, false otherwise.\n", "     */\n", "    public boolean equals(Object obj) {\n", "        if (this == obj) {\n", "            return true;\n", "        }\n", "        if (obj == null || getClass() != obj.getClass()) {\n", "            return false;\n", "        }\n", "        Glyph other = (Glyph) obj;\n", "        return Arrays.equals(chars, other.chars) && code == other.code && width == other.width;\n", "    }\n", "\n", "    /**\n", "     * Gets a Unicode string corresponding to this glyph. In general case it might consist of many characters.\n", "     * If this glyph does not have a valid unicode ({@link #hasValidUnicode()}), then a string consisting of a special\n", "     * Unicode '\\ufffd' character is returned.\n", "     * @return the Unicode string that corresponds to this glyph\n", "     */\n", "    public String getUnicodeString() {\n", "        if (chars != null) {\n", "            return String.valueOf(chars);\n", "        } else {\n", "            return REPLACEMENT_CHARACTER_STRING;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Gets Unicode char sequence corresponding to this glyph. In general case it might consist of many characters.\n", "     * If this glyph does not have a valid unicode ({@link #hasValidUnicode()}), then a special\n", "     * Unicode '\\ufffd' character is returned.\n", "     * @return the Unicode char sequence that corresponds to this glyph\n", "     */\n", "    public char[] getUnicodeChars() {\n", "        if (chars != null && chars.length > 0) {\n", "            return chars;\n", "        } else {\n", "            return REPLACEMENT_CHARACTERS;\n", "        }\n", "    }\n", "\n", "    public String toString() {\n", "        return MessageFormatUtil.format(\"[id={0}, chars={1}, uni={2}, width={3}]\",\n", "                toHex(code), chars != null ? Arrays.toString(chars) : \"null\", toHex(unicode), width);\n", "    }\n", "\n", "    private static String toHex(int ch) {\n", "        String s = \"0000\" + Integer.toHexString(ch);\n", "        return s.substring(Math.min(4, s.length() - 4));\n", "    }\n", "\n", "    private static int codePoint(char[] a) {\n", "        if (a != null) {\n", "            if (a.length == 1 && Character.isValidCodePoint(a[0])) {\n", "                return a[0];\n", "            } else if (a.length == 2 && Character.isHighSurrogate(a[0]) && Character.isLowSurrogate(a[1])) {\n", "                return Character.toCodePoint(a[0], a[1]);\n", "            }\n", "        }\n", "        return -1;\n", "    }\n", "\n", "    private static char[] getChars(int unicode) {\n", "        return unicode > -1 ? TextUtil.convertFromUtf32(unicode) : null;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class GlyphTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void hasPlacementIfAnchorDeltaNonZeroTest() {\n", "        Glyph glyph = createDummyGlyph();\n", "\n", "        Assert.assertEquals(0, glyph.getXPlacement());\n", "        Assert.assertEquals(0, glyph.getYPlacement());\n", "        Assert.assertEquals(0, glyph.getAnchorDelta());\n", "        Assert.assertFalse(glyph.hasPlacement());\n", "\n", "        glyph.setAnchorDelta((short) 10);\n", "\n", "        Assert.assertTrue(glyph.hasPlacement());\n", "    }\n", "\n", "    @Test\n", "    public void hasOffsetsIfAnchorDeltaNonZeroTest() {\n", "        Glyph glyph = createDummyGlyph();\n", "\n", "        Assert.assertEquals(0, glyph.getXPlacement());\n", "        Assert.assertEquals(0, glyph.getYPlacement());\n", "        Assert.assertEquals(0, glyph.getAnchorDelta());\n", "        Assert.assertFalse(glyph.hasOffsets());\n", "\n", "        glyph.setAnchorDelta((short) 10);\n", "\n", "        Assert.assertTrue(glyph.hasOffsets());\n", "    }\n", "\n", "    private static Glyph createDummyGlyph() {\n", "        return new Glyph(0, 0, 0);\n", "    }\n", "}\n"], "method_lines_dic": {"Glyph::::getCode()": [170, 172], "Glyph::::getWidth()": [174, 176], "Glyph::::getBbox()": [178, 180], "Glyph::::hasValidUnicode()": [182, 184], "Glyph::::getUnicode()": [186, 188], "Glyph::::setUnicode(int)": [190, 193], "Glyph::::getChars()": [195, 197], "Glyph::::setChars(char[])": [199, 201], "Glyph::::isMark()": [203, 205], "Glyph::::getXPlacement()": [207, 209], "Glyph::::setXPlacement(short)": [211, 213], "Glyph::::getYPlacement()": [215, 217], "Glyph::::setYPlacement(short)": [219, 221], "Glyph::::getXAdvance()": [223, 225], "Glyph::::setXAdvance(short)": [227, 229], "Glyph::::getYAdvance()": [231, 233], "Glyph::::setYAdvance(short)": [235, 237], "Glyph::::getAnchorDelta()": [239, 241], "Glyph::::setAnchorDelta(short)": [243, 245], "Glyph::::hasOffsets()": [247, 249], "Glyph::::hasPlacement()": [252, 254], "Glyph::::hasAdvance()": [256, 258], "Glyph::::hashCode()": [260, 267], "Glyph::::equals(java.lang.Object)": [275, 284], "Glyph::::getUnicodeString()": [292, 298], "Glyph::::getUnicodeChars()": [306, 312], "Glyph::::toString()": [314, 317], "Glyph::::toHex(int)": [319, 322], "Glyph::::codePoint(char[])": [324, 333], "Glyph::::getChars(int)": [335, 337]}, "test_method_lines_dic": {"GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()": [36, 48], "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()": [50, 62], "GlyphTest::::createDummyGlyph()": [64, 66]}, "reverse_method_lines_dic": {"170": "Glyph::::getCode()", "171": "Glyph::::getCode()", "172": "Glyph::::getCode()", "174": "Glyph::::getWidth()", "175": "Glyph::::getWidth()", "176": "Glyph::::getWidth()", "178": "Glyph::::getBbox()", "179": "Glyph::::getBbox()", "180": "Glyph::::getBbox()", "182": "Glyph::::hasValidUnicode()", "183": "Glyph::::hasValidUnicode()", "184": "Glyph::::hasValidUnicode()", "186": "Glyph::::getUnicode()", "187": "Glyph::::getUnicode()", "188": "Glyph::::getUnicode()", "190": "Glyph::::setUnicode(int)", "191": "Glyph::::setUnicode(int)", "192": "Glyph::::setUnicode(int)", "193": "Glyph::::setUnicode(int)", "195": "Glyph::::getChars()", "196": "Glyph::::getChars()", "197": "Glyph::::getChars()", "199": "Glyph::::setChars(char[])", "200": "Glyph::::setChars(char[])", "201": "Glyph::::setChars(char[])", "203": "Glyph::::isMark()", "204": "Glyph::::isMark()", "205": "Glyph::::isMark()", "207": "Glyph::::getXPlacement()", "208": "Glyph::::getXPlacement()", "209": "Glyph::::getXPlacement()", "211": "Glyph::::setXPlacement(short)", "212": "Glyph::::setXPlacement(short)", "213": "Glyph::::setXPlacement(short)", "215": "Glyph::::getYPlacement()", "216": "Glyph::::getYPlacement()", "217": "Glyph::::getYPlacement()", "219": "Glyph::::setYPlacement(short)", "220": "Glyph::::setYPlacement(short)", "221": "Glyph::::setYPlacement(short)", "223": "Glyph::::getXAdvance()", "224": "Glyph::::getXAdvance()", "225": "Glyph::::getXAdvance()", "227": "Glyph::::setXAdvance(short)", "228": "Glyph::::setXAdvance(short)", "229": "Glyph::::setXAdvance(short)", "231": "Glyph::::getYAdvance()", "232": "Glyph::::getYAdvance()", "233": "Glyph::::getYAdvance()", "235": "Glyph::::setYAdvance(short)", "236": "Glyph::::setYAdvance(short)", "237": "Glyph::::setYAdvance(short)", "239": "Glyph::::getAnchorDelta()", "240": "Glyph::::getAnchorDelta()", "241": "Glyph::::getAnchorDelta()", "243": "Glyph::::setAnchorDelta(short)", "244": "Glyph::::setAnchorDelta(short)", "245": "Glyph::::setAnchorDelta(short)", "247": "Glyph::::hasOffsets()", "248": "Glyph::::hasOffsets()", "249": "Glyph::::hasOffsets()", "252": "Glyph::::hasPlacement()", "253": "Glyph::::hasPlacement()", "254": "Glyph::::hasPlacement()", "256": "Glyph::::hasAdvance()", "257": "Glyph::::hasAdvance()", "258": "Glyph::::hasAdvance()", "260": "Glyph::::hashCode()", "261": "Glyph::::hashCode()", "262": "Glyph::::hashCode()", "263": "Glyph::::hashCode()", "264": "Glyph::::hashCode()", "265": "Glyph::::hashCode()", "266": "Glyph::::hashCode()", "267": "Glyph::::hashCode()", "275": "Glyph::::equals(java.lang.Object)", "276": "Glyph::::equals(java.lang.Object)", "277": "Glyph::::equals(java.lang.Object)", "278": "Glyph::::equals(java.lang.Object)", "279": "Glyph::::equals(java.lang.Object)", "280": "Glyph::::equals(java.lang.Object)", "281": "Glyph::::equals(java.lang.Object)", "282": "Glyph::::equals(java.lang.Object)", "283": "Glyph::::equals(java.lang.Object)", "284": "Glyph::::equals(java.lang.Object)", "292": "Glyph::::getUnicodeString()", "293": "Glyph::::getUnicodeString()", "294": "Glyph::::getUnicodeString()", "295": "Glyph::::getUnicodeString()", "296": "Glyph::::getUnicodeString()", "297": "Glyph::::getUnicodeString()", "298": "Glyph::::getUnicodeString()", "306": "Glyph::::getUnicodeChars()", "307": "Glyph::::getUnicodeChars()", "308": "Glyph::::getUnicodeChars()", "309": "Glyph::::getUnicodeChars()", "310": "Glyph::::getUnicodeChars()", "311": "Glyph::::getUnicodeChars()", "312": "Glyph::::getUnicodeChars()", "314": "Glyph::::toString()", "315": "Glyph::::toString()", "316": "Glyph::::toString()", "317": "Glyph::::toString()", "319": "Glyph::::toHex(int)", "320": "Glyph::::toHex(int)", "321": "Glyph::::toHex(int)", "322": "Glyph::::toHex(int)", "324": "Glyph::::codePoint(char[])", "325": "Glyph::::codePoint(char[])", "326": "Glyph::::codePoint(char[])", "327": "Glyph::::codePoint(char[])", "328": "Glyph::::codePoint(char[])", "329": "Glyph::::codePoint(char[])", "330": "Glyph::::codePoint(char[])", "331": "Glyph::::codePoint(char[])", "332": "Glyph::::codePoint(char[])", "333": "Glyph::::codePoint(char[])", "335": "Glyph::::getChars(int)", "336": "Glyph::::getChars(int)", "337": "Glyph::::getChars(int)"}, "test_reverse_method_lines_dic": {"36": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "37": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "38": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "39": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "40": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "41": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "42": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "43": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "44": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "45": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "46": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "47": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "48": "GlyphTest::::hasPlacementIfAnchorDeltaNonZeroTest()", "50": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "51": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "52": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "53": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "54": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "55": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "56": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "57": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "58": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "59": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "60": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "61": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "62": "GlyphTest::::hasOffsetsIfAnchorDeltaNonZeroTest()", "64": "GlyphTest::::createDummyGlyph()", "65": "GlyphTest::::createDummyGlyph()", "66": "GlyphTest::::createDummyGlyph()"}, "tests": [{"test_lines": [36, 48], "covered_lines": [32, 33, 40, 49, 50, 52, 53, 56, 66, 67, 113, 114, 115, 116, 117, 118, 119, 208, 216, 240, 244, 245, 253, 336]}, {"test_lines": [50, 62], "covered_lines": [32, 33, 40, 49, 50, 52, 53, 56, 66, 67, 113, 114, 115, 116, 117, 118, 119, 208, 216, 240, 244, 245, 248, 253, 257, 336]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/GposLookupType5.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import java.util.ArrayList;\n", "import java.util.HashMap;\n", "import java.util.List;\n", "import java.util.Map;\n", "\n", "/**\n", " * Lookup Type 5:\n", " * MarkToLigature Attachment Positioning Subtable\n", " */\n", "public class GposLookupType5 extends OpenTableLookup {\n", "\n", "    private final List<MarkToLigature> marksligatures;\n", "\n", "    public GposLookupType5(OpenTypeFontTableReader openReader, int lookupFlag, int[] subTableLocations) throws java.io.IOException {\n", "        super(openReader, lookupFlag, subTableLocations);\n", "        marksligatures = new ArrayList<>();\n", "        readSubTables();\n", "    }\n", "\n", "    @Override\n", "    public boolean transformOne(GlyphLine line) {\n", "        if (line.idx >= line.end)\n", "            return false;\n", "        if (openReader.isSkip(line.get(line.idx).getCode(), lookupFlag)) {\n", "            line.idx++;\n", "            return false;\n", "        }\n", "\n", "        boolean changed = false;\n", "        GlyphIndexer ligatureGlyphIndexer = null;\n", "        for (MarkToLigature mb : marksligatures) {\n", "            OtfMarkRecord omr = mb.marks.get(line.get(line.idx).getCode());\n", "            if (omr == null)\n", "                continue;\n", "            if (ligatureGlyphIndexer == null) {\n", "                ligatureGlyphIndexer = new GlyphIndexer();\n", "                ligatureGlyphIndexer.idx = line.idx;\n", "                ligatureGlyphIndexer.line = line;\n", "                while (true) {\n", "                    ligatureGlyphIndexer.previousGlyph(openReader, lookupFlag);\n", "                    if (ligatureGlyphIndexer.glyph == null) {\n", "                        break;\n", "                    }\n", "                    // not mark => ligature glyph\n", "                    if (!mb.marks.containsKey(ligatureGlyphIndexer.glyph.getCode())) {\n", "                        break;\n", "                    }\n", "                }\n", "                if (ligatureGlyphIndexer.glyph == null) {\n", "                    break;\n", "                }\n", "            }\n", "            List<GposAnchor[]> componentAnchors = mb.ligatures.get(ligatureGlyphIndexer.glyph.getCode());\n", "            if (componentAnchors == null) {\n", "                continue;\n", "            }\n", "            int markClass = omr.markClass;\n", "            // TODO DEVSIX-3732 For complex cases like (glyph1, glyph2, mark, glyph3) and\n", "            //  (glyph1, mark, glyph2, glyph3) when the base glyphs compose a ligature and the mark\n", "            //  is attached to the ligature afterwards, mark should be placed in the corresponding anchor\n", "            //  of that ligature (by finding the right component's anchor).\n", "            //  Excerpt from Microsoft Docs: \"For a given mark assigned to a particular class, the appropriate\n", "            //  base attachment point is determined by which ligature component the mark is associated with.\n", "            //  This is dependent on the original character string and subsequent character- or glyph-sequence\n", "            //  processing, not the font data alone. While a text-layout client is performing any character-based\n", "            //  preprocessing or any glyph-substitution operations using the GSUB table, the text-layout client\n", "            //  must keep track of the associations of marks to particular ligature-glyph components.\"\n", "            //  For now we do not store all the substitution info and therefore not able to follow that logic.\n", "            //  We place the mark symbol in the last available place for now (seems to be better default than\n", "            //  first available place).\n", "            for (int component = componentAnchors.size() - 1; component >= 0; component--) {\n", "                if (componentAnchors.get(component)[markClass] != null) {\n", "                    GposAnchor baseAnchor = componentAnchors.get(component)[markClass];\n", "                    GposAnchor markAnchor = omr.anchor;\n", "                    line.set(line.idx, new Glyph(line.get(line.idx),\n", "                            baseAnchor.XCoordinate - markAnchor.XCoordinate,\n", "                            baseAnchor.YCoordinate - markAnchor.YCoordinate,\n", "                            0, 0, ligatureGlyphIndexer.idx - line.idx));\n", "                    changed = true;\n", "                    break;\n", "                }\n", "            }\n", "\n", "            break;\n", "        }\n", "\n", "        line.idx++;\n", "        return changed;\n", "    }\n", "\n", "    @Override\n", "    protected void readSubTable(int subTableLocation) throws java.io.IOException {\n", "        openReader.rf.seek(subTableLocation);\n", "\n", "        // skip format, always 1\n", "        openReader.rf.readUnsignedShort();\n", "        int markCoverageLocation = openReader.rf.readUnsignedShort() + subTableLocation;\n", "        int ligatureCoverageLocation = openReader.rf.readUnsignedShort() + subTableLocation;\n", "        int classCount = openReader.rf.readUnsignedShort();\n", "        int markArrayLocation = openReader.rf.readUnsignedShort() + subTableLocation;\n", "        int ligatureArrayLocation = openReader.rf.readUnsignedShort() + subTableLocation;\n", "        List<Integer> markCoverage = openReader.readCoverageFormat(markCoverageLocation);\n", "        List<Integer> ligatureCoverage = openReader.readCoverageFormat(ligatureCoverageLocation);\n", "        List<OtfMarkRecord> markRecords = OtfReadCommon.readMarkArray(openReader, markArrayLocation);\n", "        MarkToLigature markToLigature = new MarkToLigature();\n", "        for (int k = 0; k < markCoverage.size(); ++k) {\n", "            markToLigature.marks.put(markCoverage.get(k), markRecords.get(k));\n", "        }\n", "        List<List<GposAnchor[]>> ligatureArray = OtfReadCommon.readLigatureArray(openReader, classCount, ligatureArrayLocation);\n", "        for (int k = 0; k < ligatureCoverage.size(); ++k) {\n", "            markToLigature.ligatures.put(ligatureCoverage.get(k), ligatureArray.get(k));\n", "        }\n", "        marksligatures.add(markToLigature);\n", "    }\n", "\n", "\n", "    public static class MarkToLigature {\n", "        public final Map<Integer, OtfMarkRecord> marks = new HashMap<>();\n", "        // Glyph id to list of components, each component has a separate list of attachment points\n", "        // defined for different mark classes\n", "        public final Map<Integer, List<GposAnchor[]>> ligatures = new HashMap<>();\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgramFactory;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.io.IOException;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "public class GposLookupType5Test extends ExtendedITextTest {\n", "\n", "    private static final String RESOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/otf/GposLookupType5Test/\";\n", "\n", "    @Test\n", "    public void verifyMarkToBaseAttachment() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont)FontProgramFactory.createFont(RESOURCE_FOLDER + \"KhmerOS.ttf\");\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "        GposLookupType5 lookup = (GposLookupType5) gposTableReader.getLookupTable(0);\n", "        List<Glyph> glyphs = Arrays.asList(new Glyph(fontProgram.getGlyphByCode(445)), new Glyph(fontProgram.getGlyphByCode(394)));\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "        gl.idx = 1;\n", "        lookup.transformOne(gl);\n", "\n", "        Assert.assertEquals(2, gl.size());\n", "        Assert.assertEquals(445, gl.get(0).getCode());\n", "        Assert.assertEquals(394, gl.get(1).getCode());\n", "        Assert.assertEquals(-1, gl.get(1).getAnchorDelta());\n", "        Assert.assertEquals(756, gl.get(1).getXPlacement());\n", "    }\n", "\n", "    @Test\n", "    // TODO on completion of DEVSIX-3732 this test will probably have to be refactored\n", "    //  since we will have to emulate previous substitutions and populate the substitution info\n", "    //  to the glyph line so that mark is attached to the correct component of a ligature\n", "    public void testSelectingCorrectAttachmentAlternative() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont)FontProgramFactory.createFont(RESOURCE_FOLDER + \"NotoNaskhArabic-Regular.ttf\");\n", "        GlyphLine glyphLine = new GlyphLine(Arrays.asList(fontProgram.getGlyphByCode(513), fontProgram.getGlyphByCode(75)));\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "        GposLookupType5 lookup = (GposLookupType5) gposTableReader.getLookupTable(3);\n", "\n", "        glyphLine.idx = 1;\n", "        lookup.transformOne(glyphLine);\n", "\n", "        Assert.assertEquals(2, glyphLine.size());\n", "        Assert.assertEquals(513, glyphLine.get(0).getCode());\n", "        Assert.assertEquals(75, glyphLine.get(1).getCode());\n", "        Assert.assertEquals(-1, glyphLine.get(1).getAnchorDelta());\n", "        Assert.assertEquals(-22, glyphLine.get(1).getXPlacement());\n", "    }\n", "\n", "    @Test\n", "    public void testThatNoTransformationsAppliedForNonRelevantGlyphs() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont)FontProgramFactory.createFont(RESOURCE_FOLDER + \"NotoNaskhArabic-Regular.ttf\");\n", "        GlyphLine glyphLine = new GlyphLine(Arrays.asList(fontProgram.getGlyph('1'), fontProgram.getGlyphByCode(75)));\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "        GposLookupType5 lookup = (GposLookupType5) gposTableReader.getLookupTable(3);\n", "\n", "        glyphLine.idx = 1;\n", "        lookup.transformOne(glyphLine);\n", "\n", "        Assert.assertEquals(2, glyphLine.size());\n", "        Assert.assertEquals(1490, glyphLine.get(0).getCode());\n", "        Assert.assertEquals(75, glyphLine.get(1).getCode());\n", "        Assert.assertEquals(0, glyphLine.get(1).getAnchorDelta());\n", "        Assert.assertEquals(0, glyphLine.get(1).getXPlacement());\n", "    }\n", "\n", "}\n"], "method_lines_dic": {"GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)": [44, 113], "GposLookupType5::::readSubTable(int)": [115, 138]}, "test_method_lines_dic": {"GposLookupType5Test::::verifyMarkToBaseAttachment()": [42, 57], "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()": [59, 77], "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()": [79, 94]}, "reverse_method_lines_dic": {"44": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "45": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "46": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "47": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "48": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "49": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "50": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "51": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "52": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "53": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "54": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "55": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "56": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "57": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "58": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "59": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "60": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "61": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "62": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "63": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "64": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "65": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "66": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "67": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "68": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "69": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "70": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "71": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "72": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "73": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "74": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "75": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "76": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "77": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "78": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "79": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "80": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "81": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "82": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "83": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "84": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "85": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "86": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "87": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "88": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "89": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "90": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "91": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "92": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "93": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "94": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "95": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "96": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "97": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "98": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "99": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "100": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "101": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "102": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "103": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "104": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "105": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "106": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "107": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "108": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "109": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "110": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "111": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "112": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "113": "GposLookupType5::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "115": "GposLookupType5::::readSubTable(int)", "116": "GposLookupType5::::readSubTable(int)", "117": "GposLookupType5::::readSubTable(int)", "118": "GposLookupType5::::readSubTable(int)", "119": "GposLookupType5::::readSubTable(int)", "120": "GposLookupType5::::readSubTable(int)", "121": "GposLookupType5::::readSubTable(int)", "122": "GposLookupType5::::readSubTable(int)", "123": "GposLookupType5::::readSubTable(int)", "124": "GposLookupType5::::readSubTable(int)", "125": "GposLookupType5::::readSubTable(int)", "126": "GposLookupType5::::readSubTable(int)", "127": "GposLookupType5::::readSubTable(int)", "128": "GposLookupType5::::readSubTable(int)", "129": "GposLookupType5::::readSubTable(int)", "130": "GposLookupType5::::readSubTable(int)", "131": "GposLookupType5::::readSubTable(int)", "132": "GposLookupType5::::readSubTable(int)", "133": "GposLookupType5::::readSubTable(int)", "134": "GposLookupType5::::readSubTable(int)", "135": "GposLookupType5::::readSubTable(int)", "136": "GposLookupType5::::readSubTable(int)", "137": "GposLookupType5::::readSubTable(int)", "138": "GposLookupType5::::readSubTable(int)"}, "test_reverse_method_lines_dic": {"42": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "43": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "44": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "45": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "46": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "47": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "48": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "49": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "50": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "51": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "52": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "53": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "54": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "55": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "56": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "57": "GposLookupType5Test::::verifyMarkToBaseAttachment()", "59": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "60": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "61": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "62": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "63": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "64": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "65": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "66": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "67": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "68": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "69": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "70": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "71": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "72": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "73": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "74": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "75": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "76": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "77": "GposLookupType5Test::::testSelectingCorrectAttachmentAlternative()", "79": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "80": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "81": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "82": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "83": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "84": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "85": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "86": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "87": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "88": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "89": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "90": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "91": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "92": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "93": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()", "94": "GposLookupType5Test::::testThatNoTransformationsAppliedForNonRelevantGlyphs()"}, "tests": [{"test_lines": [42, 57], "covered_lines": [39, 40, 41, 42, 46, 48, 53, 54, 55, 56, 57, 59, 60, 61, 62, 64, 65, 69, 70, 73, 77, 78, 81, 95, 96, 97, 98, 99, 103, 104, 108, 111, 112, 117, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 133, 134, 135, 137, 138, 141, 142, 145]}, {"test_lines": [59, 77], "covered_lines": [39, 40, 41, 42, 46, 48, 53, 54, 55, 56, 57, 59, 60, 61, 62, 64, 65, 69, 70, 73, 77, 78, 81, 95, 96, 97, 98, 99, 103, 104, 108, 111, 112, 117, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 133, 134, 135, 137, 138, 141, 142, 145]}, {"test_lines": [79, 94], "covered_lines": [39, 40, 41, 42, 46, 48, 53, 54, 55, 56, 57, 59, 60, 61, 62, 64, 65, 69, 70, 73, 77, 78, 79, 111, 112, 117, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 133, 134, 135, 137, 138, 141, 142, 145]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/GposLookupType4.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import java.util.ArrayList;\n", "import java.util.HashMap;\n", "import java.util.List;\n", "import java.util.Map;\n", "\n", "/**\n", " * Lookup Type 4:\n", " * MarkToBase Attachment Positioning Subtable\n", " */\n", "public class GposLookupType4 extends OpenTableLookup {\n", "\n", "    private final List<MarkToBase> marksbases;\n", "\n", "    public GposLookupType4(OpenTypeFontTableReader openReader, int lookupFlag, int[] subTableLocations) throws java.io.IOException {\n", "        super(openReader, lookupFlag, subTableLocations);\n", "        marksbases = new ArrayList<>();\n", "        readSubTables();\n", "    }\n", "\n", "    @Override\n", "    public boolean transformOne(GlyphLine line) {\n", "        if (line.idx >= line.end) {\n", "            return false;\n", "        }\n", "        if (openReader.isSkip(line.get(line.idx).getCode(), lookupFlag)) {\n", "            line.idx++;\n", "            return false;\n", "        }\n", "\n", "        boolean changed = false;\n", "        GlyphIndexer gi = null;\n", "        for (MarkToBase mb : marksbases) {\n", "            OtfMarkRecord omr = mb.marks.get(line.get(line.idx).getCode());\n", "            if (omr == null)\n", "                continue;\n", "            if (gi == null) {\n", "                gi = new GlyphIndexer();\n", "                gi.idx = line.idx;\n", "                gi.line = line;\n", "                while (true) {\n", "                    gi.previousGlyph(openReader, lookupFlag);\n", "                    if (gi.glyph == null) {\n", "                        break;\n", "                    }\n", "                    // not mark => base glyph\n", "                    if (openReader.getGlyphClass(gi.glyph.getCode()) != OtfClass.GLYPH_MARK) {\n", "                        break;\n", "                    }\n", "                }\n", "                if (gi.glyph == null) {\n", "                    break;\n", "                }\n", "            }\n", "            GposAnchor[] gpas = mb.bases.get(gi.glyph.getCode());\n", "            if (gpas == null) {\n", "                continue;\n", "            }\n", "            int markClass = omr.markClass;\n", "            int xPlacement = 0;\n", "            int yPlacement = 0;\n", "            GposAnchor baseAnchor = gpas[markClass];\n", "            if (baseAnchor != null) {\n", "                xPlacement = baseAnchor.XCoordinate;\n", "                yPlacement = baseAnchor.YCoordinate;\n", "            }\n", "            GposAnchor markAnchor = omr.anchor;\n", "            if (markAnchor != null) {\n", "                xPlacement -= markAnchor.XCoordinate;\n", "                yPlacement -= markAnchor.YCoordinate;\n", "            }\n", "            line.set(line.idx, new Glyph(line.get(line.idx),\n", "                    xPlacement, yPlacement,\n", "                    0, 0, gi.idx - line.idx));\n", "            changed = true;\n", "            break;\n", "        }\n", "        line.idx++;\n", "        return changed;\n", "    }\n", "\n", "    @Override\n", "    protected void readSubTable(int subTableLocation) throws java.io.IOException {\n", "        openReader.rf.seek(subTableLocation);\n", "\n", "        // skip format, always 1\n", "        openReader.rf.readUnsignedShort();\n", "        int markCoverageLocation = openReader.rf.readUnsignedShort() + subTableLocation;\n", "        int baseCoverageLocation = openReader.rf.readUnsignedShort() + subTableLocation;\n", "        int classCount = openReader.rf.readUnsignedShort();\n", "        int markArrayLocation = openReader.rf.readUnsignedShort() + subTableLocation;\n", "        int baseArrayLocation = openReader.rf.readUnsignedShort() + subTableLocation;\n", "        List<Integer> markCoverage = openReader.readCoverageFormat(markCoverageLocation);\n", "        List<Integer> baseCoverage = openReader.readCoverageFormat(baseCoverageLocation);\n", "        List<OtfMarkRecord> markRecords = OtfReadCommon.readMarkArray(openReader, markArrayLocation);\n", "        MarkToBase markToBase = new MarkToBase();\n", "        for (int k = 0; k < markCoverage.size(); ++k) {\n", "            markToBase.marks.put(markCoverage.get(k), markRecords.get(k));\n", "        }\n", "        List<GposAnchor[]> baseArray = OtfReadCommon.readBaseArray(openReader, classCount, baseArrayLocation);\n", "        for (int k = 0; k < baseCoverage.size(); ++k) {\n", "            markToBase.bases.put(baseCoverage.get(k), baseArray.get(k));\n", "        }\n", "        marksbases.add(markToBase);\n", "    }\n", "\n", "    public static class MarkToBase {\n", "        public final Map<Integer, OtfMarkRecord> marks = new HashMap<>();\n", "        public final Map<Integer, GposAnchor[]> bases = new HashMap<>();\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgramFactory;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.io.IOException;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "public class GposLookupType4Test extends ExtendedITextTest {\n", "\n", "    private static final String RESOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/otf/GposLookupType4Test/\";\n", "\n", "    @Test\n", "    public void verifyMarkToBaseAttachment() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont)FontProgramFactory.createFont(RESOURCE_FOLDER + \"Padauk-Regular.ttf\");\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "        GposLookupType4 lookup = (GposLookupType4) gposTableReader.getLookupTable(192);\n", "        List<Glyph> glyphs = Arrays.asList(new Glyph(fontProgram.getGlyphByCode(163)), new Glyph(fontProgram.getGlyphByCode(207)),\n", "                new Glyph(fontProgram.getGlyphByCode(213)));\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "        gl.idx = 2;\n", "\n", "        Assert.assertEquals(0, gl.get(2).getXPlacement());\n", "        Assert.assertEquals(0, gl.get(2).getAnchorDelta());\n", "\n", "        lookup.transformOne(gl);\n", "\n", "        Assert.assertEquals(364, gl.get(2).getXPlacement());\n", "        Assert.assertEquals(-2, gl.get(2).getAnchorDelta());\n", "    }\n", "}\n"], "method_lines_dic": {"GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)": [44, 103], "GposLookupType4::::readSubTable(int)": [105, 128]}, "test_method_lines_dic": {"GposLookupType4Test::::verifyMarkToBaseAttachment()": [42, 59]}, "reverse_method_lines_dic": {"44": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "45": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "46": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "47": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "48": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "49": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "50": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "51": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "52": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "53": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "54": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "55": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "56": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "57": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "58": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "59": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "60": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "61": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "62": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "63": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "64": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "65": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "66": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "67": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "68": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "69": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "70": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "71": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "72": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "73": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "74": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "75": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "76": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "77": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "78": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "79": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "80": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "81": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "82": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "83": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "84": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "85": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "86": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "87": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "88": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "89": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "90": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "91": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "92": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "93": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "94": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "95": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "96": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "97": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "98": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "99": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "100": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "101": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "102": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "103": "GposLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "105": "GposLookupType4::::readSubTable(int)", "106": "GposLookupType4::::readSubTable(int)", "107": "GposLookupType4::::readSubTable(int)", "108": "GposLookupType4::::readSubTable(int)", "109": "GposLookupType4::::readSubTable(int)", "110": "GposLookupType4::::readSubTable(int)", "111": "GposLookupType4::::readSubTable(int)", "112": "GposLookupType4::::readSubTable(int)", "113": "GposLookupType4::::readSubTable(int)", "114": "GposLookupType4::::readSubTable(int)", "115": "GposLookupType4::::readSubTable(int)", "116": "GposLookupType4::::readSubTable(int)", "117": "GposLookupType4::::readSubTable(int)", "118": "GposLookupType4::::readSubTable(int)", "119": "GposLookupType4::::readSubTable(int)", "120": "GposLookupType4::::readSubTable(int)", "121": "GposLookupType4::::readSubTable(int)", "122": "GposLookupType4::::readSubTable(int)", "123": "GposLookupType4::::readSubTable(int)", "124": "GposLookupType4::::readSubTable(int)", "125": "GposLookupType4::::readSubTable(int)", "126": "GposLookupType4::::readSubTable(int)", "127": "GposLookupType4::::readSubTable(int)", "128": "GposLookupType4::::readSubTable(int)"}, "test_reverse_method_lines_dic": {"42": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "43": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "44": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "45": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "46": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "47": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "48": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "49": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "50": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "51": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "52": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "53": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "54": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "55": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "56": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "57": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "58": "GposLookupType4Test::::verifyMarkToBaseAttachment()", "59": "GposLookupType4Test::::verifyMarkToBaseAttachment()"}, "tests": [{"test_lines": [42, 59], "covered_lines": [39, 40, 41, 42, 46, 49, 54, 55, 56, 57, 58, 60, 61, 62, 63, 65, 66, 70, 71, 74, 78, 79, 82, 83, 84, 85, 86, 87, 88, 90, 91, 92, 93, 95, 98, 99, 101, 102, 107, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123, 124, 125, 127, 128, 130, 131, 132]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/GlyphLine.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.util.TextUtil;\n", "\n", "import java.util.ArrayList;\n", "import java.util.Iterator;\n", "import java.util.List;\n", "\n", "public class GlyphLine {\n", "    public int start;\n", "    public int end;\n", "    public int idx;\n", "    protected List<Glyph> glyphs;\n", "    protected List<ActualText> actualText;\n", "\n", "    public GlyphLine() {\n", "        this.glyphs = new ArrayList<>();\n", "    }\n", "\n", "    /**\n", "     * Create a new line of Glyphs.\n", "     *\n", "     * @param glyphs list containing the glyphs\n", "     */\n", "    public GlyphLine(List<Glyph> glyphs) {\n", "        this.glyphs = glyphs;\n", "        this.start = 0;\n", "        this.end = glyphs.size();\n", "    }\n", "\n", "    /**\n", "     * Create a new line of Glyphs from a slice of a List of Glyphs.\n", "     *\n", "     * @param glyphs list of Glyphs to slice\n", "     * @param start  starting index of the slice\n", "     * @param end    terminating index of the slice\n", "     */\n", "    public GlyphLine(List<Glyph> glyphs, int start, int end) {\n", "        this.glyphs = glyphs;\n", "        this.start = start;\n", "        this.end = end;\n", "    }\n", "\n", "    /**\n", "     * Create a new line of Glyphs from a slice of a List of Glyphs, and add the actual text.\n", "     *\n", "     * @param glyphs     list of Glyphs to slice\n", "     * @param actualText corresponding list containing the actual text the glyphs represent\n", "     * @param start      starting index of the slice\n", "     * @param end        terminating index of the slice\n", "     */\n", "    protected GlyphLine(List<Glyph> glyphs, List<ActualText> actualText, int start, int end) {\n", "        this(glyphs, start, end);\n", "        this.actualText = actualText;\n", "    }\n", "\n", "    /**\n", "     * Copy a line of Glyphs.\n", "     *\n", "     * @param other line of Glyphs to copy\n", "     */\n", "    public GlyphLine(GlyphLine other) {\n", "        this.glyphs = other.glyphs;\n", "        this.actualText = other.actualText;\n", "        this.start = other.start;\n", "        this.end = other.end;\n", "        this.idx = other.idx;\n", "    }\n", "\n", "    /**\n", "     * Copy a slice of a line of Glyphs\n", "     *\n", "     * @param other line of Glyphs to copy\n", "     * @param start starting index of the slice\n", "     * @param end   terminating index of the slice\n", "     */\n", "    public GlyphLine(GlyphLine other, int start, int end) {\n", "        this.glyphs = other.glyphs.subList(start, end);\n", "        if (other.actualText != null) {\n", "            this.actualText = other.actualText.subList(start, end);\n", "        }\n", "        this.start = 0;\n", "        this.end = end - start;\n", "        this.idx = other.idx - start;\n", "    }\n", "\n", "    /**\n", "     * Get the unicode string representation of the GlyphLine slice.\n", "     *\n", "     * @param start starting index of the slice\n", "     * @param end   terminating index of the slice\n", "     * @return String containing the unicode representation of the slice.\n", "     */\n", "    public String toUnicodeString(int start, int end) {\n", "        ActualTextIterator iter = new ActualTextIterator(this, start, end);\n", "        StringBuilder str = new StringBuilder();\n", "        while (iter.hasNext()) {\n", "            GlyphLinePart part = iter.next();\n", "            if (part.actualText != null) {\n", "                str.append(part.actualText);\n", "            } else {\n", "                for (int i = part.start; i < part.end; i++) {\n", "                    str.append(glyphs.get(i).getUnicodeChars());\n", "                }\n", "            }\n", "        }\n", "        return str.toString();\n", "    }\n", "\n", "    @Override\n", "    public String toString() {\n", "        return toUnicodeString(start, end);\n", "    }\n", "\n", "    /**\n", "     * Copy a slice of this Glyphline.\n", "     *\n", "     * @param left  leftmost index of the slice\n", "     * @param right rightmost index of the slice\n", "     * @return new GlyphLine containing the copied slice\n", "     */\n", "    public GlyphLine copy(int left, int right) {\n", "        GlyphLine glyphLine = new GlyphLine();\n", "        glyphLine.start = 0;\n", "        glyphLine.end = right - left;\n", "        glyphLine.glyphs = new ArrayList<>(glyphs.subList(left, right));\n", "        glyphLine.actualText = actualText == null ? null : new ArrayList<>(actualText.subList(left, right));\n", "        return glyphLine;\n", "    }\n", "\n", "    public Glyph get(int index) {\n", "        return glyphs.get(index);\n", "    }\n", "\n", "    public Glyph set(int index, Glyph glyph) {\n", "        return glyphs.set(index, glyph);\n", "    }\n", "\n", "    public void add(Glyph glyph) {\n", "        glyphs.add(glyph);\n", "        if (actualText != null) {\n", "            actualText.add(null);\n", "        }\n", "    }\n", "\n", "    public void add(int index, Glyph glyph) {\n", "        glyphs.add(index, glyph);\n", "        if (actualText != null) {\n", "            actualText.add(index, null);\n", "        }\n", "    }\n", "\n", "    public void setGlyphs(List<Glyph> replacementGlyphs) {\n", "        glyphs = new ArrayList<>(replacementGlyphs);\n", "        start = 0;\n", "        end = replacementGlyphs.size();\n", "        actualText = null;\n", "    }\n", "\n", "    /**\n", "     * Add a line to the current one.\n", "     * The glyphs from the start till the end points will be copied.\n", "     * The same is true for the actual text.\n", "     *\n", "     * @param other the line that should be added to the current one\n", "     */\n", "    public void add(GlyphLine other) {\n", "        if (other.actualText != null) {\n", "            if (actualText == null) {\n", "                actualText = new ArrayList<ActualText>(glyphs.size());\n", "                for (int i = 0; i < glyphs.size(); i++) {\n", "                    actualText.add(null);\n", "                }\n", "            }\n", "            actualText.addAll(other.actualText.subList(other.start, other.end));\n", "        }\n", "        glyphs.addAll(other.glyphs.subList(other.start, other.end));\n", "        if (null != actualText) {\n", "            while (actualText.size() < glyphs.size()) {\n", "                actualText.add(null);\n", "            }\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Replaces the current content with the other line's content.\n", "     *\n", "     * @param other the line with the content to be set to the current one\n", "     */\n", "    public void replaceContent(GlyphLine other) {\n", "        glyphs.clear();\n", "        glyphs.addAll(other.glyphs);\n", "        if (other.actualText != null) {\n", "            if (actualText == null) {\n", "                actualText = new ArrayList<>();\n", "            } else {\n", "                actualText.clear();\n", "            }\n", "            actualText.addAll(other.actualText);\n", "        } else {\n", "            actualText = null;\n", "        }\n", "        start = other.start;\n", "        end = other.end;\n", "    }\n", "\n", "    public int size() {\n", "        return glyphs.size();\n", "    }\n", "\n", "    public void substituteManyToOne(OpenTypeFontTableReader tableReader, int lookupFlag, int rightPartLen, int substitutionGlyphIndex) {\n", "        OpenTableLookup.GlyphIndexer gidx = new OpenTableLookup.GlyphIndexer();\n", "        gidx.line = this;\n", "        gidx.idx = idx;\n", "\n", "        StringBuilder chars = new StringBuilder();\n", "        Glyph currentGlyph = glyphs.get(idx);\n", "        if (currentGlyph.getChars() != null) {\n", "            chars.append(currentGlyph.getChars());\n", "        } else if (currentGlyph.hasValidUnicode()) {\n", "            chars.append(TextUtil.convertFromUtf32(currentGlyph.getUnicode()));\n", "        }\n", "\n", "        for (int j = 0; j < rightPartLen; ++j) {\n", "            gidx.nextGlyph(tableReader, lookupFlag);\n", "            currentGlyph = glyphs.get(gidx.idx);\n", "            if (currentGlyph.getChars() != null) {\n", "                chars.append(currentGlyph.getChars());\n", "            } else if (currentGlyph.hasValidUnicode()) {\n", "                chars.append(TextUtil.convertFromUtf32(currentGlyph.getUnicode()));\n", "            }\n", "            removeGlyph(gidx.idx--);\n", "        }\n", "        char[] newChars = new char[chars.length()];\n", "        chars.getChars(0, chars.length(), newChars, 0);\n", "        Glyph newGlyph = tableReader.getGlyph(substitutionGlyphIndex);\n", "        newGlyph.setChars(newChars);\n", "        glyphs.set(idx, newGlyph);\n", "        end -= rightPartLen;\n", "    }\n", "\n", "    public void substituteOneToOne(OpenTypeFontTableReader tableReader, int substitutionGlyphIndex) {\n", "        Glyph oldGlyph = glyphs.get(idx);\n", "        Glyph newGlyph = tableReader.getGlyph(substitutionGlyphIndex);\n", "        if (oldGlyph.getChars() != null) {\n", "            newGlyph.setChars(oldGlyph.getChars());\n", "        } else if (newGlyph.hasValidUnicode()) {\n", "            newGlyph.setChars(TextUtil.convertFromUtf32(newGlyph.getUnicode()));\n", "        } else if (oldGlyph.hasValidUnicode()) {\n", "            newGlyph.setChars(TextUtil.convertFromUtf32(oldGlyph.getUnicode()));\n", "        }\n", "        glyphs.set(idx, newGlyph);\n", "    }\n", "\n", "    public void substituteOneToMany(OpenTypeFontTableReader tableReader, int[] substGlyphIds) {\n", "        //sequence length shall be at least 1\n", "        int substCode = substGlyphIds[0];\n", "        Glyph oldGlyph = glyphs.get(idx);\n", "        Glyph glyph = tableReader.getGlyph(substCode);\n", "        glyphs.set(idx, glyph);\n", "\n", "        if (substGlyphIds.length > 1) {\n", "            List<Glyph> additionalGlyphs = new ArrayList<>(substGlyphIds.length - 1);\n", "            for (int i = 1; i < substGlyphIds.length; ++i) {\n", "                substCode = substGlyphIds[i];\n", "                glyph = tableReader.getGlyph(substCode);\n", "                additionalGlyphs.add(glyph);\n", "            }\n", "            addAllGlyphs(idx + 1, additionalGlyphs);\n", "            if (null != actualText) {\n", "                if (null == actualText.get(idx)) {\n", "                    actualText.set(idx, new ActualText(oldGlyph.getUnicodeString()));\n", "                }\n", "                for (int i = 0; i < additionalGlyphs.size(); i++) {\n", "                    this.actualText.set(idx + 1 + i, actualText.get(idx));\n", "                }\n", "            }\n", "            idx += substGlyphIds.length - 1;\n", "            end += substGlyphIds.length - 1;\n", "        }\n", "    }\n", "\n", "    public GlyphLine filter(IGlyphLineFilter filter) {\n", "        boolean anythingFiltered = false;\n", "        List<Glyph> filteredGlyphs = new ArrayList<>(end - start);\n", "        List<ActualText> filteredActualText = actualText != null ? new ArrayList<ActualText>(end - start) : null;\n", "        for (int i = start; i < end; i++) {\n", "            if (filter.accept(glyphs.get(i))) {\n", "                filteredGlyphs.add(glyphs.get(i));\n", "                if (filteredActualText != null) {\n", "                    filteredActualText.add(actualText.get(i));\n", "                }\n", "            } else {\n", "                anythingFiltered = true;\n", "            }\n", "        }\n", "        if (anythingFiltered) {\n", "            return new GlyphLine(filteredGlyphs, filteredActualText, 0, filteredGlyphs.size());\n", "        } else {\n", "            return this;\n", "        }\n", "    }\n", "\n", "    public void setActualText(int left, int right, String text) {\n", "        if (this.actualText == null) {\n", "            this.actualText = new ArrayList<>(glyphs.size());\n", "            for (int i = 0; i < glyphs.size(); i++)\n", "                this.actualText.add(null);\n", "        }\n", "        ActualText actualText = new ActualText(text);\n", "        for (int i = left; i < right; i++) {\n", "            this.actualText.set(i, actualText);\n", "        }\n", "    }\n", "\n", "    public Iterator<GlyphLinePart> iterator() {\n", "        return new ActualTextIterator(this);\n", "    }\n", "\n", "    @Override\n", "    public boolean equals(Object obj) {\n", "        if (this == obj) {\n", "            return true;\n", "        }\n", "        if (obj == null || getClass() != obj.getClass()) {\n", "            return false;\n", "        }\n", "        GlyphLine other = (GlyphLine) obj;\n", "        if (end - start != other.end - other.start) {\n", "            return false;\n", "        }\n", "        if (actualText == null && other.actualText != null || actualText != null && other.actualText == null) {\n", "            return false;\n", "        }\n", "        for (int i = start; i < end; i++) {\n", "            int otherPos = other.start + i - start;\n", "            Glyph myGlyph = get(i);\n", "            Glyph otherGlyph = other.get(otherPos);\n", "            if (myGlyph == null && otherGlyph != null || myGlyph != null && !myGlyph.equals(otherGlyph)) {\n", "                return false;\n", "            }\n", "            ActualText myAT = actualText == null ? null : actualText.get(i);\n", "            ActualText otherAT = other.actualText == null ? null : other.actualText.get(otherPos);\n", "            if (myAT == null && otherAT != null || myAT != null && !myAT.equals(otherAT)) {\n", "                return false;\n", "            }\n", "        }\n", "        return true;\n", "    }\n", "\n", "    @Override\n", "    public int hashCode() {\n", "        int result = 0;\n", "        result = 31*result + start;\n", "        result = 31*result + end;\n", "        for (int i = start; i < end; i++) {\n", "            result = 31*result + glyphs.get(i).hashCode();\n", "        }\n", "        if (null != actualText) {\n", "            for (int i = start; i < end; i++) {\n", "                result = 31*result;\n", "                if (null != actualText.get(i)) {\n", "                    result += actualText.get(i).hashCode();\n", "                }\n", "            }\n", "        }\n", "        return result;\n", "    }\n", "\n", "    private void removeGlyph(int index) {\n", "        glyphs.remove(index);\n", "        if (actualText != null) {\n", "            actualText.remove(index);\n", "        }\n", "    }\n", "\n", "    private void addAllGlyphs(int index, List<Glyph> additionalGlyphs) {\n", "        glyphs.addAll(index, additionalGlyphs);\n", "        if (actualText != null) {\n", "            for (int i = 0; i < additionalGlyphs.size(); i++) {\n", "                this.actualText.add(index, null);\n", "            }\n", "        }\n", "    }\n", "\n", "    public interface IGlyphLineFilter {\n", "        boolean accept(Glyph glyph);\n", "    }\n", "\n", "    public static class GlyphLinePart {\n", "        public int start;\n", "        public int end;\n", "        // Might be null if it's not necessary\n", "        public String actualText;\n", "        public boolean reversed;\n", "\n", "        public GlyphLinePart(int start, int end) {\n", "            this(start, end, null);\n", "        }\n", "\n", "        public GlyphLinePart(int start, int end, String actualText) {\n", "            this.start = start;\n", "            this.end = end;\n", "            this.actualText = actualText;\n", "        }\n", "\n", "        public GlyphLinePart setReversed(boolean reversed) {\n", "            this.reversed = reversed;\n", "            return this;\n", "        }\n", "    }\n", "\n", "    protected static class ActualText {\n", "        public String value;\n", "\n", "        public ActualText(String value) {\n", "            this.value = value;\n", "        }\n", "\n", "        @Override\n", "        public boolean equals(Object obj) {\n", "            if (this == obj) {\n", "                return true;\n", "            }\n", "            if (obj == null || getClass() != obj.getClass()) {\n", "                return false;\n", "            }\n", "            ActualText other = (ActualText) obj;\n", "            return value == null && other.value == null || value.equals(other.value);\n", "        }\n", "\n", "        @Override\n", "        public int hashCode() {\n", "            return 31*value.hashCode();\n", "        }\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.io.util.StreamUtil;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class GlyphLineTest extends ExtendedITextTest {\n", "\n", "    private static List<Glyph> constructGlyphListFromString(String text, TrueTypeFont font) {\n", "        List<Glyph> glyphList = new ArrayList<>();\n", "        char[] chars = text.toCharArray();\n", "        for (char letter : chars) {\n", "            glyphList.add(font.getGlyph(letter));\n", "        }\n", "        return glyphList;\n", "    }\n", "\n", "    @Test\n", "    public void testEquals() {\n", "        Glyph glyph = new Glyph(200, 200, 200);\n", "        GlyphLine.ActualText actualText = new GlyphLine.ActualText(\"-\");\n", "\n", "        GlyphLine one = new GlyphLine(new ArrayList<Glyph>(Arrays.asList(glyph)), new ArrayList<GlyphLine.ActualText>(Arrays.asList(actualText)), 0, 1);\n", "        GlyphLine two = new GlyphLine(new ArrayList<Glyph>(Arrays.asList(glyph)), new ArrayList<GlyphLine.ActualText>(Arrays.asList(actualText)), 0, 1);\n", "\n", "        one.add(glyph);\n", "        two.add(glyph);\n", "\n", "        one.end++;\n", "        two.end++;\n", "\n", "        Assert.assertTrue(one.equals(two));\n", "    }\n", "\n", "    @Test\n", "    public void testOtherLinesAddition() throws IOException {\n", "        byte[] ttf = StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(\"./src/test/resources/com/itextpdf/io/font/otf/FreeSans.ttf\"));\n", "        TrueTypeFont font = new TrueTypeFont(ttf);\n", "\n", "        GlyphLine containerLine = new GlyphLine(constructGlyphListFromString(\"Viva France!\", font));\n", "\n", "        GlyphLine childLine1 = new GlyphLine(constructGlyphListFromString(\" Liberte\", font));\n", "        containerLine.add(childLine1);\n", "        Assert.assertEquals(containerLine.end, 12);\n", "        containerLine.end = 20;\n", "        GlyphLine childLine2 = new GlyphLine(constructGlyphListFromString(\" Egalite\", font));\n", "        containerLine.add(childLine2);\n", "        Assert.assertEquals(containerLine.end, 20);\n", "        containerLine.start = 10;\n", "        GlyphLine childLine3 = new GlyphLine(constructGlyphListFromString(\" Fraternite\", font));\n", "        containerLine.add(childLine3);\n", "        Assert.assertEquals(containerLine.start, 10);\n", "        containerLine.start = 0;\n", "        containerLine.add(constructGlyphListFromString(\"!\", font).get(0));\n", "        containerLine.end = 40;\n", "        Assert.assertEquals(containerLine.glyphs.size(), 40);\n", "    }\n", "\n", "    @Test\n", "    public void testAdditionWithActualText() throws IOException {\n", "        byte[] ttf = StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(\"./src/test/resources/com/itextpdf/io/font/otf/FreeSans.ttf\"));\n", "        TrueTypeFont font = new TrueTypeFont(ttf);\n", "\n", "        List<Glyph> glyphs = constructGlyphListFromString(\"Viva France!\", font);\n", "\n", "        GlyphLine containerLine = new GlyphLine(glyphs);\n", "        Assert.assertNull(containerLine.actualText);\n", "\n", "        containerLine.setActualText(0, 1, \"TEST\");\n", "        Assert.assertNotNull(containerLine.actualText);\n", "        Assert.assertEquals(12, containerLine.actualText.size());\n", "        Assert.assertEquals(\"TEST\", containerLine.actualText.get(0).value);\n", "\n", "        containerLine.add(new GlyphLine(glyphs));\n", "        Assert.assertEquals(24, containerLine.actualText.size());\n", "        for (int i = 13; i < 24; i++) {\n", "            Assert.assertNull(containerLine.actualText.get(i));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void testOtherLinesWithActualTextAddition() throws IOException {\n", "        byte[] ttf = StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(\"./src/test/resources/com/itextpdf/io/font/otf/FreeSans.ttf\"));\n", "        TrueTypeFont font = new TrueTypeFont(ttf);\n", "\n", "        GlyphLine containerLine = new GlyphLine(constructGlyphListFromString(\"France\", font));\n", "\n", "        GlyphLine childLine = new GlyphLine(constructGlyphListFromString(\"---Liberte\", font));\n", "        childLine.setActualText(3, 10, \"Viva\");\n", "\n", "        containerLine.add(childLine);\n", "        containerLine.end = 16;\n", "        for (int i = 0; i < 9; i++) {\n", "            Assert.assertNull(containerLine.actualText.get(i));\n", "        }\n", "        for (int i = 9; i < 16; i++) {\n", "            Assert.assertEquals(\"Viva\", containerLine.actualText.get(i).value);\n", "        }\n", "        Assert.assertEquals(\"France---Viva\", containerLine.toString());\n", "    }\n", "\n", "    @Test\n", "    public void testOtherLinesWithActualTextAddition02() throws IOException {\n", "        byte[] ttf = StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(\"./src/test/resources/com/itextpdf/io/font/otf/FreeSans.ttf\"));\n", "        TrueTypeFont font = new TrueTypeFont(ttf);\n", "\n", "        GlyphLine containerLine = new GlyphLine(constructGlyphListFromString(\"France\", font));\n", "        containerLine.setActualText(1, 5, \"id\");\n", "\n", "        GlyphLine childLine = new GlyphLine(constructGlyphListFromString(\"---Liberte\", font));\n", "        childLine.setActualText(3, 10, \"Viva\");\n", "\n", "        containerLine.add(childLine);\n", "        containerLine.end = 16;\n", "        Assert.assertNull(containerLine.actualText.get(0));\n", "        for (int i = 1; i < 5; i++) {\n", "            Assert.assertEquals(\"id\", containerLine.actualText.get(i).value);\n", "        }\n", "        for (int i = 5; i < 9; i++) {\n", "            Assert.assertNull(containerLine.actualText.get(i));\n", "        }\n", "        for (int i = 9; i < 16; i++) {\n", "            Assert.assertEquals(\"Viva\", containerLine.actualText.get(i).value);\n", "        }\n", "        Assert.assertEquals(\"Fide---Viva\", containerLine.toString());\n", "    }\n", "\n", "    @Test\n", "    public void testContentReplacingWithNullActualText() throws IOException {\n", "        byte[] ttf = StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(\"./src/test/resources/com/itextpdf/io/font/otf/FreeSans.ttf\"));\n", "        TrueTypeFont font = new TrueTypeFont(ttf);\n", "\n", "        GlyphLine lineToBeReplaced = new GlyphLine(constructGlyphListFromString(\"Byelorussia\", font));\n", "        lineToBeReplaced.setActualText(1, 2, \"e\");\n", "\n", "        GlyphLine lineToBeCopied = new GlyphLine(constructGlyphListFromString(\"Belarus\", font));\n", "        lineToBeReplaced.replaceContent(lineToBeCopied);\n", "\n", "        // Test that no exception has been thrown. Also check the content.\n", "        Assert.assertEquals(\"Belarus\", lineToBeReplaced.toString());\n", "    }\n", "\n", "    @Test\n", "    public void testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01() throws IOException {\n", "        String expectedActualTextForFirstGlyph = \"0\";\n", "        String expectedActualTextForSecondGlyph = \"A\";\n", "\n", "        byte[] ttf = StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(\"./src/test/resources/com/itextpdf/io/font/otf/FreeSans.ttf\"));\n", "        TrueTypeFont font = new TrueTypeFont(ttf);\n", "\n", "        // no actual text for the second glyph is set - it should be created during substitution\n", "        GlyphLine line = new GlyphLine(constructGlyphListFromString(\"AA\", font));\n", "        line.setActualText(0, 1, expectedActualTextForFirstGlyph);\n", "        line.idx = 1;\n", "\n", "        line.substituteOneToMany(font.getGsubTable(), new int[] {39, 40});\n", "\n", "        Assert.assertNotNull(line.actualText);\n", "        Assert.assertEquals(3, line.actualText.size());\n", "        Assert.assertSame(line.actualText.get(1), line.actualText.get(2));\n", "        Assert.assertEquals(expectedActualTextForSecondGlyph, line.actualText.get(1).value);\n", "        // check that it hasn't been corrupted\n", "        Assert.assertEquals(expectedActualTextForFirstGlyph, line.actualText.get(0).value);\n", "    }\n", "\n", "    @Test\n", "    public void testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02() throws IOException {\n", "        String expectedActualTextForFirstGlyph = \"A\";\n", "\n", "        byte[] ttf = StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(\"./src/test/resources/com/itextpdf/io/font/otf/FreeSans.ttf\"));\n", "        TrueTypeFont font = new TrueTypeFont(ttf);\n", "\n", "        GlyphLine line = new GlyphLine(constructGlyphListFromString(\"A\", font));\n", "        line.setActualText(0, 1, expectedActualTextForFirstGlyph);\n", "\n", "        line.substituteOneToMany(font.getGsubTable(), new int[] {39, 40});\n", "\n", "        Assert.assertNotNull(line.actualText);\n", "        Assert.assertEquals(2, line.actualText.size());\n", "        Assert.assertSame(line.actualText.get(0), line.actualText.get(1));\n", "        Assert.assertEquals(expectedActualTextForFirstGlyph, line.actualText.get(0).value);\n", "    }\n", "\n", "    @Test\n", "    public void testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03() throws IOException {\n", "        byte[] ttf = StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(\"./src/test/resources/com/itextpdf/io/font/otf/FreeSans.ttf\"));\n", "        TrueTypeFont font = new TrueTypeFont(ttf);\n", "\n", "        // no actual text is set\n", "        GlyphLine line = new GlyphLine(constructGlyphListFromString(\"A\", font));\n", "\n", "        line.substituteOneToMany(font.getGsubTable(), new int[] {39, 40});\n", "\n", "        Assert.assertNull(line.actualText);\n", "    }\n", "}\n", "\n"], "method_lines_dic": {"GlyphLine::::toUnicodeString(int,int)": [116, 130], "GlyphLine::::toString()": [132, 135], "GlyphLine::::copy(int,int)": [144, 151], "GlyphLine::::get(int)": [153, 155], "GlyphLine::::set(int,com.itextpdf.io.font.otf.Glyph)": [157, 159], "GlyphLine::::add(com.itextpdf.io.font.otf.Glyph)": [161, 166], "GlyphLine::::add(int,com.itextpdf.io.font.otf.Glyph)": [168, 173], "GlyphLine::::setGlyphs(java.util.List<com.itextpdf.io.font.otf.Glyph>)": [175, 180], "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)": [189, 205], "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)": [212, 227], "GlyphLine::::size()": [229, 231], "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)": [233, 262], "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)": [264, 275], "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])": [277, 303], "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)": [305, 324], "GlyphLine::::setActualText(int,int,java.lang.String)": [326, 336], "GlyphLine::::iterator()": [338, 340], "GlyphLine::::equals(java.lang.Object)": [342, 371], "GlyphLine::::hashCode()": [373, 390], "GlyphLine::::removeGlyph(int)": [392, 397], "GlyphLine::::addAllGlyphs(int,java.util.List<com.itextpdf.io.font.otf.Glyph>)": [399, 406], "GlyphLine.IGlyphLineFilter::::accept(com.itextpdf.io.font.otf.Glyph)": [409, 409], "GlyphLine.GlyphLinePart::::setReversed(boolean)": [429, 432], "GlyphLine.ActualText::::equals(java.lang.Object)": [442, 452], "GlyphLine.ActualText::::hashCode()": [454, 457]}, "test_method_lines_dic": {"GlyphLineTest::::testEquals()": [51, 66], "GlyphLineTest::::testOtherLinesAddition()": [68, 90], "GlyphLineTest::::testAdditionWithActualText()": [92, 112], "GlyphLineTest::::testOtherLinesWithActualTextAddition()": [114, 133], "GlyphLineTest::::testOtherLinesWithActualTextAddition02()": [135, 159], "GlyphLineTest::::testContentReplacingWithNullActualText()": [161, 174], "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()": [176, 197], "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()": [199, 215], "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()": [217, 228]}, "reverse_method_lines_dic": {"116": "GlyphLine::::toUnicodeString(int,int)", "117": "GlyphLine::::toUnicodeString(int,int)", "118": "GlyphLine::::toUnicodeString(int,int)", "119": "GlyphLine::::toUnicodeString(int,int)", "120": "GlyphLine::::toUnicodeString(int,int)", "121": "GlyphLine::::toUnicodeString(int,int)", "122": "GlyphLine::::toUnicodeString(int,int)", "123": "GlyphLine::::toUnicodeString(int,int)", "124": "GlyphLine::::toUnicodeString(int,int)", "125": "GlyphLine::::toUnicodeString(int,int)", "126": "GlyphLine::::toUnicodeString(int,int)", "127": "GlyphLine::::toUnicodeString(int,int)", "128": "GlyphLine::::toUnicodeString(int,int)", "129": "GlyphLine::::toUnicodeString(int,int)", "130": "GlyphLine::::toUnicodeString(int,int)", "132": "GlyphLine::::toString()", "133": "GlyphLine::::toString()", "134": "GlyphLine::::toString()", "135": "GlyphLine::::toString()", "144": "GlyphLine::::copy(int,int)", "145": "GlyphLine::::copy(int,int)", "146": "GlyphLine::::copy(int,int)", "147": "GlyphLine::::copy(int,int)", "148": "GlyphLine::::copy(int,int)", "149": "GlyphLine::::copy(int,int)", "150": "GlyphLine::::copy(int,int)", "151": "GlyphLine::::copy(int,int)", "153": "GlyphLine::::get(int)", "154": "GlyphLine::::get(int)", "155": "GlyphLine::::get(int)", "157": "GlyphLine::::set(int,com.itextpdf.io.font.otf.Glyph)", "158": "GlyphLine::::set(int,com.itextpdf.io.font.otf.Glyph)", "159": "GlyphLine::::set(int,com.itextpdf.io.font.otf.Glyph)", "161": "GlyphLine::::add(com.itextpdf.io.font.otf.Glyph)", "162": "GlyphLine::::add(com.itextpdf.io.font.otf.Glyph)", "163": "GlyphLine::::add(com.itextpdf.io.font.otf.Glyph)", "164": "GlyphLine::::add(com.itextpdf.io.font.otf.Glyph)", "165": "GlyphLine::::add(com.itextpdf.io.font.otf.Glyph)", "166": "GlyphLine::::add(com.itextpdf.io.font.otf.Glyph)", "168": "GlyphLine::::add(int,com.itextpdf.io.font.otf.Glyph)", "169": "GlyphLine::::add(int,com.itextpdf.io.font.otf.Glyph)", "170": "GlyphLine::::add(int,com.itextpdf.io.font.otf.Glyph)", "171": "GlyphLine::::add(int,com.itextpdf.io.font.otf.Glyph)", "172": "GlyphLine::::add(int,com.itextpdf.io.font.otf.Glyph)", "173": "GlyphLine::::add(int,com.itextpdf.io.font.otf.Glyph)", "175": "GlyphLine::::setGlyphs(java.util.List<com.itextpdf.io.font.otf.Glyph>)", "176": "GlyphLine::::setGlyphs(java.util.List<com.itextpdf.io.font.otf.Glyph>)", "177": "GlyphLine::::setGlyphs(java.util.List<com.itextpdf.io.font.otf.Glyph>)", "178": "GlyphLine::::setGlyphs(java.util.List<com.itextpdf.io.font.otf.Glyph>)", "179": "GlyphLine::::setGlyphs(java.util.List<com.itextpdf.io.font.otf.Glyph>)", "180": "GlyphLine::::setGlyphs(java.util.List<com.itextpdf.io.font.otf.Glyph>)", "189": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "190": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "191": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "192": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "193": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "194": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "195": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "196": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "197": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "198": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "199": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "200": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "201": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "202": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "203": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "204": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "205": "GlyphLine::::add(com.itextpdf.io.font.otf.GlyphLine)", "212": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "213": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "214": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "215": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "216": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "217": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "218": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "219": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "220": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "221": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "222": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "223": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "224": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "225": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "226": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "227": "GlyphLine::::replaceContent(com.itextpdf.io.font.otf.GlyphLine)", "229": "GlyphLine::::size()", "230": "GlyphLine::::size()", "231": "GlyphLine::::size()", "233": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "234": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "235": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "236": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "237": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "238": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "239": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "240": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "241": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "242": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "243": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "244": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "245": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "246": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "247": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "248": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "249": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "250": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "251": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "252": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "253": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "254": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "255": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "256": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "257": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "258": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "259": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "260": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "261": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "262": "GlyphLine::::substituteManyToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int,int)", "264": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "265": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "266": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "267": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "268": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "269": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "270": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "271": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "272": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "273": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "274": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "275": "GlyphLine::::substituteOneToOne(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "277": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "278": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "279": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "280": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "281": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "282": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "283": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "284": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "285": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "286": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "287": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "288": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "289": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "290": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "291": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "292": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "293": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "294": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "295": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "296": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "297": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "298": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "299": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "300": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "301": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "302": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "303": "GlyphLine::::substituteOneToMany(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[])", "305": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "306": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "307": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "308": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "309": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "310": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "311": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "312": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "313": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "314": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "315": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "316": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "317": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "318": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "319": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "320": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "321": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "322": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "323": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "324": "GlyphLine::::filter(com.itextpdf.io.font.otf.GlyphLine.IGlyphLineFilter)", "326": "GlyphLine::::setActualText(int,int,java.lang.String)", "327": "GlyphLine::::setActualText(int,int,java.lang.String)", "328": "GlyphLine::::setActualText(int,int,java.lang.String)", "329": "GlyphLine::::setActualText(int,int,java.lang.String)", "330": "GlyphLine::::setActualText(int,int,java.lang.String)", "331": "GlyphLine::::setActualText(int,int,java.lang.String)", "332": "GlyphLine::::setActualText(int,int,java.lang.String)", "333": "GlyphLine::::setActualText(int,int,java.lang.String)", "334": "GlyphLine::::setActualText(int,int,java.lang.String)", "335": "GlyphLine::::setActualText(int,int,java.lang.String)", "336": "GlyphLine::::setActualText(int,int,java.lang.String)", "338": "GlyphLine::::iterator()", "339": "GlyphLine::::iterator()", "340": "GlyphLine::::iterator()", "342": "GlyphLine::::equals(java.lang.Object)", "343": "GlyphLine::::equals(java.lang.Object)", "344": "GlyphLine::::equals(java.lang.Object)", "345": "GlyphLine::::equals(java.lang.Object)", "346": "GlyphLine::::equals(java.lang.Object)", "347": "GlyphLine::::equals(java.lang.Object)", "348": "GlyphLine::::equals(java.lang.Object)", "349": "GlyphLine::::equals(java.lang.Object)", "350": "GlyphLine::::equals(java.lang.Object)", "351": "GlyphLine::::equals(java.lang.Object)", "352": "GlyphLine::::equals(java.lang.Object)", "353": "GlyphLine::::equals(java.lang.Object)", "354": "GlyphLine::::equals(java.lang.Object)", "355": "GlyphLine::::equals(java.lang.Object)", "356": "GlyphLine::::equals(java.lang.Object)", "357": "GlyphLine::::equals(java.lang.Object)", "358": "GlyphLine::::equals(java.lang.Object)", "359": "GlyphLine::::equals(java.lang.Object)", "360": "GlyphLine::::equals(java.lang.Object)", "361": "GlyphLine::::equals(java.lang.Object)", "362": "GlyphLine::::equals(java.lang.Object)", "363": "GlyphLine::::equals(java.lang.Object)", "364": "GlyphLine::::equals(java.lang.Object)", "365": "GlyphLine::::equals(java.lang.Object)", "366": "GlyphLine::::equals(java.lang.Object)", "367": "GlyphLine::::equals(java.lang.Object)", "368": "GlyphLine::::equals(java.lang.Object)", "369": "GlyphLine::::equals(java.lang.Object)", "370": "GlyphLine::::equals(java.lang.Object)", "371": "GlyphLine::::equals(java.lang.Object)", "373": "GlyphLine::::hashCode()", "374": "GlyphLine::::hashCode()", "375": "GlyphLine::::hashCode()", "376": "GlyphLine::::hashCode()", "377": "GlyphLine::::hashCode()", "378": "GlyphLine::::hashCode()", "379": "GlyphLine::::hashCode()", "380": "GlyphLine::::hashCode()", "381": "GlyphLine::::hashCode()", "382": "GlyphLine::::hashCode()", "383": "GlyphLine::::hashCode()", "384": "GlyphLine::::hashCode()", "385": "GlyphLine::::hashCode()", "386": "GlyphLine::::hashCode()", "387": "GlyphLine::::hashCode()", "388": "GlyphLine::::hashCode()", "389": "GlyphLine::::hashCode()", "390": "GlyphLine::::hashCode()", "392": "GlyphLine::::removeGlyph(int)", "393": "GlyphLine::::removeGlyph(int)", "394": "GlyphLine::::removeGlyph(int)", "395": "GlyphLine::::removeGlyph(int)", "396": "GlyphLine::::removeGlyph(int)", "397": "GlyphLine::::removeGlyph(int)", "399": "GlyphLine::::addAllGlyphs(int,java.util.List<com.itextpdf.io.font.otf.Glyph>)", "400": "GlyphLine::::addAllGlyphs(int,java.util.List<com.itextpdf.io.font.otf.Glyph>)", "401": "GlyphLine::::addAllGlyphs(int,java.util.List<com.itextpdf.io.font.otf.Glyph>)", "402": "GlyphLine::::addAllGlyphs(int,java.util.List<com.itextpdf.io.font.otf.Glyph>)", "403": "GlyphLine::::addAllGlyphs(int,java.util.List<com.itextpdf.io.font.otf.Glyph>)", "404": "GlyphLine::::addAllGlyphs(int,java.util.List<com.itextpdf.io.font.otf.Glyph>)", "405": "GlyphLine::::addAllGlyphs(int,java.util.List<com.itextpdf.io.font.otf.Glyph>)", "406": "GlyphLine::::addAllGlyphs(int,java.util.List<com.itextpdf.io.font.otf.Glyph>)", "409": "GlyphLine.IGlyphLineFilter::::accept(com.itextpdf.io.font.otf.Glyph)", "429": "GlyphLine.GlyphLinePart::::setReversed(boolean)", "430": "GlyphLine.GlyphLinePart::::setReversed(boolean)", "431": "GlyphLine.GlyphLinePart::::setReversed(boolean)", "432": "GlyphLine.GlyphLinePart::::setReversed(boolean)", "442": "GlyphLine.ActualText::::equals(java.lang.Object)", "443": "GlyphLine.ActualText::::equals(java.lang.Object)", "444": "GlyphLine.ActualText::::equals(java.lang.Object)", "445": "GlyphLine.ActualText::::equals(java.lang.Object)", "446": "GlyphLine.ActualText::::equals(java.lang.Object)", "447": "GlyphLine.ActualText::::equals(java.lang.Object)", "448": "GlyphLine.ActualText::::equals(java.lang.Object)", "449": "GlyphLine.ActualText::::equals(java.lang.Object)", "450": "GlyphLine.ActualText::::equals(java.lang.Object)", "451": "GlyphLine.ActualText::::equals(java.lang.Object)", "452": "GlyphLine.ActualText::::equals(java.lang.Object)", "454": "GlyphLine.ActualText::::hashCode()", "455": "GlyphLine.ActualText::::hashCode()", "456": "GlyphLine.ActualText::::hashCode()", "457": "GlyphLine.ActualText::::hashCode()"}, "test_reverse_method_lines_dic": {"51": "GlyphLineTest::::testEquals()", "52": "GlyphLineTest::::testEquals()", "53": "GlyphLineTest::::testEquals()", "54": "GlyphLineTest::::testEquals()", "55": "GlyphLineTest::::testEquals()", "56": "GlyphLineTest::::testEquals()", "57": "GlyphLineTest::::testEquals()", "58": "GlyphLineTest::::testEquals()", "59": "GlyphLineTest::::testEquals()", "60": "GlyphLineTest::::testEquals()", "61": "GlyphLineTest::::testEquals()", "62": "GlyphLineTest::::testEquals()", "63": "GlyphLineTest::::testEquals()", "64": "GlyphLineTest::::testEquals()", "65": "GlyphLineTest::::testEquals()", "66": "GlyphLineTest::::testEquals()", "68": "GlyphLineTest::::testOtherLinesAddition()", "69": "GlyphLineTest::::testOtherLinesAddition()", "70": "GlyphLineTest::::testOtherLinesAddition()", "71": "GlyphLineTest::::testOtherLinesAddition()", "72": "GlyphLineTest::::testOtherLinesAddition()", "73": "GlyphLineTest::::testOtherLinesAddition()", "74": "GlyphLineTest::::testOtherLinesAddition()", "75": "GlyphLineTest::::testOtherLinesAddition()", "76": "GlyphLineTest::::testOtherLinesAddition()", "77": "GlyphLineTest::::testOtherLinesAddition()", "78": "GlyphLineTest::::testOtherLinesAddition()", "79": "GlyphLineTest::::testOtherLinesAddition()", "80": "GlyphLineTest::::testOtherLinesAddition()", "81": "GlyphLineTest::::testOtherLinesAddition()", "82": "GlyphLineTest::::testOtherLinesAddition()", "83": "GlyphLineTest::::testOtherLinesAddition()", "84": "GlyphLineTest::::testOtherLinesAddition()", "85": "GlyphLineTest::::testOtherLinesAddition()", "86": "GlyphLineTest::::testOtherLinesAddition()", "87": "GlyphLineTest::::testOtherLinesAddition()", "88": "GlyphLineTest::::testOtherLinesAddition()", "89": "GlyphLineTest::::testOtherLinesAddition()", "90": "GlyphLineTest::::testOtherLinesAddition()", "92": "GlyphLineTest::::testAdditionWithActualText()", "93": "GlyphLineTest::::testAdditionWithActualText()", "94": "GlyphLineTest::::testAdditionWithActualText()", "95": "GlyphLineTest::::testAdditionWithActualText()", "96": "GlyphLineTest::::testAdditionWithActualText()", "97": "GlyphLineTest::::testAdditionWithActualText()", "98": "GlyphLineTest::::testAdditionWithActualText()", "99": "GlyphLineTest::::testAdditionWithActualText()", "100": "GlyphLineTest::::testAdditionWithActualText()", "101": "GlyphLineTest::::testAdditionWithActualText()", "102": "GlyphLineTest::::testAdditionWithActualText()", "103": "GlyphLineTest::::testAdditionWithActualText()", "104": "GlyphLineTest::::testAdditionWithActualText()", "105": "GlyphLineTest::::testAdditionWithActualText()", "106": "GlyphLineTest::::testAdditionWithActualText()", "107": "GlyphLineTest::::testAdditionWithActualText()", "108": "GlyphLineTest::::testAdditionWithActualText()", "109": "GlyphLineTest::::testAdditionWithActualText()", "110": "GlyphLineTest::::testAdditionWithActualText()", "111": "GlyphLineTest::::testAdditionWithActualText()", "112": "GlyphLineTest::::testAdditionWithActualText()", "114": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "115": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "116": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "117": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "118": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "119": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "120": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "121": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "122": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "123": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "124": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "125": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "126": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "127": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "128": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "129": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "130": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "131": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "132": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "133": "GlyphLineTest::::testOtherLinesWithActualTextAddition()", "135": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "136": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "137": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "138": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "139": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "140": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "141": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "142": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "143": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "144": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "145": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "146": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "147": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "148": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "149": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "150": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "151": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "152": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "153": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "154": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "155": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "156": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "157": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "158": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "159": "GlyphLineTest::::testOtherLinesWithActualTextAddition02()", "161": "GlyphLineTest::::testContentReplacingWithNullActualText()", "162": "GlyphLineTest::::testContentReplacingWithNullActualText()", "163": "GlyphLineTest::::testContentReplacingWithNullActualText()", "164": "GlyphLineTest::::testContentReplacingWithNullActualText()", "165": "GlyphLineTest::::testContentReplacingWithNullActualText()", "166": "GlyphLineTest::::testContentReplacingWithNullActualText()", "167": "GlyphLineTest::::testContentReplacingWithNullActualText()", "168": "GlyphLineTest::::testContentReplacingWithNullActualText()", "169": "GlyphLineTest::::testContentReplacingWithNullActualText()", "170": "GlyphLineTest::::testContentReplacingWithNullActualText()", "171": "GlyphLineTest::::testContentReplacingWithNullActualText()", "172": "GlyphLineTest::::testContentReplacingWithNullActualText()", "173": "GlyphLineTest::::testContentReplacingWithNullActualText()", "174": "GlyphLineTest::::testContentReplacingWithNullActualText()", "176": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "177": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "178": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "179": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "180": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "181": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "182": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "183": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "184": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "185": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "186": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "187": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "188": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "189": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "190": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "191": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "192": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "193": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "194": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "195": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "196": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "197": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany01()", "199": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "200": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "201": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "202": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "203": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "204": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "205": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "206": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "207": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "208": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "209": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "210": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "211": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "212": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "213": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "214": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "215": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany02()", "217": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "218": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "219": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "220": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "221": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "222": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "223": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "224": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "225": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "226": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "227": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()", "228": "GlyphLineTest::::testActualTextForSubstitutedGlyphProcessingInSubstituteOneToMany03()"}, "tests": [{"test_lines": [51, 66], "covered_lines": [60, 61, 62, 63, 64, 75, 76, 77, 154, 162, 163, 164, 166, 344, 347, 350, 351, 354, 357, 358, 359, 360, 361, 364, 365, 366, 370, 438, 439, 440, 444, 445]}, {"test_lines": [68, 90], "covered_lines": [47, 48, 49, 50, 51, 162, 163, 166, 190, 199, 200, 205]}, {"test_lines": [92, 112], "covered_lines": [47, 48, 49, 50, 51, 190, 199, 200, 201, 202, 205, 327, 328, 329, 330, 332, 333, 334, 336, 438, 439, 440]}, {"test_lines": [114, 133], "covered_lines": [47, 48, 49, 50, 51, 60, 61, 62, 63, 64, 75, 76, 77, 117, 118, 119, 120, 121, 122, 124, 125, 128, 129, 134, 190, 191, 192, 193, 194, 197, 199, 200, 201, 205, 327, 328, 329, 330, 332, 333, 334, 336, 423, 424, 425, 426, 427, 438, 439, 440]}, {"test_lines": [135, 159], "covered_lines": [47, 48, 49, 50, 51, 60, 61, 62, 63, 64, 75, 76, 77, 117, 118, 119, 120, 121, 122, 124, 125, 128, 129, 134, 190, 191, 197, 199, 200, 201, 205, 327, 328, 329, 330, 332, 333, 334, 336, 423, 424, 425, 426, 427, 438, 439, 440]}, {"test_lines": [161, 174], "covered_lines": [47, 48, 49, 50, 51, 60, 61, 62, 63, 64, 75, 76, 77, 117, 118, 119, 120, 121, 124, 125, 128, 129, 134, 213, 214, 215, 223, 225, 226, 227, 327, 328, 329, 330, 332, 333, 334, 336, 423, 424, 425, 426, 427, 438, 439, 440]}, {"test_lines": [176, 197], "covered_lines": [47, 48, 49, 50, 51, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 291, 292, 293, 294, 296, 297, 300, 301, 303, 327, 328, 329, 330, 332, 333, 334, 336, 400, 401, 402, 403, 406, 438, 439, 440]}, {"test_lines": [199, 215], "covered_lines": [47, 48, 49, 50, 51, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 291, 292, 293, 296, 297, 300, 301, 303, 327, 328, 329, 330, 332, 333, 334, 336, 400, 401, 402, 403, 406, 438, 439, 440]}, {"test_lines": [217, 228], "covered_lines": [47, 48, 49, 50, 51, 279, 280, 281, 282, 284, 285, 286, 287, 288, 289, 291, 292, 300, 301, 303, 400, 401, 406]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/OtfReadCommon.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgram;\n", "import com.itextpdf.io.source.RandomAccessFileOrArray;\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "\n", "import java.util.ArrayList;\n", "import java.util.Collections;\n", "import java.util.HashSet;\n", "import java.util.List;\n", "import java.util.Set;\n", "\n", "public class OtfReadCommon {\n", "    public static int[] readUShortArray(RandomAccessFileOrArray rf, int size, int location) throws java.io.IOException {\n", "        int[] ret = new int[size];\n", "        for (int k = 0; k < size; ++k) {\n", "            int offset = rf.readUnsignedShort();\n", "            ret[k] = offset == 0 ? offset : offset + location;\n", "        }\n", "        return ret;\n", "    }\n", "\n", "    public static int[] readUShortArray(RandomAccessFileOrArray rf, int size) throws java.io.IOException {\n", "        return readUShortArray(rf, size, 0);\n", "    }\n", "\n", "    public static void readCoverages(RandomAccessFileOrArray rf, int[] locations, List<Set<Integer>> coverage)\n", "            throws java.io.IOException {\n", "        for (int location : locations) {\n", "            coverage.add(new HashSet<>(readCoverageFormat(rf, location)));\n", "        }\n", "    }\n", "\n", "    public static List<Integer> readCoverageFormat(RandomAccessFileOrArray rf, int coverageLocation)\n", "            throws java.io.IOException {\n", "        rf.seek(coverageLocation);\n", "        int coverageFormat = rf.readShort();\n", "        List<Integer> glyphIds;\n", "        if (coverageFormat == 1) {\n", "            int glyphCount = rf.readUnsignedShort();\n", "            glyphIds = new ArrayList<>(glyphCount);\n", "            for (int i = 0; i < glyphCount; i++) {\n", "                int coverageGlyphId = rf.readUnsignedShort();\n", "                glyphIds.add(coverageGlyphId);\n", "            }\n", "        } else if (coverageFormat == 2) {\n", "            int rangeCount = rf.readUnsignedShort();\n", "            glyphIds = new ArrayList<>();\n", "            for (int i = 0; i < rangeCount; i++) {\n", "                readRangeRecord(rf, glyphIds);\n", "            }\n", "\n", "        } else {\n", "            throw new UnsupportedOperationException(\n", "                    MessageFormatUtil.format(\"Invalid coverage format: {0}\", coverageFormat));\n", "        }\n", "\n", "        return Collections.unmodifiableList(glyphIds);\n", "    }\n", "\n", "    private static void readRangeRecord(RandomAccessFileOrArray rf, List<Integer> glyphIds) throws java.io.IOException {\n", "        int startGlyphId = rf.readUnsignedShort();\n", "        int endGlyphId = rf.readUnsignedShort();\n", "        @SuppressWarnings(\"unused\")\n", "        int startCoverageIndex = rf.readShort();\n", "        for (int glyphId = startGlyphId; glyphId <= endGlyphId; glyphId++) {\n", "            glyphIds.add(glyphId);\n", "        }\n", "    }\n", "\n", "    public static GposValueRecord readGposValueRecord(OpenTypeFontTableReader tableReader, int mask)\n", "            throws java.io.IOException {\n", "        GposValueRecord vr = new GposValueRecord();\n", "        if ((mask & 0x0001) != 0) {\n", "            vr.XPlacement =\n", "                    FontProgram.convertGlyphSpaceToTextSpace(tableReader.rf.readShort()) / tableReader.getUnitsPerEm();\n", "        }\n", "        if ((mask & 0x0002) != 0) {\n", "            vr.YPlacement =\n", "                    FontProgram.convertGlyphSpaceToTextSpace(tableReader.rf.readShort()) / tableReader.getUnitsPerEm();\n", "        }\n", "        if ((mask & 0x0004) != 0) {\n", "            vr.XAdvance =\n", "                    FontProgram.convertGlyphSpaceToTextSpace(tableReader.rf.readShort()) / tableReader.getUnitsPerEm();\n", "        }\n", "        if ((mask & 0x0008) != 0) {\n", "            vr.YAdvance =\n", "                    FontProgram.convertGlyphSpaceToTextSpace(tableReader.rf.readShort()) / tableReader.getUnitsPerEm();\n", "        }\n", "        if ((mask & 0x0010) != 0) {\n", "            tableReader.rf.skip(2);\n", "        }\n", "        if ((mask & 0x0020) != 0) {\n", "            tableReader.rf.skip(2);\n", "        }\n", "        if ((mask & 0x0040) != 0) {\n", "            tableReader.rf.skip(2);\n", "        }\n", "        if ((mask & 0x0080) != 0) {\n", "            tableReader.rf.skip(2);\n", "        }\n", "        return vr;\n", "    }\n", "\n", "    public static GposAnchor readGposAnchor(OpenTypeFontTableReader tableReader, int location)\n", "            throws java.io.IOException {\n", "        if (location == 0) {\n", "            return null;\n", "        }\n", "        tableReader.rf.seek(location);\n", "        int format = tableReader.rf.readUnsignedShort();\n", "        GposAnchor t = null;\n", "\n", "        switch (format) {\n", "            default:\n", "                t = new GposAnchor();\n", "                t.XCoordinate = FontProgram.convertGlyphSpaceToTextSpace(tableReader.rf.readShort())\n", "                        / tableReader.getUnitsPerEm();\n", "                t.YCoordinate = FontProgram.convertGlyphSpaceToTextSpace(tableReader.rf.readShort())\n", "                        / tableReader.getUnitsPerEm();\n", "                break;\n", "        }\n", "\n", "        return t;\n", "    }\n", "\n", "    public static List<OtfMarkRecord> readMarkArray(OpenTypeFontTableReader tableReader, int location)\n", "            throws java.io.IOException {\n", "        tableReader.rf.seek(location);\n", "        int markCount = tableReader.rf.readUnsignedShort();\n", "        int[] classes = new int[markCount];\n", "        int[] locations = new int[markCount];\n", "        for (int k = 0; k < markCount; ++k) {\n", "            classes[k] = tableReader.rf.readUnsignedShort();\n", "            int offset = tableReader.rf.readUnsignedShort();\n", "            locations[k] = location + offset;\n", "        }\n", "        List<OtfMarkRecord> marks = new ArrayList<OtfMarkRecord>();\n", "        for (int k = 0; k < markCount; ++k) {\n", "            OtfMarkRecord rec = new OtfMarkRecord();\n", "            rec.markClass = classes[k];\n", "            rec.anchor = readGposAnchor(tableReader, locations[k]);\n", "            marks.add(rec);\n", "        }\n", "        return marks;\n", "    }\n", "\n", "    public static SubstLookupRecord[] readSubstLookupRecords(RandomAccessFileOrArray rf, int substCount)\n", "            throws java.io.IOException {\n", "        SubstLookupRecord[] substLookUpRecords = new SubstLookupRecord[substCount];\n", "        for (int i = 0; i < substCount; ++i) {\n", "            SubstLookupRecord slr = new SubstLookupRecord();\n", "            slr.sequenceIndex = rf.readUnsignedShort();\n", "            slr.lookupListIndex = rf.readUnsignedShort();\n", "            substLookUpRecords[i] = slr;\n", "        }\n", "        return substLookUpRecords;\n", "    }\n", "\n", "    public static PosLookupRecord[] readPosLookupRecords(RandomAccessFileOrArray rf, int recordCount)\n", "            throws java.io.IOException {\n", "        PosLookupRecord[] posLookUpRecords = new PosLookupRecord[recordCount];\n", "        for (int i = 0; i < recordCount; ++i) {\n", "            PosLookupRecord lookupRecord = new PosLookupRecord();\n", "            lookupRecord.sequenceIndex = rf.readUnsignedShort();\n", "            lookupRecord.lookupListIndex = rf.readUnsignedShort();\n", "            posLookUpRecords[i] = lookupRecord;\n", "        }\n", "        return posLookUpRecords;\n", "    }\n", "\n", "    public static GposAnchor[] readAnchorArray(OpenTypeFontTableReader tableReader, int[] locations, int left,\n", "            int right) throws java.io.IOException {\n", "        GposAnchor[] anchors = new GposAnchor[right - left];\n", "        for (int i = left; i < right; i++) {\n", "            anchors[i - left] = readGposAnchor(tableReader, locations[i]);\n", "        }\n", "        return anchors;\n", "    }\n", "\n", "    public static List<GposAnchor[]> readBaseArray(OpenTypeFontTableReader tableReader, int classCount, int location)\n", "            throws java.io.IOException {\n", "        List<GposAnchor[]> baseArray = new ArrayList<>();\n", "        tableReader.rf.seek(location);\n", "        int baseCount = tableReader.rf.readUnsignedShort();\n", "        int[] anchorLocations = readUShortArray(tableReader.rf, baseCount * classCount, location);\n", "        int idx = 0;\n", "        for (int k = 0; k < baseCount; ++k) {\n", "            baseArray.add(readAnchorArray(tableReader, anchorLocations, idx, idx + classCount));\n", "            idx += classCount;\n", "        }\n", "        return baseArray;\n", "    }\n", "\n", "    public static List<List<GposAnchor[]>> readLigatureArray(OpenTypeFontTableReader tableReader, int classCount,\n", "            int location) throws java.io.IOException {\n", "        List<List<GposAnchor[]>> ligatureArray = new ArrayList<>();\n", "        tableReader.rf.seek(location);\n", "        int ligatureCount = tableReader.rf.readUnsignedShort();\n", "        int[] ligatureAttachLocations = readUShortArray(tableReader.rf, ligatureCount, location);\n", "        for (int liga = 0; liga < ligatureCount; ++liga) {\n", "            int ligatureAttachLocation = ligatureAttachLocations[liga];\n", "            List<GposAnchor[]> ligatureAttach = new ArrayList<>();\n", "            tableReader.rf.seek(ligatureAttachLocation);\n", "            int componentCount = tableReader.rf.readUnsignedShort();\n", "            final int[] componentRecordsLocation = readUShortArray(tableReader.rf, classCount * componentCount,\n", "                    ligatureAttachLocation);\n", "            int idx = 0;\n", "            for (int k = 0; k < componentCount; ++k) {\n", "                ligatureAttach.add(readAnchorArray(tableReader, componentRecordsLocation, idx, idx + classCount));\n", "                idx += classCount;\n", "            }\n", "            ligatureArray.add(ligatureAttach);\n", "        }\n", "        return ligatureArray;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgramFactory;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.io.source.IRandomAccessSource;\n", "import com.itextpdf.io.source.RandomAccessFileOrArray;\n", "import com.itextpdf.io.source.RandomAccessSourceFactory;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.util.Map;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "import java.io.IOException;\n", "import java.util.List;\n", "\n", "@Category(UnitTest.class)\n", "public class OtfReadCommonTest extends ExtendedITextTest {\n", "    private static final String RESOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/otf/OtfReadCommonTest/\";\n", "\n", "    private static final String RESOURCE_FOLDER_2 = \"./src/test/resources/com/itextpdf/io/font/otf\"\n", "            + \"/GposLookupType7Test/\";\n", "\n", "    @Test\n", "    public void testReadCoverageFormat1() throws IOException {\n", "        // Based on Example 5 from the specification\n", "        // https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2\n", "        // 0001 0005 0038 003B 0041 1042 A04A\n", "        String path = RESOURCE_FOLDER + \"coverage-format-1.bin\";\n", "        RandomAccessFileOrArray rf = new RandomAccessFileOrArray(\n", "                new RandomAccessSourceFactory().createBestSource(path));\n", "        List<Integer> glyphIds = OtfReadCommon.readCoverageFormat(rf, 0);\n", "        Assert.assertEquals(5, glyphIds.size());\n", "        Assert.assertEquals(0x38, (int) glyphIds.get(0));\n", "        Assert.assertEquals(0x3B, (int) glyphIds.get(1));\n", "        Assert.assertEquals(0x41, (int) glyphIds.get(2));\n", "        Assert.assertEquals(0x1042, (int) glyphIds.get(3));\n", "        Assert.assertEquals(0xA04A, (int) glyphIds.get(4));\n", "    }\n", "\n", "    @Test\n", "    public void testReadCoverageFormat2() throws IOException {\n", "        // Based on Example 6 from the specification\n", "        // https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2\n", "        // 0002 0001 A04E A057 0000\n", "        String path = RESOURCE_FOLDER + \"coverage-format-2.bin\";\n", "        RandomAccessFileOrArray rf = new RandomAccessFileOrArray(\n", "                new RandomAccessSourceFactory().createBestSource(path));\n", "        List<Integer> glyphIds = OtfReadCommon.readCoverageFormat(rf, 0);\n", "        Assert.assertEquals(10, glyphIds.size());\n", "        Assert.assertEquals(0xA04E, (int) glyphIds.get(0));\n", "        Assert.assertEquals(0xA057, (int) glyphIds.get(9));\n", "    }\n", "\n", "    @Test\n", "    public void testConversionGlyphToTextSpace() throws IOException {\n", "        OpenTypeFontTableReaderTest gposTableReader = new OpenTypeFontTableReaderTest(new RandomAccesArrayTest(null), 0,\n", "                null, null, 1);\n", "        // at 15 we fill up all values\n", "        GposValueRecord valueRecord = OtfReadCommon.readGposValueRecord(gposTableReader, 15);\n", "        Assert.assertEquals(2000,valueRecord.XAdvance);\n", "        Assert.assertEquals(2000,valueRecord.XPlacement);\n", "        Assert.assertEquals(2000,valueRecord.YAdvance);\n", "        Assert.assertEquals(2000,valueRecord.YPlacement);\n", "    }\n", "\n", "    class OpenTypeFontTableReaderTest extends OpenTypeFontTableReader {\n", "        protected OpenTypeFontTableReaderTest(RandomAccessFileOrArray rf, int tableLocation,\n", "                OpenTypeGdefTableReader gdef,\n", "                Map<Integer, Glyph> indexGlyphMap, int unitsPerEm) {\n", "            super(rf, tableLocation, gdef, indexGlyphMap, unitsPerEm);\n", "        }\n", "\n", "        @Override\n", "        protected OpenTableLookup readLookupTable(int lookupType, int lookupFlag, int[] subTableLocations)\n", "                throws IOException {\n", "            return null;\n", "        }\n", "    }\n", "\n", "    class RandomAccesArrayTest extends RandomAccessFileOrArray {\n", "\n", "        /**\n", "         * Creates a RandomAccessFileOrArray that wraps the specified byte source.  The byte source will be closed when\n", "         * this RandomAccessFileOrArray is closed.\n", "         *\n", "         * @param byteSource the byte source to wrap\n", "         */\n", "        public RandomAccesArrayTest(IRandomAccessSource byteSource) {\n", "            super(byteSource);\n", "        }\n", "\n", "        @Override\n", "        public short readShort() throws IOException {\n", "            return 2;\n", "        }\n", "\n", "        @Override\n", "        public long skip(long n) {\n", "            return 2;\n", "        }\n", "    }\n", "}\n"], "method_lines_dic": {"OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int,int)": [36, 43], "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int)": [45, 47], "OtfReadCommon::::readCoverages(com.itextpdf.io.source.RandomAccessFileOrArray,int[],java.util.List<java.util.Set<java.lang.Integer>>)": [49, 54], "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)": [56, 81], "OtfReadCommon::::readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List<java.lang.Integer>)": [83, 91], "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)": [93, 125], "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)": [127, 147], "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)": [149, 168], "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)": [170, 180], "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)": [182, 192], "OtfReadCommon::::readAnchorArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[],int,int)": [194, 201], "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)": [203, 215], "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)": [217, 238]}, "test_method_lines_dic": {"OtfReadCommonTest::::testReadCoverageFormat1()": [48, 63], "OtfReadCommonTest::::testReadCoverageFormat2()": [65, 77], "OtfReadCommonTest::::testConversionGlyphToTextSpace()": [79, 89], "OtfReadCommonTest.OpenTypeFontTableReaderTest::::readLookupTable(int,int,int[])": [98, 102], "OtfReadCommonTest.RandomAccesArrayTest::::readShort()": [117, 120], "OtfReadCommonTest.RandomAccesArrayTest::::skip(long)": [122, 125]}, "reverse_method_lines_dic": {"36": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int,int)", "37": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int,int)", "38": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int,int)", "39": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int,int)", "40": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int,int)", "41": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int,int)", "42": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int,int)", "43": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int,int)", "45": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "46": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "47": "OtfReadCommon::::readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "49": "OtfReadCommon::::readCoverages(com.itextpdf.io.source.RandomAccessFileOrArray,int[],java.util.List<java.util.Set<java.lang.Integer>>)", "50": "OtfReadCommon::::readCoverages(com.itextpdf.io.source.RandomAccessFileOrArray,int[],java.util.List<java.util.Set<java.lang.Integer>>)", "51": "OtfReadCommon::::readCoverages(com.itextpdf.io.source.RandomAccessFileOrArray,int[],java.util.List<java.util.Set<java.lang.Integer>>)", "52": "OtfReadCommon::::readCoverages(com.itextpdf.io.source.RandomAccessFileOrArray,int[],java.util.List<java.util.Set<java.lang.Integer>>)", "53": "OtfReadCommon::::readCoverages(com.itextpdf.io.source.RandomAccessFileOrArray,int[],java.util.List<java.util.Set<java.lang.Integer>>)", "54": "OtfReadCommon::::readCoverages(com.itextpdf.io.source.RandomAccessFileOrArray,int[],java.util.List<java.util.Set<java.lang.Integer>>)", "56": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "57": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "58": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "59": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "60": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "61": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "62": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "63": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "64": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "65": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "66": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "67": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "68": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "69": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "70": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "71": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "72": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "73": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "74": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "75": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "76": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "77": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "78": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "79": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "80": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "81": "OtfReadCommon::::readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "83": "OtfReadCommon::::readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List<java.lang.Integer>)", "84": "OtfReadCommon::::readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List<java.lang.Integer>)", "85": "OtfReadCommon::::readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List<java.lang.Integer>)", "86": "OtfReadCommon::::readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List<java.lang.Integer>)", "87": "OtfReadCommon::::readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List<java.lang.Integer>)", "88": "OtfReadCommon::::readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List<java.lang.Integer>)", "89": "OtfReadCommon::::readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List<java.lang.Integer>)", "90": "OtfReadCommon::::readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List<java.lang.Integer>)", "91": "OtfReadCommon::::readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List<java.lang.Integer>)", "93": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "94": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "95": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "96": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "97": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "98": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "99": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "100": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "101": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "102": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "103": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "104": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "105": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "106": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "107": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "108": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "109": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "110": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "111": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "112": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "113": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "114": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "115": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "116": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "117": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "118": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "119": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "120": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "121": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "122": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "123": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "124": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "125": "OtfReadCommon::::readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "127": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "128": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "129": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "130": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "131": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "132": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "133": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "134": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "135": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "136": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "137": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "138": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "139": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "140": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "141": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "142": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "143": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "144": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "145": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "146": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "147": "OtfReadCommon::::readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "149": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "150": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "151": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "152": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "153": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "154": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "155": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "156": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "157": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "158": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "159": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "160": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "161": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "162": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "163": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "164": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "165": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "166": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "167": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "168": "OtfReadCommon::::readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int)", "170": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "171": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "172": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "173": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "174": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "175": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "176": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "177": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "178": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "179": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "180": "OtfReadCommon::::readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "182": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "183": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "184": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "185": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "186": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "187": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "188": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "189": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "190": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "191": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "192": "OtfReadCommon::::readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int)", "194": "OtfReadCommon::::readAnchorArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[],int,int)", "195": "OtfReadCommon::::readAnchorArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[],int,int)", "196": "OtfReadCommon::::readAnchorArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[],int,int)", "197": "OtfReadCommon::::readAnchorArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[],int,int)", "198": "OtfReadCommon::::readAnchorArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[],int,int)", "199": "OtfReadCommon::::readAnchorArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[],int,int)", "200": "OtfReadCommon::::readAnchorArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[],int,int)", "201": "OtfReadCommon::::readAnchorArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[],int,int)", "203": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "204": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "205": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "206": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "207": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "208": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "209": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "210": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "211": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "212": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "213": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "214": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "215": "OtfReadCommon::::readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "217": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "218": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "219": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "220": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "221": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "222": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "223": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "224": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "225": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "226": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "227": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "228": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "229": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "230": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "231": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "232": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "233": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "234": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "235": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "236": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "237": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)", "238": "OtfReadCommon::::readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int)"}, "test_reverse_method_lines_dic": {"48": "OtfReadCommonTest::::testReadCoverageFormat1()", "49": "OtfReadCommonTest::::testReadCoverageFormat1()", "50": "OtfReadCommonTest::::testReadCoverageFormat1()", "51": "OtfReadCommonTest::::testReadCoverageFormat1()", "52": "OtfReadCommonTest::::testReadCoverageFormat1()", "53": "OtfReadCommonTest::::testReadCoverageFormat1()", "54": "OtfReadCommonTest::::testReadCoverageFormat1()", "55": "OtfReadCommonTest::::testReadCoverageFormat1()", "56": "OtfReadCommonTest::::testReadCoverageFormat1()", "57": "OtfReadCommonTest::::testReadCoverageFormat1()", "58": "OtfReadCommonTest::::testReadCoverageFormat1()", "59": "OtfReadCommonTest::::testReadCoverageFormat1()", "60": "OtfReadCommonTest::::testReadCoverageFormat1()", "61": "OtfReadCommonTest::::testReadCoverageFormat1()", "62": "OtfReadCommonTest::::testReadCoverageFormat1()", "63": "OtfReadCommonTest::::testReadCoverageFormat1()", "65": "OtfReadCommonTest::::testReadCoverageFormat2()", "66": "OtfReadCommonTest::::testReadCoverageFormat2()", "67": "OtfReadCommonTest::::testReadCoverageFormat2()", "68": "OtfReadCommonTest::::testReadCoverageFormat2()", "69": "OtfReadCommonTest::::testReadCoverageFormat2()", "70": "OtfReadCommonTest::::testReadCoverageFormat2()", "71": "OtfReadCommonTest::::testReadCoverageFormat2()", "72": "OtfReadCommonTest::::testReadCoverageFormat2()", "73": "OtfReadCommonTest::::testReadCoverageFormat2()", "74": "OtfReadCommonTest::::testReadCoverageFormat2()", "75": "OtfReadCommonTest::::testReadCoverageFormat2()", "76": "OtfReadCommonTest::::testReadCoverageFormat2()", "77": "OtfReadCommonTest::::testReadCoverageFormat2()", "79": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "80": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "81": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "82": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "83": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "84": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "85": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "86": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "87": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "88": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "89": "OtfReadCommonTest::::testConversionGlyphToTextSpace()", "98": "OtfReadCommonTest.OpenTypeFontTableReaderTest::::readLookupTable(int,int,int[])", "99": "OtfReadCommonTest.OpenTypeFontTableReaderTest::::readLookupTable(int,int,int[])", "100": "OtfReadCommonTest.OpenTypeFontTableReaderTest::::readLookupTable(int,int,int[])", "101": "OtfReadCommonTest.OpenTypeFontTableReaderTest::::readLookupTable(int,int,int[])", "102": "OtfReadCommonTest.OpenTypeFontTableReaderTest::::readLookupTable(int,int,int[])", "117": "OtfReadCommonTest.RandomAccesArrayTest::::readShort()", "118": "OtfReadCommonTest.RandomAccesArrayTest::::readShort()", "119": "OtfReadCommonTest.RandomAccesArrayTest::::readShort()", "120": "OtfReadCommonTest.RandomAccesArrayTest::::readShort()", "122": "OtfReadCommonTest.RandomAccesArrayTest::::skip(long)", "123": "OtfReadCommonTest.RandomAccesArrayTest::::skip(long)", "124": "OtfReadCommonTest.RandomAccesArrayTest::::skip(long)", "125": "OtfReadCommonTest.RandomAccesArrayTest::::skip(long)"}, "tests": [{"test_lines": [48, 63], "covered_lines": [58, 59, 61, 62, 63, 64, 65, 66, 68, 80]}, {"test_lines": [65, 77], "covered_lines": [58, 59, 61, 68, 69, 70, 71, 72, 75, 80, 84, 85, 87, 88, 89, 91]}, {"test_lines": [79, 89], "covered_lines": [95, 96, 97, 98, 100, 101, 102, 104, 105, 106, 108, 109, 110, 112, 115, 118, 121, 124]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/GsubLookupType6.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.otf.lookuptype6.SubTableLookup6Format1;\n", "import com.itextpdf.io.font.otf.lookuptype6.SubTableLookup6Format2;\n", "import com.itextpdf.io.font.otf.lookuptype6.SubTableLookup6Format3;\n", "\n", "import java.util.ArrayList;\n", "import java.util.HashMap;\n", "import java.util.HashSet;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "/**\n", " * LookupType 6: Chaining Contextual Substitution Subtable\n", " */\n", "public class GsubLookupType6 extends GsubLookupType5 {\n", "\n", "    protected GsubLookupType6(OpenTypeFontTableReader openReader, int lookupFlag, int[] subTableLocations) throws java.io.IOException {\n", "        super(openReader, lookupFlag, subTableLocations);\n", "    }\n", "\n", "    @Override\n", "    protected void readSubTableFormat1(int subTableLocation) throws java.io.IOException {\n", "        Map<Integer, List<ContextualSubstRule>> substMap = new HashMap<>();\n", "\n", "        int coverageOffset = openReader.rf.readUnsignedShort();\n", "        int chainSubRuleSetCount = openReader.rf.readUnsignedShort();\n", "        int[] chainSubRuleSetOffsets = openReader.readUShortArray(chainSubRuleSetCount, subTableLocation);\n", "\n", "        List<Integer> coverageGlyphIds = openReader.readCoverageFormat(subTableLocation + coverageOffset);\n", "        for (int i = 0; i < chainSubRuleSetCount; ++i) {\n", "            openReader.rf.seek(chainSubRuleSetOffsets[i]);\n", "            int chainSubRuleCount = openReader.rf.readUnsignedShort();\n", "            int[] chainSubRuleOffsets = openReader.readUShortArray(chainSubRuleCount, chainSubRuleSetOffsets[i]);\n", "\n", "            List<ContextualSubstRule> chainSubRuleSet = new ArrayList<>(chainSubRuleCount);\n", "            for (int j = 0; j < chainSubRuleCount; ++j) {\n", "                openReader.rf.seek(chainSubRuleOffsets[j]);\n", "                int backtrackGlyphCount = openReader.rf.readUnsignedShort();\n", "                int[] backtrackGlyphIds = openReader.readUShortArray(backtrackGlyphCount);\n", "                int inputGlyphCount = openReader.rf.readUnsignedShort();\n", "                int[] inputGlyphIds = openReader.readUShortArray(inputGlyphCount - 1);\n", "                int lookAheadGlyphCount = openReader.rf.readUnsignedShort();\n", "                int[] lookAheadGlyphIds = openReader.readUShortArray(lookAheadGlyphCount);\n", "                int substCount = openReader.rf.readUnsignedShort();\n", "                SubstLookupRecord[] substLookupRecords = openReader.readSubstLookupRecords(substCount);\n", "\n", "                chainSubRuleSet.add(new SubTableLookup6Format1.SubstRuleFormat1(backtrackGlyphIds, inputGlyphIds, lookAheadGlyphIds, substLookupRecords));\n", "            }\n", "            substMap.put(coverageGlyphIds.get(i), chainSubRuleSet);\n", "        }\n", "\n", "        subTables.add(new SubTableLookup6Format1(openReader, lookupFlag, substMap));\n", "    }\n", "\n", "    @Override\n", "    protected void readSubTableFormat2(int subTableLocation) throws java.io.IOException {\n", "        int coverageOffset = openReader.rf.readUnsignedShort();\n", "        int backtrackClassDefOffset = openReader.rf.readUnsignedShort();\n", "        int inputClassDefOffset = openReader.rf.readUnsignedShort();\n", "        int lookaheadClassDefOffset = openReader.rf.readUnsignedShort();\n", "        int chainSubClassSetCount = openReader.rf.readUnsignedShort();\n", "        int[] chainSubClassSetOffsets = openReader.readUShortArray(chainSubClassSetCount, subTableLocation);\n", "\n", "        Set<Integer> coverageGlyphIds = new HashSet<>(openReader.readCoverageFormat(subTableLocation + coverageOffset));\n", "        OtfClass backtrackClassDefinition = openReader.readClassDefinition(subTableLocation + backtrackClassDefOffset);\n", "        OtfClass inputClassDefinition = openReader.readClassDefinition(subTableLocation + inputClassDefOffset);\n", "        OtfClass lookaheadClassDefinition = openReader.readClassDefinition(subTableLocation + lookaheadClassDefOffset);\n", "\n", "        SubTableLookup6Format2 t = new SubTableLookup6Format2(openReader, lookupFlag, coverageGlyphIds,\n", "                backtrackClassDefinition, inputClassDefinition, lookaheadClassDefinition);\n", "\n", "        List<List<ContextualSubstRule>> subClassSets = new ArrayList<>(chainSubClassSetCount);\n", "        for (int i = 0; i < chainSubClassSetCount; ++i) {\n", "            List<ContextualSubstRule> subClassSet = null;\n", "            if (chainSubClassSetOffsets[i] != 0) {\n", "                openReader.rf.seek(chainSubClassSetOffsets[i]);\n", "                int chainSubClassRuleCount = openReader.rf.readUnsignedShort();\n", "                int[] chainSubClassRuleOffsets = openReader.readUShortArray(chainSubClassRuleCount, chainSubClassSetOffsets[i]);\n", "\n", "                subClassSet = new ArrayList<>(chainSubClassRuleCount);\n", "                for (int j = 0; j < chainSubClassRuleCount; ++j) {\n", "                    SubTableLookup6Format2.SubstRuleFormat2 rule;\n", "                    openReader.rf.seek(chainSubClassRuleOffsets[j]);\n", "\n", "                    int backtrackClassCount = openReader.rf.readUnsignedShort();\n", "                    int[] backtrackClassIds = openReader.readUShortArray(backtrackClassCount);\n", "                    int inputClassCount = openReader.rf.readUnsignedShort();\n", "                    int[] inputClassIds = openReader.readUShortArray(inputClassCount - 1);\n", "                    int lookAheadClassCount = openReader.rf.readUnsignedShort();\n", "                    int[] lookAheadClassIds = openReader.readUShortArray(lookAheadClassCount);\n", "                    int substCount = openReader.rf.readUnsignedShort();\n", "                    SubstLookupRecord[] substLookupRecords = openReader.readSubstLookupRecords(substCount);\n", "\n", "                    rule = new SubTableLookup6Format2.SubstRuleFormat2(t, backtrackClassIds, inputClassIds, lookAheadClassIds, substLookupRecords);\n", "                    subClassSet.add(rule);\n", "                }\n", "            }\n", "            subClassSets.add(subClassSet);\n", "        }\n", "\n", "        t.setSubClassSets(subClassSets);\n", "        subTables.add(t);\n", "    }\n", "\n", "    @Override\n", "    protected void readSubTableFormat3(int subTableLocation) throws java.io.IOException {\n", "        int backtrackGlyphCount = openReader.rf.readUnsignedShort();\n", "        int[] backtrackCoverageOffsets = openReader.readUShortArray(backtrackGlyphCount, subTableLocation);\n", "        int inputGlyphCount = openReader.rf.readUnsignedShort();\n", "        int[] inputCoverageOffsets = openReader.readUShortArray(inputGlyphCount, subTableLocation);\n", "        int lookaheadGlyphCount = openReader.rf.readUnsignedShort();\n", "        int[] lookaheadCoverageOffsets = openReader.readUShortArray(lookaheadGlyphCount, subTableLocation);\n", "        int substCount = openReader.rf.readUnsignedShort();\n", "        SubstLookupRecord[] substLookupRecords = openReader.readSubstLookupRecords(substCount);\n", "\n", "        List<Set<Integer>> backtrackCoverages = new ArrayList<>(backtrackGlyphCount);\n", "        openReader.readCoverages(backtrackCoverageOffsets, backtrackCoverages);\n", "\n", "        List<Set<Integer>> inputCoverages = new ArrayList<>(inputGlyphCount);\n", "        openReader.readCoverages(inputCoverageOffsets, inputCoverages);\n", "\n", "        List<Set<Integer>> lookaheadCoverages = new ArrayList<>(lookaheadGlyphCount);\n", "        openReader.readCoverages(lookaheadCoverageOffsets, lookaheadCoverages);\n", "\n", "        SubTableLookup6Format3.SubstRuleFormat3 rule =\n", "                new SubTableLookup6Format3.SubstRuleFormat3(backtrackCoverages, inputCoverages, lookaheadCoverages, substLookupRecords);\n", "        subTables.add(new SubTableLookup6Format3(openReader, lookupFlag, rule));\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgramFactory;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.io.IOException;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "public class GsubLookupType6Test extends ExtendedITextTest {\n", "\n", "    private static final String RESOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/otf/GsubLookupType6Test/\";\n", "\n", "    @Test\n", "    public void testSubstitutionApplied() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"Padauk-Regular.ttf\");\n", "        GlyphSubstitutionTableReader gsubTableReader = fontProgram.getGsubTable();\n", "\n", "        List<Glyph> glyphs = Arrays.asList(fontProgram.getGlyphByCode(233),\n", "                fontProgram.getGlyphByCode(167), fontProgram.getGlyphByCode(207),\n", "                fontProgram.getGlyphByCode(149), fontProgram.getGlyphByCode(207),\n", "                fontProgram.getGlyphByCode(186), fontProgram.getGlyphByCode(229),\n", "                fontProgram.getGlyphByCode(248));\n", "\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "\n", "        GsubLookupType6 lookup = (GsubLookupType6) gsubTableReader.getLookupTable(57);\n", "\n", "        Assert.assertEquals(233, gl.get(0).getCode());\n", "        Assert.assertTrue(lookup.transformLine(gl));\n", "        Assert.assertEquals(234, gl.get(0).getCode());\n", "    }\n", "\n", "    @Test\n", "    public void testSubstitutionNotApplied() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"Padauk-Regular.ttf\");\n", "        GlyphSubstitutionTableReader gsubTableReader = fontProgram.getGsubTable();\n", "\n", "        List<Glyph> glyphs = Arrays.asList(fontProgram.getGlyphByCode(233),\n", "                fontProgram.getGlyphByCode(167), fontProgram.getGlyphByCode(207),\n", "                fontProgram.getGlyphByCode(149), fontProgram.getGlyphByCode(207),\n", "                fontProgram.getGlyphByCode(186), fontProgram.getGlyphByCode(229),\n", "                fontProgram.getGlyphByCode(248));\n", "\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "\n", "        GsubLookupType6 lookup = (GsubLookupType6) gsubTableReader.getLookupTable(54);\n", "\n", "        Assert.assertEquals(233, gl.get(0).getCode());\n", "        Assert.assertFalse(lookup.transformLine(gl));\n", "        Assert.assertEquals(233, gl.get(0).getCode());\n", "    }\n", "\n", "\n", "}\n"], "method_lines_dic": {"GsubLookupType6::::readSubTableFormat1(int)": [45, 77], "GsubLookupType6::::readSubTableFormat2(int)": [79, 127], "GsubLookupType6::::readSubTableFormat3(int)": [129, 152]}, "test_method_lines_dic": {"GsubLookupType6Test::::testSubstitutionApplied()": [42, 60], "GsubLookupType6Test::::testSubstitutionNotApplied()": [62, 80]}, "reverse_method_lines_dic": {"45": "GsubLookupType6::::readSubTableFormat1(int)", "46": "GsubLookupType6::::readSubTableFormat1(int)", "47": "GsubLookupType6::::readSubTableFormat1(int)", "48": "GsubLookupType6::::readSubTableFormat1(int)", "49": "GsubLookupType6::::readSubTableFormat1(int)", "50": "GsubLookupType6::::readSubTableFormat1(int)", "51": "GsubLookupType6::::readSubTableFormat1(int)", "52": "GsubLookupType6::::readSubTableFormat1(int)", "53": "GsubLookupType6::::readSubTableFormat1(int)", "54": "GsubLookupType6::::readSubTableFormat1(int)", "55": "GsubLookupType6::::readSubTableFormat1(int)", "56": "GsubLookupType6::::readSubTableFormat1(int)", "57": "GsubLookupType6::::readSubTableFormat1(int)", "58": "GsubLookupType6::::readSubTableFormat1(int)", "59": "GsubLookupType6::::readSubTableFormat1(int)", "60": "GsubLookupType6::::readSubTableFormat1(int)", "61": "GsubLookupType6::::readSubTableFormat1(int)", "62": "GsubLookupType6::::readSubTableFormat1(int)", "63": "GsubLookupType6::::readSubTableFormat1(int)", "64": "GsubLookupType6::::readSubTableFormat1(int)", "65": "GsubLookupType6::::readSubTableFormat1(int)", "66": "GsubLookupType6::::readSubTableFormat1(int)", "67": "GsubLookupType6::::readSubTableFormat1(int)", "68": "GsubLookupType6::::readSubTableFormat1(int)", "69": "GsubLookupType6::::readSubTableFormat1(int)", "70": "GsubLookupType6::::readSubTableFormat1(int)", "71": "GsubLookupType6::::readSubTableFormat1(int)", "72": "GsubLookupType6::::readSubTableFormat1(int)", "73": "GsubLookupType6::::readSubTableFormat1(int)", "74": "GsubLookupType6::::readSubTableFormat1(int)", "75": "GsubLookupType6::::readSubTableFormat1(int)", "76": "GsubLookupType6::::readSubTableFormat1(int)", "77": "GsubLookupType6::::readSubTableFormat1(int)", "79": "GsubLookupType6::::readSubTableFormat2(int)", "80": "GsubLookupType6::::readSubTableFormat2(int)", "81": "GsubLookupType6::::readSubTableFormat2(int)", "82": "GsubLookupType6::::readSubTableFormat2(int)", "83": "GsubLookupType6::::readSubTableFormat2(int)", "84": "GsubLookupType6::::readSubTableFormat2(int)", "85": "GsubLookupType6::::readSubTableFormat2(int)", "86": "GsubLookupType6::::readSubTableFormat2(int)", "87": "GsubLookupType6::::readSubTableFormat2(int)", "88": "GsubLookupType6::::readSubTableFormat2(int)", "89": "GsubLookupType6::::readSubTableFormat2(int)", "90": "GsubLookupType6::::readSubTableFormat2(int)", "91": "GsubLookupType6::::readSubTableFormat2(int)", "92": "GsubLookupType6::::readSubTableFormat2(int)", "93": "GsubLookupType6::::readSubTableFormat2(int)", "94": "GsubLookupType6::::readSubTableFormat2(int)", "95": "GsubLookupType6::::readSubTableFormat2(int)", "96": "GsubLookupType6::::readSubTableFormat2(int)", "97": "GsubLookupType6::::readSubTableFormat2(int)", "98": "GsubLookupType6::::readSubTableFormat2(int)", "99": "GsubLookupType6::::readSubTableFormat2(int)", "100": "GsubLookupType6::::readSubTableFormat2(int)", "101": "GsubLookupType6::::readSubTableFormat2(int)", "102": "GsubLookupType6::::readSubTableFormat2(int)", "103": "GsubLookupType6::::readSubTableFormat2(int)", "104": "GsubLookupType6::::readSubTableFormat2(int)", "105": "GsubLookupType6::::readSubTableFormat2(int)", "106": "GsubLookupType6::::readSubTableFormat2(int)", "107": "GsubLookupType6::::readSubTableFormat2(int)", "108": "GsubLookupType6::::readSubTableFormat2(int)", "109": "GsubLookupType6::::readSubTableFormat2(int)", "110": "GsubLookupType6::::readSubTableFormat2(int)", "111": "GsubLookupType6::::readSubTableFormat2(int)", "112": "GsubLookupType6::::readSubTableFormat2(int)", "113": "GsubLookupType6::::readSubTableFormat2(int)", "114": "GsubLookupType6::::readSubTableFormat2(int)", "115": "GsubLookupType6::::readSubTableFormat2(int)", "116": "GsubLookupType6::::readSubTableFormat2(int)", "117": "GsubLookupType6::::readSubTableFormat2(int)", "118": "GsubLookupType6::::readSubTableFormat2(int)", "119": "GsubLookupType6::::readSubTableFormat2(int)", "120": "GsubLookupType6::::readSubTableFormat2(int)", "121": "GsubLookupType6::::readSubTableFormat2(int)", "122": "GsubLookupType6::::readSubTableFormat2(int)", "123": "GsubLookupType6::::readSubTableFormat2(int)", "124": "GsubLookupType6::::readSubTableFormat2(int)", "125": "GsubLookupType6::::readSubTableFormat2(int)", "126": "GsubLookupType6::::readSubTableFormat2(int)", "127": "GsubLookupType6::::readSubTableFormat2(int)", "129": "GsubLookupType6::::readSubTableFormat3(int)", "130": "GsubLookupType6::::readSubTableFormat3(int)", "131": "GsubLookupType6::::readSubTableFormat3(int)", "132": "GsubLookupType6::::readSubTableFormat3(int)", "133": "GsubLookupType6::::readSubTableFormat3(int)", "134": "GsubLookupType6::::readSubTableFormat3(int)", "135": "GsubLookupType6::::readSubTableFormat3(int)", "136": "GsubLookupType6::::readSubTableFormat3(int)", "137": "GsubLookupType6::::readSubTableFormat3(int)", "138": "GsubLookupType6::::readSubTableFormat3(int)", "139": "GsubLookupType6::::readSubTableFormat3(int)", "140": "GsubLookupType6::::readSubTableFormat3(int)", "141": "GsubLookupType6::::readSubTableFormat3(int)", "142": "GsubLookupType6::::readSubTableFormat3(int)", "143": "GsubLookupType6::::readSubTableFormat3(int)", "144": "GsubLookupType6::::readSubTableFormat3(int)", "145": "GsubLookupType6::::readSubTableFormat3(int)", "146": "GsubLookupType6::::readSubTableFormat3(int)", "147": "GsubLookupType6::::readSubTableFormat3(int)", "148": "GsubLookupType6::::readSubTableFormat3(int)", "149": "GsubLookupType6::::readSubTableFormat3(int)", "150": "GsubLookupType6::::readSubTableFormat3(int)", "151": "GsubLookupType6::::readSubTableFormat3(int)", "152": "GsubLookupType6::::readSubTableFormat3(int)"}, "test_reverse_method_lines_dic": {"42": "GsubLookupType6Test::::testSubstitutionApplied()", "43": "GsubLookupType6Test::::testSubstitutionApplied()", "44": "GsubLookupType6Test::::testSubstitutionApplied()", "45": "GsubLookupType6Test::::testSubstitutionApplied()", "46": "GsubLookupType6Test::::testSubstitutionApplied()", "47": "GsubLookupType6Test::::testSubstitutionApplied()", "48": "GsubLookupType6Test::::testSubstitutionApplied()", "49": "GsubLookupType6Test::::testSubstitutionApplied()", "50": "GsubLookupType6Test::::testSubstitutionApplied()", "51": "GsubLookupType6Test::::testSubstitutionApplied()", "52": "GsubLookupType6Test::::testSubstitutionApplied()", "53": "GsubLookupType6Test::::testSubstitutionApplied()", "54": "GsubLookupType6Test::::testSubstitutionApplied()", "55": "GsubLookupType6Test::::testSubstitutionApplied()", "56": "GsubLookupType6Test::::testSubstitutionApplied()", "57": "GsubLookupType6Test::::testSubstitutionApplied()", "58": "GsubLookupType6Test::::testSubstitutionApplied()", "59": "GsubLookupType6Test::::testSubstitutionApplied()", "60": "GsubLookupType6Test::::testSubstitutionApplied()", "62": "GsubLookupType6Test::::testSubstitutionNotApplied()", "63": "GsubLookupType6Test::::testSubstitutionNotApplied()", "64": "GsubLookupType6Test::::testSubstitutionNotApplied()", "65": "GsubLookupType6Test::::testSubstitutionNotApplied()", "66": "GsubLookupType6Test::::testSubstitutionNotApplied()", "67": "GsubLookupType6Test::::testSubstitutionNotApplied()", "68": "GsubLookupType6Test::::testSubstitutionNotApplied()", "69": "GsubLookupType6Test::::testSubstitutionNotApplied()", "70": "GsubLookupType6Test::::testSubstitutionNotApplied()", "71": "GsubLookupType6Test::::testSubstitutionNotApplied()", "72": "GsubLookupType6Test::::testSubstitutionNotApplied()", "73": "GsubLookupType6Test::::testSubstitutionNotApplied()", "74": "GsubLookupType6Test::::testSubstitutionNotApplied()", "75": "GsubLookupType6Test::::testSubstitutionNotApplied()", "76": "GsubLookupType6Test::::testSubstitutionNotApplied()", "77": "GsubLookupType6Test::::testSubstitutionNotApplied()", "78": "GsubLookupType6Test::::testSubstitutionNotApplied()", "79": "GsubLookupType6Test::::testSubstitutionNotApplied()", "80": "GsubLookupType6Test::::testSubstitutionNotApplied()"}, "tests": [{"test_lines": [42, 60], "covered_lines": [42, 43, 47, 49, 50, 51, 53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 73, 76, 77, 131, 132, 133, 134, 135, 136, 137, 138, 140, 141, 143, 144, 146, 147, 149, 151, 152]}, {"test_lines": [62, 80], "covered_lines": [42, 43, 47, 49, 50, 51, 53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 73, 76, 77, 131, 132, 133, 134, 135, 136, 137, 138, 140, 141, 143, 144, 146, 147, 149, 151, 152]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/OpenTypeFontTableReader.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.util.IntHashtable;\n", "import com.itextpdf.io.source.RandomAccessFileOrArray;\n", "\n", "import java.util.ArrayList;\n", "import java.util.HashSet;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "public abstract class OpenTypeFontTableReader {\n", "\n", "    protected final RandomAccessFileOrArray rf;\n", "\tprotected final int tableLocation;\n", "\n", "    protected List<OpenTableLookup> lookupList;\n", "    protected OpenTypeScript scriptsType;\n", "    protected OpenTypeFeature featuresType;\n", "    private final Map<Integer, Glyph> indexGlyphMap;\n", "    private final OpenTypeGdefTableReader gdef;\n", "\n", "    private final int unitsPerEm;\n", "\n", "\tprotected OpenTypeFontTableReader(RandomAccessFileOrArray rf, int tableLocation, OpenTypeGdefTableReader gdef,\n", "                                   Map<Integer, Glyph> indexGlyphMap, int unitsPerEm) {\n", "\t\tthis.rf = rf;\n", "\t\tthis.tableLocation = tableLocation;\n", "        this.indexGlyphMap = indexGlyphMap;\n", "        this.gdef = gdef;\n", "        this.unitsPerEm = unitsPerEm;\n", "\t}\n", "\n", "    public Glyph getGlyph(int index) {\n", "        return indexGlyphMap.get(index);\n", "    }\n", "\n", "    public OpenTableLookup getLookupTable(int idx) {\n", "        if (idx < 0 || idx >= lookupList.size()) {\n", "            return null;\n", "        }\n", "        return lookupList.get(idx);\n", "    }\n", "\n", "    public List<ScriptRecord> getScriptRecords() {\n", "        return scriptsType.getScriptRecords();\n", "    }\n", "\n", "    public List<FeatureRecord> getFeatureRecords() {\n", "        return featuresType.getRecords();\n", "    }\n", "\n", "    public List<FeatureRecord> getFeatures(String[] scripts, String language) {\n", "        LanguageRecord rec = scriptsType.getLanguageRecord(scripts, language);\n", "        if (rec == null) {\n", "            return null;\n", "        }\n", "        List<FeatureRecord> ret = new ArrayList<FeatureRecord>();\n", "        for (int f : rec.features) {\n", "            ret.add(featuresType.getRecord(f));\n", "        }\n", "        return ret;\n", "    }\n", "\n", "    public List<FeatureRecord> getSpecificFeatures(List<FeatureRecord> features, String[] specific) {\n", "        if (specific == null) {\n", "            return features;\n", "        }\n", "        Set<String> hs = new HashSet<String>();\n", "        //noinspection ManualArrayToCollectionCopy\n", "        for (String s : specific) {\n", "            hs.add(s);\n", "        }\n", "        List<FeatureRecord> recs = new ArrayList<FeatureRecord>();\n", "        for (FeatureRecord rec : features) {\n", "            if (hs.contains(rec.tag)) {\n", "                recs.add(rec);\n", "            }\n", "        }\n", "        return recs;\n", "    }\n", "\n", "    public FeatureRecord getRequiredFeature(String[] scripts, String language) {\n", "        LanguageRecord rec = scriptsType.getLanguageRecord(scripts, language);\n", "        if (rec == null)\n", "            return null;\n", "        return featuresType.getRecord(rec.featureRequired);\n", "    }\n", "\n", "    public List<OpenTableLookup> getLookups(FeatureRecord[] features) {\n", "        IntHashtable hash = new IntHashtable();\n", "        for (FeatureRecord rec : features) {\n", "            for (int idx : rec.lookups) {\n", "                hash.put(idx, 1);\n", "            }\n", "        }\n", "        List<OpenTableLookup> ret = new ArrayList<>();\n", "        for (int idx : hash.toOrderedKeys()) {\n", "            ret.add(lookupList.get(idx));\n", "        }\n", "        return ret;\n", "    }\n", "\n", "    public List<OpenTableLookup> getLookups(FeatureRecord feature) {\n", "        List<OpenTableLookup> ret = new ArrayList<>(feature.lookups.length);\n", "        for (int idx : feature.lookups) {\n", "            ret.add(lookupList.get(idx));\n", "        }\n", "        return ret;\n", "    }\n", "\n", "    public boolean isSkip(int glyph, int flag) {\n", "        return gdef.isSkip(glyph, flag);\n", "    }\n", "\n", "    public int getGlyphClass(int glyphCode) {\n", "        return gdef.getGlyphClassTable().getOtfClass(glyphCode);\n", "    }\n", "\n", "    public int getUnitsPerEm() {\n", "        return unitsPerEm;\n", "    }\n", "\n", "    public LanguageRecord getLanguageRecord(String otfScriptTag) {\n", "        return getLanguageRecord(otfScriptTag, null);\n", "    }\n", "\n", "    public LanguageRecord getLanguageRecord(String otfScriptTag, String langTag) {\n", "        if (otfScriptTag == null) {\n", "            return null;\n", "        }\n", "        for (final ScriptRecord record : getScriptRecords()) {\n", "            if (!otfScriptTag.equals(record.tag)) {\n", "                continue;\n", "            }\n", "            if (langTag == null) {\n", "                return record.defaultLanguage;\n", "            }\n", "            for (final LanguageRecord lang : record.languages) {\n", "                if (langTag.equals(lang.tag)) {\n", "                    return lang;\n", "                }\n", "            }\n", "        }\n", "        return null;\n", "    }\n", "\n", "\tprotected abstract OpenTableLookup readLookupTable(int lookupType, int lookupFlag, int[] subTableLocations)\n", "\t\t\tthrows java.io.IOException;\n", "\n", "    protected final OtfClass readClassDefinition(int classLocation) {\n", "        return OtfClass.create(rf, classLocation);\n", "    }\n", "\n", "    protected final int[] readUShortArray(int size, int location) throws java.io.IOException {\n", "        return OtfReadCommon.readUShortArray(rf, size, location);\n", "    }\n", "\n", "    protected final int[] readUShortArray(int size) throws java.io.IOException {\n", "        return OtfReadCommon.readUShortArray(rf, size);\n", "    }\n", "\n", "    protected void readCoverages(int[] locations, List<Set<Integer>> coverage) throws java.io.IOException {\n", "        OtfReadCommon.readCoverages(rf, locations, coverage);\n", "    }\n", "\n", "\tprotected final List<Integer> readCoverageFormat(int coverageLocation)\n", "\t\t\tthrows java.io.IOException {\n", "        return OtfReadCommon.readCoverageFormat(rf, coverageLocation);\n", "\t}\n", "\n", "    protected SubstLookupRecord[] readSubstLookupRecords(int substCount) throws java.io.IOException {\n", "        return OtfReadCommon.readSubstLookupRecords(rf, substCount);\n", "    }\n", "\n", "    protected PosLookupRecord[] readPosLookupRecords(int substCount) throws java.io.IOException {\n", "        return OtfReadCommon.readPosLookupRecords(rf, substCount);\n", "    }\n", "\n", "    protected TagAndLocation[] readTagAndLocations(int baseLocation) throws java.io.IOException {\n", "        int count = rf.readUnsignedShort();\n", "        TagAndLocation[] tagslLocs = new TagAndLocation[count];\n", "        for (int k = 0; k < count; ++k) {\n", "            TagAndLocation tl = new TagAndLocation();\n", "            tl.tag = rf.readString(4, \"utf-8\");\n", "            tl.location = rf.readUnsignedShort() + baseLocation;\n", "            tagslLocs[k] = tl;\n", "        }\n", "        return tagslLocs;\n", "    }\n", "\n", "    /**\n", "     * This is the starting point of the class. A sub-class must call this\n", "     * method to start getting call backs to the {@link #readLookupTable(int, int, int[])}\n", "     * method.\n", "     * @throws FontReadingException\n", "     */\n", "    final void startReadingTable() throws FontReadingException {\n", "        try {\n", "            rf.seek(tableLocation);\n", "            /*int version =*/\n", "            // version not used\n", "            rf.readInt();\n", "            int scriptListOffset = rf.readUnsignedShort();\n", "            int featureListOffset = rf.readUnsignedShort();\n", "            int lookupListOffset = rf.readUnsignedShort();\n", "            // read the Script tables\n", "            scriptsType = new OpenTypeScript(this, tableLocation + scriptListOffset);\n", "            // read Feature table\n", "            featuresType = new OpenTypeFeature(this, tableLocation + featureListOffset);\n", "            // read LookUpList table\n", "            readLookupListTable(tableLocation + lookupListOffset);\n", "        } catch (java.io.IOException e) {\n", "            throw new FontReadingException(\"Error reading font file\", e);\n", "        }\n", "    }\n", "\n", "    private void readLookupListTable(int lookupListTableLocation) throws java.io.IOException {\n", "        lookupList = new ArrayList<>();\n", "        rf.seek(lookupListTableLocation);\n", "        int lookupCount = rf.readUnsignedShort();\n", "        int[] lookupTableLocations = readUShortArray(lookupCount, lookupListTableLocation);\n", "        // read LookUp tables\n", "        for (int lookupLocation : lookupTableLocations) {\n", "\n", "            // be tolerant to NULL offset in LookupList table\n", "            if (lookupLocation == 0) {\n", "                continue;\n", "            }\n", "            readLookupTable(lookupLocation);\n", "        }\n", "    }\n", "\n", "    private void readLookupTable(int lookupTableLocation) throws java.io.IOException {\n", "        rf.seek(lookupTableLocation);\n", "        int lookupType = rf.readUnsignedShort();\n", "        int lookupFlag = rf.readUnsignedShort();\n", "        int subTableCount = rf.readUnsignedShort();\n", "        int[] subTableLocations = readUShortArray(subTableCount, lookupTableLocation);\n", "        lookupList.add(readLookupTable(lookupType, lookupFlag, subTableLocations));\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgramFactory;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "import java.io.IOException;\n", "\n", "@Category(UnitTest.class)\n", "public class OpenTypeFontTableReaderTest extends ExtendedITextTest {\n", "    private static final String RESOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/otf/OpenTypeFontTableReaderTest/\";\n", "\n", "    @Test\n", "    public void testFetchLangSysByTag() throws IOException {\n", "\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"NotoSansMyanmar-Regular.ttf\");\n", "\n", "        GlyphSubstitutionTableReader gsub = fontProgram.getGsubTable();\n", "        ScriptRecord mym2 = gsub.getScriptRecords().get(0);\n", "\n", "        Assert.assertEquals(\"mym2\", mym2.tag);\n", "        // default LangSys has no tag\n", "        Assert.assertEquals(\"\", gsub.getLanguageRecord(\"mym2\").tag);\n", "        Assert.assertEquals(LanguageTags.SGAW_KAREN, gsub.getLanguageRecord(\"mym2\", LanguageTags.SGAW_KAREN).tag);\n", "        Assert.assertEquals(LanguageTags.MON, gsub.getLanguageRecord(\"mym2\", LanguageTags.MON).tag);\n", "\n", "        Assert.assertNull(gsub.getLanguageRecord(null));\n", "        Assert.assertNull(gsub.getLanguageRecord(\"mym3\"));\n", "        Assert.assertNull(gsub.getLanguageRecord(\"mym3\", LanguageTags.SGAW_KAREN));\n", "    }\n", "\n", "\n", "    @Test\n", "    public void testGetLookupsArray() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"NotoSansMyanmar-Regular.ttf\");\n", "        GlyphSubstitutionTableReader gsub = fontProgram.getGsubTable();\n", "        FeatureRecord firstRecord = new FeatureRecord();\n", "        firstRecord.lookups = new int[]{5, 2};\n", "        firstRecord.tag = \"1\";\n", "        FeatureRecord secondRecord = new FeatureRecord();\n", "        secondRecord.lookups = new int[]{4, 10};\n", "        secondRecord.tag = \"2\";\n", "        FeatureRecord[] records = new FeatureRecord[]{firstRecord, secondRecord};\n", "\n", "        int[] lookupsLocations = gsub.getLookups(firstRecord).stream().mapToInt(record -> record.subTableLocations[0]).toArray();\n", "        int[] expected = new int[]{142610, 142436};\n", "        Assert.assertArrayEquals(expected, lookupsLocations);\n", "\n", "        lookupsLocations = gsub.getLookups(records).stream().mapToInt(record -> record.subTableLocations[0]).toArray();\n", "        expected = new int[]{142436, 142538, 142610, 143908};\n", "        Assert.assertArrayEquals(expected, lookupsLocations);\n", "    }\n", "}\n"], "method_lines_dic": {"OpenTypeFontTableReader::::getGlyph(int)": [56, 58], "OpenTypeFontTableReader::::getLookupTable(int)": [60, 65], "OpenTypeFontTableReader::::getScriptRecords()": [67, 69], "OpenTypeFontTableReader::::getFeatureRecords()": [71, 73], "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)": [75, 85], "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])": [87, 103], "OpenTypeFontTableReader::::getRequiredFeature(java.lang.String[],java.lang.String)": [105, 110], "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])": [112, 124], "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord)": [126, 132], "OpenTypeFontTableReader::::isSkip(int,int)": [134, 136], "OpenTypeFontTableReader::::getGlyphClass(int)": [138, 140], "OpenTypeFontTableReader::::getUnitsPerEm()": [142, 144], "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String)": [146, 148], "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)": [150, 168], "OpenTypeFontTableReader::::readLookupTable(int,int,int[])": [170, 171], "OpenTypeFontTableReader::::readClassDefinition(int)": [173, 175], "OpenTypeFontTableReader::::readUShortArray(int,int)": [177, 179], "OpenTypeFontTableReader::::readUShortArray(int)": [181, 183], "OpenTypeFontTableReader::::readCoverages(int[],java.util.List<java.util.Set<java.lang.Integer>>)": [185, 187], "OpenTypeFontTableReader::::readCoverageFormat(int)": [189, 192], "OpenTypeFontTableReader::::readSubstLookupRecords(int)": [194, 196], "OpenTypeFontTableReader::::readPosLookupRecords(int)": [198, 200], "OpenTypeFontTableReader::::readTagAndLocations(int)": [202, 212], "OpenTypeFontTableReader::::startReadingTable()": [220, 238], "OpenTypeFontTableReader::::readLookupListTable(int)": [240, 254], "OpenTypeFontTableReader::::readLookupTable(int)": [256, 263]}, "test_method_lines_dic": {"OpenTypeFontTableReaderTest::::testFetchLangSysByTag()": [41, 58], "OpenTypeFontTableReaderTest::::testGetLookupsArray()": [61, 80]}, "reverse_method_lines_dic": {"56": "OpenTypeFontTableReader::::getGlyph(int)", "57": "OpenTypeFontTableReader::::getGlyph(int)", "58": "OpenTypeFontTableReader::::getGlyph(int)", "60": "OpenTypeFontTableReader::::getLookupTable(int)", "61": "OpenTypeFontTableReader::::getLookupTable(int)", "62": "OpenTypeFontTableReader::::getLookupTable(int)", "63": "OpenTypeFontTableReader::::getLookupTable(int)", "64": "OpenTypeFontTableReader::::getLookupTable(int)", "65": "OpenTypeFontTableReader::::getLookupTable(int)", "67": "OpenTypeFontTableReader::::getScriptRecords()", "68": "OpenTypeFontTableReader::::getScriptRecords()", "69": "OpenTypeFontTableReader::::getScriptRecords()", "71": "OpenTypeFontTableReader::::getFeatureRecords()", "72": "OpenTypeFontTableReader::::getFeatureRecords()", "73": "OpenTypeFontTableReader::::getFeatureRecords()", "75": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "76": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "77": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "78": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "79": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "80": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "81": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "82": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "83": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "84": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "85": "OpenTypeFontTableReader::::getFeatures(java.lang.String[],java.lang.String)", "87": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "88": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "89": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "90": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "91": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "92": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "93": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "94": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "95": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "96": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "97": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "98": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "99": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "100": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "101": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "102": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "103": "OpenTypeFontTableReader::::getSpecificFeatures(java.util.List<com.itextpdf.io.font.otf.FeatureRecord>,java.lang.String[])", "105": "OpenTypeFontTableReader::::getRequiredFeature(java.lang.String[],java.lang.String)", "106": "OpenTypeFontTableReader::::getRequiredFeature(java.lang.String[],java.lang.String)", "107": "OpenTypeFontTableReader::::getRequiredFeature(java.lang.String[],java.lang.String)", "108": "OpenTypeFontTableReader::::getRequiredFeature(java.lang.String[],java.lang.String)", "109": "OpenTypeFontTableReader::::getRequiredFeature(java.lang.String[],java.lang.String)", "110": "OpenTypeFontTableReader::::getRequiredFeature(java.lang.String[],java.lang.String)", "112": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "113": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "114": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "115": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "116": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "117": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "118": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "119": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "120": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "121": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "122": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "123": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "124": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord[])", "126": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord)", "127": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord)", "128": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord)", "129": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord)", "130": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord)", "131": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord)", "132": "OpenTypeFontTableReader::::getLookups(com.itextpdf.io.font.otf.FeatureRecord)", "134": "OpenTypeFontTableReader::::isSkip(int,int)", "135": "OpenTypeFontTableReader::::isSkip(int,int)", "136": "OpenTypeFontTableReader::::isSkip(int,int)", "138": "OpenTypeFontTableReader::::getGlyphClass(int)", "139": "OpenTypeFontTableReader::::getGlyphClass(int)", "140": "OpenTypeFontTableReader::::getGlyphClass(int)", "142": "OpenTypeFontTableReader::::getUnitsPerEm()", "143": "OpenTypeFontTableReader::::getUnitsPerEm()", "144": "OpenTypeFontTableReader::::getUnitsPerEm()", "146": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String)", "147": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String)", "148": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String)", "150": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "151": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "152": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "153": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "154": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "155": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "156": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "157": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "158": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "159": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "160": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "161": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "162": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "163": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "164": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "165": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "166": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "167": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "168": "OpenTypeFontTableReader::::getLanguageRecord(java.lang.String,java.lang.String)", "170": "OpenTypeFontTableReader::::readLookupTable(int,int,int[])", "171": "OpenTypeFontTableReader::::readLookupTable(int,int,int[])", "173": "OpenTypeFontTableReader::::readClassDefinition(int)", "174": "OpenTypeFontTableReader::::readClassDefinition(int)", "175": "OpenTypeFontTableReader::::readClassDefinition(int)", "177": "OpenTypeFontTableReader::::readUShortArray(int,int)", "178": "OpenTypeFontTableReader::::readUShortArray(int,int)", "179": "OpenTypeFontTableReader::::readUShortArray(int,int)", "181": "OpenTypeFontTableReader::::readUShortArray(int)", "182": "OpenTypeFontTableReader::::readUShortArray(int)", "183": "OpenTypeFontTableReader::::readUShortArray(int)", "185": "OpenTypeFontTableReader::::readCoverages(int[],java.util.List<java.util.Set<java.lang.Integer>>)", "186": "OpenTypeFontTableReader::::readCoverages(int[],java.util.List<java.util.Set<java.lang.Integer>>)", "187": "OpenTypeFontTableReader::::readCoverages(int[],java.util.List<java.util.Set<java.lang.Integer>>)", "189": "OpenTypeFontTableReader::::readCoverageFormat(int)", "190": "OpenTypeFontTableReader::::readCoverageFormat(int)", "191": "OpenTypeFontTableReader::::readCoverageFormat(int)", "192": "OpenTypeFontTableReader::::readCoverageFormat(int)", "194": "OpenTypeFontTableReader::::readSubstLookupRecords(int)", "195": "OpenTypeFontTableReader::::readSubstLookupRecords(int)", "196": "OpenTypeFontTableReader::::readSubstLookupRecords(int)", "198": "OpenTypeFontTableReader::::readPosLookupRecords(int)", "199": "OpenTypeFontTableReader::::readPosLookupRecords(int)", "200": "OpenTypeFontTableReader::::readPosLookupRecords(int)", "202": "OpenTypeFontTableReader::::readTagAndLocations(int)", "203": "OpenTypeFontTableReader::::readTagAndLocations(int)", "204": "OpenTypeFontTableReader::::readTagAndLocations(int)", "205": "OpenTypeFontTableReader::::readTagAndLocations(int)", "206": "OpenTypeFontTableReader::::readTagAndLocations(int)", "207": "OpenTypeFontTableReader::::readTagAndLocations(int)", "208": "OpenTypeFontTableReader::::readTagAndLocations(int)", "209": "OpenTypeFontTableReader::::readTagAndLocations(int)", "210": "OpenTypeFontTableReader::::readTagAndLocations(int)", "211": "OpenTypeFontTableReader::::readTagAndLocations(int)", "212": "OpenTypeFontTableReader::::readTagAndLocations(int)", "220": "OpenTypeFontTableReader::::startReadingTable()", "221": "OpenTypeFontTableReader::::startReadingTable()", "222": "OpenTypeFontTableReader::::startReadingTable()", "223": "OpenTypeFontTableReader::::startReadingTable()", "224": "OpenTypeFontTableReader::::startReadingTable()", "225": "OpenTypeFontTableReader::::startReadingTable()", "226": "OpenTypeFontTableReader::::startReadingTable()", "227": "OpenTypeFontTableReader::::startReadingTable()", "228": "OpenTypeFontTableReader::::startReadingTable()", "229": "OpenTypeFontTableReader::::startReadingTable()", "230": "OpenTypeFontTableReader::::startReadingTable()", "231": "OpenTypeFontTableReader::::startReadingTable()", "232": "OpenTypeFontTableReader::::startReadingTable()", "233": "OpenTypeFontTableReader::::startReadingTable()", "234": "OpenTypeFontTableReader::::startReadingTable()", "235": "OpenTypeFontTableReader::::startReadingTable()", "236": "OpenTypeFontTableReader::::startReadingTable()", "237": "OpenTypeFontTableReader::::startReadingTable()", "238": "OpenTypeFontTableReader::::startReadingTable()", "240": "OpenTypeFontTableReader::::readLookupListTable(int)", "241": "OpenTypeFontTableReader::::readLookupListTable(int)", "242": "OpenTypeFontTableReader::::readLookupListTable(int)", "243": "OpenTypeFontTableReader::::readLookupListTable(int)", "244": "OpenTypeFontTableReader::::readLookupListTable(int)", "245": "OpenTypeFontTableReader::::readLookupListTable(int)", "246": "OpenTypeFontTableReader::::readLookupListTable(int)", "247": "OpenTypeFontTableReader::::readLookupListTable(int)", "248": "OpenTypeFontTableReader::::readLookupListTable(int)", "249": "OpenTypeFontTableReader::::readLookupListTable(int)", "250": "OpenTypeFontTableReader::::readLookupListTable(int)", "251": "OpenTypeFontTableReader::::readLookupListTable(int)", "252": "OpenTypeFontTableReader::::readLookupListTable(int)", "253": "OpenTypeFontTableReader::::readLookupListTable(int)", "254": "OpenTypeFontTableReader::::readLookupListTable(int)", "256": "OpenTypeFontTableReader::::readLookupTable(int)", "257": "OpenTypeFontTableReader::::readLookupTable(int)", "258": "OpenTypeFontTableReader::::readLookupTable(int)", "259": "OpenTypeFontTableReader::::readLookupTable(int)", "260": "OpenTypeFontTableReader::::readLookupTable(int)", "261": "OpenTypeFontTableReader::::readLookupTable(int)", "262": "OpenTypeFontTableReader::::readLookupTable(int)", "263": "OpenTypeFontTableReader::::readLookupTable(int)"}, "test_reverse_method_lines_dic": {"41": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "42": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "43": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "44": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "45": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "46": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "47": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "48": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "49": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "50": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "51": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "52": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "53": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "54": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "55": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "56": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "57": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "58": "OpenTypeFontTableReaderTest::::testFetchLangSysByTag()", "61": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "62": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "63": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "64": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "65": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "66": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "67": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "68": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "69": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "70": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "71": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "72": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "73": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "74": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "75": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "76": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "77": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "78": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "79": "OpenTypeFontTableReaderTest::::testGetLookupsArray()", "80": "OpenTypeFontTableReaderTest::::testGetLookupsArray()"}, "tests": [{"test_lines": [41, 58], "covered_lines": [48, 49, 50, 51, 52, 53, 54, 68, 143, 147, 151, 152, 154, 155, 156, 158, 159, 161, 162, 163, 167, 174, 178, 182, 191, 195, 199, 203, 204, 205, 206, 207, 208, 209, 211, 222, 225, 226, 227, 228, 230, 232, 234, 237, 238, 241, 242, 243, 244, 246, 249, 252, 254, 257, 258, 259, 260, 261, 262, 263]}, {"test_lines": [61, 80], "covered_lines": [48, 49, 50, 51, 52, 53, 54, 113, 114, 115, 116, 119, 120, 121, 123, 127, 128, 129, 131, 143, 174, 178, 182, 191, 195, 199, 203, 204, 205, 206, 207, 208, 209, 211, 222, 225, 226, 227, 228, 230, 232, 234, 237, 238, 241, 242, 243, 244, 246, 249, 252, 254, 257, 258, 259, 260, 261, 262, 263]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/GsubLookupType4.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import java.util.ArrayList;\n", "import java.util.HashMap;\n", "import java.util.List;\n", "import java.util.Map;\n", "\n", "/**\n", " * LookupType 4: Ligature Substitution Subtable\n", " */\n", "public class GsubLookupType4 extends OpenTableLookup {\n", "    /**\n", "     * The key is the first character. The first element in the int array is the\n", "     * output ligature\n", "     */\n", "    private Map<Integer,List<int[]>> ligatures;\n", "    \n", "    public GsubLookupType4(OpenTypeFontTableReader openReader, int lookupFlag, int[] subTableLocations) throws java.io.IOException {\n", "        super(openReader, lookupFlag, subTableLocations);\n", "        ligatures = new HashMap<>();\n", "        readSubTables();\n", "    }\n", "    \n", "    @Override\n", "    public boolean transformOne(GlyphLine line) {\n", "        if (line.idx >= line.end)\n", "            return false;\n", "        boolean changed = false;\n", "        Glyph g = line.get(line.idx);\n", "        boolean match = false;\n", "        if (ligatures.containsKey(g.getCode()) && !openReader.isSkip(g.getCode(), lookupFlag)) {\n", "            GlyphIndexer gidx = new GlyphIndexer();\n", "            gidx.line = line;\n", "            List<int[]> ligs = ligatures.get(g.getCode());\n", "            for (int[] lig : ligs) {\n", "                match = true;\n", "                gidx.idx = line.idx;\n", "                for (int j = 1; j < lig.length; ++j) {\n", "                    gidx.nextGlyph(openReader, lookupFlag);\n", "                    if (gidx.glyph == null || gidx.glyph.getCode() != lig[j]) {\n", "                        match = false;\n", "                        break;\n", "                    }\n", "                }\n", "                if (match) {\n", "                    line.substituteManyToOne(openReader, lookupFlag, lig.length - 1, lig[0]);\n", "                    break;\n", "                }\n", "            }\n", "        }\n", "        if (match) {\n", "            changed = true;\n", "        }\n", "        line.idx++;\n", "        return changed;\n", "    }\n", "\n", "    @Override\n", "    protected void readSubTable(int subTableLocation) throws java.io.IOException {\n", "        openReader.rf.seek(subTableLocation);\n", "        // subformat - always 1\n", "        openReader.rf.readShort();\n", "        int coverage = openReader.rf.readUnsignedShort() + subTableLocation;\n", "        int ligSetCount = openReader.rf.readUnsignedShort();\n", "        int[] ligatureSet = new int[ligSetCount];\n", "        for (int k = 0; k < ligSetCount; ++k) {\n", "            ligatureSet[k] = openReader.rf.readUnsignedShort() + subTableLocation;\n", "        }\n", "        List<Integer> coverageGlyphIds = openReader.readCoverageFormat(coverage);\n", "        for (int k = 0; k < ligSetCount; ++k) {\n", "            openReader.rf.seek(ligatureSet[k]);\n", "            int ligatureCount = openReader.rf.readUnsignedShort();\n", "            int[] ligature = new int[ligatureCount];\n", "            for (int j = 0; j < ligatureCount; ++j) {\n", "                ligature[j] = openReader.rf.readUnsignedShort() + ligatureSet[k];\n", "            }\n", "            List<int[]> components = new ArrayList<>(ligatureCount);\n", "            for (int j = 0; j < ligatureCount; ++j) {\n", "                openReader.rf.seek(ligature[j]);\n", "                int ligGlyph = openReader.rf.readUnsignedShort();\n", "                int compCount = openReader.rf.readUnsignedShort();\n", "                int[] component = new int[compCount];\n", "                component[0] = ligGlyph;\n", "                for (int i = 1; i < compCount; ++i) {\n", "                    component[i] = openReader.rf.readUnsignedShort();\n", "                }\n", "                components.add(component);\n", "            }\n", "            ligatures.put(coverageGlyphIds.get(k), components);\n", "        }\n", "    }    \n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgramFactory;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.io.IOException;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "public class GsubLookupType4Test extends ExtendedITextTest {\n", "\n", "    private static final String RESOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/otf/GsubLookupType4Test/\";\n", "\n", "    @Test\n", "    public void testNoIndexOutOfBound() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"DejaVuSansMono.ttf\");\n", "        GlyphSubstitutionTableReader gsubTableReader = fontProgram.getGsubTable();\n", "\n", "        List<Glyph> glyphs = Arrays.asList(new Glyph(1, 1, 1),\n", "                                           new Glyph(1, 1, 1),\n", "                                           new Glyph(1, 1, 1),\n", "                                           new Glyph(1, 1, 1),\n", "                                           new Glyph(1, 1, 1),\n", "                                           new Glyph(1, 1, 1));\n", "\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "        gl.idx = gl.end;\n", "\n", "        GsubLookupType4 lookup = (GsubLookupType4) gsubTableReader.getLookupTable(6);\n", "\n", "        //Assert that no exception is thrown if gl.idx = gl.end\n", "        Assert.assertFalse(lookup.transformOne(gl));\n", "    }\n", "}\n"], "method_lines_dic": {"GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)": [46, 78], "GsubLookupType4::::readSubTable(int)": [80, 113]}, "test_method_lines_dic": {"GsubLookupType4Test::::testNoIndexOutOfBound()": [42, 61]}, "reverse_method_lines_dic": {"46": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "47": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "48": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "49": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "50": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "51": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "52": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "53": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "54": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "55": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "56": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "57": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "58": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "59": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "60": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "61": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "62": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "63": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "64": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "65": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "66": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "67": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "68": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "69": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "70": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "71": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "72": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "73": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "74": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "75": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "76": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "77": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "78": "GsubLookupType4::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "80": "GsubLookupType4::::readSubTable(int)", "81": "GsubLookupType4::::readSubTable(int)", "82": "GsubLookupType4::::readSubTable(int)", "83": "GsubLookupType4::::readSubTable(int)", "84": "GsubLookupType4::::readSubTable(int)", "85": "GsubLookupType4::::readSubTable(int)", "86": "GsubLookupType4::::readSubTable(int)", "87": "GsubLookupType4::::readSubTable(int)", "88": "GsubLookupType4::::readSubTable(int)", "89": "GsubLookupType4::::readSubTable(int)", "90": "GsubLookupType4::::readSubTable(int)", "91": "GsubLookupType4::::readSubTable(int)", "92": "GsubLookupType4::::readSubTable(int)", "93": "GsubLookupType4::::readSubTable(int)", "94": "GsubLookupType4::::readSubTable(int)", "95": "GsubLookupType4::::readSubTable(int)", "96": "GsubLookupType4::::readSubTable(int)", "97": "GsubLookupType4::::readSubTable(int)", "98": "GsubLookupType4::::readSubTable(int)", "99": "GsubLookupType4::::readSubTable(int)", "100": "GsubLookupType4::::readSubTable(int)", "101": "GsubLookupType4::::readSubTable(int)", "102": "GsubLookupType4::::readSubTable(int)", "103": "GsubLookupType4::::readSubTable(int)", "104": "GsubLookupType4::::readSubTable(int)", "105": "GsubLookupType4::::readSubTable(int)", "106": "GsubLookupType4::::readSubTable(int)", "107": "GsubLookupType4::::readSubTable(int)", "108": "GsubLookupType4::::readSubTable(int)", "109": "GsubLookupType4::::readSubTable(int)", "110": "GsubLookupType4::::readSubTable(int)", "111": "GsubLookupType4::::readSubTable(int)", "112": "GsubLookupType4::::readSubTable(int)", "113": "GsubLookupType4::::readSubTable(int)"}, "test_reverse_method_lines_dic": {"42": "GsubLookupType4Test::::testNoIndexOutOfBound()", "43": "GsubLookupType4Test::::testNoIndexOutOfBound()", "44": "GsubLookupType4Test::::testNoIndexOutOfBound()", "45": "GsubLookupType4Test::::testNoIndexOutOfBound()", "46": "GsubLookupType4Test::::testNoIndexOutOfBound()", "47": "GsubLookupType4Test::::testNoIndexOutOfBound()", "48": "GsubLookupType4Test::::testNoIndexOutOfBound()", "49": "GsubLookupType4Test::::testNoIndexOutOfBound()", "50": "GsubLookupType4Test::::testNoIndexOutOfBound()", "51": "GsubLookupType4Test::::testNoIndexOutOfBound()", "52": "GsubLookupType4Test::::testNoIndexOutOfBound()", "53": "GsubLookupType4Test::::testNoIndexOutOfBound()", "54": "GsubLookupType4Test::::testNoIndexOutOfBound()", "55": "GsubLookupType4Test::::testNoIndexOutOfBound()", "56": "GsubLookupType4Test::::testNoIndexOutOfBound()", "57": "GsubLookupType4Test::::testNoIndexOutOfBound()", "58": "GsubLookupType4Test::::testNoIndexOutOfBound()", "59": "GsubLookupType4Test::::testNoIndexOutOfBound()", "60": "GsubLookupType4Test::::testNoIndexOutOfBound()", "61": "GsubLookupType4Test::::testNoIndexOutOfBound()"}, "tests": [{"test_lines": [42, 61], "covered_lines": [41, 42, 43, 44, 48, 49, 82, 84, 85, 86, 87, 88, 89, 91, 92, 93, 94, 95, 96, 97, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109, 111, 113]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/OpenTypeGdefTableReader.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.source.RandomAccessFileOrArray;\n", "\n", "\n", "public class OpenTypeGdefTableReader {\n", "    static final int FLAG_IGNORE_BASE = 2;\n", "    static final int FLAG_IGNORE_LIGATURE = 4;\n", "    static final int FLAG_IGNORE_MARK = 8;\n", "\n", "    private final int tableLocation;\n", "    private final RandomAccessFileOrArray rf;\n", "    private OtfClass glyphClass;\n", "    private OtfClass markAttachmentClass;\n", "    \n", "    public OpenTypeGdefTableReader(RandomAccessFileOrArray rf, int tableLocation) {\n", "        this.rf = rf;\n", "        this.tableLocation = tableLocation;\n", "    }\n", "    \n", "    public void readTable() throws java.io.IOException {\n", "        if (tableLocation > 0) {\n", "            rf.seek(tableLocation);\n", "            // version, we only support 0x00010000\n", "            rf.readUnsignedInt();\n", "            int glyphClassDefOffset = rf.readUnsignedShort();\n", "            // skip Attachment Point List Table\n", "            rf.readUnsignedShort();\n", "            // skip Ligature Caret List Table\n", "            rf.readUnsignedShort();\n", "            int markAttachClassDefOffset = rf.readUnsignedShort();\n", "            if (glyphClassDefOffset > 0) {\n", "                glyphClass = OtfClass.create(rf, glyphClassDefOffset + tableLocation);\n", "            }\n", "            if (markAttachClassDefOffset > 0) {\n", "                markAttachmentClass = OtfClass.create(rf, markAttachClassDefOffset + tableLocation);\n", "            }\n", "        }\n", "    }\n", "    \n", "    public boolean isSkip(int glyph, int flag) {\n", "        if (glyphClass != null && (flag & (FLAG_IGNORE_BASE | FLAG_IGNORE_LIGATURE | FLAG_IGNORE_MARK)) != 0) {\n", "            int cla = glyphClass.getOtfClass(glyph);\n", "            if (cla == OtfClass.GLYPH_BASE && (flag & FLAG_IGNORE_BASE) != 0) {\n", "                return true;\n", "            }\n", "            if (cla == OtfClass.GLYPH_MARK && (flag & FLAG_IGNORE_MARK) != 0) {\n", "                return true;\n", "            }\n", "            if (cla == OtfClass.GLYPH_LIGATURE && (flag & FLAG_IGNORE_LIGATURE) != 0) {\n", "                return true;\n", "            }\n", "        }\n", "        int markAttachmentType = (flag >> 8);\n", "        // If MarkAttachmentType is non-zero, then mark attachment classes must be defined in the\n", "        // Mark Attachment Class Definition Table in the GDEF table. When processing glyph sequences,\n", "        // a lookup must ignore any mark glyphs that are not in the specified mark attachment class;\n", "        // only marks of the specified type are processed.\n", "        if (markAttachmentType != 0 && glyphClass != null) {\n", "            int currentGlyphClass = glyphClass.getOtfClass(glyph);\n", "            // Will be 0 in case the class is not defined for this particular glyph\n", "            int glyphMarkAttachmentClass = markAttachmentClass != null ? markAttachmentClass.getOtfClass(glyph) : 0;\n", "            return currentGlyphClass == OtfClass.GLYPH_MARK && glyphMarkAttachmentClass != markAttachmentType;\n", "        }\n", "        return false;\n", "    }\n", "\n", "    public OtfClass getGlyphClassTable() {\n", "        return glyphClass;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgramFactory;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.io.IOException;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "public class OpenTypeGdefTableReaderTest extends ExtendedITextTest {\n", "    private static final String RESOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/otf/OpenTypeGdefTableReaderTest/\";\n", "\n", "    @Test\n", "    public void testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass() throws IOException {\n", "        String fontName = \"Padauk-Regular.ttf\";\n", "        TrueTypeFont fontProgram = (TrueTypeFont)FontProgramFactory.createFont(RESOURCE_FOLDER + fontName);\n", "        OpenTypeGdefTableReader gdef = fontProgram.getGdefTable();\n", "        int glyphCode = 207;\n", "        Assert.assertEquals(OtfClass.GLYPH_MARK, gdef.getGlyphClassTable().getOtfClass(glyphCode));\n", "        Assert.assertTrue(gdef.isSkip(glyphCode, (1 << 8) | OpenTypeGdefTableReader.FLAG_IGNORE_BASE));\n", "    }\n", "\n", "    @Test\n", "    public void testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass() throws IOException {\n", "        String fontName = \"Padauk-Regular.ttf\";\n", "        TrueTypeFont fontProgram = (TrueTypeFont)FontProgramFactory.createFont(RESOURCE_FOLDER + fontName);\n", "        OpenTypeGdefTableReader gdef = fontProgram.getGdefTable();\n", "        int glyphCode = 151;\n", "        Assert.assertEquals(OtfClass.GLYPH_MARK, gdef.getGlyphClassTable().getOtfClass(glyphCode));\n", "        Assert.assertFalse(gdef.isSkip(glyphCode, (1 << 8) | OpenTypeGdefTableReader.FLAG_IGNORE_BASE));\n", "    }\n", "\n", "    @Test\n", "    public void testLookupFlagWithMarkAttachmentTypeAndBaseGlyph() throws IOException {\n", "        String fontName = \"Padauk-Regular.ttf\";\n", "        TrueTypeFont fontProgram = (TrueTypeFont)FontProgramFactory.createFont(RESOURCE_FOLDER + fontName);\n", "        OpenTypeGdefTableReader gdef = fontProgram.getGdefTable();\n", "        int glyphCode = 165;\n", "        Assert.assertEquals(OtfClass.GLYPH_BASE, gdef.getGlyphClassTable().getOtfClass(glyphCode));\n", "        Assert.assertFalse(gdef.isSkip(glyphCode, (1 << 8)));\n", "    }\n", "\n", "}\n"], "method_lines_dic": {"OpenTypeGdefTableReader::::readTable()": [43, 61], "OpenTypeGdefTableReader::::isSkip(int,int)": [63, 88], "OpenTypeGdefTableReader::::getGlyphClassTable()": [90, 92]}, "test_method_lines_dic": {"OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass()": [39, 47], "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass()": [49, 57], "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndBaseGlyph()": [59, 67]}, "reverse_method_lines_dic": {"43": "OpenTypeGdefTableReader::::readTable()", "44": "OpenTypeGdefTableReader::::readTable()", "45": "OpenTypeGdefTableReader::::readTable()", "46": "OpenTypeGdefTableReader::::readTable()", "47": "OpenTypeGdefTableReader::::readTable()", "48": "OpenTypeGdefTableReader::::readTable()", "49": "OpenTypeGdefTableReader::::readTable()", "50": "OpenTypeGdefTableReader::::readTable()", "51": "OpenTypeGdefTableReader::::readTable()", "52": "OpenTypeGdefTableReader::::readTable()", "53": "OpenTypeGdefTableReader::::readTable()", "54": "OpenTypeGdefTableReader::::readTable()", "55": "OpenTypeGdefTableReader::::readTable()", "56": "OpenTypeGdefTableReader::::readTable()", "57": "OpenTypeGdefTableReader::::readTable()", "58": "OpenTypeGdefTableReader::::readTable()", "59": "OpenTypeGdefTableReader::::readTable()", "60": "OpenTypeGdefTableReader::::readTable()", "61": "OpenTypeGdefTableReader::::readTable()", "63": "OpenTypeGdefTableReader::::isSkip(int,int)", "64": "OpenTypeGdefTableReader::::isSkip(int,int)", "65": "OpenTypeGdefTableReader::::isSkip(int,int)", "66": "OpenTypeGdefTableReader::::isSkip(int,int)", "67": "OpenTypeGdefTableReader::::isSkip(int,int)", "68": "OpenTypeGdefTableReader::::isSkip(int,int)", "69": "OpenTypeGdefTableReader::::isSkip(int,int)", "70": "OpenTypeGdefTableReader::::isSkip(int,int)", "71": "OpenTypeGdefTableReader::::isSkip(int,int)", "72": "OpenTypeGdefTableReader::::isSkip(int,int)", "73": "OpenTypeGdefTableReader::::isSkip(int,int)", "74": "OpenTypeGdefTableReader::::isSkip(int,int)", "75": "OpenTypeGdefTableReader::::isSkip(int,int)", "76": "OpenTypeGdefTableReader::::isSkip(int,int)", "77": "OpenTypeGdefTableReader::::isSkip(int,int)", "78": "OpenTypeGdefTableReader::::isSkip(int,int)", "79": "OpenTypeGdefTableReader::::isSkip(int,int)", "80": "OpenTypeGdefTableReader::::isSkip(int,int)", "81": "OpenTypeGdefTableReader::::isSkip(int,int)", "82": "OpenTypeGdefTableReader::::isSkip(int,int)", "83": "OpenTypeGdefTableReader::::isSkip(int,int)", "84": "OpenTypeGdefTableReader::::isSkip(int,int)", "85": "OpenTypeGdefTableReader::::isSkip(int,int)", "86": "OpenTypeGdefTableReader::::isSkip(int,int)", "87": "OpenTypeGdefTableReader::::isSkip(int,int)", "88": "OpenTypeGdefTableReader::::isSkip(int,int)", "90": "OpenTypeGdefTableReader::::getGlyphClassTable()", "91": "OpenTypeGdefTableReader::::getGlyphClassTable()", "92": "OpenTypeGdefTableReader::::getGlyphClassTable()"}, "test_reverse_method_lines_dic": {"39": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass()", "40": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass()", "41": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass()", "42": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass()", "43": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass()", "44": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass()", "45": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass()", "46": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass()", "47": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithoutMarkAttachmentClass()", "49": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass()", "50": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass()", "51": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass()", "52": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass()", "53": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass()", "54": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass()", "55": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass()", "56": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass()", "57": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndMarkGlyphWithSameMarkAttachmentClass()", "59": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndBaseGlyph()", "60": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndBaseGlyph()", "61": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndBaseGlyph()", "62": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndBaseGlyph()", "63": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndBaseGlyph()", "64": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndBaseGlyph()", "65": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndBaseGlyph()", "66": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndBaseGlyph()", "67": "OpenTypeGdefTableReaderTest::::testLookupFlagWithMarkAttachmentTypeAndBaseGlyph()"}, "tests": [{"test_lines": [39, 47], "covered_lines": [38, 39, 40, 41, 44, 45, 47, 48, 50, 52, 53, 54, 55, 57, 58, 61, 64, 65, 66, 69, 72, 76, 81, 82, 84, 85, 91]}, {"test_lines": [49, 57], "covered_lines": [38, 39, 40, 41, 44, 45, 47, 48, 50, 52, 53, 54, 55, 57, 58, 61, 64, 65, 66, 69, 72, 76, 81, 82, 84, 85, 91]}, {"test_lines": [59, 67], "covered_lines": [38, 39, 40, 41, 44, 45, 47, 48, 50, 52, 53, 54, 55, 57, 58, 61, 64, 76, 81, 82, 84, 85, 91]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/GposLookupType8.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format1;\n", "import com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format1.PosRuleFormat1;\n", "import com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format2;\n", "import com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format2.PosRuleFormat2;\n", "import com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format3;\n", "\n", "import java.util.ArrayList;\n", "import java.util.Collections;\n", "import java.util.HashMap;\n", "import java.util.HashSet;\n", "import java.util.List;\n", "import java.util.Map;\n", "import java.util.Set;\n", "\n", "/**\n", " * Lookup Type 8:\n", " * Chaining Contextual Positioning Subtable\n", " */\n", "public class GposLookupType8 extends GposLookupType7 {\n", "\n", "    protected GposLookupType8(OpenTypeFontTableReader openReader, int lookupFlag, int[] subTableLocations)\n", "            throws IOException, java.io.IOException {\n", "        super(openReader, lookupFlag, subTableLocations);\n", "        subTables = new ArrayList<>();\n", "        readSubTables();\n", "    }\n", "\n", "    @Override\n", "    protected void readSubTable(int subTableLocation) throws java.io.IOException {\n", "        openReader.rf.seek(subTableLocation);\n", "        int substFormat = openReader.rf.readShort();\n", "        switch (substFormat) {\n", "            case 1:\n", "                readSubTableFormat1(subTableLocation);\n", "                break;\n", "            case 2:\n", "                readSubTableFormat2(subTableLocation);\n", "                break;\n", "            case 3:\n", "                readSubTableFormat3(subTableLocation);\n", "                break;\n", "            default:\n", "                throw new IllegalArgumentException(\"Bad subtable format identifier: \" + substFormat);\n", "        }\n", "    }\n", "\n", "    @Override\n", "    protected void readSubTableFormat2(int subTableLocation) throws java.io.IOException {\n", "        int coverageOffset = openReader.rf.readUnsignedShort();\n", "        int backtrackClassDefOffset = openReader.rf.readUnsignedShort();\n", "        int inputClassDefOffset = openReader.rf.readUnsignedShort();\n", "        int lookaheadClassDefOffset = openReader.rf.readUnsignedShort();\n", "        int chainPosClassSetCount = openReader.rf.readUnsignedShort();\n", "        int[] chainPosClassSetOffsets = openReader.readUShortArray(chainPosClassSetCount, subTableLocation);\n", "\n", "        Set<Integer> coverageGlyphIds = new HashSet<>(openReader.readCoverageFormat(subTableLocation + coverageOffset));\n", "        OtfClass backtrackClassDefinition = openReader.readClassDefinition(subTableLocation + backtrackClassDefOffset);\n", "        OtfClass inputClassDefinition = openReader.readClassDefinition(subTableLocation + inputClassDefOffset);\n", "        OtfClass lookaheadClassDefinition = openReader.readClassDefinition(subTableLocation + lookaheadClassDefOffset);\n", "\n", "        PosTableLookup8Format2 t = new PosTableLookup8Format2(openReader, lookupFlag, coverageGlyphIds,\n", "                backtrackClassDefinition, inputClassDefinition, lookaheadClassDefinition);\n", "\n", "        for (int i = 0; i < chainPosClassSetCount; ++i) {\n", "                List<ContextualPositionRule> posClassSet = Collections.<ContextualPositionRule>emptyList();\n", "            if (chainPosClassSetOffsets[i] != 0) {\n", "                openReader.rf.seek(chainPosClassSetOffsets[i]);\n", "                int chainPosClassRuleCount = openReader.rf.readUnsignedShort();\n", "                int[] chainPosClassRuleOffsets =\n", "                        openReader.readUShortArray(chainPosClassRuleCount, chainPosClassSetOffsets[i]);\n", "\n", "                posClassSet = new ArrayList<>(chainPosClassRuleCount);\n", "                for (int j = 0; j < chainPosClassRuleCount; ++j) {\n", "                    openReader.rf.seek(chainPosClassRuleOffsets[j]);\n", "\n", "                    int backtrackClassCount = openReader.rf.readUnsignedShort();\n", "                    int[] backtrackClassIds = openReader.readUShortArray(backtrackClassCount);\n", "                    int inputClassCount = openReader.rf.readUnsignedShort();\n", "                    int[] inputClassIds = openReader.readUShortArray(inputClassCount - 1);\n", "                    int lookAheadClassCount = openReader.rf.readUnsignedShort();\n", "                    int[] lookAheadClassIds = openReader.readUShortArray(lookAheadClassCount);\n", "                    int substCount = openReader.rf.readUnsignedShort();\n", "                    PosLookupRecord[] posLookupRecords = openReader.readPosLookupRecords(substCount);\n", "\n", "                    PosRuleFormat2 rule = new PosRuleFormat2(t, backtrackClassIds, inputClassIds, lookAheadClassIds, posLookupRecords);\n", "                    posClassSet.add(rule);\n", "                }\n", "            }\n", "            t.addPosClassSet(posClassSet);\n", "        }\n", "\n", "        subTables.add(t);\n", "    }\n", "\n", "    private void readSubTableFormat1(int subTableLocation) throws java.io.IOException {\n", "        Map<Integer, List<ContextualPositionRule>> posMap = new HashMap<>();\n", "\n", "        int coverageOffset = openReader.rf.readUnsignedShort();\n", "        int chainPosRuleSetCount = openReader.rf.readUnsignedShort();\n", "        int[] chainPosRuleSetOffsets = openReader.readUShortArray(chainPosRuleSetCount, subTableLocation);\n", "\n", "        List<Integer> coverageGlyphIds = openReader.readCoverageFormat(subTableLocation + coverageOffset);\n", "        for (int i = 0; i < chainPosRuleSetCount; ++i) {\n", "            openReader.rf.seek(chainPosRuleSetOffsets[i]);\n", "            int chainPosRuleCount = openReader.rf.readUnsignedShort();\n", "            int[] chainPosRuleOffsets = openReader.readUShortArray(chainPosRuleCount, chainPosRuleSetOffsets[i]);\n", "\n", "            List<ContextualPositionRule> chainPosRuleSet = new ArrayList<>(chainPosRuleCount);\n", "            for (int j = 0; j < chainPosRuleCount; ++j) {\n", "                openReader.rf.seek(chainPosRuleOffsets[j]);\n", "                int backtrackGlyphCount = openReader.rf.readUnsignedShort();\n", "                int[] backtrackGlyphIds = openReader.readUShortArray(backtrackGlyphCount);\n", "                int inputGlyphCount = openReader.rf.readUnsignedShort();\n", "                int[] inputGlyphIds = openReader.readUShortArray(inputGlyphCount - 1);\n", "                int lookAheadGlyphCount = openReader.rf.readUnsignedShort();\n", "                int[] lookAheadGlyphIds = openReader.readUShortArray(lookAheadGlyphCount);\n", "                int posCount = openReader.rf.readUnsignedShort();\n", "                PosLookupRecord[] posLookupRecords = openReader.readPosLookupRecords(posCount);\n", "\n", "                chainPosRuleSet.add(new PosRuleFormat1(backtrackGlyphIds, inputGlyphIds, lookAheadGlyphIds,\n", "                        posLookupRecords));\n", "            }\n", "            posMap.put(coverageGlyphIds.get(i), chainPosRuleSet);\n", "        }\n", "\n", "        subTables.add(new PosTableLookup8Format1(openReader, lookupFlag, posMap));\n", "    }\n", "\n", "    private void readSubTableFormat3(int subTableLocation) throws java.io.IOException {\n", "        int backtrackGlyphCount = openReader.rf.readUnsignedShort();\n", "        int[] backtrackCoverageOffsets = openReader.readUShortArray(backtrackGlyphCount, subTableLocation);\n", "        int inputGlyphCount = openReader.rf.readUnsignedShort();\n", "        int[] inputCoverageOffsets = openReader.readUShortArray(inputGlyphCount, subTableLocation);\n", "        int lookaheadGlyphCount = openReader.rf.readUnsignedShort();\n", "        int[] lookaheadCoverageOffsets = openReader.readUShortArray(lookaheadGlyphCount, subTableLocation);\n", "        int posCount = openReader.rf.readUnsignedShort();\n", "        PosLookupRecord[] posLookupRecords = openReader.readPosLookupRecords(posCount);\n", "\n", "        List<Set<Integer>> backtrackCoverages = new ArrayList<>(backtrackGlyphCount);\n", "        openReader.readCoverages(backtrackCoverageOffsets, backtrackCoverages);\n", "\n", "        List<Set<Integer>> inputCoverages = new ArrayList<>(inputGlyphCount);\n", "        openReader.readCoverages(inputCoverageOffsets, inputCoverages);\n", "\n", "        List<Set<Integer>> lookaheadCoverages = new ArrayList<>(lookaheadGlyphCount);\n", "        openReader.readCoverages(lookaheadCoverageOffsets, lookaheadCoverages);\n", "\n", "        PosTableLookup8Format3.PosRuleFormat3 rule = new PosTableLookup8Format3.PosRuleFormat3(backtrackCoverages,\n", "                inputCoverages, lookaheadCoverages, posLookupRecords);\n", "        subTables.add(new PosTableLookup8Format3(openReader, lookupFlag, rule));\n", "    }\n", "\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgramFactory;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.io.IOException;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "public class GposLookupType8Test extends ExtendedITextTest {\n", "\n", "    private static final String RESOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/otf/GposLookupType8Test/\";\n", "\n", "    @Test\n", "    public void verifyXAdvanceIsAppliedForContextualPositioning() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"Padauk-Regular.ttf\");\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "\n", "        List<Glyph> glyphs = Arrays.asList(fontProgram.getGlyphByCode(233), fontProgram.getGlyphByCode(163),\n", "                fontProgram.getGlyphByCode(158), fontProgram.getGlyphByCode(227));\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "\n", "        GposLookupType8 lookup = (GposLookupType8) gposTableReader.getLookupTable(92);\n", "\n", "        Assert.assertEquals(0, gl.get(2).getXAdvance());\n", "        Assert.assertTrue(lookup.transformLine(gl));\n", "        Assert.assertEquals(28, gl.get(2).getXAdvance());\n", "    }\n", "\n", "    @Test\n", "    public void verifyXAdvanceIsAppliedForPosTableLookup8Format2() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"NotoSansMyanmar-Regular.ttf\");\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "\n", "        List<Glyph> glyphs = Arrays.asList(fontProgram.getGlyphByCode(29),\n", "                fontProgram.getGlyphByCode(26),\n", "                fontProgram.getGlyphByCode(431),\n", "                fontProgram.getGlyphByCode(415),\n", "                fontProgram.getGlyphByCode(199),\n", "                fontProgram.getGlyphByCode(26),\n", "                fontProgram.getGlyphByCode(407),\n", "                fontProgram.getGlyphByCode(210),\n", "                fontProgram.getGlyphByCode(417));\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "\n", "        GposLookupType8 lookup = (GposLookupType8) gposTableReader.getLookupTable(0);\n", "\n", "        Assert.assertEquals(0, gl.get(1).getXAdvance());\n", "        Assert.assertTrue(lookup.transformLine(gl));\n", "        Assert.assertEquals(134, gl.get(1).getXAdvance());\n", "    }\n", "\n", "    @Test\n", "    public void verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"Padauk-Regular.ttf\");\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "\n", "        List<Glyph> glyphs = Arrays.asList(fontProgram.getGlyphByCode(233), fontProgram.getGlyphByCode(163),\n", "                fontProgram.getGlyphByCode(158), fontProgram.getGlyphByCode(233));\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "\n", "        GposLookupType8 lookup = (GposLookupType8) gposTableReader.getLookupTable(92);\n", "\n", "        Assert.assertFalse(lookup.transformLine(gl));\n", "        for (int i = 0; i < gl.size(); i++) {\n", "            Assert.assertEquals(0, gl.get(i).getXAdvance());\n", "            Assert.assertEquals(0, gl.get(i).getYAdvance());\n", "        }\n", "    }\n", "\n", "}\n"], "method_lines_dic": {"GposLookupType8::::readSubTable(int)": [53, 70], "GposLookupType8::::readSubTableFormat2(int)": [72, 118], "GposLookupType8::::readSubTableFormat1(int)": [120, 152], "GposLookupType8::::readSubTableFormat3(int)": [154, 176]}, "test_method_lines_dic": {"GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()": [42, 56], "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()": [58, 79], "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()": [81, 97]}, "reverse_method_lines_dic": {"53": "GposLookupType8::::readSubTable(int)", "54": "GposLookupType8::::readSubTable(int)", "55": "GposLookupType8::::readSubTable(int)", "56": "GposLookupType8::::readSubTable(int)", "57": "GposLookupType8::::readSubTable(int)", "58": "GposLookupType8::::readSubTable(int)", "59": "GposLookupType8::::readSubTable(int)", "60": "GposLookupType8::::readSubTable(int)", "61": "GposLookupType8::::readSubTable(int)", "62": "GposLookupType8::::readSubTable(int)", "63": "GposLookupType8::::readSubTable(int)", "64": "GposLookupType8::::readSubTable(int)", "65": "GposLookupType8::::readSubTable(int)", "66": "GposLookupType8::::readSubTable(int)", "67": "GposLookupType8::::readSubTable(int)", "68": "GposLookupType8::::readSubTable(int)", "69": "GposLookupType8::::readSubTable(int)", "70": "GposLookupType8::::readSubTable(int)", "72": "GposLookupType8::::readSubTableFormat2(int)", "73": "GposLookupType8::::readSubTableFormat2(int)", "74": "GposLookupType8::::readSubTableFormat2(int)", "75": "GposLookupType8::::readSubTableFormat2(int)", "76": "GposLookupType8::::readSubTableFormat2(int)", "77": "GposLookupType8::::readSubTableFormat2(int)", "78": "GposLookupType8::::readSubTableFormat2(int)", "79": "GposLookupType8::::readSubTableFormat2(int)", "80": "GposLookupType8::::readSubTableFormat2(int)", "81": "GposLookupType8::::readSubTableFormat2(int)", "82": "GposLookupType8::::readSubTableFormat2(int)", "83": "GposLookupType8::::readSubTableFormat2(int)", "84": "GposLookupType8::::readSubTableFormat2(int)", "85": "GposLookupType8::::readSubTableFormat2(int)", "86": "GposLookupType8::::readSubTableFormat2(int)", "87": "GposLookupType8::::readSubTableFormat2(int)", "88": "GposLookupType8::::readSubTableFormat2(int)", "89": "GposLookupType8::::readSubTableFormat2(int)", "90": "GposLookupType8::::readSubTableFormat2(int)", "91": "GposLookupType8::::readSubTableFormat2(int)", "92": "GposLookupType8::::readSubTableFormat2(int)", "93": "GposLookupType8::::readSubTableFormat2(int)", "94": "GposLookupType8::::readSubTableFormat2(int)", "95": "GposLookupType8::::readSubTableFormat2(int)", "96": "GposLookupType8::::readSubTableFormat2(int)", "97": "GposLookupType8::::readSubTableFormat2(int)", "98": "GposLookupType8::::readSubTableFormat2(int)", "99": "GposLookupType8::::readSubTableFormat2(int)", "100": "GposLookupType8::::readSubTableFormat2(int)", "101": "GposLookupType8::::readSubTableFormat2(int)", "102": "GposLookupType8::::readSubTableFormat2(int)", "103": "GposLookupType8::::readSubTableFormat2(int)", "104": "GposLookupType8::::readSubTableFormat2(int)", "105": "GposLookupType8::::readSubTableFormat2(int)", "106": "GposLookupType8::::readSubTableFormat2(int)", "107": "GposLookupType8::::readSubTableFormat2(int)", "108": "GposLookupType8::::readSubTableFormat2(int)", "109": "GposLookupType8::::readSubTableFormat2(int)", "110": "GposLookupType8::::readSubTableFormat2(int)", "111": "GposLookupType8::::readSubTableFormat2(int)", "112": "GposLookupType8::::readSubTableFormat2(int)", "113": "GposLookupType8::::readSubTableFormat2(int)", "114": "GposLookupType8::::readSubTableFormat2(int)", "115": "GposLookupType8::::readSubTableFormat2(int)", "116": "GposLookupType8::::readSubTableFormat2(int)", "117": "GposLookupType8::::readSubTableFormat2(int)", "118": "GposLookupType8::::readSubTableFormat2(int)", "120": "GposLookupType8::::readSubTableFormat1(int)", "121": "GposLookupType8::::readSubTableFormat1(int)", "122": "GposLookupType8::::readSubTableFormat1(int)", "123": "GposLookupType8::::readSubTableFormat1(int)", "124": "GposLookupType8::::readSubTableFormat1(int)", "125": "GposLookupType8::::readSubTableFormat1(int)", "126": "GposLookupType8::::readSubTableFormat1(int)", "127": "GposLookupType8::::readSubTableFormat1(int)", "128": "GposLookupType8::::readSubTableFormat1(int)", "129": "GposLookupType8::::readSubTableFormat1(int)", "130": "GposLookupType8::::readSubTableFormat1(int)", "131": "GposLookupType8::::readSubTableFormat1(int)", "132": "GposLookupType8::::readSubTableFormat1(int)", "133": "GposLookupType8::::readSubTableFormat1(int)", "134": "GposLookupType8::::readSubTableFormat1(int)", "135": "GposLookupType8::::readSubTableFormat1(int)", "136": "GposLookupType8::::readSubTableFormat1(int)", "137": "GposLookupType8::::readSubTableFormat1(int)", "138": "GposLookupType8::::readSubTableFormat1(int)", "139": "GposLookupType8::::readSubTableFormat1(int)", "140": "GposLookupType8::::readSubTableFormat1(int)", "141": "GposLookupType8::::readSubTableFormat1(int)", "142": "GposLookupType8::::readSubTableFormat1(int)", "143": "GposLookupType8::::readSubTableFormat1(int)", "144": "GposLookupType8::::readSubTableFormat1(int)", "145": "GposLookupType8::::readSubTableFormat1(int)", "146": "GposLookupType8::::readSubTableFormat1(int)", "147": "GposLookupType8::::readSubTableFormat1(int)", "148": "GposLookupType8::::readSubTableFormat1(int)", "149": "GposLookupType8::::readSubTableFormat1(int)", "150": "GposLookupType8::::readSubTableFormat1(int)", "151": "GposLookupType8::::readSubTableFormat1(int)", "152": "GposLookupType8::::readSubTableFormat1(int)", "154": "GposLookupType8::::readSubTableFormat3(int)", "155": "GposLookupType8::::readSubTableFormat3(int)", "156": "GposLookupType8::::readSubTableFormat3(int)", "157": "GposLookupType8::::readSubTableFormat3(int)", "158": "GposLookupType8::::readSubTableFormat3(int)", "159": "GposLookupType8::::readSubTableFormat3(int)", "160": "GposLookupType8::::readSubTableFormat3(int)", "161": "GposLookupType8::::readSubTableFormat3(int)", "162": "GposLookupType8::::readSubTableFormat3(int)", "163": "GposLookupType8::::readSubTableFormat3(int)", "164": "GposLookupType8::::readSubTableFormat3(int)", "165": "GposLookupType8::::readSubTableFormat3(int)", "166": "GposLookupType8::::readSubTableFormat3(int)", "167": "GposLookupType8::::readSubTableFormat3(int)", "168": "GposLookupType8::::readSubTableFormat3(int)", "169": "GposLookupType8::::readSubTableFormat3(int)", "170": "GposLookupType8::::readSubTableFormat3(int)", "171": "GposLookupType8::::readSubTableFormat3(int)", "172": "GposLookupType8::::readSubTableFormat3(int)", "173": "GposLookupType8::::readSubTableFormat3(int)", "174": "GposLookupType8::::readSubTableFormat3(int)", "175": "GposLookupType8::::readSubTableFormat3(int)", "176": "GposLookupType8::::readSubTableFormat3(int)"}, "test_reverse_method_lines_dic": {"42": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "43": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "44": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "45": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "46": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "47": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "48": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "49": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "50": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "51": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "52": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "53": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "54": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "55": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "56": "GposLookupType8Test::::verifyXAdvanceIsAppliedForContextualPositioning()", "58": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "59": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "60": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "61": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "62": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "63": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "64": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "65": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "66": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "67": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "68": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "69": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "70": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "71": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "72": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "73": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "74": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "75": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "76": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "77": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "78": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "79": "GposLookupType8Test::::verifyXAdvanceIsAppliedForPosTableLookup8Format2()", "81": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "82": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "83": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "84": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "85": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "86": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "87": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "88": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "89": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "90": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "91": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "92": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "93": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "94": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "95": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "96": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()", "97": "GposLookupType8Test::::verifyXAdvanceIsNotAppliedForUnsatisfiedContextualPositioning()"}, "tests": [{"test_lines": [42, 56], "covered_lines": [48, 49, 50, 51, 55, 56, 57, 59, 60, 65, 66, 70, 121, 123, 124, 125, 127, 128, 129, 130, 131, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 148, 151, 152, 155, 156, 157, 158, 159, 160, 161, 162, 164, 165, 167, 168, 170, 171, 173, 175, 176]}, {"test_lines": [58, 79], "covered_lines": [48, 49, 50, 51, 55, 56, 57, 62, 63, 70, 74, 75, 76, 77, 78, 79, 81, 82, 83, 84, 86, 89, 90, 91, 92, 93, 94, 95, 97, 98, 99, 101, 102, 103, 104, 105, 106, 107, 108, 110, 111, 114, 117, 118]}, {"test_lines": [81, 97], "covered_lines": [48, 49, 50, 51, 55, 56, 57, 59, 60, 65, 66, 70, 121, 123, 124, 125, 127, 128, 129, 130, 131, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 145, 148, 151, 152, 155, 156, 157, 158, 159, 160, 161, 162, 164, 165, 167, 168, 170, 171, 173, 175, 176]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/GposLookupType1.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import java.util.ArrayList;\n", "import java.util.HashMap;\n", "import java.util.List;\n", "import java.util.Map;\n", "\n", "\n", "/**\n", " * Lookup Type 1: Single Adjustment Positioning Subtable\n", " */\n", "public class GposLookupType1 extends OpenTableLookup {\n", "\n", "    private Map<Integer, GposValueRecord> valueRecordMap = new HashMap<>();\n", "\n", "    public GposLookupType1(OpenTypeFontTableReader openReader, int lookupFlag, int[] subTableLocations)\n", "            throws java.io.IOException {\n", "        super(openReader, lookupFlag, subTableLocations);\n", "        readSubTables();\n", "    }\n", "\n", "    @Override\n", "    public boolean transformOne(GlyphLine line) {\n", "        if (line.idx >= line.end) {\n", "            return false;\n", "        }\n", "        if (openReader.isSkip(line.get(line.idx).getCode(), lookupFlag)) {\n", "            line.idx++;\n", "            return false;\n", "        }\n", "        int glyphCode = line.get(line.idx).getCode();\n", "        boolean positionApplied = false;\n", "        GposValueRecord valueRecord = valueRecordMap.get(glyphCode);\n", "        if (valueRecord != null) {\n", "            Glyph newGlyph = new Glyph(line.get(line.idx));\n", "            newGlyph.setXAdvance((short)(newGlyph.getXAdvance() + valueRecord.XAdvance));\n", "            newGlyph.setYAdvance((short)(newGlyph.getYAdvance() + valueRecord.YAdvance));\n", "            line.set(line.idx, newGlyph);\n", "            positionApplied = true;\n", "        }\n", "        line.idx++;\n", "        return positionApplied;\n", "    }\n", "\n", "    @Override\n", "    protected void readSubTable(int subTableLocation) throws java.io.IOException {\n", "        openReader.rf.seek(subTableLocation);\n", "        int subTableFormat = openReader.rf.readShort();\n", "        int coverageOffset = openReader.rf.readUnsignedShort();\n", "        int valueFormat = openReader.rf.readUnsignedShort();\n", "        if (subTableFormat == 1) {\n", "            GposValueRecord valueRecord = OtfReadCommon.readGposValueRecord(openReader, valueFormat);\n", "            List<Integer> coverageGlyphIds = openReader.readCoverageFormat(subTableLocation + coverageOffset);\n", "            for (Integer glyphId : coverageGlyphIds) {\n", "                valueRecordMap.put((int) glyphId, valueRecord);\n", "            }\n", "        } else if (subTableFormat == 2) {\n", "            int valueCount = openReader.rf.readUnsignedShort();\n", "            List<GposValueRecord> valueRecords = new ArrayList<>();\n", "            for (int i = 0; i < valueCount; i++) {\n", "                GposValueRecord valueRecord = OtfReadCommon.readGposValueRecord(openReader, valueFormat);\n", "                valueRecords.add(valueRecord);\n", "            }\n", "            List<Integer> coverageGlyphIds = openReader.readCoverageFormat(subTableLocation + coverageOffset);\n", "            for (int i = 0; i < coverageGlyphIds.size(); i++) {\n", "                valueRecordMap.put((int) coverageGlyphIds.get(i), valueRecords.get(i));\n", "            }\n", "        } else {\n", "            throw new IllegalArgumentException(\"Bad subtable format identifier: \" + subTableFormat);\n", "        }\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.font.FontProgramFactory;\n", "import com.itextpdf.io.font.TrueTypeFont;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.io.IOException;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "public class GposLookupType1Test extends ExtendedITextTest {\n", "    private static final String RESOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/font/otf/GposLookupType1Test/\";\n", "\n", "    @Test\n", "    public void verifyXAdvanceIsAppliedSubFormat1() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"NotoSansMyanmar-Regular.ttf\");\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "        GposLookupType1 lookup = (GposLookupType1) gposTableReader.getLookupTable(29);\n", "        List<Glyph> glyphs = Arrays.asList(new Glyph(fontProgram.getGlyphByCode(174)),\n", "                new Glyph(fontProgram.getGlyphByCode(5)));\n", "\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "        gl.idx = 0;\n", "\n", "        Assert.assertEquals(0, gl.get(0).getXAdvance());\n", "\n", "        Assert.assertTrue(lookup.transformOne(gl));\n", "\n", "        Assert.assertEquals(219, gl.get(0).getXAdvance());\n", "    }\n", "\n", "    @Test\n", "    public void verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"NotoSansMyanmar-Regular.ttf\");\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "        GposLookupType1 lookup = (GposLookupType1) gposTableReader.getLookupTable(29);\n", "        List<Glyph> glyphs = Arrays.asList(new Glyph(fontProgram.getGlyphByCode(5)),\n", "                new Glyph(fontProgram.getGlyphByCode(174)));\n", "\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "        gl.idx = 0;\n", "\n", "        Assert.assertEquals(0, gl.get(0).getXAdvance());\n", "\n", "        Assert.assertFalse(lookup.transformOne(gl));\n", "\n", "        Assert.assertEquals(0, gl.get(0).getXAdvance());\n", "    }\n", "\n", "    @Test\n", "    public void verifyDifferentXAdvanceIsAppliedSubFormat2() throws IOException {\n", "        TrueTypeFont fontProgram = (TrueTypeFont) FontProgramFactory.createFont(RESOURCE_FOLDER + \"NotoSansMyanmar-Regular.ttf\");\n", "        GlyphPositioningTableReader gposTableReader = fontProgram.getGposTable();\n", "        GposLookupType1 lookup = (GposLookupType1) gposTableReader.getLookupTable(16);\n", "\n", "        List<Glyph> glyphs = Arrays.asList(new Glyph(fontProgram.getGlyphByCode(401)),\n", "                new Glyph(fontProgram.getGlyphByCode(5)));\n", "        GlyphLine gl = new GlyphLine(glyphs);\n", "        Assert.assertEquals(0, gl.get(0).getXAdvance());\n", "        Assert.assertTrue(lookup.transformOne(gl));\n", "        Assert.assertEquals(109, gl.get(0).getXAdvance());\n", "\n", "        // Subtable type 2 defines different GposValueRecords for different coverage glyphs\n", "\n", "        glyphs = Arrays.asList(new Glyph(fontProgram.getGlyphByCode(508)),\n", "                new Glyph(fontProgram.getGlyphByCode(5)));\n", "        gl = new GlyphLine(glyphs);\n", "        Assert.assertEquals(0, gl.get(0).getXAdvance());\n", "        Assert.assertTrue(lookup.transformOne(gl));\n", "        Assert.assertEquals(158, gl.get(0).getXAdvance());\n", "    }\n", "\n", "}\n"], "method_lines_dic": {"GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)": [44, 65], "GposLookupType1::::readSubTable(int)": [67, 93]}, "test_method_lines_dic": {"GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()": [41, 57], "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()": [59, 75], "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()": [77, 98]}, "reverse_method_lines_dic": {"44": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "45": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "46": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "47": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "48": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "49": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "50": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "51": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "52": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "53": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "54": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "55": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "56": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "57": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "58": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "59": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "60": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "61": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "62": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "63": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "64": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "65": "GposLookupType1::::transformOne(com.itextpdf.io.font.otf.GlyphLine)", "67": "GposLookupType1::::readSubTable(int)", "68": "GposLookupType1::::readSubTable(int)", "69": "GposLookupType1::::readSubTable(int)", "70": "GposLookupType1::::readSubTable(int)", "71": "GposLookupType1::::readSubTable(int)", "72": "GposLookupType1::::readSubTable(int)", "73": "GposLookupType1::::readSubTable(int)", "74": "GposLookupType1::::readSubTable(int)", "75": "GposLookupType1::::readSubTable(int)", "76": "GposLookupType1::::readSubTable(int)", "77": "GposLookupType1::::readSubTable(int)", "78": "GposLookupType1::::readSubTable(int)", "79": "GposLookupType1::::readSubTable(int)", "80": "GposLookupType1::::readSubTable(int)", "81": "GposLookupType1::::readSubTable(int)", "82": "GposLookupType1::::readSubTable(int)", "83": "GposLookupType1::::readSubTable(int)", "84": "GposLookupType1::::readSubTable(int)", "85": "GposLookupType1::::readSubTable(int)", "86": "GposLookupType1::::readSubTable(int)", "87": "GposLookupType1::::readSubTable(int)", "88": "GposLookupType1::::readSubTable(int)", "89": "GposLookupType1::::readSubTable(int)", "90": "GposLookupType1::::readSubTable(int)", "91": "GposLookupType1::::readSubTable(int)", "92": "GposLookupType1::::readSubTable(int)", "93": "GposLookupType1::::readSubTable(int)"}, "test_reverse_method_lines_dic": {"41": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "42": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "43": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "44": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "45": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "46": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "47": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "48": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "49": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "50": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "51": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "52": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "53": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "54": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "55": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "56": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "57": "GposLookupType1Test::::verifyXAdvanceIsAppliedSubFormat1()", "59": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "60": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "61": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "62": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "63": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "64": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "65": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "66": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "67": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "68": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "69": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "70": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "71": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "72": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "73": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "74": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "75": "GposLookupType1Test::::verifyPositionIsNotAppliedForIrrelevantGlyphSubFormat1()", "77": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "78": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "79": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "80": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "81": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "82": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "83": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "84": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "85": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "86": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "87": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "88": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "89": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "90": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "91": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "92": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "93": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "94": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "95": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "96": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "97": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()", "98": "GposLookupType1Test::::verifyDifferentXAdvanceIsAppliedSubFormat2()"}, "tests": [{"test_lines": [41, 57], "covered_lines": [36, 40, 41, 42, 46, 49, 53, 54, 55, 56, 57, 58, 59, 60, 61, 63, 64, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 86, 87, 88, 90, 93]}, {"test_lines": [59, 75], "covered_lines": [36, 40, 41, 42, 46, 49, 53, 54, 55, 56, 63, 64, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 86, 87, 88, 90, 93]}, {"test_lines": [77, 98], "covered_lines": [36, 40, 41, 42, 46, 49, 53, 54, 55, 56, 57, 58, 59, 60, 61, 63, 64, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 86, 87, 88, 90, 93]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/otf/ActualTextIterator.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.io.util.TextUtil;\n", "\n", "import java.util.Iterator;\n", "\n", "public class ActualTextIterator implements Iterator<GlyphLine.GlyphLinePart> {\n", "\n", "    private GlyphLine glyphLine;\n", "\n", "    public ActualTextIterator(GlyphLine glyphLine) {\n", "        this.glyphLine = glyphLine;\n", "        this.pos = glyphLine.start;\n", "    }\n", "\n", "    public ActualTextIterator(GlyphLine glyphLine, int start, int end) {\n", "        this(new GlyphLine(glyphLine.glyphs, glyphLine.actualText, start, end));\n", "    }\n", "\n", "    private int pos;\n", "\n", "    @Override\n", "    public boolean hasNext() {\n", "        return pos < glyphLine.end;\n", "    }\n", "\n", "    @Override\n", "    public GlyphLine.GlyphLinePart next() {\n", "        if (glyphLine.actualText == null) {\n", "            GlyphLine.GlyphLinePart result = new GlyphLine.GlyphLinePart(pos, glyphLine.end, null);\n", "            pos = glyphLine.end;\n", "            return result;\n", "        } else {\n", "            GlyphLine.GlyphLinePart currentResult = nextGlyphLinePart(pos);\n", "            if (currentResult == null) {\n", "                return null;\n", "            }\n", "            pos = currentResult.end;\n", "\n", "            if (!glyphLinePartNeedsActualText(currentResult)) {\n", "                currentResult.actualText = null;\n", "                // Try to add more pieces without \"actual text\"\n", "                while (pos < glyphLine.end) {\n", "                    GlyphLine.GlyphLinePart nextResult = nextGlyphLinePart(pos);\n", "                    if (nextResult != null && !glyphLinePartNeedsActualText(nextResult)) {\n", "                        currentResult.end = nextResult.end;\n", "                        pos = nextResult.end;\n", "                    } else {\n", "                        break;\n", "                    }\n", "                }\n", "            }\n", "            return currentResult;\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void remove() {\n", "        throw new IllegalStateException(\"Operation not supported\");\n", "    }\n", "\n", "    private GlyphLine.GlyphLinePart nextGlyphLinePart(int pos) {\n", "        if (pos >= glyphLine.end) {\n", "            return null;\n", "        }\n", "        int startPos = pos;\n", "        GlyphLine.ActualText startActualText = glyphLine.actualText.get(pos);\n", "        while (pos < glyphLine.end && glyphLine.actualText.get(pos) == startActualText) {\n", "            pos++;\n", "        }\n", "        return new GlyphLine.GlyphLinePart(startPos, pos, startActualText != null ? startActualText.value : null);\n", "    }\n", "\n", "    private boolean glyphLinePartNeedsActualText(GlyphLine.GlyphLinePart glyphLinePart) {\n", "        if (glyphLinePart.actualText == null) {\n", "            return false;\n", "        }\n", "        boolean needsActualText = false;\n", "        StringBuilder toUnicodeMapResult = new StringBuilder();\n", "        for (int i = glyphLinePart.start; i < glyphLinePart.end; i++) {\n", "            Glyph currentGlyph = glyphLine.glyphs.get(i);\n", "            if (!currentGlyph.hasValidUnicode()) {\n", "                needsActualText = true;\n", "                break;\n", "            }\n", "            toUnicodeMapResult.append(TextUtil.convertFromUtf32(currentGlyph.getUnicode()));\n", "        }\n", "\n", "        return needsActualText || !toUnicodeMapResult.toString().equals(glyphLinePart.actualText);\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.otf;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "import java.util.Arrays;\n", "\n", "@Category(UnitTest.class)\n", "public class ActualTextIteratorTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void testActualTestParts() {\n", "        Glyph glyph = new Glyph(200, 200, '\\u002d');\n", "        GlyphLine glyphLine = new GlyphLine(Arrays.asList(glyph));\n", "        glyphLine.setActualText(0, 1, \"\\u002d\");\n", "        ActualTextIterator actualTextIterator = new ActualTextIterator(glyphLine);\n", "        GlyphLine.GlyphLinePart part = actualTextIterator.next();\n", "        // When actual text is the same as the result by text extraction, we should omit redundant actual text in the content stream\n", "        Assert.assertNull(part.actualText);\n", "    }\n", "\n", "}\n"], "method_lines_dic": {"ActualTextIterator::::hasNext()": [44, 47], "ActualTextIterator::::next()": [49, 77], "ActualTextIterator::::remove()": [79, 82], "ActualTextIterator::::nextGlyphLinePart(int)": [84, 94], "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)": [96, 112]}, "test_method_lines_dic": {"ActualTextIteratorTest::::testActualTestParts()": [36, 45]}, "reverse_method_lines_dic": {"44": "ActualTextIterator::::hasNext()", "45": "ActualTextIterator::::hasNext()", "46": "ActualTextIterator::::hasNext()", "47": "ActualTextIterator::::hasNext()", "49": "ActualTextIterator::::next()", "50": "ActualTextIterator::::next()", "51": "ActualTextIterator::::next()", "52": "ActualTextIterator::::next()", "53": "ActualTextIterator::::next()", "54": "ActualTextIterator::::next()", "55": "ActualTextIterator::::next()", "56": "ActualTextIterator::::next()", "57": "ActualTextIterator::::next()", "58": "ActualTextIterator::::next()", "59": "ActualTextIterator::::next()", "60": "ActualTextIterator::::next()", "61": "ActualTextIterator::::next()", "62": "ActualTextIterator::::next()", "63": "ActualTextIterator::::next()", "64": "ActualTextIterator::::next()", "65": "ActualTextIterator::::next()", "66": "ActualTextIterator::::next()", "67": "ActualTextIterator::::next()", "68": "ActualTextIterator::::next()", "69": "ActualTextIterator::::next()", "70": "ActualTextIterator::::next()", "71": "ActualTextIterator::::next()", "72": "ActualTextIterator::::next()", "73": "ActualTextIterator::::next()", "74": "ActualTextIterator::::next()", "75": "ActualTextIterator::::next()", "76": "ActualTextIterator::::next()", "77": "ActualTextIterator::::next()", "79": "ActualTextIterator::::remove()", "80": "ActualTextIterator::::remove()", "81": "ActualTextIterator::::remove()", "82": "ActualTextIterator::::remove()", "84": "ActualTextIterator::::nextGlyphLinePart(int)", "85": "ActualTextIterator::::nextGlyphLinePart(int)", "86": "ActualTextIterator::::nextGlyphLinePart(int)", "87": "ActualTextIterator::::nextGlyphLinePart(int)", "88": "ActualTextIterator::::nextGlyphLinePart(int)", "89": "ActualTextIterator::::nextGlyphLinePart(int)", "90": "ActualTextIterator::::nextGlyphLinePart(int)", "91": "ActualTextIterator::::nextGlyphLinePart(int)", "92": "ActualTextIterator::::nextGlyphLinePart(int)", "93": "ActualTextIterator::::nextGlyphLinePart(int)", "94": "ActualTextIterator::::nextGlyphLinePart(int)", "96": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "97": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "98": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "99": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "100": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "101": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "102": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "103": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "104": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "105": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "106": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "107": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "108": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "109": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "110": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "111": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)", "112": "ActualTextIterator::::glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine.GlyphLinePart)"}, "test_reverse_method_lines_dic": {"36": "ActualTextIteratorTest::::testActualTestParts()", "37": "ActualTextIteratorTest::::testActualTestParts()", "38": "ActualTextIteratorTest::::testActualTestParts()", "39": "ActualTextIteratorTest::::testActualTestParts()", "40": "ActualTextIteratorTest::::testActualTestParts()", "41": "ActualTextIteratorTest::::testActualTestParts()", "42": "ActualTextIteratorTest::::testActualTestParts()", "43": "ActualTextIteratorTest::::testActualTestParts()", "44": "ActualTextIteratorTest::::testActualTestParts()", "45": "ActualTextIteratorTest::::testActualTestParts()"}, "tests": [{"test_lines": [36, 45], "covered_lines": [33, 34, 35, 36, 51, 56, 57, 60, 62, 63, 65, 75, 85, 88, 89, 90, 91, 93, 97, 100, 101, 102, 103, 104, 108, 111]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/cmap/CMapByteCid.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.cmap;\n", "\n", "import com.itextpdf.io.exceptions.IOException;\n", "\n", "import java.util.ArrayList;\n", "import java.util.List;\n", "\n", "public class CMapByteCid extends AbstractCMap {\n", "\n", "\n", "    protected static class Cursor {\n", "\n", "        public int offset;\n", "        public int length;\n", "\n", "        public Cursor(int offset, int length) {\n", "            this.offset = offset;\n", "            this.length = length;\n", "        }\n", "    }\n", "\n", "    private List<int[]> planes = new ArrayList<>();\n", "\n", "    public CMapByteCid() {\n", "        planes.add(new int[256]);\n", "    }\n", "\n", "    @Override\n", "    void addChar(String mark, CMapObject code) {\n", "        if (code.isNumber()) {\n", "            encodeSequence(decodeStringToByte(mark), (int) code.getValue());\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Decode byte sequence.\n", "     *\n", "     * @param cidBytes byteCodeBytes\n", "     * @param offset   number of bytes to skip before starting to return chars from the sequence\n", "     * @param length   number of bytes to process\n", "     * @return string that contains decoded representation of the given sequence\n", "     */\n", "    public String decodeSequence(byte[] cidBytes, int offset, int length) {\n", "        StringBuilder sb = new StringBuilder();\n", "        Cursor cursor = new Cursor(offset, length);\n", "        int cid;\n", "        while ((cid = decodeSingle(cidBytes, cursor)) >= 0) {\n", "            sb.append((char)cid);\n", "        }\n", "        return sb.toString();\n", "    }\n", "\n", "    protected int decodeSingle(byte[] cidBytes, Cursor cursor) {\n", "        int end = cursor.offset + cursor.length;\n", "        int currentPlane = 0;\n", "        while (cursor.offset < end) {\n", "            int one = cidBytes[cursor.offset++] & 0xff;\n", "            cursor.length--;\n", "            int[] plane = planes.get(currentPlane);\n", "            int cid = plane[one];\n", "            if ((cid & 0x8000) == 0) {\n", "                return cid;\n", "            } else {\n", "                currentPlane = cid & 0x7fff;\n", "            }\n", "        }\n", "        return -1;\n", "    }\n", "\n", "    private void encodeSequence(byte[] seq, int cid) {\n", "        int size = seq.length - 1;\n", "        int nextPlane = 0;\n", "        for (int idx = 0; idx < size; ++idx) {\n", "            int[] plane = planes.get(nextPlane);\n", "            int one = seq[idx] & 0xff;\n", "            int c = plane[one];\n", "            if (c != 0 && (c & 0x8000) == 0)\n", "                throw new IOException(\"Inconsistent mapping.\");\n", "            if (c == 0) {\n", "                planes.add(new int[256]);\n", "                c = (planes.size() - 1 | 0x8000);\n", "                plane[one] = c;\n", "            }\n", "            nextPlane = c & 0x7fff;\n", "        }\n", "        int[] plane = planes.get(nextPlane);\n", "        int one = seq[size] & 0xff;\n", "        int c = plane[one];\n", "        if ((c & 0x8000) != 0)\n", "            throw new IOException(\"Inconsistent mapping.\");\n", "        plane[one] = cid;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.cmap;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class CMapByteCidTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void addCharAndDecodeByteCodeTest() {\n", "        CMapByteCid cMapByteCid = new CMapByteCid();\n", "        char byteCode = (char)0x94e0;\n", "        int cid = 7779;\n", "\n", "        byte[] byteCodeBytes = {(byte) ((byteCode & 0xFF00) >> 8), (byte) (byteCode & 0xFF)};\n", "        char[] charPerByteSequence = {(char) byteCodeBytes[0], (char) byteCodeBytes[1]};\n", "\n", "        cMapByteCid.addChar(new String(charPerByteSequence), new CMapObject(CMapObject.NUMBER, cid));\n", "\n", "        String actual = cMapByteCid.decodeSequence(byteCodeBytes, 0, 2);\n", "        String expected = new String(new char[]{(char) cid});\n", "\n", "        Assert.assertEquals(expected, actual);\n", "    }\n", "}\n"], "method_lines_dic": {"CMapByteCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)": [50, 55], "CMapByteCid::::decodeSequence(byte[],int,int)": [65, 73], "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)": [75, 90], "CMapByteCid::::encodeSequence(byte[],int)": [92, 114]}, "test_method_lines_dic": {"CMapByteCidTest::::addCharAndDecodeByteCodeTest()": [34, 49]}, "reverse_method_lines_dic": {"50": "CMapByteCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "51": "CMapByteCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "52": "CMapByteCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "53": "CMapByteCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "54": "CMapByteCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "55": "CMapByteCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "65": "CMapByteCid::::decodeSequence(byte[],int,int)", "66": "CMapByteCid::::decodeSequence(byte[],int,int)", "67": "CMapByteCid::::decodeSequence(byte[],int,int)", "68": "CMapByteCid::::decodeSequence(byte[],int,int)", "69": "CMapByteCid::::decodeSequence(byte[],int,int)", "70": "CMapByteCid::::decodeSequence(byte[],int,int)", "71": "CMapByteCid::::decodeSequence(byte[],int,int)", "72": "CMapByteCid::::decodeSequence(byte[],int,int)", "73": "CMapByteCid::::decodeSequence(byte[],int,int)", "75": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "76": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "77": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "78": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "79": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "80": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "81": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "82": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "83": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "84": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "85": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "86": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "87": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "88": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "89": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "90": "CMapByteCid::::decodeSingle(byte[],com.itextpdf.io.font.cmap.CMapByteCid.Cursor)", "92": "CMapByteCid::::encodeSequence(byte[],int)", "93": "CMapByteCid::::encodeSequence(byte[],int)", "94": "CMapByteCid::::encodeSequence(byte[],int)", "95": "CMapByteCid::::encodeSequence(byte[],int)", "96": "CMapByteCid::::encodeSequence(byte[],int)", "97": "CMapByteCid::::encodeSequence(byte[],int)", "98": "CMapByteCid::::encodeSequence(byte[],int)", "99": "CMapByteCid::::encodeSequence(byte[],int)", "100": "CMapByteCid::::encodeSequence(byte[],int)", "101": "CMapByteCid::::encodeSequence(byte[],int)", "102": "CMapByteCid::::encodeSequence(byte[],int)", "103": "CMapByteCid::::encodeSequence(byte[],int)", "104": "CMapByteCid::::encodeSequence(byte[],int)", "105": "CMapByteCid::::encodeSequence(byte[],int)", "106": "CMapByteCid::::encodeSequence(byte[],int)", "107": "CMapByteCid::::encodeSequence(byte[],int)", "108": "CMapByteCid::::encodeSequence(byte[],int)", "109": "CMapByteCid::::encodeSequence(byte[],int)", "110": "CMapByteCid::::encodeSequence(byte[],int)", "111": "CMapByteCid::::encodeSequence(byte[],int)", "112": "CMapByteCid::::encodeSequence(byte[],int)", "113": "CMapByteCid::::encodeSequence(byte[],int)", "114": "CMapByteCid::::encodeSequence(byte[],int)"}, "test_reverse_method_lines_dic": {"34": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "35": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "36": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "37": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "38": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "39": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "40": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "41": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "42": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "43": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "44": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "45": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "46": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "47": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "48": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()", "49": "CMapByteCidTest::::addCharAndDecodeByteCodeTest()"}, "tests": [{"test_lines": [34, 49], "covered_lines": [38, 39, 40, 41, 44, 46, 47, 48, 52, 53, 55, 66, 67, 69, 70, 72, 76, 77, 78, 79, 80, 81, 82, 83, 84, 86, 88, 89, 93, 94, 95, 96, 97, 98, 99, 101, 102, 103, 104, 106, 108, 109, 110, 111, 113, 114]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/cmap/CMapCidToCodepoint.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.cmap;\n", "\n", "import com.itextpdf.io.util.IntHashtable;\n", "\n", "import java.util.ArrayList;\n", "import java.util.HashMap;\n", "import java.util.List;\n", "import java.util.Map;\n", "\n", "public class CMapCidToCodepoint extends AbstractCMap {\n", "    private static final byte[] EMPTY = {};\n", "\n", "    private final Map<Integer, byte[]> map = new HashMap<>();\n", "    private final List<byte[]> codeSpaceRanges = new ArrayList<>();\n", "\n", "    @Override\n", "    void addChar(String mark, CMapObject code) {\n", "        if (code.isNumber()) {\n", "            byte[] ser = decodeStringToByte(mark);\n", "            map.put((int)code.getValue(), ser);\n", "        }\n", "    }\n", "\n", "    public byte[] lookup(int cid) {\n", "        byte[] ser = map.get(cid);\n", "        if (ser == null) {\n", "            return EMPTY;\n", "        } else {\n", "            return ser;\n", "        }\n", "    }\n", "\n", "    public IntHashtable getReversMap() {\n", "        IntHashtable code2cid = new IntHashtable(map.size());\n", "        for (Map.Entry<Integer, byte[]> entry : map.entrySet()) {\n", "            byte[] bytes = entry.getValue();\n", "            int byteCode = 0;\n", "            for (byte b: bytes) {\n", "                byteCode <<= 8;\n", "                byteCode += b & 0xff;\n", "            }\n", "            code2cid.put(byteCode, entry.getKey());\n", "        }\n", "        return code2cid;\n", "    }\n", "\n", "    /**\n", "     * Returns a list containing sequential pairs of code space beginning and endings:\n", "     * (begincodespacerange1, endcodespacerange1, begincodespacerange2, endcodespacerange1, ...)\n", "     *\n", "     * @return list of {@code byte[]} that contain code space ranges\n", "     */\n", "    public List<byte[]> getCodeSpaceRanges() {\n", "        return codeSpaceRanges;\n", "    }\n", "\n", "    @Override\n", "    void addCodeSpaceRange(byte[] low, byte[] high) {\n", "        codeSpaceRanges.add(low);\n", "        codeSpaceRanges.add(high);\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.cmap;\n", "\n", "import com.itextpdf.io.util.IntHashtable;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class CMapCidToCodepointTest extends ExtendedITextTest {\n", "    @Test\n", "    public void addCharAndLookupTest() {\n", "        CMapCidToCodepoint cidToCode = new CMapCidToCodepoint();\n", "        Assert.assertArrayEquals(new byte[0], cidToCode.lookup(14));\n", "        cidToCode.addChar(new String(new byte[] {32, 17}), new CMapObject(CMapObject.NUMBER, 14));\n", "        cidToCode.addChar(new String(new byte[] {32, 19}), new CMapObject(CMapObject.STRING, \"some text\"));\n", "\n", "        Assert.assertArrayEquals(new byte[] {32, 17}, cidToCode.lookup(14));\n", "        Assert.assertArrayEquals(new byte[0], cidToCode.lookup(1));\n", "    }\n", "\n", "    @Test\n", "    public void getReverseMapTest() {\n", "        CMapCidToCodepoint cidToCode = new CMapCidToCodepoint();\n", "        cidToCode.addChar(new String(new byte[] {32, 17}), new CMapObject(CMapObject.NUMBER, 14));\n", "        cidToCode.addChar(new String(new byte[] {32, 18}), new CMapObject(CMapObject.NUMBER, 15));\n", "\n", "        IntHashtable table = cidToCode.getReversMap();\n", "        Assert.assertEquals(2, table.size());\n", "        Assert.assertEquals(14, table.get(8209));\n", "        Assert.assertEquals(15, table.get(8210));\n", "    }\n", "\n", "    @Test\n", "    public void addAndGetCodeSpaceRangeTest() {\n", "        CMapCidToCodepoint cidToCode = new CMapCidToCodepoint();\n", "        Assert.assertTrue(cidToCode.getCodeSpaceRanges().isEmpty());\n", "\n", "        cidToCode.addCodeSpaceRange(new byte[] {11}, new byte[] {12, 13});\n", "        cidToCode.addCodeSpaceRange(null, new byte[] {});\n", "        List<byte[]> codeSpaceRanges = cidToCode.getCodeSpaceRanges();\n", "        Assert.assertEquals(4, codeSpaceRanges.size());\n", "        Assert.assertArrayEquals(new byte[] {11}, codeSpaceRanges.get(0));\n", "        Assert.assertArrayEquals(new byte[] {12, 13}, codeSpaceRanges.get(1));\n", "        Assert.assertNull(codeSpaceRanges.get(2));\n", "        Assert.assertArrayEquals(new byte[] {}, codeSpaceRanges.get(3));\n", "    }\n", "}\n"], "method_lines_dic": {"CMapCidToCodepoint::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)": [38, 44], "CMapCidToCodepoint::::lookup(int)": [46, 53], "CMapCidToCodepoint::::getReversMap()": [55, 67], "CMapCidToCodepoint::::getCodeSpaceRanges()": [75, 77], "CMapCidToCodepoint::::addCodeSpaceRange(byte[],byte[])": [79, 83]}, "test_method_lines_dic": {"CMapCidToCodepointTest::::addCharAndLookupTest()": [36, 45], "CMapCidToCodepointTest::::getReverseMapTest()": [47, 57], "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()": [59, 72]}, "reverse_method_lines_dic": {"38": "CMapCidToCodepoint::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "39": "CMapCidToCodepoint::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "40": "CMapCidToCodepoint::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "41": "CMapCidToCodepoint::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "42": "CMapCidToCodepoint::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "43": "CMapCidToCodepoint::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "44": "CMapCidToCodepoint::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "46": "CMapCidToCodepoint::::lookup(int)", "47": "CMapCidToCodepoint::::lookup(int)", "48": "CMapCidToCodepoint::::lookup(int)", "49": "CMapCidToCodepoint::::lookup(int)", "50": "CMapCidToCodepoint::::lookup(int)", "51": "CMapCidToCodepoint::::lookup(int)", "52": "CMapCidToCodepoint::::lookup(int)", "53": "CMapCidToCodepoint::::lookup(int)", "55": "CMapCidToCodepoint::::getReversMap()", "56": "CMapCidToCodepoint::::getReversMap()", "57": "CMapCidToCodepoint::::getReversMap()", "58": "CMapCidToCodepoint::::getReversMap()", "59": "CMapCidToCodepoint::::getReversMap()", "60": "CMapCidToCodepoint::::getReversMap()", "61": "CMapCidToCodepoint::::getReversMap()", "62": "CMapCidToCodepoint::::getReversMap()", "63": "CMapCidToCodepoint::::getReversMap()", "64": "CMapCidToCodepoint::::getReversMap()", "65": "CMapCidToCodepoint::::getReversMap()", "66": "CMapCidToCodepoint::::getReversMap()", "67": "CMapCidToCodepoint::::getReversMap()", "75": "CMapCidToCodepoint::::getCodeSpaceRanges()", "76": "CMapCidToCodepoint::::getCodeSpaceRanges()", "77": "CMapCidToCodepoint::::getCodeSpaceRanges()", "79": "CMapCidToCodepoint::::addCodeSpaceRange(byte[],byte[])", "80": "CMapCidToCodepoint::::addCodeSpaceRange(byte[],byte[])", "81": "CMapCidToCodepoint::::addCodeSpaceRange(byte[],byte[])", "82": "CMapCidToCodepoint::::addCodeSpaceRange(byte[],byte[])", "83": "CMapCidToCodepoint::::addCodeSpaceRange(byte[],byte[])"}, "test_reverse_method_lines_dic": {"36": "CMapCidToCodepointTest::::addCharAndLookupTest()", "37": "CMapCidToCodepointTest::::addCharAndLookupTest()", "38": "CMapCidToCodepointTest::::addCharAndLookupTest()", "39": "CMapCidToCodepointTest::::addCharAndLookupTest()", "40": "CMapCidToCodepointTest::::addCharAndLookupTest()", "41": "CMapCidToCodepointTest::::addCharAndLookupTest()", "42": "CMapCidToCodepointTest::::addCharAndLookupTest()", "43": "CMapCidToCodepointTest::::addCharAndLookupTest()", "44": "CMapCidToCodepointTest::::addCharAndLookupTest()", "45": "CMapCidToCodepointTest::::addCharAndLookupTest()", "47": "CMapCidToCodepointTest::::getReverseMapTest()", "48": "CMapCidToCodepointTest::::getReverseMapTest()", "49": "CMapCidToCodepointTest::::getReverseMapTest()", "50": "CMapCidToCodepointTest::::getReverseMapTest()", "51": "CMapCidToCodepointTest::::getReverseMapTest()", "52": "CMapCidToCodepointTest::::getReverseMapTest()", "53": "CMapCidToCodepointTest::::getReverseMapTest()", "54": "CMapCidToCodepointTest::::getReverseMapTest()", "55": "CMapCidToCodepointTest::::getReverseMapTest()", "56": "CMapCidToCodepointTest::::getReverseMapTest()", "57": "CMapCidToCodepointTest::::getReverseMapTest()", "59": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "60": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "61": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "62": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "63": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "64": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "65": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "66": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "67": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "68": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "69": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "70": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "71": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()", "72": "CMapCidToCodepointTest::::addAndGetCodeSpaceRangeTest()"}, "tests": [{"test_lines": [36, 45], "covered_lines": [32, 33, 35, 36, 40, 41, 42, 44, 47, 48, 49, 51]}, {"test_lines": [47, 57], "covered_lines": [32, 33, 35, 36, 40, 41, 42, 44, 56, 57, 58, 59, 60, 61, 62, 64, 65, 66]}, {"test_lines": [59, 72], "covered_lines": [32, 33, 35, 36, 76, 81, 82, 83]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/cmap/CMapCodepointToCid.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.cmap;\n", "\n", "import com.itextpdf.io.util.IntHashtable;\n", "\n", "/**\n", " * Class represents real codepoint-CID mapping without any additional manipulation.\n", " *\n", " * <p>\n", " * See {@link CMapCidToCodepoint} for CID-codepoint representation.\n", " */\n", "public class CMapCodepointToCid extends AbstractCMap {\n", "\n", "    private final IntHashtable map;\n", "\n", "    public CMapCodepointToCid() {\n", "        map = new IntHashtable();\n", "    }\n", "\n", "    public CMapCodepointToCid(CMapCidToCodepoint reverseMap) {\n", "        map = reverseMap.getReversMap();\n", "    }\n", "\n", "    @Override\n", "    void addChar(String mark, CMapObject code) {\n", "        if (code.isNumber()) {\n", "            byte[] ser = decodeStringToByte(mark);\n", "            int byteCode = 0;\n", "            for (byte b: ser) {\n", "                byteCode <<= 8;\n", "                byteCode += b & 0xff;\n", "            }\n", "            map.put(byteCode, (int) code.getValue());\n", "        }\n", "    }\n", "\n", "    public int lookup(int codepoint) {\n", "        return this.map.get(codepoint);\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.cmap;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class CMapCodepointToCidTest extends ExtendedITextTest {\n", "    @Test\n", "    public void reverseConstructorTest() {\n", "        CMapCidToCodepoint cidToCode = new CMapCidToCodepoint();\n", "        cidToCode.addChar(new String(new byte[] {32, 17}), new CMapObject(CMapObject.NUMBER, 14));\n", "        cidToCode.addChar(new String(new byte[] {32, 18}), new CMapObject(CMapObject.NUMBER, 15));\n", "\n", "        CMapCodepointToCid codeToCid = new CMapCodepointToCid(cidToCode);\n", "        Assert.assertEquals(14, codeToCid.lookup(8209));\n", "        Assert.assertEquals(15, codeToCid.lookup(8210));\n", "    }\n", "\n", "    @Test\n", "    public void addCharAndLookupTest() {\n", "        CMapCodepointToCid codeToCid = new CMapCodepointToCid();\n", "        Assert.assertEquals(0, codeToCid.lookup(8209));\n", "\n", "        codeToCid.addChar(new String(new byte[] {32, 17}), new CMapObject(CMapObject.NUMBER, 14));\n", "        codeToCid.addChar(new String(new byte[] {32, 19}), new CMapObject(CMapObject.STRING, \"some text\"));\n", "\n", "        Assert.assertEquals(14, codeToCid.lookup(8209));\n", "        Assert.assertEquals(0, codeToCid.lookup(1));\n", "    }\n", "}\n"], "method_lines_dic": {"CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)": [45, 56], "CMapCodepointToCid::::lookup(int)": [58, 60]}, "test_method_lines_dic": {"CMapCodepointToCidTest::::reverseConstructorTest()": [34, 43], "CMapCodepointToCidTest::::addCharAndLookupTest()": [45, 55]}, "reverse_method_lines_dic": {"45": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "46": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "47": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "48": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "49": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "50": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "51": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "52": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "53": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "54": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "55": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "56": "CMapCodepointToCid::::addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject)", "58": "CMapCodepointToCid::::lookup(int)", "59": "CMapCodepointToCid::::lookup(int)", "60": "CMapCodepointToCid::::lookup(int)"}, "test_reverse_method_lines_dic": {"34": "CMapCodepointToCidTest::::reverseConstructorTest()", "35": "CMapCodepointToCidTest::::reverseConstructorTest()", "36": "CMapCodepointToCidTest::::reverseConstructorTest()", "37": "CMapCodepointToCidTest::::reverseConstructorTest()", "38": "CMapCodepointToCidTest::::reverseConstructorTest()", "39": "CMapCodepointToCidTest::::reverseConstructorTest()", "40": "CMapCodepointToCidTest::::reverseConstructorTest()", "41": "CMapCodepointToCidTest::::reverseConstructorTest()", "42": "CMapCodepointToCidTest::::reverseConstructorTest()", "43": "CMapCodepointToCidTest::::reverseConstructorTest()", "45": "CMapCodepointToCidTest::::addCharAndLookupTest()", "46": "CMapCodepointToCidTest::::addCharAndLookupTest()", "47": "CMapCodepointToCidTest::::addCharAndLookupTest()", "48": "CMapCodepointToCidTest::::addCharAndLookupTest()", "49": "CMapCodepointToCidTest::::addCharAndLookupTest()", "50": "CMapCodepointToCidTest::::addCharAndLookupTest()", "51": "CMapCodepointToCidTest::::addCharAndLookupTest()", "52": "CMapCodepointToCidTest::::addCharAndLookupTest()", "53": "CMapCodepointToCidTest::::addCharAndLookupTest()", "54": "CMapCodepointToCidTest::::addCharAndLookupTest()", "55": "CMapCodepointToCidTest::::addCharAndLookupTest()"}, "tests": [{"test_lines": [34, 43], "covered_lines": [41, 42, 43, 59]}, {"test_lines": [45, 55], "covered_lines": [37, 38, 39, 47, 48, 49, 50, 51, 52, 54, 56, 59]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/font/cmap/StandardCMapCharsets.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.cmap;\n", "\n", "import java.nio.charset.StandardCharsets;\n", "import java.util.HashMap;\n", "import java.util.Map;\n", "\n", "\n", "public final class StandardCMapCharsets {\n", "    private static final Map<String, CMapCharsetEncoder> encoders = new HashMap<>();\n", "    private static final CMapCharsetEncoder UTF16_ENCODER = new CMapCharsetEncoder(StandardCharsets.UTF_16BE);\n", "    private static final CMapCharsetEncoder UCS2_ENCODER = new CMapCharsetEncoder(StandardCharsets.UTF_16BE, true);\n", "\n", "    private StandardCMapCharsets() {\n", "\n", "    }\n", "\n", "    private static void registerHV(String cmapPrefix, CMapCharsetEncoder encoder) {\n", "        encoders.put(cmapPrefix + \"-H\", encoder);\n", "        encoders.put(cmapPrefix + \"-V\", encoder);\n", "    }\n", "\n", "    static {\n", "        registerEncoder();\n", "    }\n", "\n", "    private static void registerEncoder() {\n", "        // Register encoders for all standard non-identity CMaps in PDF\n", "\n", "        // Simplified Chinese\n", "        registerHV(\"UniGB-UCS2\", UCS2_ENCODER);\n", "        registerHV(\"UniGB-UTF16\", UTF16_ENCODER);\n", "\n", "        // Traditional Chinese\n", "        registerHV(\"UniCNS-UCS2\", UCS2_ENCODER);\n", "        registerHV(\"UniCNS-UTF16\", UTF16_ENCODER);\n", "\n", "        // Japanese\n", "        registerHV(\"UniJIS-UCS2\", UCS2_ENCODER);\n", "        registerHV(\"UniJIS-UCS2-HW\", UCS2_ENCODER);\n", "        registerHV(\"UniJIS2004-UTF16\", UTF16_ENCODER);\n", "        registerHV(\"UniJIS-UTF16\", UTF16_ENCODER);\n", "\n", "        // Korean\n", "        registerHV(\"UniKS-UCS2\", UCS2_ENCODER);\n", "        registerHV(\"UniKS-UTF16\", UTF16_ENCODER);\n", "    }\n", "\n", "    public static CMapCharsetEncoder getEncoder(String stdCmapName) {\n", "        return encoders.get(stdCmapName);\n", "    }\n", "\n", "    /**\n", "     * Charset encoders are disabled.\n", "     */\n", "    public static void disableCharsetEncoders() {\n", "        encoders.clear();\n", "    }\n", "\n", "    /**\n", "     * Charset encoders are enabled (default).\n", "     */\n", "    public static void enableCharsetEncoders() {\n", "        if ( encoders.size() == 0 ) {\n", "            registerEncoder();\n", "        }\n", "    }\n", "\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.font.cmap;\n", "\n", "import com.itextpdf.commons.exceptions.ITextException;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.source.ByteBuffer;\n", "import com.itextpdf.io.util.TextUtil;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class StandardCMapCharsetsTest extends ExtendedITextTest {\n", "\n", "    private static final String TEST_STRING_WITH_DIFFERENT_UNICODES = \"e\u0440\u060a\\u0E84\\uA515\ub00f\";\n", "    private static final byte[] BYTES_REPRESENTATION_OF_TEST_STRING = new byte[] {\n", "            0, 101, // Latin Small Letter E\n", "            4, 64, // Cyrillic Small Letter Er\n", "            6, 10, // Arabic-Indic Per Ten Thousand Sign\n", "            14, (byte)0x84, // Lao Letter Kho Tam\n", "            (byte)0xA5, 21, // Vai Syllable Ndee\n", "            (byte)0xB0, 15, // Hangul Syllable Ggwigs\n", "    };\n", "\n", "    @Test\n", "    public void ucs2EncodingStringTest() {\n", "        CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UCS2-H\");\n", "        // UCS-2 represents full BMP, so all symbols should be correctly processed\n", "        ByteBuffer buffer = new ByteBuffer(BYTES_REPRESENTATION_OF_TEST_STRING.length);\n", "        for (int cp : TextUtil.convertToUtf32(TEST_STRING_WITH_DIFFERENT_UNICODES)) {\n", "            byte[] actual = encoder.encodeUnicodeCodePoint(cp);\n", "            buffer.append(actual);\n", "        }\n", "        Assert.assertArrayEquals(BYTES_REPRESENTATION_OF_TEST_STRING, buffer.toByteArray());\n", "    }\n", "    @Test\n", "    public void ucs2TryToEncodeSymbolNotFromBmpStringTest() {\n", "        CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UCS2-H\");\n", "        // Symbol outside BMP of Unicode, so in native Java UTF-16 it encoded by surrogate pair\n", "        // It is U+10437 symbol (Deseret Small Letter Yee)\n", "        String str = \"\\uD801\\uDC37\";\n", "        int cp = TextUtil.convertToUtf32(str)[0];\n", "        Exception e = Assert.assertThrows(ITextException.class, () ->\n", "                encoder.encodeUnicodeCodePoint(cp));\n", "        Assert.assertEquals(IoExceptionMessageConstant.ONLY_BMP_ENCODING, e.getMessage());\n", "    }\n", "    @Test\n", "    public void ucs2EncodingCodePointTest() {\n", "        CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UCS2-H\");\n", "        // U+0E84 (Lao Letter Kho Tam) from BMP\n", "        int codePoint = 3716;\n", "        byte[] actual = encoder.encodeUnicodeCodePoint(codePoint);\n", "        Assert.assertArrayEquals(new byte[] {14, (byte)0x84}, actual);\n", "    }\n", "\n", "    @Test\n", "    public void utf16EncodingStringTest() {\n", "        CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UTF16-H\");\n", "        ByteBuffer buffer = new ByteBuffer(BYTES_REPRESENTATION_OF_TEST_STRING.length);\n", "        for (int cp : TextUtil.convertToUtf32(TEST_STRING_WITH_DIFFERENT_UNICODES)) {\n", "            byte[] actual = encoder.encodeUnicodeCodePoint(cp);\n", "            buffer.append(actual);\n", "        }\n", "        Assert.assertArrayEquals(BYTES_REPRESENTATION_OF_TEST_STRING, buffer.toByteArray());\n", "        // UTF-16 represents full BMP, so all symbols should be correctly processed\n", "    }\n", "    @Test\n", "    public void utf16TryToEncodeSymbolNotFromBmpStringTest() {\n", "        CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UTF16-H\");\n", "        // Symbol outside BMP of Unicode, so in native Java UTF-16 it encoded by surrogate pair\n", "        // It is U+10437 symbol (Deseret Small Letter Yee)\n", "        String str = \"\\uD801\\uDC37\";\n", "        byte[] actual = encoder.encodeUnicodeCodePoint(TextUtil.convertToUtf32(str)[0]);\n", "        Assert.assertArrayEquals(new byte[] {(byte)0xD8, 1, (byte)0xDC, 55}, actual);\n", "    }\n", "\n", "    @Test\n", "    public void ucs2TryToEncodeSymbolNotFromBmpCodePointTest() {\n", "        CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UCS2-H\");\n", "        // It is U+10437 symbol (Deseret Small Letter Yee) outside BMP\n", "        int codePoint = 66615;\n", "        Exception e = Assert.assertThrows(ITextException.class, () -> encoder.encodeUnicodeCodePoint(codePoint));\n", "        Assert.assertEquals(IoExceptionMessageConstant.ONLY_BMP_ENCODING, e.getMessage());\n", "    }\n", "\n", "    @Test\n", "    public void udf16EncodingCodePointTest() {\n", "        CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UTF16-H\");\n", "        // U+0E84 (Lao Letter Kho Tam) from BMP\n", "        int codePoint = 3716;\n", "        byte[] actual = encoder.encodeUnicodeCodePoint(codePoint);\n", "        Assert.assertArrayEquals(new byte[] {14, (byte)0x84}, actual);\n", "    }\n", "\n", "    @Test\n", "    public void udf16TryToEncodeSymbolNotFromBmpCodePointTest() {\n", "        CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UTF16-H\");\n", "        // It is U+10437 symbol (Deseret Small Letter Yee) outside BMP\n", "        int codePoint = 66615;\n", "        byte[] actual = encoder.encodeUnicodeCodePoint(codePoint);\n", "        Assert.assertArrayEquals(new byte[] {(byte)0xD8, 1, (byte)0xDC, 55}, actual);\n", "    }\n", "\n", "    @Test\n", "    public void charsetEncodersDisabledTest() {\n", "        try {\n", "            StandardCMapCharsets.disableCharsetEncoders();\n", "            CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UTF16-H\");\n", "            Assert.assertNull(encoder);\n", "        } finally {\n", "            StandardCMapCharsets.enableCharsetEncoders();\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void charsetEncodersReEnabledTest() {\n", "        try {\n", "            StandardCMapCharsets.disableCharsetEncoders();\n", "            CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UTF16-H\");\n", "            Assert.assertNull(encoder);\n", "        } finally {\n", "            StandardCMapCharsets.enableCharsetEncoders();\n", "            CMapCharsetEncoder encoder = StandardCMapCharsets.getEncoder(\"UniGB-UTF16-H\");\n", "            Assert.assertNotNull(encoder);\n", "        }\n", "    }\n", "}\n"], "method_lines_dic": {"StandardCMapCharsets::::registerHV(java.lang.String,com.itextpdf.io.font.cmap.CMapCharsetEncoder)": [39, 42], "StandardCMapCharsets::::registerEncoder()": [48, 68], "StandardCMapCharsets::::getEncoder(java.lang.String)": [70, 72], "StandardCMapCharsets::::disableCharsetEncoders()": [77, 79], "StandardCMapCharsets::::enableCharsetEncoders()": [84, 88]}, "test_method_lines_dic": {"StandardCMapCharsetsTest::::ucs2EncodingStringTest()": [49, 59], "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()": [60, 70], "StandardCMapCharsetsTest::::ucs2EncodingCodePointTest()": [71, 78], "StandardCMapCharsetsTest::::utf16EncodingStringTest()": [80, 90], "StandardCMapCharsetsTest::::utf16TryToEncodeSymbolNotFromBmpStringTest()": [91, 99], "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpCodePointTest()": [101, 108], "StandardCMapCharsetsTest::::udf16EncodingCodePointTest()": [110, 117], "StandardCMapCharsetsTest::::udf16TryToEncodeSymbolNotFromBmpCodePointTest()": [119, 126], "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()": [128, 137], "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()": [139, 150]}, "reverse_method_lines_dic": {"39": "StandardCMapCharsets::::registerHV(java.lang.String,com.itextpdf.io.font.cmap.CMapCharsetEncoder)", "40": "StandardCMapCharsets::::registerHV(java.lang.String,com.itextpdf.io.font.cmap.CMapCharsetEncoder)", "41": "StandardCMapCharsets::::registerHV(java.lang.String,com.itextpdf.io.font.cmap.CMapCharsetEncoder)", "42": "StandardCMapCharsets::::registerHV(java.lang.String,com.itextpdf.io.font.cmap.CMapCharsetEncoder)", "48": "StandardCMapCharsets::::registerEncoder()", "49": "StandardCMapCharsets::::registerEncoder()", "50": "StandardCMapCharsets::::registerEncoder()", "51": "StandardCMapCharsets::::registerEncoder()", "52": "StandardCMapCharsets::::registerEncoder()", "53": "StandardCMapCharsets::::registerEncoder()", "54": "StandardCMapCharsets::::registerEncoder()", "55": "StandardCMapCharsets::::registerEncoder()", "56": "StandardCMapCharsets::::registerEncoder()", "57": "StandardCMapCharsets::::registerEncoder()", "58": "StandardCMapCharsets::::registerEncoder()", "59": "StandardCMapCharsets::::registerEncoder()", "60": "StandardCMapCharsets::::registerEncoder()", "61": "StandardCMapCharsets::::registerEncoder()", "62": "StandardCMapCharsets::::registerEncoder()", "63": "StandardCMapCharsets::::registerEncoder()", "64": "StandardCMapCharsets::::registerEncoder()", "65": "StandardCMapCharsets::::registerEncoder()", "66": "StandardCMapCharsets::::registerEncoder()", "67": "StandardCMapCharsets::::registerEncoder()", "68": "StandardCMapCharsets::::registerEncoder()", "70": "StandardCMapCharsets::::getEncoder(java.lang.String)", "71": "StandardCMapCharsets::::getEncoder(java.lang.String)", "72": "StandardCMapCharsets::::getEncoder(java.lang.String)", "77": "StandardCMapCharsets::::disableCharsetEncoders()", "78": "StandardCMapCharsets::::disableCharsetEncoders()", "79": "StandardCMapCharsets::::disableCharsetEncoders()", "84": "StandardCMapCharsets::::enableCharsetEncoders()", "85": "StandardCMapCharsets::::enableCharsetEncoders()", "86": "StandardCMapCharsets::::enableCharsetEncoders()", "87": "StandardCMapCharsets::::enableCharsetEncoders()", "88": "StandardCMapCharsets::::enableCharsetEncoders()"}, "test_reverse_method_lines_dic": {"49": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "50": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "51": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "52": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "53": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "54": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "55": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "56": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "57": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "58": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "59": "StandardCMapCharsetsTest::::ucs2EncodingStringTest()", "60": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "61": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "62": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "63": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "64": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "65": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "66": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "67": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "68": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "69": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "70": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpStringTest()", "71": "StandardCMapCharsetsTest::::ucs2EncodingCodePointTest()", "72": "StandardCMapCharsetsTest::::ucs2EncodingCodePointTest()", "73": "StandardCMapCharsetsTest::::ucs2EncodingCodePointTest()", "74": "StandardCMapCharsetsTest::::ucs2EncodingCodePointTest()", "75": "StandardCMapCharsetsTest::::ucs2EncodingCodePointTest()", "76": "StandardCMapCharsetsTest::::ucs2EncodingCodePointTest()", "77": "StandardCMapCharsetsTest::::ucs2EncodingCodePointTest()", "78": "StandardCMapCharsetsTest::::ucs2EncodingCodePointTest()", "80": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "81": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "82": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "83": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "84": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "85": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "86": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "87": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "88": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "89": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "90": "StandardCMapCharsetsTest::::utf16EncodingStringTest()", "91": "StandardCMapCharsetsTest::::utf16TryToEncodeSymbolNotFromBmpStringTest()", "92": "StandardCMapCharsetsTest::::utf16TryToEncodeSymbolNotFromBmpStringTest()", "93": "StandardCMapCharsetsTest::::utf16TryToEncodeSymbolNotFromBmpStringTest()", "94": "StandardCMapCharsetsTest::::utf16TryToEncodeSymbolNotFromBmpStringTest()", "95": "StandardCMapCharsetsTest::::utf16TryToEncodeSymbolNotFromBmpStringTest()", "96": "StandardCMapCharsetsTest::::utf16TryToEncodeSymbolNotFromBmpStringTest()", "97": "StandardCMapCharsetsTest::::utf16TryToEncodeSymbolNotFromBmpStringTest()", "98": "StandardCMapCharsetsTest::::utf16TryToEncodeSymbolNotFromBmpStringTest()", "99": "StandardCMapCharsetsTest::::utf16TryToEncodeSymbolNotFromBmpStringTest()", "101": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpCodePointTest()", "102": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpCodePointTest()", "103": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpCodePointTest()", "104": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpCodePointTest()", "105": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpCodePointTest()", "106": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpCodePointTest()", "107": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpCodePointTest()", "108": "StandardCMapCharsetsTest::::ucs2TryToEncodeSymbolNotFromBmpCodePointTest()", "110": "StandardCMapCharsetsTest::::udf16EncodingCodePointTest()", "111": "StandardCMapCharsetsTest::::udf16EncodingCodePointTest()", "112": "StandardCMapCharsetsTest::::udf16EncodingCodePointTest()", "113": "StandardCMapCharsetsTest::::udf16EncodingCodePointTest()", "114": "StandardCMapCharsetsTest::::udf16EncodingCodePointTest()", "115": "StandardCMapCharsetsTest::::udf16EncodingCodePointTest()", "116": "StandardCMapCharsetsTest::::udf16EncodingCodePointTest()", "117": "StandardCMapCharsetsTest::::udf16EncodingCodePointTest()", "119": "StandardCMapCharsetsTest::::udf16TryToEncodeSymbolNotFromBmpCodePointTest()", "120": "StandardCMapCharsetsTest::::udf16TryToEncodeSymbolNotFromBmpCodePointTest()", "121": "StandardCMapCharsetsTest::::udf16TryToEncodeSymbolNotFromBmpCodePointTest()", "122": "StandardCMapCharsetsTest::::udf16TryToEncodeSymbolNotFromBmpCodePointTest()", "123": "StandardCMapCharsetsTest::::udf16TryToEncodeSymbolNotFromBmpCodePointTest()", "124": "StandardCMapCharsetsTest::::udf16TryToEncodeSymbolNotFromBmpCodePointTest()", "125": "StandardCMapCharsetsTest::::udf16TryToEncodeSymbolNotFromBmpCodePointTest()", "126": "StandardCMapCharsetsTest::::udf16TryToEncodeSymbolNotFromBmpCodePointTest()", "128": "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()", "129": "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()", "130": "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()", "131": "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()", "132": "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()", "133": "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()", "134": "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()", "135": "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()", "136": "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()", "137": "StandardCMapCharsetsTest::::charsetEncodersDisabledTest()", "139": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "140": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "141": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "142": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "143": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "144": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "145": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "146": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "147": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "148": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "149": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()", "150": "StandardCMapCharsetsTest::::charsetEncodersReEnabledTest()"}, "tests": [{"test_lines": [49, 59], "covered_lines": [31, 32, 33, 40, 41, 42, 45, 46, 52, 53, 56, 57, 60, 61, 62, 63, 66, 67, 68, 71]}, {"test_lines": [60, 70], "covered_lines": [31, 32, 33, 40, 41, 42, 45, 46, 52, 53, 56, 57, 60, 61, 62, 63, 66, 67, 68, 71]}, {"test_lines": [71, 78], "covered_lines": [31, 32, 33, 40, 41, 42, 45, 46, 52, 53, 56, 57, 60, 61, 62, 63, 66, 67, 68, 71]}, {"test_lines": [80, 90], "covered_lines": [31, 32, 33, 40, 41, 42, 45, 46, 52, 53, 56, 57, 60, 61, 62, 63, 66, 67, 68, 71]}, {"test_lines": [91, 99], "covered_lines": [31, 32, 33, 40, 41, 42, 45, 46, 52, 53, 56, 57, 60, 61, 62, 63, 66, 67, 68, 71]}, {"test_lines": [101, 108], "covered_lines": [31, 32, 33, 40, 41, 42, 45, 46, 52, 53, 56, 57, 60, 61, 62, 63, 66, 67, 68, 71]}, {"test_lines": [110, 117], "covered_lines": [31, 32, 33, 40, 41, 42, 45, 46, 52, 53, 56, 57, 60, 61, 62, 63, 66, 67, 68, 71]}, {"test_lines": [119, 126], "covered_lines": [31, 32, 33, 40, 41, 42, 45, 46, 52, 53, 56, 57, 60, 61, 62, 63, 66, 67, 68, 71]}, {"test_lines": [128, 137], "covered_lines": [31, 32, 33, 40, 41, 42, 45, 46, 52, 53, 56, 57, 60, 61, 62, 63, 66, 67, 68, 71, 78, 79, 85, 86, 88]}, {"test_lines": [139, 150], "covered_lines": [31, 32, 33, 40, 41, 42, 45, 46, 52, 53, 56, 57, 60, 61, 62, 63, 66, 67, 68, 71, 78, 79, 85, 86, 88]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/image/JpegImageHelper.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.image;\n", "\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.logs.IoLogMessageConstant;\n", "import com.itextpdf.io.util.StreamUtil;\n", "import com.itextpdf.io.colors.IccProfile;\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "\n", "import java.io.InputStream;\n", "import java.util.HashMap;\n", "import java.util.Map;\n", "\n", "import org.slf4j.Logger;\n", "import org.slf4j.LoggerFactory;\n", "\n", "class JpegImageHelper {\n", "    private static final Logger LOGGER = LoggerFactory.getLogger(JpegImageHelper.class);\n", "\n", "    /**\n", "     * This is a type of marker.\n", "     */\n", "    private static final int NOT_A_MARKER = -1;\n", "\n", "    /**\n", "     * This is a type of marker.\n", "     */\n", "    private static final int VALID_MARKER = 0;\n", "\n", "    /**\n", "     * Acceptable Jpeg markers.\n", "     */\n", "    private static final int[] VALID_MARKERS = {0xC0, 0xC1, 0xC2};\n", "\n", "    /**\n", "     * This is a type of marker.\n", "     */\n", "    private static final int UNSUPPORTED_MARKER = 1;\n", "\n", "    /**\n", "     * Unsupported Jpeg markers.\n", "     */\n", "    private static final int[] UNSUPPORTED_MARKERS = {0xC3, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCD, 0xCE, 0xCF};\n", "\n", "    /**\n", "     * This is a type of marker.\n", "     */\n", "    private static final int NOPARAM_MARKER = 2;\n", "\n", "    /**\n", "     * Jpeg markers without additional parameters.\n", "     */\n", "    private static final int[] NOPARAM_MARKERS = {0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0x01};\n", "\n", "    /**\n", "     * Marker value\n", "     */\n", "    private static final int M_APP0 = 0xE0;\n", "    /**\n", "     * Marker value\n", "     */\n", "    private static final int M_APP2 = 0xE2;\n", "    /**\n", "     * Marker value\n", "     */\n", "    private static final int M_APPE = 0xEE;\n", "    /**\n", "     * Marker value for Photoshop IRB\n", "     */\n", "    private static final int M_APPD = 0xED;\n", "\n", "    /**\n", "     * sequence that is used in all Jpeg files\n", "     */\n", "    private static final byte[] JFIF_ID = {0x4A, 0x46, 0x49, 0x46, 0x00};\n", "\n", "    /**\n", "     * sequence preceding Photoshop resolution data\n", "     */\n", "    private static final byte[] PS_8BIM_RESO = {0x38, 0x42, 0x49, 0x4d, 0x03, (byte) 0xed};\n", "\n", "    /**\n", "     * Process the passed Image data as a JPEG image.\n", "     * Image is loaded and all image attributes are initialized and/or updated.\n", "     *\n", "     * @param image the image to process as a JPEG image\n", "     */\n", "    public static void processImage(ImageData image) {\n", "        if (image.getOriginalType() != ImageType.JPEG)\n", "            throw new IllegalArgumentException(\"JPEG image expected\");\n", "        InputStream jpegStream = null;\n", "        try {\n", "            String errorID;\n", "            if (image.getData() == null) {\n", "                image.loadData();\n", "                errorID = image.getUrl().toString();\n", "            } else {\n", "                errorID = \"Byte array\";\n", "            }\n", "            jpegStream = new java.io.ByteArrayInputStream(image.getData());\n", "            image.imageSize = image.getData().length;\n", "            processParameters(jpegStream, errorID, image);\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.JPEG_IMAGE_EXCEPTION, e);\n", "        } finally {\n", "            if (jpegStream != null) {\n", "                try {\n", "                    jpegStream.close();\n", "                } catch (java.io.IOException ignore) { }\n", "            }\n", "        }\n", "        updateAttributes(image);\n", "    }\n", "\n", "    static void attemptToSetIccProfileToImage(byte[][] icc, ImageData image) {\n", "        if (icc != null) {\n", "            int total = 0;\n", "            for (final byte[] value : icc) {\n", "                if (value == null) {\n", "                    return;\n", "                }\n", "                total += value.length - 14;\n", "            }\n", "            byte[] ficc = new byte[total];\n", "            total = 0;\n", "            for (final byte[] bytes : icc) {\n", "                System.arraycopy(bytes, 14, ficc, total, bytes.length - 14);\n", "                total += bytes.length - 14;\n", "            }\n", "            try {\n", "                image.setProfile(IccProfile.getInstance(ficc, image.getColorEncodingComponentsNumber()));\n", "            } catch (Exception e) {\n", "                LOGGER.error(MessageFormatUtil.format(\n", "                        IoLogMessageConstant.DURING_CONSTRUCTION_OF_ICC_PROFILE_ERROR_OCCURRED,\n", "                        e.getClass().getSimpleName(), e.getMessage()));\n", "            }\n", "        }\n", "    }\n", "\n", "    private static void updateAttributes(ImageData image) {\n", "        image.filter = \"DCTDecode\";\n", "        if (image.getColorTransform() == 0) {\n", "            Map<String, Object> decodeParms = new HashMap<>();\n", "            decodeParms.put(\"ColorTransform\", 0);\n", "            image.decodeParms = decodeParms;\n", "        }\n", "        int colorComponents = image.getColorEncodingComponentsNumber();\n", "        if (colorComponents != 1 && colorComponents != 3 && image.isInverted()) {\n", "            image.decode = new float[]{1, 0, 1, 0, 1, 0, 1, 0};\n", "        }\n", "    }\n", "\n", "    /**\n", "     * This method checks if the image is a valid JPEG and processes some parameters.\n", "     *\n", "     * @throws IOException\n", "     * @throws java.io.IOException\n", "     */\n", "    private static void processParameters(InputStream jpegStream, String errorID, ImageData image) throws java.io.IOException {\n", "        byte[][] icc = null;\n", "        if (jpegStream.read() != 0xFF || jpegStream.read() != 0xD8) {\n", "            throw new IOException(IoExceptionMessageConstant.IS_NOT_A_VALID_JPEG_FILE).setMessageParams(errorID);\n", "        }\n", "        boolean firstPass = true;\n", "        int len;\n", "        while (true) {\n", "            int v = jpegStream.read();\n", "            if (v < 0)\n", "                throw new IOException(IoExceptionMessageConstant.PREMATURE_EOF_WHILE_READING_JPEG);\n", "            if (v == 0xFF) {\n", "                int marker = jpegStream.read();\n", "                if (firstPass && marker == M_APP0) {\n", "                    firstPass = false;\n", "                    len = getShort(jpegStream);\n", "                    if (len < 16) {\n", "                        StreamUtil.skip(jpegStream, len - 2);\n", "                        continue;\n", "                    }\n", "                    byte[] bcomp = new byte[JFIF_ID.length];\n", "                    int r = jpegStream.read(bcomp);\n", "                    if (r != bcomp.length)\n", "                        throw new IOException(IoExceptionMessageConstant.CORRUPTED_JFIF_MARKER).setMessageParams(errorID);\n", "                    boolean found = true;\n", "                    for (int k = 0; k < bcomp.length; ++k) {\n", "                        if (bcomp[k] != JFIF_ID[k]) {\n", "                            found = false;\n", "                            break;\n", "                        }\n", "                    }\n", "                    if (!found) {\n", "                        StreamUtil.skip(jpegStream, len - 2 - bcomp.length);\n", "                        continue;\n", "                    }\n", "                    StreamUtil.skip(jpegStream, 2);\n", "                    int units = jpegStream.read();\n", "                    int dx = getShort(jpegStream);\n", "                    int dy = getShort(jpegStream);\n", "                    if (units == 1) {\n", "                        image.setDpi(dx, dy);\n", "                    } else if (units == 2) {\n", "                        image.setDpi((int) (dx * 2.54f + 0.5f), (int) (dy * 2.54f + 0.5f));\n", "                    }\n", "                    StreamUtil.skip(jpegStream, len - 2 - bcomp.length - 7);\n", "                    continue;\n", "                }\n", "                if (marker == M_APPE) {\n", "                    len = getShort(jpegStream) - 2;\n", "                    byte[] byteappe = new byte[len];\n", "                    for (int k = 0; k < len; ++k) {\n", "                        byteappe[k] = (byte) jpegStream.read();\n", "                    }\n", "                    if (byteappe.length >= 12) {\n", "                        String appe = new String(byteappe, 0, 5, \"ISO-8859-1\");\n", "                        if (appe.equals(\"Adobe\")) {\n", "                            image.setInverted(true);\n", "                        }\n", "                    }\n", "                    continue;\n", "                }\n", "                if (marker == M_APP2) {\n", "                    len = getShort(jpegStream) - 2;\n", "                    byte[] byteapp2 = new byte[len];\n", "                    for (int k = 0; k < len; ++k) {\n", "                        byteapp2[k] = (byte) jpegStream.read();\n", "                    }\n", "                    if (byteapp2.length >= 14) {\n", "                        String app2 = new String(byteapp2, 0, 11, \"ISO-8859-1\");\n", "                        if (app2.equals(\"ICC_PROFILE\")) {\n", "                            int order = byteapp2[12] & 0xff;\n", "                            int count = byteapp2[13] & 0xff;\n", "                            // some jpeg producers don't know how to count to 1\n", "                            if (order < 1)\n", "                                order = 1;\n", "                            if (count < 1)\n", "                                count = 1;\n", "                            if (icc == null)\n", "                                icc = new byte[count][];\n", "                            icc[order - 1] = byteapp2;\n", "                        }\n", "                    }\n", "                    continue;\n", "                }\n", "                if (marker == M_APPD) {\n", "                    len = getShort(jpegStream) - 2;\n", "                    byte[] byteappd = new byte[len];\n", "                    for (int k = 0; k < len; k++) {\n", "                        byteappd[k] = (byte) jpegStream.read();\n", "                    }\n", "                    // search for '8BIM Resolution' marker\n", "                    int k;\n", "                    for (k = 0; k < len - PS_8BIM_RESO.length; k++) {\n", "                        boolean found = true;\n", "                        for (int j = 0; j < PS_8BIM_RESO.length; j++) {\n", "                            if (byteappd[k + j] != PS_8BIM_RESO[j]) {\n", "                                found = false;\n", "                                break;\n", "                            }\n", "                        }\n", "                        if (found)\n", "                            break;\n", "                    }\n", "\n", "                    k += PS_8BIM_RESO.length;\n", "                    if (k < len - PS_8BIM_RESO.length) {\n", "                        // \"PASCAL String\" for name, i.e. string prefix with length byte\n", "                        // padded to be even length; 2 null bytes if empty\n", "                        byte namelength = byteappd[k];\n", "                        // add length byte\n", "                        namelength++;\n", "                        // add padding\n", "                        if (namelength % 2 == 1)\n", "                            namelength++;\n", "                        // just skip name\n", "                        k += namelength;\n", "                        // size of the resolution data\n", "                        int resosize = (byteappd[k] << 24) + (byteappd[k + 1] << 16) + (byteappd[k + 2] << 8) + byteappd[k + 3];\n", "                        // should be 16\n", "                        if (resosize != 16) {\n", "                            // fail silently, for now\n", "                            //System.err.println(\"DEBUG: unsupported resolution IRB size\");\n", "                            continue;\n", "                        }\n", "                        k += 4;\n", "                        int dx = (byteappd[k] << 8) + (byteappd[k + 1] & 0xff);\n", "                        k += 2;\n", "                        // skip 2 unknown bytes\n", "                        k += 2;\n", "                        int unitsx = (byteappd[k] << 8) + (byteappd[k + 1] & 0xff);\n", "                        k += 2;\n", "                        // skip 2 unknown bytes\n", "                        k += 2;\n", "                        int dy = (byteappd[k] << 8) + (byteappd[k + 1] & 0xff);\n", "                        k += 2;\n", "                        // skip 2 unknown bytes\n", "                        k += 2;\n", "                        int unitsy = (byteappd[k] << 8) + (byteappd[k + 1] & 0xff);\n", "\n", "                        if (unitsx == 1 || unitsx == 2) {\n", "                            dx = (unitsx == 2 ? (int) (dx * 2.54f + 0.5f) : dx);\n", "                            // make sure this is consistent with JFIF data\n", "                            if (image.getDpiX() != 0 && image.getDpiX() != dx) {\n", "                                LOGGER.debug(MessageFormatUtil.format(\"Inconsistent metadata (dpiX: {0} vs {1})\", image.getDpiX(), dx));\n", "                            } else {\n", "                                image.setDpi(dx, image.getDpiY());\n", "                            }\n", "                        }\n", "                        if (unitsy == 1 || unitsy == 2) {\n", "                            dy = (unitsy == 2 ? (int) (dy * 2.54f + 0.5f) : dy);\n", "                            // make sure this is consistent with JFIF data\n", "                            if (image.getDpiY() != 0 && image.getDpiY() != dy) {\n", "                                LOGGER.debug(MessageFormatUtil.format(\"Inconsistent metadata (dpiY: {0} vs {1})\", image.getDpiY(), dy));\n", "                            } else {\n", "                                image.setDpi(image.getDpiX(), dx);\n", "                            }\n", "                        }\n", "                    }\n", "                    continue;\n", "                }\n", "                firstPass = false;\n", "                int markertype = marker(marker);\n", "                if (markertype == VALID_MARKER) {\n", "                    StreamUtil.skip(jpegStream, 2);\n", "                    if (jpegStream.read() != 0x08) {\n", "                        throw new IOException(IoExceptionMessageConstant.MUST_HAVE_8_BITS_PER_COMPONENT).setMessageParams(errorID);\n", "                    }\n", "                    image.setHeight(getShort(jpegStream));\n", "                    image.setWidth(getShort(jpegStream));\n", "                    image.setColorEncodingComponentsNumber(jpegStream.read());\n", "                    image.setBpc(8);\n", "                    break;\n", "                } else if (markertype == UNSUPPORTED_MARKER) {\n", "                    throw new IOException(IoExceptionMessageConstant.UNSUPPORTED_JPEG_MARKER).setMessageParams(errorID, Integer.toString(marker));\n", "                } else if (markertype != NOPARAM_MARKER) {\n", "                    StreamUtil.skip(jpegStream, getShort(jpegStream) - 2);\n", "                }\n", "            }\n", "        }\n", "\n", "        attemptToSetIccProfileToImage(icc, image);\n", "    }\n", "\n", "    /**\n", "     * Reads a short from the <CODE>InputStream</CODE>.\n", "     *\n", "     * @param jpegStream the <CODE>InputStream</CODE>\n", "     * @return an int\n", "     * @throws java.io.IOException\n", "     */\n", "    private static int getShort(InputStream jpegStream) throws java.io.IOException {\n", "        return (jpegStream.read() << 8) + jpegStream.read();\n", "    }\n", "\n", "    /**\n", "     * Returns a type of marker.\n", "     *\n", "     * @param marker an int\n", "     * @return a type: <VAR>VALID_MARKER</VAR>, <VAR>UNSUPPORTED_MARKER</VAR> or <VAR>NOPARAM_MARKER</VAR>\n", "     */\n", "    private static int marker(int marker) {\n", "        for (int i = 0; i < VALID_MARKERS.length; i++) {\n", "            if (marker == VALID_MARKERS[i]) {\n", "                return VALID_MARKER;\n", "            }\n", "        }\n", "        for (int i = 0; i < NOPARAM_MARKERS.length; i++) {\n", "            if (marker == NOPARAM_MARKERS[i]) {\n", "                return NOPARAM_MARKER;\n", "            }\n", "        }\n", "        for (int i = 0; i < UNSUPPORTED_MARKERS.length; i++) {\n", "            if (marker == UNSUPPORTED_MARKERS[i]) {\n", "                return UNSUPPORTED_MARKER;\n", "            }\n", "        }\n", "        return NOT_A_MARKER;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.image;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.io.logs.IoLogMessageConstant;\n", "import com.itextpdf.io.util.StreamUtil;\n", "import com.itextpdf.test.AssertUtil;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.LogLevelConstants;\n", "import com.itextpdf.test.annotations.LogMessage;\n", "import com.itextpdf.test.annotations.LogMessages;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import java.io.InputStream;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class JpegImageHelperTest extends ExtendedITextTest {\n", "    public static final String SOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/image/\";\n", "\n", "    @Test\n", "    @LogMessages(messages = {\n", "            @LogMessage(messageTemplate = IoLogMessageConstant.DURING_CONSTRUCTION_OF_ICC_PROFILE_ERROR_OCCURRED, logLevel = LogLevelConstants.ERROR)\n", "    })\n", "    public void attemptToSetInvalidIccProfileToImageTest() throws IOException {\n", "        try (InputStream fis = FileUtil.getInputStreamForFile(SOURCE_FOLDER + \"WP_20140410_001.jpg\")) {\n", "\n", "            ImageData img = ImageDataFactory.createJpeg(StreamUtil.inputStreamToArray(fis));\n", "            int size = 100;\n", "            // Instantiate new byte[size][] instead new byte[size][size] necessary for autoporting\n", "            byte[][] icc = new byte[size][];\n", "            for (int i = 0; i < size; i++) {\n", "                icc[i] = new byte[size];\n", "                for (int j = 0; j < size; j++) {\n", "                    icc[i][j] = (byte) j;\n", "                }\n", "            }\n", "            AssertUtil.doesNotThrow(() -> JpegImageHelper.attemptToSetIccProfileToImage(icc, img));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void attemptToSetNullIccProfileToImageTest() throws IOException {\n", "        try (InputStream fis = FileUtil.getInputStreamForFile(SOURCE_FOLDER + \"WP_20140410_001.jpg\")) {\n", "            byte[][] icc = new byte[][] {null, null};\n", "            ImageData img = ImageDataFactory.createJpeg(StreamUtil.inputStreamToArray(fis));\n", "            AssertUtil.doesNotThrow(() -> JpegImageHelper.attemptToSetIccProfileToImage(icc, img));\n", "        }\n", "    }\n", "}\n"], "method_lines_dic": {"JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)": [110, 135], "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)": [137, 160], "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)": [162, 173], "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)": [181, 362], "JpegImageHelper::::getShort(java.io.InputStream)": [371, 373], "JpegImageHelper::::marker(int)": [381, 398]}, "test_method_lines_dic": {"JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()": [44, 63], "JpegImageHelperTest::::attemptToSetNullIccProfileToImageTest()": [65, 72]}, "reverse_method_lines_dic": {"110": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "111": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "112": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "113": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "114": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "115": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "116": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "117": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "118": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "119": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "120": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "121": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "122": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "123": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "124": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "125": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "126": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "127": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "128": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "129": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "130": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "131": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "132": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "133": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "134": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "135": "JpegImageHelper::::processImage(com.itextpdf.io.image.ImageData)", "137": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "138": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "139": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "140": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "141": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "142": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "143": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "144": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "145": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "146": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "147": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "148": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "149": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "150": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "151": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "152": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "153": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "154": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "155": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "156": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "157": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "158": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "159": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "160": "JpegImageHelper::::attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData)", "162": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "163": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "164": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "165": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "166": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "167": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "168": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "169": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "170": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "171": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "172": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "173": "JpegImageHelper::::updateAttributes(com.itextpdf.io.image.ImageData)", "181": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "182": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "183": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "184": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "185": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "186": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "187": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "188": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "189": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "190": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "191": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "192": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "193": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "194": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "195": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "196": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "197": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "198": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "199": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "200": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "201": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "202": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "203": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "204": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "205": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "206": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "207": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "208": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "209": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "210": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "211": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "212": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "213": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "214": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "215": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "216": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "217": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "218": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "219": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "220": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "221": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "222": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "223": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "224": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "225": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "226": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "227": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "228": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "229": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "230": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "231": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "232": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "233": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "234": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "235": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "236": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "237": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "238": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "239": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "240": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "241": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "242": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "243": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "244": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "245": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "246": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "247": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "248": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "249": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "250": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "251": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "252": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "253": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "254": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "255": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "256": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "257": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "258": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "259": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "260": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "261": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "262": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "263": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "264": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "265": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "266": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "267": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "268": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "269": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "270": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "271": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "272": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "273": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "274": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "275": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "276": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "277": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "278": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "279": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "280": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "281": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "282": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "283": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "284": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "285": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "286": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "287": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "288": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "289": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "290": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "291": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "292": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "293": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "294": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "295": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "296": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "297": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "298": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "299": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "300": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "301": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "302": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "303": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "304": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "305": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "306": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "307": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "308": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "309": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "310": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "311": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "312": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "313": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "314": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "315": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "316": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "317": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "318": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "319": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "320": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "321": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "322": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "323": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "324": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "325": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "326": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "327": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "328": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "329": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "330": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "331": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "332": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "333": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "334": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "335": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "336": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "337": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "338": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "339": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "340": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "341": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "342": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "343": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "344": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "345": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "346": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "347": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "348": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "349": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "350": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "351": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "352": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "353": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "354": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "355": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "356": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "357": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "358": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "359": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "360": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "361": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "362": "JpegImageHelper::::processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData)", "371": "JpegImageHelper::::getShort(java.io.InputStream)", "372": "JpegImageHelper::::getShort(java.io.InputStream)", "373": "JpegImageHelper::::getShort(java.io.InputStream)", "381": "JpegImageHelper::::marker(int)", "382": "JpegImageHelper::::marker(int)", "383": "JpegImageHelper::::marker(int)", "384": "JpegImageHelper::::marker(int)", "385": "JpegImageHelper::::marker(int)", "386": "JpegImageHelper::::marker(int)", "387": "JpegImageHelper::::marker(int)", "388": "JpegImageHelper::::marker(int)", "389": "JpegImageHelper::::marker(int)", "390": "JpegImageHelper::::marker(int)", "391": "JpegImageHelper::::marker(int)", "392": "JpegImageHelper::::marker(int)", "393": "JpegImageHelper::::marker(int)", "394": "JpegImageHelper::::marker(int)", "395": "JpegImageHelper::::marker(int)", "396": "JpegImageHelper::::marker(int)", "397": "JpegImageHelper::::marker(int)", "398": "JpegImageHelper::::marker(int)"}, "test_reverse_method_lines_dic": {"44": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "45": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "46": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "47": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "48": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "49": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "50": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "51": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "52": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "53": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "54": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "55": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "56": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "57": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "58": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "59": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "60": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "61": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "62": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "63": "JpegImageHelperTest::::attemptToSetInvalidIccProfileToImageTest()", "65": "JpegImageHelperTest::::attemptToSetNullIccProfileToImageTest()", "66": "JpegImageHelperTest::::attemptToSetNullIccProfileToImageTest()", "67": "JpegImageHelperTest::::attemptToSetNullIccProfileToImageTest()", "68": "JpegImageHelperTest::::attemptToSetNullIccProfileToImageTest()", "69": "JpegImageHelperTest::::attemptToSetNullIccProfileToImageTest()", "70": "JpegImageHelperTest::::attemptToSetNullIccProfileToImageTest()", "71": "JpegImageHelperTest::::attemptToSetNullIccProfileToImageTest()", "72": "JpegImageHelperTest::::attemptToSetNullIccProfileToImageTest()"}, "tests": [{"test_lines": [44, 63], "covered_lines": [40, 55, 65, 75, 97, 102, 111, 113, 116, 120, 122, 123, 124, 128, 130, 131, 134, 135, 138, 139, 140, 141, 144, 146, 147, 148, 149, 150, 154, 155, 157, 160, 163, 164, 169, 170, 173, 182, 183, 186, 189, 190, 192, 193, 194, 228, 242, 265, 341, 342, 343, 344, 345, 348, 349, 350, 351, 352, 353, 355, 356, 359, 361, 362, 372, 382, 383, 384, 387, 388, 392, 393, 397]}, {"test_lines": [65, 72], "covered_lines": [40, 55, 65, 75, 97, 102, 111, 113, 116, 120, 122, 123, 124, 128, 130, 131, 134, 135, 138, 139, 140, 141, 142, 160, 163, 164, 169, 170, 173, 182, 183, 186, 189, 190, 192, 193, 194, 228, 242, 265, 341, 342, 343, 344, 345, 348, 349, 350, 351, 352, 353, 355, 356, 359, 361, 362, 372, 382, 383, 384, 387, 388, 392, 393, 397]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/image/ImageDataFactory.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.image;\n", "\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.codec.CCITTG4Encoder;\n", "import com.itextpdf.io.codec.TIFFFaxDecoder;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.util.UrlUtil;\n", "\n", "import java.net.MalformedURLException;\n", "import java.net.URL;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "\n", "public final class ImageDataFactory {\n", "\n", "    private ImageDataFactory() {\n", "    }\n", "\n", "    /**\n", "     * Create an ImageData instance representing the image from the image bytes.\n", "     * @param bytes byte representation of the image.\n", "     * @param recoverImage whether to recover from a image error (for TIFF-images)\n", "     * @return The created ImageData object.\n", "     */\n", "    public static ImageData create(byte[] bytes, boolean recoverImage) {\n", "        return createImageInstance(bytes, recoverImage);\n", "    }\n", "\n", "    /**\n", "     * Create an ImageData instance representing the image from the image bytes.\n", "     * @param bytes byte representation of the image.\n", "     * @return The created ImageData object.\n", "     */\n", "    public static ImageData create(byte[] bytes) {\n", "        return create(bytes, false);\n", "    }\n", "\n", "    /**\n", "     * Create an ImageData instance representing the image from the file located at the specified url.\n", "     * @param url location of the image\n", "     * @param recoverImage whether to recover from a image error (for TIFF-images)\n", "     * @return The created ImageData object.\n", "     */\n", "    public static ImageData create(URL url, boolean recoverImage) {\n", "        return createImageInstance(url, recoverImage);\n", "    }\n", "\n", "    /**\n", "     * Create an ImageData instance representing the image from the file located at the specified url.\n", "     * @param url location of the image\n", "     * @return The created ImageData object.\n", "     */\n", "    public static ImageData create(URL url) {\n", "        return create(url, false);\n", "    }\n", "\n", "    /**\n", "     * Create an ImageData instance representing the image from the specified file.\n", "     * @param filename filename of the file containing the image\n", "     * @param recoverImage whether to recover from a image error (for TIFF-images)\n", "     * @return The created ImageData object.\n", "     * @throws MalformedURLException if an error occurred generating the URL.\n", "     */\n", "    public static ImageData create(String filename, boolean recoverImage) throws MalformedURLException {\n", "        return create(UrlUtil.toURL(filename), recoverImage);\n", "    }\n", "\n", "    /**\n", "     * Create an ImageData instance representing the image from the specified file.\n", "     * @param filename filename of the file containing the image\n", "     * @return The created ImageData object.\n", "     * @throws MalformedURLException if an error occurred generating the URL.\n", "     */\n", "    public static ImageData create(String filename) throws MalformedURLException {\n", "        return create(filename, false);\n", "    }\n", "\n", "    /**\n", "     * Create an ImageData instance from the passed parameters.\n", "     *\n", "     * @param width width of the image in pixels\n", "     * @param height height of the image in pixels\n", "     * @param reverseBits whether to reverse the bits stored in data (TIFF images).\n", "     * @param typeCCITT Type of CCITT encoding\n", "     * @param parameters colour space parameters\n", "     * @param data array containing raw image data\n", "     * @param transparency array containing transparency information\n", "     * @return created ImageData object.\n", "     */\n", "    public static ImageData create(int width, int height, boolean reverseBits,\n", "                                   int typeCCITT, int parameters, byte[] data,\n", "                                   int[] transparency) {\n", "        if (transparency != null && transparency.length != 2)\n", "            throw new IOException(IoExceptionMessageConstant.TRANSPARENCY_LENGTH_MUST_BE_EQUAL_TO_2_WITH_CCITT_IMAGES);\n", "        if (typeCCITT != RawImageData.CCITTG4 && typeCCITT != RawImageData.CCITTG3_1D && typeCCITT != RawImageData.CCITTG3_2D)\n", "            throw new IOException(IoExceptionMessageConstant.CCITT_COMPRESSION_TYPE_MUST_BE_CCITTG4_CCITTG3_1D_OR_CCITTG3_2D);\n", "        if (reverseBits)\n", "            TIFFFaxDecoder.reverseBits(data);\n", "        RawImageData image = new RawImageData(data, ImageType.RAW);\n", "        image.setTypeCcitt(typeCCITT);\n", "        image.height = height;\n", "        image.width = width;\n", "        image.colorEncodingComponentsNumber = parameters;\n", "        image.transparency = transparency;\n", "        return image;\n", "    }\n", "\n", "    /**\n", "     * Create an ImageData instance from the passed parameters.\n", "     *\n", "     * @param width width of the image in pixels\n", "     * @param height height of the image in pixels\n", "     * @param components colour space components\n", "     * @param bpc bits per colour.\n", "     * @param data array containing raw image data\n", "     * @param transparency array containing transparency information\n", "     * @return created ImageData object.\n", "     */\n", "    public static ImageData create(int width, int height, int components,\n", "                                   int bpc, byte[] data, int[] transparency) {\n", "        if (transparency != null && transparency.length != components * 2)\n", "            throw new IOException(IoExceptionMessageConstant.TRANSPARENCY_LENGTH_MUST_BE_EQUAL_TO_2_WITH_CCITT_IMAGES);\n", "        if (components == 1 && bpc == 1) {\n", "            byte[] g4 = CCITTG4Encoder.compress(data, width, height);\n", "            return ImageDataFactory.create(width, height, false, RawImageData.CCITTG4, RawImageData.CCITT_BLACKIS1, g4, transparency);\n", "        }\n", "        RawImageData image = new RawImageData(data, ImageType.RAW);\n", "        image.height = height;\n", "        image.width = width;\n", "        if (components != 1 && components != 3 && components != 4)\n", "            throw new IOException(IoExceptionMessageConstant.COMPONENTS_MUST_BE_1_3_OR_4);\n", "        if (bpc != 1 && bpc != 2 && bpc != 4 && bpc != 8)\n", "            throw new IOException(IoExceptionMessageConstant.BITS_PER_COMPONENT_MUST_BE_1_2_4_OR_8);\n", "        image.colorEncodingComponentsNumber = components;\n", "        image.bpc = bpc;\n", "        image.data = data;\n", "        image.transparency = transparency;\n", "        return image;\n", "    }\n", "\n", "    // Android-Conversion-Skip-Block-Start (java.awt library isn't available on Android)\n", "    /**\n", "     * Gets an instance of an Image from a java.awt.Image\n", "     *\n", "     * @param image the java.awt.Image to convert\n", "     * @param color if different from <CODE>null</CODE> the transparency pixels are replaced by this color\n", "     * @return RawImage\n", "     * @throws java.io.IOException if an I/O error occurs.\n", "     */\n", "    public static ImageData create(java.awt.Image image, java.awt.Color color) throws java.io.IOException {\n", "        return ImageDataFactory.create(image, color, false);\n", "    }\n", "\n", "    /**\n", "     * Gets an instance of an Image from a java.awt.Image.\n", "     *\n", "     * @param image   the <CODE>java.awt.Image</CODE> to convert\n", "     * @param color   if different from <CODE>null</CODE> the transparency pixels are replaced by this color\n", "     * @param forceBW if <CODE>true</CODE> the image is treated as black and white\n", "     * @return RawImage\n", "     * @throws java.io.IOException if an I/O error occurs.\n", "     */\n", "    public static ImageData create(java.awt.Image image, java.awt.Color color, boolean forceBW) throws java.io.IOException {\n", "        return AwtImageDataFactory.create(image, color, forceBW);\n", "    }\n", "    // Android-Conversion-Skip-Block-End\n", "\n", "    /**\n", "     * Get a bitmap ImageData instance from the specified url.\n", "     *\n", "     * @param url location of the image.\n", "     * @param noHeader Whether the image contains a header.\n", "     * @return created ImageData\n", "     */\n", "    public static ImageData createBmp(URL url, boolean noHeader) {\n", "        validateImageType(url, ImageType.BMP);\n", "        final ImageData image = new BmpImageData(url, noHeader);\n", "        BmpImageHelper.processImage(image);\n", "        return image;\n", "    }\n", "\n", "    /**\n", "     * Get a bitmap ImageData instance from the provided bytes.\n", "     *\n", "     * @param bytes array containing the raw image data\n", "     * @param noHeader Whether the image contains a header.\n", "     * @return created ImageData\n", "     */\n", "    public static ImageData createBmp(byte[] bytes, boolean noHeader) {\n", "        if (noHeader || ImageTypeDetector.detectImageType(bytes) == ImageType.BMP) {\n", "            ImageData image = new BmpImageData(bytes, noHeader);\n", "            BmpImageHelper.processImage(image);\n", "            return image;\n", "        }\n", "        throw new IllegalArgumentException(\"BMP image expected.\");\n", "    }\n", "\n", "    /**\n", "     * Return a GifImage object. This object cannot be added to a document\n", "     *\n", "     * @param bytes array containing the raw image data\n", "     * @return GifImageData instance.\n", "     */\n", "    public static GifImageData createGif(byte[] bytes) {\n", "        validateImageType(bytes, ImageType.GIF);\n", "        GifImageData image = new GifImageData(bytes);\n", "        GifImageHelper.processImage(image);\n", "        return image;\n", "    }\n", "\n", "    /**\n", "     * Returns a specified frame of the gif image\n", "     *\n", "     * @param url   url of gif image\n", "     * @param frame number of frame to be returned, 1-based\n", "     * @return GifImageData instance.\n", "     */\n", "    public static ImageData createGifFrame(URL url, int frame) {\n", "        return createGifFrames(url, new int[] {frame}).get(0);\n", "    }\n", "\n", "    /**\n", "     * Returns a specified frame of the gif image\n", "     *\n", "     * @param bytes byte array of gif image\n", "     * @param frame number of frame to be returned, 1-based\n", "     * @return GifImageData instance\n", "     */\n", "    public static ImageData createGifFrame(byte[] bytes, int frame) {\n", "        return createGifFrames(bytes, new int[] {frame}).get(0);\n", "    }\n", "\n", "    /**\n", "     * Returns <CODE>List</CODE> of gif image frames\n", "     *\n", "     * @param bytes        byte array of gif image\n", "     * @param frameNumbers array of frame numbers of gif image, 1-based\n", "     * @return all frames of gif image\n", "     */\n", "    public static List<ImageData> createGifFrames(byte[] bytes, int[] frameNumbers) {\n", "        validateImageType(bytes, ImageType.GIF);\n", "        GifImageData image = new GifImageData(bytes);\n", "        return processGifImageAndExtractFrames(frameNumbers, image);\n", "    }\n", "\n", "    /**\n", "     * Returns <CODE>List</CODE> of gif image frames\n", "     *\n", "     * @param url          url of gif image\n", "     * @param frameNumbers array of frame numbers of gif image, 1-based\n", "     * @return all frames of gif image\n", "     */\n", "    public static List<ImageData> createGifFrames(URL url, int[] frameNumbers) {\n", "        validateImageType(url, ImageType.GIF);\n", "        GifImageData image = new GifImageData(url);\n", "        return processGifImageAndExtractFrames(frameNumbers, image);\n", "    }\n", "\n", "    /**\n", "     * Returns <CODE>List</CODE> of gif image frames\n", "     *\n", "     * @param bytes byte array of gif image\n", "     * @return all frames of gif image\n", "     */\n", "    public static List<ImageData> createGifFrames(byte[] bytes) {\n", "        validateImageType(bytes, ImageType.GIF);\n", "        GifImageData image = new GifImageData(bytes);\n", "        GifImageHelper.processImage(image);\n", "        return image.getFrames();\n", "    }\n", "\n", "    /**\n", "     * Returns <CODE>List</CODE> of gif image frames\n", "     *\n", "     * @param url url of gif image\n", "     * @return all frames of gif image\n", "     */\n", "    public static List<ImageData> createGifFrames(URL url) {\n", "        validateImageType(url, ImageType.GIF);\n", "        GifImageData image = new GifImageData(url);\n", "        GifImageHelper.processImage(image);\n", "        return image.getFrames();\n", "    }\n", "\n", "    public static ImageData createJbig2(URL url, int page) {\n", "        if (page < 1)\n", "            throw new IllegalArgumentException(\"The page number must be greater than 0\");\n", "        validateImageType(url, ImageType.JBIG2);\n", "        ImageData image = new Jbig2ImageData(url, page);\n", "        Jbig2ImageHelper.processImage(image);\n", "        return image;\n", "    }\n", "\n", "    public static ImageData createJbig2(byte[] bytes, int page) {\n", "        if (page < 1)\n", "            throw new IllegalArgumentException(\"The page number must be greater than 0\");\n", "        validateImageType(bytes, ImageType.JBIG2);\n", "        ImageData image = new Jbig2ImageData(bytes, page);\n", "        Jbig2ImageHelper.processImage(image);\n", "        return image;\n", "\n", "    }\n", "\n", "    /**\n", "     * Create an {@link ImageData} instance from a Jpeg image url\n", "     * @param url URL\n", "     * @return the created JPEG image\n", "     */\n", "    public static ImageData createJpeg(URL url) {\n", "        validateImageType(url, ImageType.JPEG);\n", "        ImageData image = new JpegImageData(url);\n", "        JpegImageHelper.processImage(image);\n", "        return image;\n", "    }\n", "\n", "    public static ImageData createJpeg(byte[] bytes) {\n", "        validateImageType(bytes, ImageType.JPEG);\n", "        ImageData image = new JpegImageData(bytes);\n", "        JpegImageHelper.processImage(image);\n", "        return image;\n", "\n", "    }\n", "\n", "    public static ImageData createJpeg2000(URL url) {\n", "        validateImageType(url, ImageType.JPEG2000);\n", "        ImageData image = new Jpeg2000ImageData(url);\n", "        Jpeg2000ImageHelper.processImage(image);\n", "        return image;\n", "    }\n", "\n", "    public static ImageData createJpeg2000(byte[] bytes) {\n", "        validateImageType(bytes, ImageType.JPEG2000);\n", "        ImageData image = new Jpeg2000ImageData(bytes);\n", "        Jpeg2000ImageHelper.processImage(image);\n", "        return image;\n", "    }\n", "\n", "    public static ImageData createPng(URL url) {\n", "        validateImageType(url, ImageType.PNG);\n", "        ImageData image = new PngImageData(url);\n", "        PngImageHelper.processImage(image);\n", "        return image;\n", "    }\n", "\n", "    public static ImageData createPng(byte[] bytes) {\n", "        validateImageType(bytes, ImageType.PNG);\n", "        ImageData image = new PngImageData(bytes);\n", "        PngImageHelper.processImage(image);\n", "        return image;\n", "    }\n", "\n", "    public static ImageData createTiff(URL url, boolean recoverFromImageError, int page, boolean direct) {\n", "        validateImageType(url, ImageType.TIFF);\n", "        ImageData image = new TiffImageData(url, recoverFromImageError, page, direct);\n", "        TiffImageHelper.processImage(image);\n", "        return image;\n", "    }\n", "\n", "    public static ImageData createTiff(byte[] bytes, boolean recoverFromImageError, int page, boolean direct) {\n", "        validateImageType(bytes, ImageType.TIFF);\n", "        ImageData image = new TiffImageData(bytes, recoverFromImageError, page, direct);\n", "        TiffImageHelper.processImage(image);\n", "        return image;\n", "    }\n", "\n", "    public static ImageData createRawImage(byte[] bytes) {\n", "        return new RawImageData(bytes, ImageType.RAW);\n", "    }\n", "\n", "    /**\n", "     * Checks if the type of image (based on first 8 bytes) is supported by factory.\n", "     * <br>\n", "     * <b>Note:</b> if this method returns {@code true} it doesn't means that {@link #create(byte[])} won't throw exception\n", "     *\n", "     * @param source image raw bytes\n", "     * @return {@code true} if first eight bytes are recognised by factory as valid image type and {@code false} otherwise\n", "     */\n", "    public static boolean isSupportedType(byte[] source) {\n", "        if (source == null) {\n", "            return false;\n", "        }\n", "        ImageType imageType = ImageTypeDetector.detectImageType(source);\n", "        return isSupportedType(imageType);\n", "    }\n", "\n", "    /**\n", "     * Checks if the type of image (based on first 8 bytes) is supported by factory.\n", "     * <br>\n", "     * <b>Note:</b> if this method returns {@code true} it doesn't means that {@link #create(byte[])} won't throw exception\n", "     *\n", "     * @param source image URL\n", "     * @return {@code true} if first eight bytes are recognised by factory as valid image type and {@code false} otherwise\n", "     */\n", "    public static boolean isSupportedType(URL source) {\n", "        if (source == null) {\n", "            return false;\n", "        }\n", "        ImageType imageType = ImageTypeDetector.detectImageType(source);\n", "        return isSupportedType(imageType);\n", "    }\n", "\n", "    /**\n", "     * Checks if the type of image is supported by factory.\n", "     * <br>\n", "     * <b>Note:</b> if this method returns {@code true} it doesn't means that {@link #create(byte[])} won't throw exception\n", "     *\n", "     * @param imageType image type\n", "     * @return {@code true} if image type is supported and {@code false} otherwise\n", "     */\n", "    public static boolean isSupportedType(ImageType imageType) {\n", "        return imageType == ImageType.GIF || imageType == ImageType.JPEG || imageType == ImageType.JPEG2000\n", "                || imageType == ImageType.PNG || imageType == ImageType.BMP || imageType == ImageType.TIFF\n", "                || imageType == ImageType.JBIG2;\n", "    }\n", "\n", "    private static ImageData createImageInstance(URL source, boolean recoverImage) {\n", "        ImageType imageType = ImageTypeDetector.detectImageType(source);\n", "        switch (imageType) {\n", "            case GIF: {\n", "                GifImageData image = new GifImageData(source);\n", "                GifImageHelper.processImage(image, 0);\n", "                return image.getFrames().get(0);\n", "            }\n", "            case JPEG: {\n", "                ImageData image = new JpegImageData(source);\n", "                JpegImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            case JPEG2000: {\n", "                ImageData image = new Jpeg2000ImageData(source);\n", "                Jpeg2000ImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            case PNG: {\n", "                ImageData image = new PngImageData(source);\n", "                PngImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            case BMP: {\n", "                ImageData image = new BmpImageData(source, false);\n", "                BmpImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            case TIFF: {\n", "                ImageData image = new TiffImageData(source, recoverImage, 1, false);\n", "                TiffImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            case JBIG2: {\n", "                ImageData image = new Jbig2ImageData(source, 1);\n", "                Jbig2ImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            default:\n", "                throw new IOException(IoExceptionMessageConstant.IMAGE_FORMAT_CANNOT_BE_RECOGNIZED);\n", "        }\n", "    }\n", "\n", "    private static ImageData createImageInstance(byte[] bytes, boolean recoverImage) {\n", "        ImageType imageType = ImageTypeDetector.detectImageType(bytes);\n", "        switch (imageType) {\n", "            case GIF: {\n", "                GifImageData image = new GifImageData(bytes);\n", "                GifImageHelper.processImage(image, 0);\n", "                return image.getFrames().get(0);\n", "            }\n", "            case JPEG: {\n", "                ImageData image = new JpegImageData(bytes);\n", "                JpegImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            case JPEG2000: {\n", "                ImageData image = new Jpeg2000ImageData(bytes);\n", "                Jpeg2000ImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            case PNG: {\n", "                ImageData image = new PngImageData(bytes);\n", "                PngImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            case BMP: {\n", "                ImageData image = new BmpImageData(bytes, false);\n", "                BmpImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            case TIFF: {\n", "                ImageData image = new TiffImageData(bytes, recoverImage, 1, false);\n", "                TiffImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            case JBIG2: {\n", "                ImageData image = new Jbig2ImageData(bytes, 1);\n", "                Jbig2ImageHelper.processImage(image);\n", "                return image;\n", "            }\n", "            default:\n", "                throw new IOException(IoExceptionMessageConstant.IMAGE_FORMAT_CANNOT_BE_RECOGNIZED);\n", "        }\n", "    }\n", "\n", "    private static List<ImageData> processGifImageAndExtractFrames(int[] frameNumbers, GifImageData image) {\n", "        Arrays.sort(frameNumbers);\n", "        GifImageHelper.processImage(image, frameNumbers[frameNumbers.length - 1] - 1);\n", "        List<ImageData> frames = new ArrayList<>();\n", "        for (int frame : frameNumbers) {\n", "            frames.add(image.getFrames().get(frame - 1));\n", "        }\n", "        return frames;\n", "    }\n", "\n", "    private static void validateImageType(byte[] image, ImageType expectedType) {\n", "        ImageType detectedType = ImageTypeDetector.detectImageType(image);\n", "        if (detectedType != expectedType) {\n", "            throw new IllegalArgumentException(expectedType.name() +\n", "                    \" image expected. Detected image type: \" + detectedType.name());\n", "        }\n", "    }\n", "\n", "    private static void validateImageType(URL imageUrl, ImageType expectedType) {\n", "        ImageType detectedType = ImageTypeDetector.detectImageType(imageUrl);\n", "        if (detectedType != expectedType) {\n", "            throw new IllegalArgumentException(expectedType.name() +\n", "                    \" image expected. Detected image type: \" + detectedType.name());\n", "        }\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.image;\n", "\n", "import com.itextpdf.io.util.StreamUtil;\n", "import com.itextpdf.io.util.UrlUtil;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import java.io.InputStream;\n", "import java.net.URL;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class ImageDataFactoryTest extends ExtendedITextTest {\n", "\n", "    private static final String SOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/image/ImageDataFactoryTest/\";\n", "    private static final String IMAGE_NAME = \"image\";\n", "\n", "    @Test\n", "    public void testGetColorEncodingComponentsNumber() {\n", "        byte data[] = new byte[1];\n", "        ImageData raw = ImageDataFactory.create(1, 1, 1, 8, data, null);\n", "\n", "        Assert.assertEquals(1, raw.getColorEncodingComponentsNumber());\n", "    }\n", "\n", "    @Test\n", "    public void testSetColorEncodingComponentsNumber() {\n", "        byte data[] = new byte[1];\n", "        ImageData raw = ImageDataFactory.create(1, 1, 1, 8, data, null);\n", "        raw.setColorEncodingComponentsNumber(3);\n", "\n", "        Assert.assertEquals(3, raw.getColorEncodingComponentsNumber());\n", "    }\n", "\n", "    @Test\n", "    public void testGetColorEncodingComponentsNumberCCITT() {\n", "        byte data[] = new byte[1];\n", "        ImageData raw = ImageDataFactory.create(1, 1, false, 0x100, 1, data, null);\n", "\n", "        Assert.assertEquals(1, raw.getColorEncodingComponentsNumber());\n", "    }\n", "\n", "    @Test\n", "    public void testImageTypeSupportUnknownFile() throws IOException {\n", "        testImageTypeSupport(UrlUtil.toURL(SOURCE_FOLDER + IMAGE_NAME + \".txt\"), false);\n", "    }\n", "\n", "    @Test\n", "    public void testImageTypeSupportGifFile() throws IOException {\n", "        testImageTypeSupport(UrlUtil.toURL(SOURCE_FOLDER + IMAGE_NAME + \".gif\"), true);\n", "    }\n", "\n", "    @Test\n", "    public void testImageTypeSupportJpegFile() throws IOException {\n", "        testImageTypeSupport(UrlUtil.toURL(SOURCE_FOLDER + IMAGE_NAME + \".jpg\"), true);\n", "    }\n", "\n", "    @Test\n", "    public void testImageTypeSupportTiffFile() throws IOException {\n", "        testImageTypeSupport(UrlUtil.toURL(SOURCE_FOLDER + IMAGE_NAME + \".tiff\"), true);\n", "    }\n", "\n", "    @Test\n", "    public void testImageTypeSupportWmfType() {\n", "        Assert.assertFalse(ImageDataFactory.isSupportedType(ImageType.WMF));\n", "    }\n", "\n", "    private void testImageTypeSupport(URL location, boolean expectedResult) throws IOException {\n", "        Assert.assertEquals(expectedResult, ImageDataFactory.isSupportedType(location));\n", "        try (InputStream inputStream = UrlUtil.openStream(location)) {\n", "            Assert.assertEquals(expectedResult, ImageDataFactory.isSupportedType(StreamUtil.inputStreamToArray(inputStream)));\n", "        }\n", "    }\n", "\n", "}\n"], "method_lines_dic": {"ImageDataFactory::::create(byte[],boolean)": [48, 50], "ImageDataFactory::::create(byte[])": [57, 59], "ImageDataFactory::::create(java.net.URL,boolean)": [67, 69], "ImageDataFactory::::create(java.net.URL)": [76, 78], "ImageDataFactory::::create(java.lang.String,boolean)": [87, 89], "ImageDataFactory::::create(java.lang.String)": [97, 99], "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])": [113, 129], "ImageDataFactory::::create(int,int,int,int,byte[],int[])": [142, 162], "ImageDataFactory::::create(java.awt.Image,java.awt.Color)": [173, 175], "ImageDataFactory::::create(java.awt.Image,java.awt.Color,boolean)": [186, 188], "ImageDataFactory::::createBmp(java.net.URL,boolean)": [198, 203], "ImageDataFactory::::createBmp(byte[],boolean)": [212, 219], "ImageDataFactory::::createGif(byte[])": [227, 232], "ImageDataFactory::::createGifFrame(java.net.URL,int)": [241, 243], "ImageDataFactory::::createGifFrame(byte[],int)": [252, 254], "ImageDataFactory::::createGifFrames(byte[],int[])": [263, 267], "ImageDataFactory::::createGifFrames(java.net.URL,int[])": [276, 280], "ImageDataFactory::::createGifFrames(byte[])": [288, 293], "ImageDataFactory::::createGifFrames(java.net.URL)": [301, 306], "ImageDataFactory::::createJbig2(java.net.URL,int)": [308, 315], "ImageDataFactory::::createJbig2(byte[],int)": [317, 325], "ImageDataFactory::::createJpeg(java.net.URL)": [332, 337], "ImageDataFactory::::createJpeg(byte[])": [339, 345], "ImageDataFactory::::createJpeg2000(java.net.URL)": [347, 352], "ImageDataFactory::::createJpeg2000(byte[])": [354, 359], "ImageDataFactory::::createPng(java.net.URL)": [361, 366], "ImageDataFactory::::createPng(byte[])": [368, 373], "ImageDataFactory::::createTiff(java.net.URL,boolean,int,boolean)": [375, 380], "ImageDataFactory::::createTiff(byte[],boolean,int,boolean)": [382, 387], "ImageDataFactory::::createRawImage(byte[])": [389, 391], "ImageDataFactory::::isSupportedType(byte[])": [401, 407], "ImageDataFactory::::isSupportedType(java.net.URL)": [417, 423], "ImageDataFactory::::isSupportedType(com.itextpdf.io.image.ImageType)": [433, 437], "ImageDataFactory::::createImageInstance(java.net.URL,boolean)": [439, 480], "ImageDataFactory::::createImageInstance(byte[],boolean)": [482, 523], "ImageDataFactory::::processGifImageAndExtractFrames(int[],com.itextpdf.io.image.GifImageData)": [525, 533], "ImageDataFactory::::validateImageType(byte[],com.itextpdf.io.image.ImageType)": [535, 541], "ImageDataFactory::::validateImageType(java.net.URL,com.itextpdf.io.image.ImageType)": [543, 549]}, "test_method_lines_dic": {"ImageDataFactoryTest::::testGetColorEncodingComponentsNumber()": [43, 49], "ImageDataFactoryTest::::testSetColorEncodingComponentsNumber()": [51, 58], "ImageDataFactoryTest::::testGetColorEncodingComponentsNumberCCITT()": [60, 66], "ImageDataFactoryTest::::testImageTypeSupportUnknownFile()": [68, 71], "ImageDataFactoryTest::::testImageTypeSupportGifFile()": [73, 76], "ImageDataFactoryTest::::testImageTypeSupportJpegFile()": [78, 81], "ImageDataFactoryTest::::testImageTypeSupportTiffFile()": [83, 86], "ImageDataFactoryTest::::testImageTypeSupportWmfType()": [88, 91], "ImageDataFactoryTest::::testImageTypeSupport(java.net.URL,boolean)": [93, 98]}, "reverse_method_lines_dic": {"48": "ImageDataFactory::::create(byte[],boolean)", "49": "ImageDataFactory::::create(byte[],boolean)", "50": "ImageDataFactory::::create(byte[],boolean)", "57": "ImageDataFactory::::create(byte[])", "58": "ImageDataFactory::::create(byte[])", "59": "ImageDataFactory::::create(byte[])", "67": "ImageDataFactory::::create(java.net.URL,boolean)", "68": "ImageDataFactory::::create(java.net.URL,boolean)", "69": "ImageDataFactory::::create(java.net.URL,boolean)", "76": "ImageDataFactory::::create(java.net.URL)", "77": "ImageDataFactory::::create(java.net.URL)", "78": "ImageDataFactory::::create(java.net.URL)", "87": "ImageDataFactory::::create(java.lang.String,boolean)", "88": "ImageDataFactory::::create(java.lang.String,boolean)", "89": "ImageDataFactory::::create(java.lang.String,boolean)", "97": "ImageDataFactory::::create(java.lang.String)", "98": "ImageDataFactory::::create(java.lang.String)", "99": "ImageDataFactory::::create(java.lang.String)", "113": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "114": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "115": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "116": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "117": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "118": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "119": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "120": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "121": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "122": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "123": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "124": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "125": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "126": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "127": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "128": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "129": "ImageDataFactory::::create(int,int,boolean,int,int,byte[],int[])", "142": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "143": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "144": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "145": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "146": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "147": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "148": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "149": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "150": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "151": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "152": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "153": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "154": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "155": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "156": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "157": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "158": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "159": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "160": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "161": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "162": "ImageDataFactory::::create(int,int,int,int,byte[],int[])", "173": "ImageDataFactory::::create(java.awt.Image,java.awt.Color)", "174": "ImageDataFactory::::create(java.awt.Image,java.awt.Color)", "175": "ImageDataFactory::::create(java.awt.Image,java.awt.Color)", "186": "ImageDataFactory::::create(java.awt.Image,java.awt.Color,boolean)", "187": "ImageDataFactory::::create(java.awt.Image,java.awt.Color,boolean)", "188": "ImageDataFactory::::create(java.awt.Image,java.awt.Color,boolean)", "198": "ImageDataFactory::::createBmp(java.net.URL,boolean)", "199": "ImageDataFactory::::createBmp(java.net.URL,boolean)", "200": "ImageDataFactory::::createBmp(java.net.URL,boolean)", "201": "ImageDataFactory::::createBmp(java.net.URL,boolean)", "202": "ImageDataFactory::::createBmp(java.net.URL,boolean)", "203": "ImageDataFactory::::createBmp(java.net.URL,boolean)", "212": "ImageDataFactory::::createBmp(byte[],boolean)", "213": "ImageDataFactory::::createBmp(byte[],boolean)", "214": "ImageDataFactory::::createBmp(byte[],boolean)", "215": "ImageDataFactory::::createBmp(byte[],boolean)", "216": "ImageDataFactory::::createBmp(byte[],boolean)", "217": "ImageDataFactory::::createBmp(byte[],boolean)", "218": "ImageDataFactory::::createBmp(byte[],boolean)", "219": "ImageDataFactory::::createBmp(byte[],boolean)", "227": "ImageDataFactory::::createGif(byte[])", "228": "ImageDataFactory::::createGif(byte[])", "229": "ImageDataFactory::::createGif(byte[])", "230": "ImageDataFactory::::createGif(byte[])", "231": "ImageDataFactory::::createGif(byte[])", "232": "ImageDataFactory::::createGif(byte[])", "241": "ImageDataFactory::::createGifFrame(java.net.URL,int)", "242": "ImageDataFactory::::createGifFrame(java.net.URL,int)", "243": "ImageDataFactory::::createGifFrame(java.net.URL,int)", "252": "ImageDataFactory::::createGifFrame(byte[],int)", "253": "ImageDataFactory::::createGifFrame(byte[],int)", "254": "ImageDataFactory::::createGifFrame(byte[],int)", "263": "ImageDataFactory::::createGifFrames(byte[],int[])", "264": "ImageDataFactory::::createGifFrames(byte[],int[])", "265": "ImageDataFactory::::createGifFrames(byte[],int[])", "266": "ImageDataFactory::::createGifFrames(byte[],int[])", "267": "ImageDataFactory::::createGifFrames(byte[],int[])", "276": "ImageDataFactory::::createGifFrames(java.net.URL,int[])", "277": "ImageDataFactory::::createGifFrames(java.net.URL,int[])", "278": "ImageDataFactory::::createGifFrames(java.net.URL,int[])", "279": "ImageDataFactory::::createGifFrames(java.net.URL,int[])", "280": "ImageDataFactory::::createGifFrames(java.net.URL,int[])", "288": "ImageDataFactory::::createGifFrames(byte[])", "289": "ImageDataFactory::::createGifFrames(byte[])", "290": "ImageDataFactory::::createGifFrames(byte[])", "291": "ImageDataFactory::::createGifFrames(byte[])", "292": "ImageDataFactory::::createGifFrames(byte[])", "293": "ImageDataFactory::::createGifFrames(byte[])", "301": "ImageDataFactory::::createGifFrames(java.net.URL)", "302": "ImageDataFactory::::createGifFrames(java.net.URL)", "303": "ImageDataFactory::::createGifFrames(java.net.URL)", "304": "ImageDataFactory::::createGifFrames(java.net.URL)", "305": "ImageDataFactory::::createGifFrames(java.net.URL)", "306": "ImageDataFactory::::createGifFrames(java.net.URL)", "308": "ImageDataFactory::::createJbig2(java.net.URL,int)", "309": "ImageDataFactory::::createJbig2(java.net.URL,int)", "310": "ImageDataFactory::::createJbig2(java.net.URL,int)", "311": "ImageDataFactory::::createJbig2(java.net.URL,int)", "312": "ImageDataFactory::::createJbig2(java.net.URL,int)", "313": "ImageDataFactory::::createJbig2(java.net.URL,int)", "314": "ImageDataFactory::::createJbig2(java.net.URL,int)", "315": "ImageDataFactory::::createJbig2(java.net.URL,int)", "317": "ImageDataFactory::::createJbig2(byte[],int)", "318": "ImageDataFactory::::createJbig2(byte[],int)", "319": "ImageDataFactory::::createJbig2(byte[],int)", "320": "ImageDataFactory::::createJbig2(byte[],int)", "321": "ImageDataFactory::::createJbig2(byte[],int)", "322": "ImageDataFactory::::createJbig2(byte[],int)", "323": "ImageDataFactory::::createJbig2(byte[],int)", "324": "ImageDataFactory::::createJbig2(byte[],int)", "325": "ImageDataFactory::::createJbig2(byte[],int)", "332": "ImageDataFactory::::createJpeg(java.net.URL)", "333": "ImageDataFactory::::createJpeg(java.net.URL)", "334": "ImageDataFactory::::createJpeg(java.net.URL)", "335": "ImageDataFactory::::createJpeg(java.net.URL)", "336": "ImageDataFactory::::createJpeg(java.net.URL)", "337": "ImageDataFactory::::createJpeg(java.net.URL)", "339": "ImageDataFactory::::createJpeg(byte[])", "340": "ImageDataFactory::::createJpeg(byte[])", "341": "ImageDataFactory::::createJpeg(byte[])", "342": "ImageDataFactory::::createJpeg(byte[])", "343": "ImageDataFactory::::createJpeg(byte[])", "344": "ImageDataFactory::::createJpeg(byte[])", "345": "ImageDataFactory::::createJpeg(byte[])", "347": "ImageDataFactory::::createJpeg2000(java.net.URL)", "348": "ImageDataFactory::::createJpeg2000(java.net.URL)", "349": "ImageDataFactory::::createJpeg2000(java.net.URL)", "350": "ImageDataFactory::::createJpeg2000(java.net.URL)", "351": "ImageDataFactory::::createJpeg2000(java.net.URL)", "352": "ImageDataFactory::::createJpeg2000(java.net.URL)", "354": "ImageDataFactory::::createJpeg2000(byte[])", "355": "ImageDataFactory::::createJpeg2000(byte[])", "356": "ImageDataFactory::::createJpeg2000(byte[])", "357": "ImageDataFactory::::createJpeg2000(byte[])", "358": "ImageDataFactory::::createJpeg2000(byte[])", "359": "ImageDataFactory::::createJpeg2000(byte[])", "361": "ImageDataFactory::::createPng(java.net.URL)", "362": "ImageDataFactory::::createPng(java.net.URL)", "363": "ImageDataFactory::::createPng(java.net.URL)", "364": "ImageDataFactory::::createPng(java.net.URL)", "365": "ImageDataFactory::::createPng(java.net.URL)", "366": "ImageDataFactory::::createPng(java.net.URL)", "368": "ImageDataFactory::::createPng(byte[])", "369": "ImageDataFactory::::createPng(byte[])", "370": "ImageDataFactory::::createPng(byte[])", "371": "ImageDataFactory::::createPng(byte[])", "372": "ImageDataFactory::::createPng(byte[])", "373": "ImageDataFactory::::createPng(byte[])", "375": "ImageDataFactory::::createTiff(java.net.URL,boolean,int,boolean)", "376": "ImageDataFactory::::createTiff(java.net.URL,boolean,int,boolean)", "377": "ImageDataFactory::::createTiff(java.net.URL,boolean,int,boolean)", "378": "ImageDataFactory::::createTiff(java.net.URL,boolean,int,boolean)", "379": "ImageDataFactory::::createTiff(java.net.URL,boolean,int,boolean)", "380": "ImageDataFactory::::createTiff(java.net.URL,boolean,int,boolean)", "382": "ImageDataFactory::::createTiff(byte[],boolean,int,boolean)", "383": "ImageDataFactory::::createTiff(byte[],boolean,int,boolean)", "384": "ImageDataFactory::::createTiff(byte[],boolean,int,boolean)", "385": "ImageDataFactory::::createTiff(byte[],boolean,int,boolean)", "386": "ImageDataFactory::::createTiff(byte[],boolean,int,boolean)", "387": "ImageDataFactory::::createTiff(byte[],boolean,int,boolean)", "389": "ImageDataFactory::::createRawImage(byte[])", "390": "ImageDataFactory::::createRawImage(byte[])", "391": "ImageDataFactory::::createRawImage(byte[])", "401": "ImageDataFactory::::isSupportedType(byte[])", "402": "ImageDataFactory::::isSupportedType(byte[])", "403": "ImageDataFactory::::isSupportedType(byte[])", "404": "ImageDataFactory::::isSupportedType(byte[])", "405": "ImageDataFactory::::isSupportedType(byte[])", "406": "ImageDataFactory::::isSupportedType(byte[])", "407": "ImageDataFactory::::isSupportedType(byte[])", "417": "ImageDataFactory::::isSupportedType(java.net.URL)", "418": "ImageDataFactory::::isSupportedType(java.net.URL)", "419": "ImageDataFactory::::isSupportedType(java.net.URL)", "420": "ImageDataFactory::::isSupportedType(java.net.URL)", "421": "ImageDataFactory::::isSupportedType(java.net.URL)", "422": "ImageDataFactory::::isSupportedType(java.net.URL)", "423": "ImageDataFactory::::isSupportedType(java.net.URL)", "433": "ImageDataFactory::::isSupportedType(com.itextpdf.io.image.ImageType)", "434": "ImageDataFactory::::isSupportedType(com.itextpdf.io.image.ImageType)", "435": "ImageDataFactory::::isSupportedType(com.itextpdf.io.image.ImageType)", "436": "ImageDataFactory::::isSupportedType(com.itextpdf.io.image.ImageType)", "437": "ImageDataFactory::::isSupportedType(com.itextpdf.io.image.ImageType)", "439": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "440": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "441": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "442": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "443": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "444": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "445": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "446": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "447": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "448": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "449": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "450": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "451": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "452": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "453": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "454": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "455": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "456": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "457": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "458": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "459": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "460": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "461": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "462": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "463": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "464": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "465": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "466": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "467": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "468": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "469": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "470": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "471": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "472": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "473": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "474": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "475": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "476": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "477": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "478": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "479": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "480": "ImageDataFactory::::createImageInstance(java.net.URL,boolean)", "482": "ImageDataFactory::::createImageInstance(byte[],boolean)", "483": "ImageDataFactory::::createImageInstance(byte[],boolean)", "484": "ImageDataFactory::::createImageInstance(byte[],boolean)", "485": "ImageDataFactory::::createImageInstance(byte[],boolean)", "486": "ImageDataFactory::::createImageInstance(byte[],boolean)", "487": "ImageDataFactory::::createImageInstance(byte[],boolean)", "488": "ImageDataFactory::::createImageInstance(byte[],boolean)", "489": "ImageDataFactory::::createImageInstance(byte[],boolean)", "490": "ImageDataFactory::::createImageInstance(byte[],boolean)", "491": "ImageDataFactory::::createImageInstance(byte[],boolean)", "492": "ImageDataFactory::::createImageInstance(byte[],boolean)", "493": "ImageDataFactory::::createImageInstance(byte[],boolean)", "494": "ImageDataFactory::::createImageInstance(byte[],boolean)", "495": "ImageDataFactory::::createImageInstance(byte[],boolean)", "496": "ImageDataFactory::::createImageInstance(byte[],boolean)", "497": "ImageDataFactory::::createImageInstance(byte[],boolean)", "498": "ImageDataFactory::::createImageInstance(byte[],boolean)", "499": "ImageDataFactory::::createImageInstance(byte[],boolean)", "500": "ImageDataFactory::::createImageInstance(byte[],boolean)", "501": "ImageDataFactory::::createImageInstance(byte[],boolean)", "502": "ImageDataFactory::::createImageInstance(byte[],boolean)", "503": "ImageDataFactory::::createImageInstance(byte[],boolean)", "504": "ImageDataFactory::::createImageInstance(byte[],boolean)", "505": "ImageDataFactory::::createImageInstance(byte[],boolean)", "506": "ImageDataFactory::::createImageInstance(byte[],boolean)", "507": "ImageDataFactory::::createImageInstance(byte[],boolean)", "508": "ImageDataFactory::::createImageInstance(byte[],boolean)", "509": "ImageDataFactory::::createImageInstance(byte[],boolean)", "510": "ImageDataFactory::::createImageInstance(byte[],boolean)", "511": "ImageDataFactory::::createImageInstance(byte[],boolean)", "512": "ImageDataFactory::::createImageInstance(byte[],boolean)", "513": "ImageDataFactory::::createImageInstance(byte[],boolean)", "514": "ImageDataFactory::::createImageInstance(byte[],boolean)", "515": "ImageDataFactory::::createImageInstance(byte[],boolean)", "516": "ImageDataFactory::::createImageInstance(byte[],boolean)", "517": "ImageDataFactory::::createImageInstance(byte[],boolean)", "518": "ImageDataFactory::::createImageInstance(byte[],boolean)", "519": "ImageDataFactory::::createImageInstance(byte[],boolean)", "520": "ImageDataFactory::::createImageInstance(byte[],boolean)", "521": "ImageDataFactory::::createImageInstance(byte[],boolean)", "522": "ImageDataFactory::::createImageInstance(byte[],boolean)", "523": "ImageDataFactory::::createImageInstance(byte[],boolean)", "525": "ImageDataFactory::::processGifImageAndExtractFrames(int[],com.itextpdf.io.image.GifImageData)", "526": "ImageDataFactory::::processGifImageAndExtractFrames(int[],com.itextpdf.io.image.GifImageData)", "527": "ImageDataFactory::::processGifImageAndExtractFrames(int[],com.itextpdf.io.image.GifImageData)", "528": "ImageDataFactory::::processGifImageAndExtractFrames(int[],com.itextpdf.io.image.GifImageData)", "529": "ImageDataFactory::::processGifImageAndExtractFrames(int[],com.itextpdf.io.image.GifImageData)", "530": "ImageDataFactory::::processGifImageAndExtractFrames(int[],com.itextpdf.io.image.GifImageData)", "531": "ImageDataFactory::::processGifImageAndExtractFrames(int[],com.itextpdf.io.image.GifImageData)", "532": "ImageDataFactory::::processGifImageAndExtractFrames(int[],com.itextpdf.io.image.GifImageData)", "533": "ImageDataFactory::::processGifImageAndExtractFrames(int[],com.itextpdf.io.image.GifImageData)", "535": "ImageDataFactory::::validateImageType(byte[],com.itextpdf.io.image.ImageType)", "536": "ImageDataFactory::::validateImageType(byte[],com.itextpdf.io.image.ImageType)", "537": "ImageDataFactory::::validateImageType(byte[],com.itextpdf.io.image.ImageType)", "538": "ImageDataFactory::::validateImageType(byte[],com.itextpdf.io.image.ImageType)", "539": "ImageDataFactory::::validateImageType(byte[],com.itextpdf.io.image.ImageType)", "540": "ImageDataFactory::::validateImageType(byte[],com.itextpdf.io.image.ImageType)", "541": "ImageDataFactory::::validateImageType(byte[],com.itextpdf.io.image.ImageType)", "543": "ImageDataFactory::::validateImageType(java.net.URL,com.itextpdf.io.image.ImageType)", "544": "ImageDataFactory::::validateImageType(java.net.URL,com.itextpdf.io.image.ImageType)", "545": "ImageDataFactory::::validateImageType(java.net.URL,com.itextpdf.io.image.ImageType)", "546": "ImageDataFactory::::validateImageType(java.net.URL,com.itextpdf.io.image.ImageType)", "547": "ImageDataFactory::::validateImageType(java.net.URL,com.itextpdf.io.image.ImageType)", "548": "ImageDataFactory::::validateImageType(java.net.URL,com.itextpdf.io.image.ImageType)", "549": "ImageDataFactory::::validateImageType(java.net.URL,com.itextpdf.io.image.ImageType)"}, "test_reverse_method_lines_dic": {"43": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumber()", "44": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumber()", "45": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumber()", "46": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumber()", "47": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumber()", "48": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumber()", "49": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumber()", "51": "ImageDataFactoryTest::::testSetColorEncodingComponentsNumber()", "52": "ImageDataFactoryTest::::testSetColorEncodingComponentsNumber()", "53": "ImageDataFactoryTest::::testSetColorEncodingComponentsNumber()", "54": "ImageDataFactoryTest::::testSetColorEncodingComponentsNumber()", "55": "ImageDataFactoryTest::::testSetColorEncodingComponentsNumber()", "56": "ImageDataFactoryTest::::testSetColorEncodingComponentsNumber()", "57": "ImageDataFactoryTest::::testSetColorEncodingComponentsNumber()", "58": "ImageDataFactoryTest::::testSetColorEncodingComponentsNumber()", "60": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumberCCITT()", "61": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumberCCITT()", "62": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumberCCITT()", "63": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumberCCITT()", "64": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumberCCITT()", "65": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumberCCITT()", "66": "ImageDataFactoryTest::::testGetColorEncodingComponentsNumberCCITT()", "68": "ImageDataFactoryTest::::testImageTypeSupportUnknownFile()", "69": "ImageDataFactoryTest::::testImageTypeSupportUnknownFile()", "70": "ImageDataFactoryTest::::testImageTypeSupportUnknownFile()", "71": "ImageDataFactoryTest::::testImageTypeSupportUnknownFile()", "73": "ImageDataFactoryTest::::testImageTypeSupportGifFile()", "74": "ImageDataFactoryTest::::testImageTypeSupportGifFile()", "75": "ImageDataFactoryTest::::testImageTypeSupportGifFile()", "76": "ImageDataFactoryTest::::testImageTypeSupportGifFile()", "78": "ImageDataFactoryTest::::testImageTypeSupportJpegFile()", "79": "ImageDataFactoryTest::::testImageTypeSupportJpegFile()", "80": "ImageDataFactoryTest::::testImageTypeSupportJpegFile()", "81": "ImageDataFactoryTest::::testImageTypeSupportJpegFile()", "83": "ImageDataFactoryTest::::testImageTypeSupportTiffFile()", "84": "ImageDataFactoryTest::::testImageTypeSupportTiffFile()", "85": "ImageDataFactoryTest::::testImageTypeSupportTiffFile()", "86": "ImageDataFactoryTest::::testImageTypeSupportTiffFile()", "88": "ImageDataFactoryTest::::testImageTypeSupportWmfType()", "89": "ImageDataFactoryTest::::testImageTypeSupportWmfType()", "90": "ImageDataFactoryTest::::testImageTypeSupportWmfType()", "91": "ImageDataFactoryTest::::testImageTypeSupportWmfType()", "93": "ImageDataFactoryTest::::testImageTypeSupport(java.net.URL,boolean)", "94": "ImageDataFactoryTest::::testImageTypeSupport(java.net.URL,boolean)", "95": "ImageDataFactoryTest::::testImageTypeSupport(java.net.URL,boolean)", "96": "ImageDataFactoryTest::::testImageTypeSupport(java.net.URL,boolean)", "97": "ImageDataFactoryTest::::testImageTypeSupport(java.net.URL,boolean)", "98": "ImageDataFactoryTest::::testImageTypeSupport(java.net.URL,boolean)"}, "tests": [{"test_lines": [43, 49], "covered_lines": [144, 146, 150, 151, 152, 153, 155, 157, 158, 159, 160, 161]}, {"test_lines": [51, 58], "covered_lines": [144, 146, 150, 151, 152, 153, 155, 157, 158, 159, 160, 161]}, {"test_lines": [60, 66], "covered_lines": [116, 118, 120, 122, 123, 124, 125, 126, 127, 128]}, {"test_lines": [68, 71], "covered_lines": [402, 405, 406, 418, 421, 422, 434]}, {"test_lines": [73, 76], "covered_lines": [402, 405, 406, 418, 421, 422, 434]}, {"test_lines": [78, 81], "covered_lines": [402, 405, 406, 418, 421, 422, 434]}, {"test_lines": [83, 86], "covered_lines": [402, 405, 406, 418, 421, 422, 434]}, {"test_lines": [88, 91], "covered_lines": [434]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/image/ImageTypeDetector.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.image;\n", "\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.util.UrlUtil;\n", "\n", "import java.io.ByteArrayInputStream;\n", "import java.io.InputStream;\n", "import java.net.URL;\n", "\n", "/**\n", " * Helper class that detects image type by magic bytes\n", " */\n", "public final class ImageTypeDetector {\n", "\n", "    private static final byte[] gif = new byte[]{(byte) 'G', (byte) 'I', (byte) 'F'};\n", "    private static final byte[] jpeg = new byte[]{(byte) 0xFF, (byte) 0xD8};\n", "    private static final byte[] jpeg2000_1 = new byte[]{0x00, 0x00, 0x00, 0x0c};\n", "    private static final byte[] jpeg2000_2 = new byte[]{(byte) 0xff, (byte) 0x4f, (byte) 0xff, 0x51};\n", "    private static final byte[] png = new byte[]{(byte) 137, 80, 78, 71};\n", "    private static final byte[] wmf = new byte[]{(byte) 0xD7, (byte) 0xCD};\n", "    private static final byte[] bmp = new byte[]{(byte) 'B', (byte) 'M'};\n", "    private static final byte[] tiff_1 = new byte[]{(byte) 'M', (byte) 'M', 0, 42};\n", "    private static final byte[] tiff_2 = new byte[]{(byte) 'I', (byte) 'I', 42, 0};\n", "    private static final byte[] jbig2 = new byte[]{(byte) 0x97, (byte) 'J', (byte) 'B', (byte) '2', (byte) '\\r', (byte) '\\n', 0x1a, (byte) '\\n'};\n", "\n", "    private ImageTypeDetector() {\n", "    }\n", "\n", "    /**\n", "     * Detect image type by magic bytes given the byte array source.\n", "     *\n", "     * @param source image bytes\n", "     * @return detected image type, see{@link ImageType}. Returns {@link ImageType#NONE} if image type is unknown\n", "     */\n", "    public static ImageType detectImageType(byte[] source) {\n", "        byte[] header = readImageType(source);\n", "        return detectImageTypeByHeader(header);\n", "    }\n", "\n", "    /**\n", "     * Detect image type by magic bytes given the source URL.\n", "     *\n", "     * @param source image URL\n", "     * @return detected image type, see{@link ImageType}. Returns {@link ImageType#NONE} if image type is unknown\n", "     */\n", "    public static ImageType detectImageType(URL source) {\n", "        byte[] header = readImageType(source);\n", "        return detectImageTypeByHeader(header);\n", "    }\n", "\n", "    /**\n", "     * Detect image type by magic bytes given the input stream.\n", "     *\n", "     * @param stream image stream\n", "     * @return detected image type, see{@link ImageType}. Returns {@link ImageType#NONE} if image type is unknown\n", "     */\n", "    public static ImageType detectImageType(InputStream stream) {\n", "        byte[] header = readImageType(stream);\n", "        return detectImageTypeByHeader(header);\n", "    }\n", "\n", "    private static ImageType detectImageTypeByHeader(byte[] header) {\n", "        if (imageTypeIs(header, gif)) {\n", "            return ImageType.GIF;\n", "        } else if (imageTypeIs(header, jpeg)) {\n", "            return ImageType.JPEG;\n", "        } else if (imageTypeIs(header, jpeg2000_1) || imageTypeIs(header, jpeg2000_2)) {\n", "            return ImageType.JPEG2000;\n", "        } else if (imageTypeIs(header, png)) {\n", "            return ImageType.PNG;\n", "        } else if (imageTypeIs(header, bmp)) {\n", "            return ImageType.BMP;\n", "        } else if (imageTypeIs(header, tiff_1) || imageTypeIs(header, tiff_2)) {\n", "            return ImageType.TIFF;\n", "        } else if (imageTypeIs(header, jbig2)) {\n", "            return ImageType.JBIG2;\n", "        } else if (imageTypeIs(header, wmf)) {\n", "            return ImageType.WMF;\n", "        }\n", "        return ImageType.NONE;\n", "    }\n", "\n", "    private static boolean imageTypeIs(byte[] imageType, byte[] compareWith) {\n", "        for (int i = 0; i < compareWith.length; i++) {\n", "            if (imageType[i] != compareWith[i])\n", "                return false;\n", "        }\n", "        return true;\n", "    }\n", "\n", "    private static byte[] readImageType(URL source) {\n", "        try (InputStream stream = UrlUtil.openStream(source)) {\n", "            return readImageType(stream);\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.IO_EXCEPTION, e);\n", "        }\n", "    }\n", "\n", "    private static byte[] readImageType(InputStream stream) {\n", "        try {\n", "            byte[] bytes = new byte[8];\n", "            stream.read(bytes);\n", "            return bytes;\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.IO_EXCEPTION, e);\n", "        }\n", "    }\n", "\n", "    private static byte[] readImageType(byte[] source) {\n", "        try {\n", "            InputStream stream = new ByteArrayInputStream(source);\n", "            byte[] bytes = new byte[8];\n", "            stream.read(bytes);\n", "            return bytes;\n", "        } catch (java.io.IOException e) {\n", "            return null;\n", "        }\n", "    }\n", "\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.image;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.io.util.StreamUtil;\n", "import com.itextpdf.io.util.UrlUtil;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import java.io.InputStream;\n", "import java.net.MalformedURLException;\n", "import java.net.URL;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class ImageTypeDetectorTest extends ExtendedITextTest {\n", "\n", "    private static final String SOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/image/ImageTypeDetectorTest/\";\n", "    private static final String IMAGE_NAME = \"image\";\n", "\n", "    @Test\n", "    public void testUrlUnknown() throws MalformedURLException {\n", "        testURL(UrlUtil.toURL(SOURCE_FOLDER + IMAGE_NAME + \".txt\"), ImageType.NONE);\n", "    }\n", "\n", "    @Test\n", "    public void testUrlGif() throws MalformedURLException {\n", "        testURL(UrlUtil.toURL(SOURCE_FOLDER + IMAGE_NAME + \".gif\"), ImageType.GIF);\n", "    }\n", "\n", "    @Test\n", "    public void testUrlJpeg() throws MalformedURLException {\n", "        testURL(UrlUtil.toURL(SOURCE_FOLDER + IMAGE_NAME + \".jpg\"), ImageType.JPEG);\n", "    }\n", "\n", "    @Test\n", "    public void testUrlTiff() throws MalformedURLException {\n", "        testURL(UrlUtil.toURL(SOURCE_FOLDER + IMAGE_NAME + \".tiff\"), ImageType.TIFF);\n", "    }\n", "\n", "    @Test\n", "    public void testUrlWmf() throws MalformedURLException {\n", "        testURL(UrlUtil.toURL(SOURCE_FOLDER + IMAGE_NAME + \".wmf\"), ImageType.WMF);\n", "    }\n", "\n", "    @Test\n", "    public void testNullUrl() throws MalformedURLException {\n", "        URL url = UrlUtil.toURL(\"not existing path\");\n", "\n", "        Assert.assertThrows(com.itextpdf.io.exceptions.IOException.class,\n", "                () -> ImageTypeDetector.detectImageType(url)\n", "        );\n", "    }\n", "\n", "    @Test\n", "    public void testStreamUnknown() throws IOException {\n", "        testStream(FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".txt\"), ImageType.NONE);\n", "    }\n", "\n", "    @Test\n", "    public void testStreamGif() throws IOException {\n", "        testStream(FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".gif\"), ImageType.GIF);\n", "    }\n", "\n", "    @Test\n", "    public void testStreamJpeg() throws IOException {\n", "        testStream(FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".jpg\"), ImageType.JPEG);\n", "    }\n", "\n", "    @Test\n", "    public void testStreamTiff() throws IOException {\n", "        testStream(FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".tiff\"), ImageType.TIFF);\n", "    }\n", "\n", "    @Test\n", "    public void testStreamWmf() throws IOException {\n", "        testStream(FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".wmf\"), ImageType.WMF);\n", "    }\n", "\n", "    @Test\n", "    public void testStreamClosed() throws IOException {\n", "        InputStream stream = FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".wmf\");\n", "        stream.close();\n", "\n", "        // A common exception is expected instead of com.itextpdf.io.exceptions.IOException, because in .NET\n", "        // the thrown exception is different\n", "        Assert.assertThrows(Exception.class, () -> ImageTypeDetector.detectImageType(stream));\n", "    }\n", "\n", "    @Test\n", "    public void testBytesUnknown() throws IOException {\n", "        testBytes(StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".txt\")),\n", "                ImageType.NONE);\n", "    }\n", "\n", "    @Test\n", "    public void testBytesGif() throws IOException {\n", "        testBytes(StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".gif\")),\n", "                ImageType.GIF);\n", "    }\n", "\n", "    @Test\n", "    public void testBytesJpeg() throws IOException {\n", "        testBytes(StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".jpg\")),\n", "                ImageType.JPEG);\n", "    }\n", "\n", "    @Test\n", "    public void testBytesTiff() throws IOException {\n", "        testBytes(StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".tiff\")),\n", "                ImageType.TIFF);\n", "    }\n", "\n", "    @Test\n", "    public void testBytesWmf() throws IOException {\n", "        testBytes(StreamUtil.inputStreamToArray(FileUtil.getInputStreamForFile(SOURCE_FOLDER + IMAGE_NAME + \".wmf\")),\n", "                ImageType.WMF);\n", "    }\n", "\n", "    private static void testURL(URL location, ImageType expectedType) {\n", "        Assert.assertEquals(expectedType, ImageTypeDetector.detectImageType(location));\n", "    }\n", "\n", "    private static void testStream(InputStream stream, ImageType expectedType) {\n", "        Assert.assertEquals(expectedType, ImageTypeDetector.detectImageType(stream));\n", "    }\n", "\n", "    private static void testBytes(byte[] bytes, ImageType expectedType) {\n", "        Assert.assertEquals(expectedType, ImageTypeDetector.detectImageType(bytes));\n", "    }\n", "}\n"], "method_lines_dic": {"ImageTypeDetector::::detectImageType(byte[])": [58, 61], "ImageTypeDetector::::detectImageType(java.net.URL)": [69, 72], "ImageTypeDetector::::detectImageType(java.io.InputStream)": [80, 83], "ImageTypeDetector::::detectImageTypeByHeader(byte[])": [85, 104], "ImageTypeDetector::::imageTypeIs(byte[],byte[])": [106, 112], "ImageTypeDetector::::readImageType(java.net.URL)": [114, 120], "ImageTypeDetector::::readImageType(java.io.InputStream)": [122, 130], "ImageTypeDetector::::readImageType(byte[])": [132, 141]}, "test_method_lines_dic": {"ImageTypeDetectorTest::::testUrlUnknown()": [45, 48], "ImageTypeDetectorTest::::testUrlGif()": [50, 53], "ImageTypeDetectorTest::::testUrlJpeg()": [55, 58], "ImageTypeDetectorTest::::testUrlTiff()": [60, 63], "ImageTypeDetectorTest::::testUrlWmf()": [65, 68], "ImageTypeDetectorTest::::testNullUrl()": [70, 77], "ImageTypeDetectorTest::::testStreamUnknown()": [79, 82], "ImageTypeDetectorTest::::testStreamGif()": [84, 87], "ImageTypeDetectorTest::::testStreamJpeg()": [89, 92], "ImageTypeDetectorTest::::testStreamTiff()": [94, 97], "ImageTypeDetectorTest::::testStreamWmf()": [99, 102], "ImageTypeDetectorTest::::testStreamClosed()": [104, 112], "ImageTypeDetectorTest::::testBytesUnknown()": [114, 118], "ImageTypeDetectorTest::::testBytesGif()": [120, 124], "ImageTypeDetectorTest::::testBytesJpeg()": [126, 130], "ImageTypeDetectorTest::::testBytesTiff()": [132, 136], "ImageTypeDetectorTest::::testBytesWmf()": [138, 142]}, "reverse_method_lines_dic": {"58": "ImageTypeDetector::::detectImageType(byte[])", "59": "ImageTypeDetector::::detectImageType(byte[])", "60": "ImageTypeDetector::::detectImageType(byte[])", "61": "ImageTypeDetector::::detectImageType(byte[])", "69": "ImageTypeDetector::::detectImageType(java.net.URL)", "70": "ImageTypeDetector::::detectImageType(java.net.URL)", "71": "ImageTypeDetector::::detectImageType(java.net.URL)", "72": "ImageTypeDetector::::detectImageType(java.net.URL)", "80": "ImageTypeDetector::::detectImageType(java.io.InputStream)", "81": "ImageTypeDetector::::detectImageType(java.io.InputStream)", "82": "ImageTypeDetector::::detectImageType(java.io.InputStream)", "83": "ImageTypeDetector::::detectImageType(java.io.InputStream)", "85": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "86": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "87": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "88": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "89": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "90": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "91": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "92": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "93": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "94": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "95": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "96": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "97": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "98": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "99": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "100": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "101": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "102": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "103": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "104": "ImageTypeDetector::::detectImageTypeByHeader(byte[])", "106": "ImageTypeDetector::::imageTypeIs(byte[],byte[])", "107": "ImageTypeDetector::::imageTypeIs(byte[],byte[])", "108": "ImageTypeDetector::::imageTypeIs(byte[],byte[])", "109": "ImageTypeDetector::::imageTypeIs(byte[],byte[])", "110": "ImageTypeDetector::::imageTypeIs(byte[],byte[])", "111": "ImageTypeDetector::::imageTypeIs(byte[],byte[])", "112": "ImageTypeDetector::::imageTypeIs(byte[],byte[])", "114": "ImageTypeDetector::::readImageType(java.net.URL)", "115": "ImageTypeDetector::::readImageType(java.net.URL)", "116": "ImageTypeDetector::::readImageType(java.net.URL)", "117": "ImageTypeDetector::::readImageType(java.net.URL)", "118": "ImageTypeDetector::::readImageType(java.net.URL)", "119": "ImageTypeDetector::::readImageType(java.net.URL)", "120": "ImageTypeDetector::::readImageType(java.net.URL)", "122": "ImageTypeDetector::::readImageType(java.io.InputStream)", "123": "ImageTypeDetector::::readImageType(java.io.InputStream)", "124": "ImageTypeDetector::::readImageType(java.io.InputStream)", "125": "ImageTypeDetector::::readImageType(java.io.InputStream)", "126": "ImageTypeDetector::::readImageType(java.io.InputStream)", "127": "ImageTypeDetector::::readImageType(java.io.InputStream)", "128": "ImageTypeDetector::::readImageType(java.io.InputStream)", "129": "ImageTypeDetector::::readImageType(java.io.InputStream)", "130": "ImageTypeDetector::::readImageType(java.io.InputStream)", "132": "ImageTypeDetector::::readImageType(byte[])", "133": "ImageTypeDetector::::readImageType(byte[])", "134": "ImageTypeDetector::::readImageType(byte[])", "135": "ImageTypeDetector::::readImageType(byte[])", "136": "ImageTypeDetector::::readImageType(byte[])", "137": "ImageTypeDetector::::readImageType(byte[])", "138": "ImageTypeDetector::::readImageType(byte[])", "139": "ImageTypeDetector::::readImageType(byte[])", "140": "ImageTypeDetector::::readImageType(byte[])", "141": "ImageTypeDetector::::readImageType(byte[])"}, "test_reverse_method_lines_dic": {"45": "ImageTypeDetectorTest::::testUrlUnknown()", "46": "ImageTypeDetectorTest::::testUrlUnknown()", "47": "ImageTypeDetectorTest::::testUrlUnknown()", "48": "ImageTypeDetectorTest::::testUrlUnknown()", "50": "ImageTypeDetectorTest::::testUrlGif()", "51": "ImageTypeDetectorTest::::testUrlGif()", "52": "ImageTypeDetectorTest::::testUrlGif()", "53": "ImageTypeDetectorTest::::testUrlGif()", "55": "ImageTypeDetectorTest::::testUrlJpeg()", "56": "ImageTypeDetectorTest::::testUrlJpeg()", "57": "ImageTypeDetectorTest::::testUrlJpeg()", "58": "ImageTypeDetectorTest::::testUrlJpeg()", "60": "ImageTypeDetectorTest::::testUrlTiff()", "61": "ImageTypeDetectorTest::::testUrlTiff()", "62": "ImageTypeDetectorTest::::testUrlTiff()", "63": "ImageTypeDetectorTest::::testUrlTiff()", "65": "ImageTypeDetectorTest::::testUrlWmf()", "66": "ImageTypeDetectorTest::::testUrlWmf()", "67": "ImageTypeDetectorTest::::testUrlWmf()", "68": "ImageTypeDetectorTest::::testUrlWmf()", "70": "ImageTypeDetectorTest::::testNullUrl()", "71": "ImageTypeDetectorTest::::testNullUrl()", "72": "ImageTypeDetectorTest::::testNullUrl()", "73": "ImageTypeDetectorTest::::testNullUrl()", "74": "ImageTypeDetectorTest::::testNullUrl()", "75": "ImageTypeDetectorTest::::testNullUrl()", "76": "ImageTypeDetectorTest::::testNullUrl()", "77": "ImageTypeDetectorTest::::testNullUrl()", "79": "ImageTypeDetectorTest::::testStreamUnknown()", "80": "ImageTypeDetectorTest::::testStreamUnknown()", "81": "ImageTypeDetectorTest::::testStreamUnknown()", "82": "ImageTypeDetectorTest::::testStreamUnknown()", "84": "ImageTypeDetectorTest::::testStreamGif()", "85": "ImageTypeDetectorTest::::testStreamGif()", "86": "ImageTypeDetectorTest::::testStreamGif()", "87": "ImageTypeDetectorTest::::testStreamGif()", "89": "ImageTypeDetectorTest::::testStreamJpeg()", "90": "ImageTypeDetectorTest::::testStreamJpeg()", "91": "ImageTypeDetectorTest::::testStreamJpeg()", "92": "ImageTypeDetectorTest::::testStreamJpeg()", "94": "ImageTypeDetectorTest::::testStreamTiff()", "95": "ImageTypeDetectorTest::::testStreamTiff()", "96": "ImageTypeDetectorTest::::testStreamTiff()", "97": "ImageTypeDetectorTest::::testStreamTiff()", "99": "ImageTypeDetectorTest::::testStreamWmf()", "100": "ImageTypeDetectorTest::::testStreamWmf()", "101": "ImageTypeDetectorTest::::testStreamWmf()", "102": "ImageTypeDetectorTest::::testStreamWmf()", "104": "ImageTypeDetectorTest::::testStreamClosed()", "105": "ImageTypeDetectorTest::::testStreamClosed()", "106": "ImageTypeDetectorTest::::testStreamClosed()", "107": "ImageTypeDetectorTest::::testStreamClosed()", "108": "ImageTypeDetectorTest::::testStreamClosed()", "109": "ImageTypeDetectorTest::::testStreamClosed()", "110": "ImageTypeDetectorTest::::testStreamClosed()", "111": "ImageTypeDetectorTest::::testStreamClosed()", "112": "ImageTypeDetectorTest::::testStreamClosed()", "114": "ImageTypeDetectorTest::::testBytesUnknown()", "115": "ImageTypeDetectorTest::::testBytesUnknown()", "116": "ImageTypeDetectorTest::::testBytesUnknown()", "117": "ImageTypeDetectorTest::::testBytesUnknown()", "118": "ImageTypeDetectorTest::::testBytesUnknown()", "120": "ImageTypeDetectorTest::::testBytesGif()", "121": "ImageTypeDetectorTest::::testBytesGif()", "122": "ImageTypeDetectorTest::::testBytesGif()", "123": "ImageTypeDetectorTest::::testBytesGif()", "124": "ImageTypeDetectorTest::::testBytesGif()", "126": "ImageTypeDetectorTest::::testBytesJpeg()", "127": "ImageTypeDetectorTest::::testBytesJpeg()", "128": "ImageTypeDetectorTest::::testBytesJpeg()", "129": "ImageTypeDetectorTest::::testBytesJpeg()", "130": "ImageTypeDetectorTest::::testBytesJpeg()", "132": "ImageTypeDetectorTest::::testBytesTiff()", "133": "ImageTypeDetectorTest::::testBytesTiff()", "134": "ImageTypeDetectorTest::::testBytesTiff()", "135": "ImageTypeDetectorTest::::testBytesTiff()", "136": "ImageTypeDetectorTest::::testBytesTiff()", "138": "ImageTypeDetectorTest::::testBytesWmf()", "139": "ImageTypeDetectorTest::::testBytesWmf()", "140": "ImageTypeDetectorTest::::testBytesWmf()", "141": "ImageTypeDetectorTest::::testBytesWmf()", "142": "ImageTypeDetectorTest::::testBytesWmf()"}, "tests": [{"test_lines": [45, 48], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 70, 71, 86, 88, 90, 92, 94, 96, 98, 100, 103, 107, 108, 109, 115, 116, 117, 124, 125, 126]}, {"test_lines": [50, 53], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 70, 71, 86, 87, 107, 108, 111, 115, 116, 117, 124, 125, 126]}, {"test_lines": [55, 58], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 70, 71, 86, 88, 89, 107, 108, 109, 111, 115, 116, 117, 124, 125, 126]}, {"test_lines": [60, 63], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 70, 71, 86, 88, 90, 92, 94, 96, 97, 107, 108, 109, 111, 115, 116, 117, 124, 125, 126]}, {"test_lines": [65, 68], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 70, 71, 86, 88, 90, 92, 94, 96, 98, 100, 101, 107, 108, 109, 111, 115, 116, 117, 124, 125, 126]}, {"test_lines": [70, 77], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 117, 118]}, {"test_lines": [79, 82], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 81, 82, 86, 88, 90, 92, 94, 96, 98, 100, 103, 107, 108, 109, 124, 125, 126]}, {"test_lines": [84, 87], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 81, 82, 86, 87, 107, 108, 111, 124, 125, 126]}, {"test_lines": [89, 92], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 81, 82, 86, 88, 89, 107, 108, 109, 111, 124, 125, 126]}, {"test_lines": [94, 97], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 81, 82, 86, 88, 90, 92, 94, 96, 97, 107, 108, 109, 111, 124, 125, 126]}, {"test_lines": [99, 102], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 81, 82, 86, 88, 90, 92, 94, 96, 98, 100, 101, 107, 108, 109, 111, 124, 125, 126]}, {"test_lines": [104, 112], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 124, 127, 128]}, {"test_lines": [114, 118], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 59, 60, 86, 88, 90, 92, 94, 96, 98, 100, 103, 107, 108, 109, 134, 135, 136, 137]}, {"test_lines": [120, 124], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 59, 60, 86, 87, 107, 108, 111, 134, 135, 136, 137]}, {"test_lines": [126, 130], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 59, 60, 86, 88, 89, 107, 108, 109, 111, 134, 135, 136, 137]}, {"test_lines": [132, 136], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 59, 60, 86, 88, 90, 92, 94, 96, 97, 107, 108, 109, 111, 134, 135, 136, 137]}, {"test_lines": [138, 142], "covered_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 59, 60, 86, 88, 90, 92, 94, 96, 98, 100, 101, 107, 108, 109, 111, 134, 135, 136, 137]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/codec/brotli/dec/Transform.java": {"class_content": ["/* Copyright 2015 Google Inc. All Rights Reserved.\n", "\n", "   Distributed under MIT license.\n", "   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n", "*/\n", "\n", "package com.itextpdf.io.codec.brotli.dec;\n", "\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.IDENTITY;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_FIRST_1;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_FIRST_2;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_FIRST_3;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_FIRST_4;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_FIRST_5;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_FIRST_6;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_FIRST_7;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_FIRST_9;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_LAST_1;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_LAST_2;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_LAST_3;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_LAST_4;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_LAST_5;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_LAST_6;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_LAST_7;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_LAST_8;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.OMIT_LAST_9;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.UPPERCASE_ALL;\n", "import static com.itextpdf.io.codec.brotli.dec.WordTransformType.UPPERCASE_FIRST;\n", "\n", "import java.nio.ByteBuffer;\n", "\n", "/**\n", " * Transformations on dictionary words.\n", " */\n", "final class Transform {\n", "\n", "  private final byte[] prefix;\n", "  private final int type;\n", "  private final byte[] suffix;\n", "\n", "  Transform(String prefix, int type, String suffix) {\n", "    this.prefix = readUniBytes(prefix);\n", "    this.type = type;\n", "    this.suffix = readUniBytes(suffix);\n", "  }\n", "\n", "  static byte[] readUniBytes(String uniBytes) {\n", "    byte[] result = new byte[uniBytes.length()];\n", "    for (int i = 0; i < result.length; ++i) {\n", "      result[i] = (byte) uniBytes.charAt(i);\n", "    }\n", "    return result;\n", "  }\n", "\n", "  static final Transform[] TRANSFORMS = {\n", "          new Transform(\"\", IDENTITY, \"\"),\n", "          new Transform(\"\", IDENTITY, \" \"),\n", "          new Transform(\" \", IDENTITY, \" \"),\n", "          new Transform(\"\", OMIT_FIRST_1, \"\"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \" \"),\n", "          new Transform(\"\", IDENTITY, \" the \"),\n", "          new Transform(\" \", IDENTITY, \"\"),\n", "          new Transform(\"s \", IDENTITY, \" \"),\n", "          new Transform(\"\", IDENTITY, \" of \"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \"\"),\n", "          new Transform(\"\", IDENTITY, \" and \"),\n", "          new Transform(\"\", OMIT_FIRST_2, \"\"),\n", "          new Transform(\"\", OMIT_LAST_1, \"\"),\n", "          new Transform(\", \", IDENTITY, \" \"),\n", "          new Transform(\"\", IDENTITY, \", \"),\n", "          new Transform(\" \", UPPERCASE_FIRST, \" \"),\n", "          new Transform(\"\", IDENTITY, \" in \"),\n", "          new Transform(\"\", IDENTITY, \" to \"),\n", "          new Transform(\"e \", IDENTITY, \" \"),\n", "          new Transform(\"\", IDENTITY, \"\\\"\"),\n", "          new Transform(\"\", IDENTITY, \".\"),\n", "          new Transform(\"\", IDENTITY, \"\\\">\"),\n", "          new Transform(\"\", IDENTITY, \"\\n\"),\n", "          new Transform(\"\", OMIT_LAST_3, \"\"),\n", "          new Transform(\"\", IDENTITY, \"]\"),\n", "          new Transform(\"\", IDENTITY, \" for \"),\n", "          new Transform(\"\", OMIT_FIRST_3, \"\"),\n", "          new Transform(\"\", OMIT_LAST_2, \"\"),\n", "          new Transform(\"\", IDENTITY, \" a \"),\n", "          new Transform(\"\", IDENTITY, \" that \"),\n", "          new Transform(\" \", UPPERCASE_FIRST, \"\"),\n", "          new Transform(\"\", IDENTITY, \". \"),\n", "          new Transform(\".\", IDENTITY, \"\"),\n", "          new Transform(\" \", IDENTITY, \", \"),\n", "          new Transform(\"\", OMIT_FIRST_4, \"\"),\n", "          new Transform(\"\", IDENTITY, \" with \"),\n", "          new Transform(\"\", IDENTITY, \"'\"),\n", "          new Transform(\"\", IDENTITY, \" from \"),\n", "          new Transform(\"\", IDENTITY, \" by \"),\n", "          new Transform(\"\", OMIT_FIRST_5, \"\"),\n", "          new Transform(\"\", OMIT_FIRST_6, \"\"),\n", "          new Transform(\" the \", IDENTITY, \"\"),\n", "          new Transform(\"\", OMIT_LAST_4, \"\"),\n", "          new Transform(\"\", IDENTITY, \". The \"),\n", "          new Transform(\"\", UPPERCASE_ALL, \"\"),\n", "          new Transform(\"\", IDENTITY, \" on \"),\n", "          new Transform(\"\", IDENTITY, \" as \"),\n", "          new Transform(\"\", IDENTITY, \" is \"),\n", "          new Transform(\"\", OMIT_LAST_7, \"\"),\n", "          new Transform(\"\", OMIT_LAST_1, \"ing \"),\n", "          new Transform(\"\", IDENTITY, \"\\n\\t\"),\n", "          new Transform(\"\", IDENTITY, \":\"),\n", "          new Transform(\" \", IDENTITY, \". \"),\n", "          new Transform(\"\", IDENTITY, \"ed \"),\n", "          new Transform(\"\", OMIT_FIRST_9, \"\"),\n", "          new Transform(\"\", OMIT_FIRST_7, \"\"),\n", "          new Transform(\"\", OMIT_LAST_6, \"\"),\n", "          new Transform(\"\", IDENTITY, \"(\"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \", \"),\n", "          new Transform(\"\", OMIT_LAST_8, \"\"),\n", "          new Transform(\"\", IDENTITY, \" at \"),\n", "          new Transform(\"\", IDENTITY, \"ly \"),\n", "          new Transform(\" the \", IDENTITY, \" of \"),\n", "          new Transform(\"\", OMIT_LAST_5, \"\"),\n", "          new Transform(\"\", OMIT_LAST_9, \"\"),\n", "          new Transform(\" \", UPPERCASE_FIRST, \", \"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \"\\\"\"),\n", "          new Transform(\".\", IDENTITY, \"(\"),\n", "          new Transform(\"\", UPPERCASE_ALL, \" \"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \"\\\">\"),\n", "          new Transform(\"\", IDENTITY, \"=\\\"\"),\n", "          new Transform(\" \", IDENTITY, \".\"),\n", "          new Transform(\".com/\", IDENTITY, \"\"),\n", "          new Transform(\" the \", IDENTITY, \" of the \"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \"'\"),\n", "          new Transform(\"\", IDENTITY, \". This \"),\n", "          new Transform(\"\", IDENTITY, \",\"),\n", "          new Transform(\".\", IDENTITY, \" \"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \"(\"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \".\"),\n", "          new Transform(\"\", IDENTITY, \" not \"),\n", "          new Transform(\" \", IDENTITY, \"=\\\"\"),\n", "          new Transform(\"\", IDENTITY, \"er \"),\n", "          new Transform(\" \", UPPERCASE_ALL, \" \"),\n", "          new Transform(\"\", IDENTITY, \"al \"),\n", "          new Transform(\" \", UPPERCASE_ALL, \"\"),\n", "          new Transform(\"\", IDENTITY, \"='\"),\n", "          new Transform(\"\", UPPERCASE_ALL, \"\\\"\"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \". \"),\n", "          new Transform(\" \", IDENTITY, \"(\"),\n", "          new Transform(\"\", IDENTITY, \"ful \"),\n", "          new Transform(\" \", UPPERCASE_FIRST, \". \"),\n", "          new Transform(\"\", IDENTITY, \"ive \"),\n", "          new Transform(\"\", IDENTITY, \"less \"),\n", "          new Transform(\"\", UPPERCASE_ALL, \"'\"),\n", "          new Transform(\"\", IDENTITY, \"est \"),\n", "          new Transform(\" \", UPPERCASE_FIRST, \".\"),\n", "          new Transform(\"\", UPPERCASE_ALL, \"\\\">\"),\n", "          new Transform(\" \", IDENTITY, \"='\"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \",\"),\n", "          new Transform(\"\", IDENTITY, \"ize \"),\n", "          new Transform(\"\", UPPERCASE_ALL, \".\"),\n", "          new Transform(\"\\u00c2\\u00a0\", IDENTITY, \"\"),\n", "          new Transform(\" \", IDENTITY, \",\"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \"=\\\"\"),\n", "          new Transform(\"\", UPPERCASE_ALL, \"=\\\"\"),\n", "          new Transform(\"\", IDENTITY, \"ous \"),\n", "          new Transform(\"\", UPPERCASE_ALL, \", \"),\n", "          new Transform(\"\", UPPERCASE_FIRST, \"='\"),\n", "          new Transform(\" \", UPPERCASE_FIRST, \",\"),\n", "          new Transform(\" \", UPPERCASE_ALL, \"=\\\"\"),\n", "          new Transform(\" \", UPPERCASE_ALL, \", \"),\n", "          new Transform(\"\", UPPERCASE_ALL, \",\"),\n", "          new Transform(\"\", UPPERCASE_ALL, \"(\"),\n", "          new Transform(\"\", UPPERCASE_ALL, \". \"),\n", "          new Transform(\" \", UPPERCASE_ALL, \".\"),\n", "          new Transform(\"\", UPPERCASE_ALL, \"='\"),\n", "          new Transform(\" \", UPPERCASE_ALL, \". \"),\n", "          new Transform(\" \", UPPERCASE_FIRST, \"=\\\"\"),\n", "          new Transform(\" \", UPPERCASE_ALL, \"='\"),\n", "          new Transform(\" \", UPPERCASE_FIRST, \"='\")\n", "  };\n", "\n", "  static int transformDictionaryWord(byte[] dst, int dstOffset, ByteBuffer data, int wordOffset,\n", "                                     int len, Transform transform) {\n", "    int offset = dstOffset;\n", "\n", "    // Copy prefix.\n", "    byte[] string = transform.prefix;\n", "    int tmp = string.length;\n", "    int i = 0;\n", "    // In most cases tmp < 10 -> no benefits from System.arrayCopy\n", "    while (i < tmp) {\n", "      dst[offset++] = string[i++];\n", "    }\n", "\n", "    // Copy trimmed word.\n", "    int op = transform.type;\n", "    tmp = WordTransformType.getOmitFirst(op);\n", "    if (tmp > len) {\n", "      tmp = len;\n", "    }\n", "    wordOffset += tmp;\n", "    len -= tmp;\n", "    len -= WordTransformType.getOmitLast(op);\n", "    i = len;\n", "    while (i > 0) {\n", "      dst[offset++] = data.get(wordOffset++);\n", "      i--;\n", "    }\n", "\n", "    if (op == UPPERCASE_ALL || op == UPPERCASE_FIRST) {\n", "      int uppercaseOffset = offset - len;\n", "      if (op == UPPERCASE_FIRST) {\n", "        len = 1;\n", "      }\n", "      while (len > 0) {\n", "        tmp = dst[uppercaseOffset] & 0xFF;\n", "        if (tmp < 0xc0) {\n", "          if (tmp >= 'a' && tmp <= 'z') {\n", "            dst[uppercaseOffset] ^= (byte) 32;\n", "          }\n", "          uppercaseOffset += 1;\n", "          len -= 1;\n", "        } else if (tmp < 0xe0) {\n", "          dst[uppercaseOffset + 1] ^= (byte) 32;\n", "          uppercaseOffset += 2;\n", "          len -= 2;\n", "        } else {\n", "          dst[uppercaseOffset + 2] ^= (byte) 5;\n", "          uppercaseOffset += 3;\n", "          len -= 3;\n", "        }\n", "      }\n", "    }\n", "\n", "    // Copy suffix.\n", "    string = transform.suffix;\n", "    tmp = string.length;\n", "    i = 0;\n", "    while (i < tmp) {\n", "      dst[offset++] = string[i++];\n", "    }\n", "\n", "    return offset - dstOffset;\n", "  }\n", "}\n"], "test_content": ["/* Copyright 2015 Google Inc. All Rights Reserved.\n", "\n", "   Distributed under MIT license.\n", "   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n", "*/\n", "\n", "package com.itextpdf.io.codec.brotli.dec;\n", "\n", "import static org.junit.Assert.assertArrayEquals;\n", "import static org.junit.Assert.assertEquals;\n", "\n", "import java.nio.ByteBuffer;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "/**\n", " * Tests for {@link Transform}.\n", " */\n", "@Category(UnitTest.class)\n", "public class TransformTest extends ExtendedITextTest{\n", "\n", "  private static long crc64(byte[] data) {\n", "    long crc = -1;\n", "    for (int i = 0; i < data.length; ++i) {\n", "      long c = (crc ^ (long) (data[i] & 0xFF)) & 0xFF;\n", "      for (int k = 0; k < 8; k++) {\n", "        c = (c >>> 1) ^ (-(c & 1L) & -3932672073523589310L);\n", "      }\n", "      crc = c ^ (crc >>> 8);\n", "    }\n", "    return ~crc;\n", "  }\n", "\n", "  @Test\n", "  public void testTrimAll() {\n", "    byte[] output = new byte[2];\n", "    byte[] input = {119, 111, 114, 100}; // \"word\"\n", "    Transform transform = new Transform(\"[\", WordTransformType.OMIT_FIRST_5, \"]\");\n", "    Transform.transformDictionaryWord(\n", "        output, 0, ByteBuffer.wrap(input), 0, input.length, transform);\n", "    byte[] expectedOutput = {91, 93}; // \"[]\"\n", "    assertArrayEquals(expectedOutput, output);\n", "  }\n", "\n", "  @Test\n", "  public void testCapitalize() {\n", "    byte[] output = new byte[8];\n", "    byte[] input = {113, -61, -90, -32, -92, -86}; // \"q\u00e6\u092a\"\n", "    Transform transform = new Transform(\"[\", WordTransformType.UPPERCASE_ALL, \"]\");\n", "    Transform.transformDictionaryWord(\n", "      output, 0, ByteBuffer.wrap(input), 0, input.length, transform);\n", "    byte[] expectedOutput = {91, 81, -61, -122, -32, -92, -81, 93}; // \"[Q\u00c6\u092f]\"\n", "    assertArrayEquals(expectedOutput, output);\n", "  }\n", "\n", "  @Test\n", "  public void testAllTransforms() {\n", "    /* This string allows to apply all transforms: head and tail cutting, capitalization and\n", "       turning to upper case; all results will be mutually different. */\n", "    // \"o123456789abcdef\"\n", "    byte[] testWord = {111, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102};\n", "    byte[] output = new byte[2259];\n", "    int offset = 0;\n", "    for (int i = 0; i < Transform.TRANSFORMS.length; ++i) {\n", "      offset += Transform.transformDictionaryWord(\n", "          output, offset, ByteBuffer.wrap(testWord), 0, testWord.length, Transform.TRANSFORMS[i]);\n", "      output[offset++] = -1;\n", "    }\n", "    assertEquals(output.length, offset);\n", "    assertEquals(8929191060211225186L, crc64(output));\n", "  }\n", "}\n"], "method_lines_dic": {"Transform::::readUniBytes(java.lang.String)": [47, 53], "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)": [179, 241]}, "test_method_lines_dic": {"TransformTest::::crc64(byte[])": [25, 35], "TransformTest::::testTrimAll()": [37, 46], "TransformTest::::testCapitalize()": [48, 57], "TransformTest::::testAllTransforms()": [59, 74]}, "reverse_method_lines_dic": {"47": "Transform::::readUniBytes(java.lang.String)", "48": "Transform::::readUniBytes(java.lang.String)", "49": "Transform::::readUniBytes(java.lang.String)", "50": "Transform::::readUniBytes(java.lang.String)", "51": "Transform::::readUniBytes(java.lang.String)", "52": "Transform::::readUniBytes(java.lang.String)", "53": "Transform::::readUniBytes(java.lang.String)", "179": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "180": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "181": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "182": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "183": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "184": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "185": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "186": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "187": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "188": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "189": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "190": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "191": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "192": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "193": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "194": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "195": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "196": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "197": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "198": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "199": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "200": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "201": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "202": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "203": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "204": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "205": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "206": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "207": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "208": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "209": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "210": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "211": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "212": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "213": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "214": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "215": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "216": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "217": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "218": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "219": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "220": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "221": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "222": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "223": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "224": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "225": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "226": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "227": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "228": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "229": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "230": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "231": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "232": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "233": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "234": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "235": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "236": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "237": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "238": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "239": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "240": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)", "241": "Transform::::transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform)"}, "test_reverse_method_lines_dic": {"25": "TransformTest::::crc64(byte[])", "26": "TransformTest::::crc64(byte[])", "27": "TransformTest::::crc64(byte[])", "28": "TransformTest::::crc64(byte[])", "29": "TransformTest::::crc64(byte[])", "30": "TransformTest::::crc64(byte[])", "31": "TransformTest::::crc64(byte[])", "32": "TransformTest::::crc64(byte[])", "33": "TransformTest::::crc64(byte[])", "34": "TransformTest::::crc64(byte[])", "35": "TransformTest::::crc64(byte[])", "37": "TransformTest::::testTrimAll()", "38": "TransformTest::::testTrimAll()", "39": "TransformTest::::testTrimAll()", "40": "TransformTest::::testTrimAll()", "41": "TransformTest::::testTrimAll()", "42": "TransformTest::::testTrimAll()", "43": "TransformTest::::testTrimAll()", "44": "TransformTest::::testTrimAll()", "45": "TransformTest::::testTrimAll()", "46": "TransformTest::::testTrimAll()", "48": "TransformTest::::testCapitalize()", "49": "TransformTest::::testCapitalize()", "50": "TransformTest::::testCapitalize()", "51": "TransformTest::::testCapitalize()", "52": "TransformTest::::testCapitalize()", "53": "TransformTest::::testCapitalize()", "54": "TransformTest::::testCapitalize()", "55": "TransformTest::::testCapitalize()", "56": "TransformTest::::testCapitalize()", "57": "TransformTest::::testCapitalize()", "59": "TransformTest::::testAllTransforms()", "60": "TransformTest::::testAllTransforms()", "61": "TransformTest::::testAllTransforms()", "62": "TransformTest::::testAllTransforms()", "63": "TransformTest::::testAllTransforms()", "64": "TransformTest::::testAllTransforms()", "65": "TransformTest::::testAllTransforms()", "66": "TransformTest::::testAllTransforms()", "67": "TransformTest::::testAllTransforms()", "68": "TransformTest::::testAllTransforms()", "69": "TransformTest::::testAllTransforms()", "70": "TransformTest::::testAllTransforms()", "71": "TransformTest::::testAllTransforms()", "72": "TransformTest::::testAllTransforms()", "73": "TransformTest::::testAllTransforms()", "74": "TransformTest::::testAllTransforms()"}, "tests": [{"test_lines": [37, 46], "covered_lines": [41, 42, 43, 44, 45, 48, 49, 50, 52, 55, 181, 184, 185, 186, 188, 189, 193, 194, 195, 196, 198, 199, 200, 201, 202, 207, 233, 234, 235, 236, 237, 240]}, {"test_lines": [48, 57], "covered_lines": [41, 42, 43, 44, 45, 48, 49, 50, 52, 55, 181, 184, 185, 186, 188, 189, 193, 194, 195, 198, 199, 200, 201, 202, 203, 204, 207, 208, 209, 212, 213, 214, 215, 216, 218, 219, 220, 221, 222, 223, 225, 226, 227, 233, 234, 235, 236, 237, 240]}, {"test_lines": [59, 74], "covered_lines": [41, 42, 43, 44, 45, 48, 49, 50, 52, 55, 181, 184, 185, 186, 188, 189, 193, 194, 195, 198, 199, 200, 201, 202, 203, 204, 207, 208, 209, 210, 212, 213, 214, 215, 216, 218, 219, 233, 234, 235, 236, 237, 240]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/codec/brotli/dec/Decode.java": {"class_content": ["/* Copyright 2015 Google Inc. All Rights Reserved.\n", "\n", "   Distributed under MIT license.\n", "   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n", "*/\n", "\n", "package com.itextpdf.io.codec.brotli.dec;\n", "\n", "/**\n", " * API for Brotli decompression.\n", " */\n", "final class Decode {\n", "\n", "  private static final int DEFAULT_CODE_LENGTH = 8;\n", "  private static final int CODE_LENGTH_REPEAT_CODE = 16;\n", "  private static final int NUM_LITERAL_CODES = 256;\n", "  private static final int NUM_INSERT_AND_COPY_CODES = 704;\n", "  private static final int NUM_BLOCK_LENGTH_CODES = 26;\n", "  private static final int LITERAL_CONTEXT_BITS = 6;\n", "  private static final int DISTANCE_CONTEXT_BITS = 2;\n", "\n", "  private static final int HUFFMAN_TABLE_BITS = 8;\n", "  private static final int HUFFMAN_TABLE_MASK = 0xFF;\n", "\n", "  private static final int CODE_LENGTH_CODES = 18;\n", "  private static final int[] CODE_LENGTH_CODE_ORDER = {\n", "      1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n", "  };\n", "\n", "  private static final int NUM_DISTANCE_SHORT_CODES = 16;\n", "  private static final int[] DISTANCE_SHORT_CODE_INDEX_OFFSET = {\n", "      3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2\n", "  };\n", "\n", "  private static final int[] DISTANCE_SHORT_CODE_VALUE_OFFSET = {\n", "      0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3\n", "  };\n", "\n", "  /**\n", "   * Static Huffman code for the code length code lengths.\n", "   */\n", "  private static final int[] FIXED_TABLE = {\n", "      0x020000, 0x020004, 0x020003, 0x030002, 0x020000, 0x020004, 0x020003, 0x040001,\n", "      0x020000, 0x020004, 0x020003, 0x030002, 0x020000, 0x020004, 0x020003, 0x040005\n", "  };\n", "\n", "  /**\n", "   * Decodes a number in the range [0..255], by reading 1 - 11 bits.\n", "   */\n", "  private static int decodeVarLenUnsignedByte(BitReader br) {\n", "    if (BitReader.readBits(br, 1) != 0) {\n", "      int n = BitReader.readBits(br, 3);\n", "      if (n == 0) {\n", "        return 1;\n", "      } else {\n", "        return BitReader.readBits(br, n) + (1 << n);\n", "      }\n", "    }\n", "    return 0;\n", "  }\n", "\n", "  private static void decodeMetaBlockLength(BitReader br, State state) {\n", "    state.inputEnd = BitReader.readBits(br, 1) == 1;\n", "    state.metaBlockLength = 0;\n", "    state.isUncompressed = false;\n", "    state.isMetadata = false;\n", "    if (state.inputEnd && BitReader.readBits(br, 1) != 0) {\n", "      return;\n", "    }\n", "    int sizeNibbles = BitReader.readBits(br, 2) + 4;\n", "    if (sizeNibbles == 7) {\n", "      state.isMetadata = true;\n", "      if (BitReader.readBits(br, 1) != 0) {\n", "        throw new BrotliRuntimeException(\"Corrupted reserved bit\");\n", "      }\n", "      int sizeBytes = BitReader.readBits(br, 2);\n", "      if (sizeBytes == 0) {\n", "        return;\n", "      }\n", "      for (int i = 0; i < sizeBytes; i++) {\n", "        int bits = BitReader.readBits(br, 8);\n", "        if (bits == 0 && i + 1 == sizeBytes && sizeBytes > 1) {\n", "          throw new BrotliRuntimeException(\"Exuberant nibble\");\n", "        }\n", "        state.metaBlockLength |= bits << (i * 8);\n", "      }\n", "    } else {\n", "      for (int i = 0; i < sizeNibbles; i++) {\n", "        int bits = BitReader.readBits(br, 4);\n", "        if (bits == 0 && i + 1 == sizeNibbles && sizeNibbles > 4) {\n", "          throw new BrotliRuntimeException(\"Exuberant nibble\");\n", "        }\n", "        state.metaBlockLength |= bits << (i * 4);\n", "      }\n", "    }\n", "    state.metaBlockLength++;\n", "    if (!state.inputEnd) {\n", "      state.isUncompressed = BitReader.readBits(br, 1) == 1;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Decodes the next Huffman code from bit-stream.\n", "   */\n", "  private static int readSymbol(int[] table, int offset, BitReader br) {\n", "    int val = (int) (br.accumulator >>> br.bitOffset);\n", "    offset += val & HUFFMAN_TABLE_MASK;\n", "    int bits = table[offset] >> 16;\n", "    int sym = table[offset] & 0xFFFF;\n", "    if (bits <= HUFFMAN_TABLE_BITS) {\n", "      br.bitOffset += bits;\n", "      return sym;\n", "    }\n", "    offset += sym;\n", "    int mask = (1 << bits) - 1;\n", "    offset += (val & mask) >>> HUFFMAN_TABLE_BITS;\n", "    br.bitOffset += ((table[offset] >> 16) + HUFFMAN_TABLE_BITS);\n", "    return table[offset] & 0xFFFF;\n", "  }\n", "\n", "  private static int readBlockLength(int[] table, int offset, BitReader br) {\n", "    BitReader.fillBitWindow(br);\n", "    int code = readSymbol(table, offset, br);\n", "    int n = Prefix.BLOCK_LENGTH_N_BITS[code];\n", "    return Prefix.BLOCK_LENGTH_OFFSET[code] + BitReader.readBits(br, n);\n", "  }\n", "\n", "  private static int translateShortCodes(int code, int[] ringBuffer, int index) {\n", "    if (code < NUM_DISTANCE_SHORT_CODES) {\n", "      index += DISTANCE_SHORT_CODE_INDEX_OFFSET[code];\n", "      index &= 3;\n", "      return ringBuffer[index] + DISTANCE_SHORT_CODE_VALUE_OFFSET[code];\n", "    }\n", "    return code - NUM_DISTANCE_SHORT_CODES + 1;\n", "  }\n", "\n", "  private static void moveToFront(int[] v, int index) {\n", "    int value = v[index];\n", "    for (; index > 0; index--) {\n", "      v[index] = v[index - 1];\n", "    }\n", "    v[0] = value;\n", "  }\n", "\n", "  private static void inverseMoveToFrontTransform(byte[] v, int vLen) {\n", "    int[] mtf = new int[256];\n", "    for (int i = 0; i < 256; i++) {\n", "      mtf[i] = i;\n", "    }\n", "    for (int i = 0; i < vLen; i++) {\n", "      int index = v[i] & 0xFF;\n", "      v[i] = (byte) mtf[index];\n", "      if (index != 0) {\n", "        moveToFront(mtf, index);\n", "      }\n", "    }\n", "  }\n", "\n", "  private static void readHuffmanCodeLengths(\n", "      int[] codeLengthCodeLengths, int numSymbols, int[] codeLengths, BitReader br) {\n", "    int symbol = 0;\n", "    int prevCodeLen = DEFAULT_CODE_LENGTH;\n", "    int repeat = 0;\n", "    int repeatCodeLen = 0;\n", "    int space = 32768;\n", "    int[] table = new int[32];\n", "\n", "    Huffman.buildHuffmanTable(table, 0, 5, codeLengthCodeLengths, CODE_LENGTH_CODES);\n", "\n", "    while (symbol < numSymbols && space > 0) {\n", "      BitReader.readMoreInput(br);\n", "      BitReader.fillBitWindow(br);\n", "      int p = (int) ((br.accumulator >>> br.bitOffset)) & 31;\n", "      br.bitOffset += table[p] >> 16;\n", "      int codeLen = table[p] & 0xFFFF;\n", "      if (codeLen < CODE_LENGTH_REPEAT_CODE) {\n", "        repeat = 0;\n", "        codeLengths[symbol++] = codeLen;\n", "        if (codeLen != 0) {\n", "          prevCodeLen = codeLen;\n", "          space -= 32768 >> codeLen;\n", "        }\n", "      } else {\n", "        int extraBits = codeLen - 14;\n", "        int newLen = 0;\n", "        if (codeLen == CODE_LENGTH_REPEAT_CODE) {\n", "          newLen = prevCodeLen;\n", "        }\n", "        if (repeatCodeLen != newLen) {\n", "          repeat = 0;\n", "          repeatCodeLen = newLen;\n", "        }\n", "        int oldRepeat = repeat;\n", "        if (repeat > 0) {\n", "          repeat -= 2;\n", "          repeat <<= extraBits;\n", "        }\n", "        repeat += BitReader.readBits(br, extraBits) + 3;\n", "        int repeatDelta = repeat - oldRepeat;\n", "        if (symbol + repeatDelta > numSymbols) {\n", "          throw new BrotliRuntimeException(\"symbol + repeatDelta > numSymbols\"); // COV_NF_LINE\n", "        }\n", "        for (int i = 0; i < repeatDelta; i++) {\n", "          codeLengths[symbol++] = repeatCodeLen;\n", "        }\n", "        if (repeatCodeLen != 0) {\n", "          space -= repeatDelta << (15 - repeatCodeLen);\n", "        }\n", "      }\n", "    }\n", "    if (space != 0) {\n", "      throw new BrotliRuntimeException(\"Unused space\"); // COV_NF_LINE\n", "    }\n", "    // TODO: Pass max_symbol to Huffman table builder instead?\n", "    Utils.fillWithZeroes(codeLengths, symbol, numSymbols - symbol);\n", "  }\n", "\n", "  // TODO: Use specialized versions for smaller tables.\n", "  static void readHuffmanCode(int alphabetSize, int[] table, int offset, BitReader br) {\n", "    boolean ok = true;\n", "    int simpleCodeOrSkip;\n", "    BitReader.readMoreInput(br);\n", "    // TODO: Avoid allocation.\n", "    int[] codeLengths = new int[alphabetSize];\n", "    simpleCodeOrSkip = BitReader.readBits(br, 2);\n", "    if (simpleCodeOrSkip == 1) { // Read symbols, codes & code lengths directly.\n", "      int maxBitsCounter = alphabetSize - 1;\n", "      int maxBits = 0;\n", "      int[] symbols = new int[4];\n", "      int numSymbols = BitReader.readBits(br, 2) + 1;\n", "      while (maxBitsCounter != 0) {\n", "        maxBitsCounter >>= 1;\n", "        maxBits++;\n", "      }\n", "      // TODO: uncomment when codeLengths is reused.\n", "      // Utils.fillWithZeroes(codeLengths, 0, alphabetSize);\n", "      for (int i = 0; i < numSymbols; i++) {\n", "        symbols[i] = BitReader.readBits(br, maxBits) % alphabetSize;\n", "        codeLengths[symbols[i]] = 2;\n", "      }\n", "      codeLengths[symbols[0]] = 1;\n", "      switch (numSymbols) {\n", "        case 1:\n", "          break;\n", "        case 2:\n", "          ok = symbols[0] != symbols[1];\n", "          codeLengths[symbols[1]] = 1;\n", "          break;\n", "        case 3:\n", "          ok = symbols[0] != symbols[1] && symbols[0] != symbols[2] && symbols[1] != symbols[2];\n", "          break;\n", "        case 4:\n", "        default:\n", "          ok = symbols[0] != symbols[1] && symbols[0] != symbols[2] && symbols[0] != symbols[3]\n", "              && symbols[1] != symbols[2] && symbols[1] != symbols[3] && symbols[2] != symbols[3];\n", "          if (BitReader.readBits(br, 1) == 1) {\n", "            codeLengths[symbols[2]] = 3;\n", "            codeLengths[symbols[3]] = 3;\n", "          } else {\n", "            codeLengths[symbols[0]] = 2;\n", "          }\n", "          break;\n", "      }\n", "    } else { // Decode Huffman-coded code lengths.\n", "      int[] codeLengthCodeLengths = new int[CODE_LENGTH_CODES];\n", "      int space = 32;\n", "      int numCodes = 0;\n", "      for (int i = simpleCodeOrSkip; i < CODE_LENGTH_CODES && space > 0; i++) {\n", "        int codeLenIdx = CODE_LENGTH_CODE_ORDER[i];\n", "        BitReader.fillBitWindow(br);\n", "        int p = (int) (br.accumulator >>> br.bitOffset) & 15;\n", "        // TODO: Demultiplex FIXED_TABLE.\n", "        br.bitOffset += FIXED_TABLE[p] >> 16;\n", "        int v = FIXED_TABLE[p] & 0xFFFF;\n", "        codeLengthCodeLengths[codeLenIdx] = v;\n", "        if (v != 0) {\n", "          space -= (32 >> v);\n", "          numCodes++;\n", "        }\n", "      }\n", "      ok = (numCodes == 1 || space == 0);\n", "      readHuffmanCodeLengths(codeLengthCodeLengths, alphabetSize, codeLengths, br);\n", "    }\n", "    if (!ok) {\n", "      throw new BrotliRuntimeException(\"Can't readHuffmanCode\"); // COV_NF_LINE\n", "    }\n", "    Huffman.buildHuffmanTable(table, offset, HUFFMAN_TABLE_BITS, codeLengths, alphabetSize);\n", "  }\n", "\n", "  private static int decodeContextMap(int contextMapSize, byte[] contextMap, BitReader br) {\n", "    BitReader.readMoreInput(br);\n", "    int numTrees = decodeVarLenUnsignedByte(br) + 1;\n", "\n", "    if (numTrees == 1) {\n", "      Utils.fillWithZeroes(contextMap, 0, contextMapSize);\n", "      return numTrees;\n", "    }\n", "\n", "    boolean useRleForZeros = BitReader.readBits(br, 1) == 1;\n", "    int maxRunLengthPrefix = 0;\n", "    if (useRleForZeros) {\n", "      maxRunLengthPrefix = BitReader.readBits(br, 4) + 1;\n", "    }\n", "    int[] table = new int[Huffman.HUFFMAN_MAX_TABLE_SIZE];\n", "    readHuffmanCode(numTrees + maxRunLengthPrefix, table, 0, br);\n", "    for (int i = 0; i < contextMapSize; ) {\n", "      BitReader.readMoreInput(br);\n", "      BitReader.fillBitWindow(br);\n", "      int code = readSymbol(table, 0, br);\n", "      if (code == 0) {\n", "        contextMap[i] = 0;\n", "        i++;\n", "      } else if (code <= maxRunLengthPrefix) {\n", "        int reps = (1 << code) + BitReader.readBits(br, code);\n", "        while (reps != 0) {\n", "          if (i >= contextMapSize) {\n", "            throw new BrotliRuntimeException(\"Corrupted context map\"); // COV_NF_LINE\n", "          }\n", "          contextMap[i] = 0;\n", "          i++;\n", "          reps--;\n", "        }\n", "      } else {\n", "        contextMap[i] = (byte) (code - maxRunLengthPrefix);\n", "        i++;\n", "      }\n", "    }\n", "    if (BitReader.readBits(br, 1) == 1) {\n", "      inverseMoveToFrontTransform(contextMap, contextMapSize);\n", "    }\n", "    return numTrees;\n", "  }\n", "\n", "  private static void decodeBlockTypeAndLength(State state, int treeType) {\n", "    final BitReader br = state.br;\n", "    final int[] ringBuffers = state.blockTypeRb;\n", "    final int offset = treeType * 2;\n", "    BitReader.fillBitWindow(br);\n", "    int blockType = readSymbol(\n", "        state.blockTypeTrees, treeType * Huffman.HUFFMAN_MAX_TABLE_SIZE, br);\n", "    state.blockLength[treeType] = readBlockLength(state.blockLenTrees,\n", "        treeType * Huffman.HUFFMAN_MAX_TABLE_SIZE, br);\n", "\n", "    if (blockType == 1) {\n", "      blockType = ringBuffers[offset + 1] + 1;\n", "    } else if (blockType == 0) {\n", "      blockType = ringBuffers[offset];\n", "    } else {\n", "      blockType -= 2;\n", "    }\n", "    if (blockType >= state.numBlockTypes[treeType]) {\n", "      blockType -= state.numBlockTypes[treeType];\n", "    }\n", "    ringBuffers[offset] = ringBuffers[offset + 1];\n", "    ringBuffers[offset + 1] = blockType;\n", "  }\n", "\n", "  private static void decodeLiteralBlockSwitch(State state) {\n", "    decodeBlockTypeAndLength(state, 0);\n", "    int literalBlockType = state.blockTypeRb[1];\n", "    state.contextMapSlice = literalBlockType << LITERAL_CONTEXT_BITS;\n", "    state.literalTreeIndex = state.contextMap[state.contextMapSlice] & 0xFF;\n", "    state.literalTree = state.hGroup0.trees[state.literalTreeIndex];\n", "    int contextMode = state.contextModes[literalBlockType];\n", "    state.contextLookupOffset1 = Context.LOOKUP_OFFSETS[contextMode];\n", "    state.contextLookupOffset2 = Context.LOOKUP_OFFSETS[contextMode + 1];\n", "  }\n", "\n", "  private static void decodeCommandBlockSwitch(State state) {\n", "    decodeBlockTypeAndLength(state, 1);\n", "    state.treeCommandOffset = state.hGroup1.trees[state.blockTypeRb[3]];\n", "  }\n", "\n", "  private static void decodeDistanceBlockSwitch(State state) {\n", "    decodeBlockTypeAndLength(state, 2);\n", "    state.distContextMapSlice = state.blockTypeRb[5] << DISTANCE_CONTEXT_BITS;\n", "  }\n", "\n", "  private static void maybeReallocateRingBuffer(State state) {\n", "    int newSize = state.maxRingBufferSize;\n", "    if ((long) newSize > state.expectedTotalSize) {\n", "      /* TODO: Handle 2GB+ cases more gracefully. */\n", "      int minimalNewSize = (int) state.expectedTotalSize + state.customDictionary.length;\n", "      while ((newSize >> 1) > minimalNewSize) {\n", "        newSize >>= 1;\n", "      }\n", "      if (!state.inputEnd && newSize < 16384 && state.maxRingBufferSize >= 16384) {\n", "        newSize = 16384;\n", "      }\n", "    }\n", "    if (newSize <= state.ringBufferSize) {\n", "      return;\n", "    }\n", "    int ringBufferSizeWithSlack = newSize + Dictionary.MAX_TRANSFORMED_WORD_LENGTH;\n", "    byte[] newBuffer = new byte[ringBufferSizeWithSlack];\n", "    if (state.ringBuffer != null) {\n", "      System.arraycopy(state.ringBuffer, 0, newBuffer, 0, state.ringBufferSize);\n", "    } else {\n", "      /* Prepend custom dictionary, if any. */\n", "      if (state.customDictionary.length != 0) {\n", "        int length = state.customDictionary.length;\n", "        int offset = 0;\n", "        if (length > state.maxBackwardDistance) {\n", "          offset = length - state.maxBackwardDistance;\n", "          length = state.maxBackwardDistance;\n", "        }\n", "        System.arraycopy(state.customDictionary, offset, newBuffer, 0, length);\n", "        state.pos = length;\n", "        state.bytesToIgnore = length;\n", "      }\n", "    }\n", "    state.ringBuffer = newBuffer;\n", "    state.ringBufferSize = newSize;\n", "  }\n", "\n", "  /**\n", "   * Reads next metablock header.\n", "   *\n", "   * @param state decoding state\n", "   */\n", "  private static void readMetablockInfo(State state) {\n", "    final BitReader br = state.br;\n", "\n", "    if (state.inputEnd) {\n", "      state.nextRunningState = RunningState.FINISHED;\n", "      state.bytesToWrite = state.pos;\n", "      state.bytesWritten = 0;\n", "      state.runningState = RunningState.WRITE;\n", "      return;\n", "    }\n", "    // TODO: Reset? Do we need this?\n", "    state.hGroup0.codes = null;\n", "    state.hGroup0.trees = null;\n", "    state.hGroup1.codes = null;\n", "    state.hGroup1.trees = null;\n", "    state.hGroup2.codes = null;\n", "    state.hGroup2.trees = null;\n", "\n", "    BitReader.readMoreInput(br);\n", "    decodeMetaBlockLength(br, state);\n", "    if (state.metaBlockLength == 0 && !state.isMetadata) {\n", "      return;\n", "    }\n", "    if (state.isUncompressed || state.isMetadata) {\n", "      BitReader.jumpToByteBoundary(br);\n", "      state.runningState = state.isMetadata ? RunningState.READ_METADATA : RunningState.COPY_UNCOMPRESSED;\n", "    } else {\n", "      state.runningState = RunningState.COMPRESSED_BLOCK_START;\n", "    }\n", "\n", "    if (state.isMetadata) {\n", "      return;\n", "    }\n", "    state.expectedTotalSize += state.metaBlockLength;\n", "    if (state.ringBufferSize < state.maxRingBufferSize) {\n", "      maybeReallocateRingBuffer(state);\n", "    }\n", "  }\n", "\n", "  private static void readMetablockHuffmanCodesAndContextMaps(State state) {\n", "    final BitReader br = state.br;\n", "\n", "    for (int i = 0; i < 3; i++) {\n", "      state.numBlockTypes[i] = decodeVarLenUnsignedByte(br) + 1;\n", "      state.blockLength[i] = 1 << 28;\n", "      if (state.numBlockTypes[i] > 1) {\n", "        readHuffmanCode(state.numBlockTypes[i] + 2, state.blockTypeTrees,\n", "            i * Huffman.HUFFMAN_MAX_TABLE_SIZE, br);\n", "        readHuffmanCode(NUM_BLOCK_LENGTH_CODES, state.blockLenTrees,\n", "            i * Huffman.HUFFMAN_MAX_TABLE_SIZE, br);\n", "        state.blockLength[i] = readBlockLength(state.blockLenTrees,\n", "            i * Huffman.HUFFMAN_MAX_TABLE_SIZE, br);\n", "      }\n", "    }\n", "\n", "    BitReader.readMoreInput(br);\n", "    state.distancePostfixBits = BitReader.readBits(br, 2);\n", "    state.numDirectDistanceCodes =\n", "        NUM_DISTANCE_SHORT_CODES + (BitReader.readBits(br, 4) << state.distancePostfixBits);\n", "    state.distancePostfixMask = (1 << state.distancePostfixBits) - 1;\n", "    int numDistanceCodes = state.numDirectDistanceCodes + (48 << state.distancePostfixBits);\n", "    // TODO: Reuse?\n", "    state.contextModes = new byte[state.numBlockTypes[0]];\n", "    for (int i = 0; i < state.numBlockTypes[0];) {\n", "      /* Ensure that less than 256 bits read between readMoreInput. */\n", "      int limit = Math.min(i + 96, state.numBlockTypes[0]);\n", "      for (; i < limit; ++i) {\n", "        state.contextModes[i] = (byte) (BitReader.readBits(br, 2) << 1);\n", "      }\n", "      BitReader.readMoreInput(br);\n", "    }\n", "\n", "    // TODO: Reuse?\n", "    state.contextMap = new byte[state.numBlockTypes[0] << LITERAL_CONTEXT_BITS];\n", "    int numLiteralTrees = decodeContextMap(state.numBlockTypes[0] << LITERAL_CONTEXT_BITS,\n", "        state.contextMap, br);\n", "    state.trivialLiteralContext = true;\n", "    for (int j = 0; j < state.numBlockTypes[0] << LITERAL_CONTEXT_BITS; j++) {\n", "      if (state.contextMap[j] != j >> LITERAL_CONTEXT_BITS) {\n", "        state.trivialLiteralContext = false;\n", "        break;\n", "      }\n", "    }\n", "\n", "    // TODO: Reuse?\n", "    state.distContextMap = new byte[state.numBlockTypes[2] << DISTANCE_CONTEXT_BITS];\n", "    int numDistTrees = decodeContextMap(state.numBlockTypes[2] << DISTANCE_CONTEXT_BITS,\n", "        state.distContextMap, br);\n", "\n", "    HuffmanTreeGroup.init(state.hGroup0, NUM_LITERAL_CODES, numLiteralTrees);\n", "    HuffmanTreeGroup.init(state.hGroup1, NUM_INSERT_AND_COPY_CODES, state.numBlockTypes[1]);\n", "    HuffmanTreeGroup.init(state.hGroup2, numDistanceCodes, numDistTrees);\n", "\n", "    HuffmanTreeGroup.decode(state.hGroup0, br);\n", "    HuffmanTreeGroup.decode(state.hGroup1, br);\n", "    HuffmanTreeGroup.decode(state.hGroup2, br);\n", "\n", "    state.contextMapSlice = 0;\n", "    state.distContextMapSlice = 0;\n", "    state.contextLookupOffset1 = Context.LOOKUP_OFFSETS[state.contextModes[0]];\n", "    state.contextLookupOffset2 = Context.LOOKUP_OFFSETS[state.contextModes[0] + 1];\n", "    state.literalTreeIndex = 0;\n", "    state.literalTree = state.hGroup0.trees[0];\n", "    state.treeCommandOffset = state.hGroup1.trees[0]; // TODO: == 0?\n", "\n", "    state.blockTypeRb[0] = state.blockTypeRb[2] = state.blockTypeRb[4] = 1;\n", "    state.blockTypeRb[1] = state.blockTypeRb[3] = state.blockTypeRb[5] = 0;\n", "  }\n", "\n", "  private static void copyUncompressedData(State state) {\n", "    final BitReader br = state.br;\n", "    final byte[] ringBuffer = state.ringBuffer;\n", "\n", "    // Could happen if block ends at ring buffer end.\n", "    if (state.metaBlockLength <= 0) {\n", "      BitReader.reload(br);\n", "      state.runningState = RunningState.BLOCK_START;\n", "      return;\n", "    }\n", "\n", "    int chunkLength = Math.min(state.ringBufferSize - state.pos, state.metaBlockLength);\n", "    BitReader.copyBytes(br, ringBuffer, state.pos, chunkLength);\n", "    state.metaBlockLength -= chunkLength;\n", "    state.pos += chunkLength;\n", "    if (state.pos == state.ringBufferSize) {\n", "        state.nextRunningState = RunningState.COPY_UNCOMPRESSED;\n", "        state.bytesToWrite = state.ringBufferSize;\n", "        state.bytesWritten = 0;\n", "        state.runningState = RunningState.WRITE;\n", "        return;\n", "      }\n", "\n", "    BitReader.reload(br);\n", "    state.runningState = RunningState.BLOCK_START;\n", "  }\n", "\n", "  private static boolean writeRingBuffer(State state) {\n", "    /* Ignore custom dictionary bytes. */\n", "    if (state.bytesToIgnore != 0) {\n", "      state.bytesWritten += state.bytesToIgnore;\n", "      state.bytesToIgnore = 0;\n", "    }\n", "    int toWrite = Math.min(state.outputLength - state.outputUsed,\n", "        state.bytesToWrite - state.bytesWritten);\n", "    if (toWrite != 0) {\n", "      System.arraycopy(state.ringBuffer, state.bytesWritten, state.output,\n", "          state.outputOffset + state.outputUsed, toWrite);\n", "      state.outputUsed += toWrite;\n", "      state.bytesWritten += toWrite;\n", "    }\n", "\n", "    return state.outputUsed < state.outputLength;\n", "  }\n", "\n", "  static void setCustomDictionary(State state, byte[] data) {\n", "    state.customDictionary = (data == null) ? new byte[0] : data;\n", "  }\n", "\n", "  /**\n", "   * Actual decompress implementation.\n", "   */\n", "  static void decompress(State state) {\n", "    if (state.runningState == RunningState.UNINITIALIZED) {\n", "      throw new IllegalStateException(\"Can't decompress until initialized\");\n", "    }\n", "    if (state.runningState == RunningState.CLOSED) {\n", "      throw new IllegalStateException(\"Can't decompress after close\");\n", "    }\n", "    final BitReader br = state.br;\n", "    int ringBufferMask = state.ringBufferSize - 1;\n", "    byte[] ringBuffer = state.ringBuffer;\n", "\n", "    while (state.runningState != RunningState.FINISHED) {\n", "      // TODO: extract cases to methods for the better readability.\n", "      switch (state.runningState) {\n", "        case RunningState.BLOCK_START:\n", "          if (state.metaBlockLength < 0) {\n", "            throw new BrotliRuntimeException(\"Invalid metablock length\");\n", "          }\n", "          readMetablockInfo(state);\n", "          /* Ring-buffer would be reallocated here. */\n", "          ringBufferMask = state.ringBufferSize - 1;\n", "          ringBuffer = state.ringBuffer;\n", "          continue;\n", "\n", "        case RunningState.COMPRESSED_BLOCK_START:\n", "          readMetablockHuffmanCodesAndContextMaps(state);\n", "          state.runningState = RunningState.MAIN_LOOP;\n", "          // Fall through\n", "\n", "        case RunningState.MAIN_LOOP:\n", "          if (state.metaBlockLength <= 0) {\n", "            state.runningState = RunningState.BLOCK_START;\n", "            continue;\n", "          }\n", "          BitReader.readMoreInput(br);\n", "          if (state.blockLength[1] == 0) {\n", "            decodeCommandBlockSwitch(state);\n", "          }\n", "          state.blockLength[1]--;\n", "          BitReader.fillBitWindow(br);\n", "          int cmdCode = readSymbol(state.hGroup1.codes, state.treeCommandOffset, br);\n", "          int rangeIdx = cmdCode >>> 6;\n", "          state.distanceCode = 0;\n", "          if (rangeIdx >= 2) {\n", "            rangeIdx -= 2;\n", "            state.distanceCode = -1;\n", "          }\n", "          int insertCode = Prefix.INSERT_RANGE_LUT[rangeIdx] + ((cmdCode >>> 3) & 7);\n", "          int copyCode = Prefix.COPY_RANGE_LUT[rangeIdx] + (cmdCode & 7);\n", "          state.insertLength = Prefix.INSERT_LENGTH_OFFSET[insertCode] + BitReader\n", "              .readBits(br, Prefix.INSERT_LENGTH_N_BITS[insertCode]);\n", "          state.copyLength = Prefix.COPY_LENGTH_OFFSET[copyCode] + BitReader\n", "              .readBits(br, Prefix.COPY_LENGTH_N_BITS[copyCode]);\n", "\n", "          state.j = 0;\n", "          state.runningState = RunningState.INSERT_LOOP;\n", "\n", "          // Fall through\n", "        case RunningState.INSERT_LOOP:\n", "          if (state.trivialLiteralContext) {\n", "            while (state.j < state.insertLength) {\n", "              BitReader.readMoreInput(br);\n", "              if (state.blockLength[0] == 0) {\n", "                decodeLiteralBlockSwitch(state);\n", "              }\n", "              state.blockLength[0]--;\n", "              BitReader.fillBitWindow(br);\n", "              ringBuffer[state.pos] =\n", "                  (byte) readSymbol(state.hGroup0.codes, state.literalTree, br);\n", "              state.j++;\n", "              if (state.pos++ == ringBufferMask) {\n", "                state.nextRunningState = RunningState.INSERT_LOOP;\n", "                state.bytesToWrite = state.ringBufferSize;\n", "                state.bytesWritten = 0;\n", "                state.runningState = RunningState.WRITE;\n", "                break;\n", "              }\n", "            }\n", "          } else {\n", "            int prevByte1 = ringBuffer[(state.pos - 1) & ringBufferMask] & 0xFF;\n", "            int prevByte2 = ringBuffer[(state.pos - 2) & ringBufferMask] & 0xFF;\n", "            while (state.j < state.insertLength) {\n", "              BitReader.readMoreInput(br);\n", "              if (state.blockLength[0] == 0) {\n", "                decodeLiteralBlockSwitch(state);\n", "              }\n", "              int literalTreeIndex = state.contextMap[state.contextMapSlice\n", "                + (Context.LOOKUP[state.contextLookupOffset1 + prevByte1]\n", "                    | Context.LOOKUP[state.contextLookupOffset2 + prevByte2])] & 0xFF;\n", "              state.blockLength[0]--;\n", "              prevByte2 = prevByte1;\n", "              BitReader.fillBitWindow(br);\n", "              prevByte1 = readSymbol(\n", "                  state.hGroup0.codes, state.hGroup0.trees[literalTreeIndex], br);\n", "              ringBuffer[state.pos] = (byte) prevByte1;\n", "              state.j++;\n", "              if (state.pos++ == ringBufferMask) {\n", "                state.nextRunningState = RunningState.INSERT_LOOP;\n", "                state.bytesToWrite = state.ringBufferSize;\n", "                state.bytesWritten = 0;\n", "                state.runningState = RunningState.WRITE;\n", "                break;\n", "              }\n", "            }\n", "          }\n", "          if (state.runningState != RunningState.INSERT_LOOP) {\n", "            continue;\n", "          }\n", "          state.metaBlockLength -= state.insertLength;\n", "          if (state.metaBlockLength <= 0) {\n", "            state.runningState = RunningState.MAIN_LOOP;\n", "            continue;\n", "          }\n", "          if (state.distanceCode < 0) {\n", "            BitReader.readMoreInput(br);\n", "            if (state.blockLength[2] == 0) {\n", "              decodeDistanceBlockSwitch(state);\n", "            }\n", "            state.blockLength[2]--;\n", "            BitReader.fillBitWindow(br);\n", "            state.distanceCode = readSymbol(state.hGroup2.codes, state.hGroup2.trees[\n", "                state.distContextMap[state.distContextMapSlice\n", "                    + (state.copyLength > 4 ? 3 : state.copyLength - 2)] & 0xFF], br);\n", "            if (state.distanceCode >= state.numDirectDistanceCodes) {\n", "              state.distanceCode -= state.numDirectDistanceCodes;\n", "              int postfix = state.distanceCode & state.distancePostfixMask;\n", "              state.distanceCode >>>= state.distancePostfixBits;\n", "              int n = (state.distanceCode >>> 1) + 1;\n", "              int offset = ((2 + (state.distanceCode & 1)) << n) - 4;\n", "              state.distanceCode = state.numDirectDistanceCodes + postfix\n", "                  + ((offset + BitReader.readBits(br, n)) << state.distancePostfixBits);\n", "            }\n", "          }\n", "\n", "          // Convert the distance code to the actual distance by possibly looking up past distances\n", "          // from the ringBuffer.\n", "          state.distance = translateShortCodes(state.distanceCode, state.distRb, state.distRbIdx);\n", "          if (state.distance < 0) {\n", "            throw new BrotliRuntimeException(\"Negative distance\"); // COV_NF_LINE\n", "          }\n", "\n", "          if (state.maxDistance != state.maxBackwardDistance\n", "              && state.pos < state.maxBackwardDistance) {\n", "            state.maxDistance = state.pos;\n", "          } else {\n", "            state.maxDistance = state.maxBackwardDistance;\n", "          }\n", "\n", "          state.copyDst = state.pos;\n", "          if (state.distance > state.maxDistance) {\n", "            state.runningState = RunningState.TRANSFORM;\n", "            continue;\n", "          }\n", "\n", "          if (state.distanceCode > 0) {\n", "            state.distRb[state.distRbIdx & 3] = state.distance;\n", "            state.distRbIdx++;\n", "          }\n", "\n", "          if (state.copyLength > state.metaBlockLength) {\n", "            throw new BrotliRuntimeException(\"Invalid backward reference\"); // COV_NF_LINE\n", "          }\n", "          state.j = 0;\n", "          state.runningState = RunningState.COPY_LOOP;\n", "          // fall through\n", "        case RunningState.COPY_LOOP:\n", "          int src = (state.pos - state.distance) & ringBufferMask;\n", "          int dst = state.pos;\n", "          int copyLength = state.copyLength - state.j;\n", "          if ((src + copyLength < ringBufferMask) && (dst + copyLength < ringBufferMask)) {\n", "            for (int k = 0; k < copyLength; ++k) {\n", "              ringBuffer[dst++] = ringBuffer[src++];\n", "            }\n", "            state.j += copyLength;\n", "            state.metaBlockLength -= copyLength;\n", "            state.pos += copyLength;\n", "          } else {\n", "            for (; state.j < state.copyLength;) {\n", "              ringBuffer[state.pos] =\n", "                  ringBuffer[(state.pos - state.distance) & ringBufferMask];\n", "              state.metaBlockLength--;\n", "              state.j++;\n", "              if (state.pos++ == ringBufferMask) {\n", "                state.nextRunningState = RunningState.COPY_LOOP;\n", "                state.bytesToWrite = state.ringBufferSize;\n", "                state.bytesWritten = 0;\n", "                state.runningState = RunningState.WRITE;\n", "                break;\n", "              }\n", "            }\n", "          }\n", "          if (state.runningState == RunningState.COPY_LOOP) {\n", "            state.runningState = RunningState.MAIN_LOOP;\n", "          }\n", "          continue;\n", "\n", "        case RunningState.TRANSFORM:\n", "          if (state.copyLength >= Dictionary.MIN_WORD_LENGTH\n", "              && state.copyLength <= Dictionary.MAX_WORD_LENGTH) {\n", "            int offset = Dictionary.OFFSETS_BY_LENGTH[state.copyLength];\n", "            int wordId = state.distance - state.maxDistance - 1;\n", "            int shift = Dictionary.SIZE_BITS_BY_LENGTH[state.copyLength];\n", "            int mask = (1 << shift) - 1;\n", "            int wordIdx = wordId & mask;\n", "            int transformIdx = wordId >>> shift;\n", "            offset += wordIdx * state.copyLength;\n", "            if (transformIdx < Transform.TRANSFORMS.length) {\n", "              int len = Transform.transformDictionaryWord(ringBuffer, state.copyDst,\n", "                  Dictionary.getData(), offset, state.copyLength,\n", "                  Transform.TRANSFORMS[transformIdx]);\n", "              state.copyDst += len;\n", "              state.pos += len;\n", "              state.metaBlockLength -= len;\n", "              if (state.copyDst >= state.ringBufferSize) {\n", "                state.nextRunningState = RunningState.COPY_WRAP_BUFFER;\n", "                state.bytesToWrite = state.ringBufferSize;\n", "                state.bytesWritten = 0;\n", "                state.runningState = RunningState.WRITE;\n", "                continue;\n", "              }\n", "            } else {\n", "              throw new BrotliRuntimeException(\"Invalid backward reference\"); // COV_NF_LINE\n", "            }\n", "          } else {\n", "            throw new BrotliRuntimeException(\"Invalid backward reference\"); // COV_NF_LINE\n", "          }\n", "          state.runningState = RunningState.MAIN_LOOP;\n", "          continue;\n", "\n", "        case RunningState.COPY_WRAP_BUFFER:\n", "          System.arraycopy(ringBuffer, state.ringBufferSize, ringBuffer, 0,\n", "              state.copyDst - state.ringBufferSize);\n", "          state.runningState = RunningState.MAIN_LOOP;\n", "          continue;\n", "\n", "        case RunningState.READ_METADATA:\n", "          while (state.metaBlockLength > 0) {\n", "            BitReader.readMoreInput(br);\n", "            // Optimize\n", "            BitReader.readBits(br, 8);\n", "            state.metaBlockLength--;\n", "          }\n", "          state.runningState = RunningState.BLOCK_START;\n", "          continue;\n", "\n", "\n", "        case RunningState.COPY_UNCOMPRESSED:\n", "          copyUncompressedData(state);\n", "          continue;\n", "\n", "        case RunningState.WRITE:\n", "          if (!writeRingBuffer(state)) {\n", "            // Output buffer is full.\n", "            return;\n", "          }\n", "          if (state.pos >= state.maxBackwardDistance) {\n", "            state.maxDistance = state.maxBackwardDistance;\n", "          }\n", "          state.pos &= ringBufferMask;\n", "          state.runningState = state.nextRunningState;\n", "          continue;\n", "\n", "        default:\n", "          throw new BrotliRuntimeException(\"Unexpected state \" + state.runningState);\n", "      }\n", "    }\n", "    if (state.runningState == RunningState.FINISHED) {\n", "      if (state.metaBlockLength < 0) {\n", "        throw new BrotliRuntimeException(\"Invalid metablock length\");\n", "      }\n", "      BitReader.jumpToByteBoundary(br);\n", "      BitReader.checkHealth(state.br, true);\n", "    }\n", "  }\n", "}\n"], "test_content": ["/* Copyright 2015 Google Inc. All Rights Reserved.\n", "\n", "   Distributed under MIT license.\n", "   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n", "*/\n", "\n", "package com.itextpdf.io.codec.brotli.dec;\n", "\n", "import static org.junit.Assert.assertArrayEquals;\n", "\n", "import java.io.ByteArrayInputStream;\n", "import java.io.ByteArrayOutputStream;\n", "import java.io.IOException;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "/**\n", " * Tests for {@link Decode}.\n", " */\n", "@Category(UnitTest.class)\n", "public class DecodeTest extends ExtendedITextTest{\n", "\n", "  private byte[] decompress(byte[] data, boolean byByte) throws IOException {\n", "    byte[] buffer = new byte[65536];\n", "    ByteArrayInputStream input = new ByteArrayInputStream(data);\n", "    ByteArrayOutputStream output = new ByteArrayOutputStream();\n", "    BrotliInputStream brotliInput = new BrotliInputStream(input);\n", "    if (byByte) {\n", "      byte[] oneByte = new byte[1];\n", "      while (true) {\n", "        int next = brotliInput.read();\n", "        if (next == -1) {\n", "          break;\n", "        }\n", "        oneByte[0] = (byte) next;\n", "        output.write(oneByte, 0, 1);\n", "      }\n", "    } else {\n", "      while (true) {\n", "        int len = brotliInput.read(buffer, 0, buffer.length);\n", "        if (len <= 0) {\n", "          break;\n", "        }\n", "        output.write(buffer, 0, len);\n", "      }\n", "    }\n", "    brotliInput.close();\n", "    return output.toByteArray();\n", "  }\n", "\n", "  private byte[] decompressWithDictionary(byte[] data, byte[] dictionary) throws IOException {\n", "    byte[] buffer = new byte[65536];\n", "    ByteArrayInputStream input = new ByteArrayInputStream(data);\n", "    ByteArrayOutputStream output = new ByteArrayOutputStream();\n", "    BrotliInputStream brotliInput = new BrotliInputStream(\n", "        input, BrotliInputStream.DEFAULT_INTERNAL_BUFFER_SIZE, dictionary);\n", "    while (true) {\n", "      int len = brotliInput.read(buffer, 0, buffer.length);\n", "      if (len <= 0) {\n", "        break;\n", "      }\n", "      output.write(buffer, 0, len);\n", "    }\n", "    brotliInput.close();\n", "    return output.toByteArray();\n", "  }\n", "\n", "  private void checkDecodeResourceWithDictionary(String expected, String compressed,\n", "      String dictionary) throws IOException {\n", "    byte[] expectedBytes = Transform.readUniBytes(expected);\n", "    byte[] compressedBytes = Transform.readUniBytes(compressed);\n", "    byte[] dictionaryBytes = Transform.readUniBytes(dictionary);\n", "    byte[] actual = decompressWithDictionary(compressedBytes, dictionaryBytes);\n", "    assertArrayEquals(expectedBytes, actual);\n", "  }\n", "\n", "  private void checkDecodeResource(String expected, String compressed) throws IOException {\n", "    byte[] expectedBytes = Transform.readUniBytes(expected);\n", "    byte[] compressedBytes = Transform.readUniBytes(compressed);\n", "    byte[] actual = decompress(compressedBytes, false);\n", "    assertArrayEquals(expectedBytes, actual);\n", "    byte[] actualByByte = decompress(compressedBytes, true);\n", "    assertArrayEquals(expectedBytes, actualByByte);\n", "  }\n", "\n", "  @Test\n", "  public void testEmpty() throws IOException {\n", "    checkDecodeResource(\n", "        \"\",\n", "        \"\\u0006\");\n", "  }\n", "\n", "  @Test\n", "  public void testX() throws IOException {\n", "    checkDecodeResource(\n", "        \"X\",\n", "        \"\\u000B\\u0000\\u0080X\\u0003\");\n", "  }\n", "\n", "  @Test\n", "  public void testX10Y10() throws IOException {\n", "    checkDecodeResource(\n", "        \"XXXXXXXXXXYYYYYYYYYY\",\n", "        \"\\u001B\\u0013\\u0000\\u0000\\u00A4\\u00B0\\u00B2\\u00EA\\u0081G\\u0002\\u008A\");\n", "  }\n", "\n", "  @Test\n", "  public void testX64() throws IOException {\n", "    checkDecodeResource(\n", "        \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n", "        \"\\u001B\\u003F\\u0000\\u0000$\\u00B0\\u00E2\\u0099\\u0080\\u0012\");\n", "  }\n", "\n", "  @Test\n", "  public void testUkkonooa() throws IOException {\n", "    checkDecodeResource(\n", "        \"ukko nooa, ukko nooa oli kunnon mies, kun han meni saunaan, \"\n", "        + \"pisti laukun naulaan, ukko nooa, ukko nooa oli kunnon mies.\",\n", "        \"\\u001Bv\\u0000\\u0000\\u0014J\\u00AC\\u009Bz\\u00BD\\u00E1\\u0097\\u009D\\u007F\\u008E\\u00C2\\u0082\"\n", "        + \"6\\u000E\\u009C\\u00E0\\u0090\\u0003\\u00F7\\u008B\\u009E8\\u00E6\\u00B6\\u0000\\u00AB\\u00C3\\u00CA\"\n", "        + \"\\u00A0\\u00C2\\u00DAf6\\u00DC\\u00CD\\u0080\\u008D.!\\u00D7n\\u00E3\\u00EAL\\u00B8\\u00F0\\u00D2\"\n", "        + \"\\u00B8\\u00C7\\u00C2pM:\\u00F0i~\\u00A1\\u00B8Es\\u00AB\\u00C4W\\u001E\");\n", "  }\n", "\n", "  @Test\n", "  public void testMonkey() throws IOException {\n", "    checkDecodeResource(\n", "        \"znxcvnmz,xvnm.,zxcnv.,xcn.z,vn.zvn.zxcvn.,zxcn.vn.v,znm.,vnzx.,vnzxc.vn.z,vnz.,nv.z,nvmz\"\n", "        + \"xc,nvzxcvcnm.,vczxvnzxcnvmxc.zmcnvzm.,nvmc,nzxmc,vn.mnnmzxc,vnxcnmv,znvzxcnmv,.xcnvm,zxc\"\n", "        + \"nzxv.zx,qweryweurqioweupropqwutioweupqrioweutiopweuriopweuriopqwurioputiopqwuriowuqeriou\"\n", "        + \"pqweropuweropqwurweuqriopuropqwuriopuqwriopuqweopruioqweurqweuriouqweopruioupqiytioqtyio\"\n", "        + \"wtyqptypryoqweutioioqtweqruowqeytiowquiourowetyoqwupiotweuqiorweuqroipituqwiorqwtioweuri\"\n", "        + \"ouytuioerytuioweryuitoweytuiweyuityeruirtyuqriqweuropqweiruioqweurioqwuerioqwyuituierwot\"\n", "        + \"ueryuiotweyrtuiwertyioweryrueioqptyioruyiopqwtjkasdfhlafhlasdhfjklashjkfhasjklfhklasjdfh\"\n", "        + \"klasdhfjkalsdhfklasdhjkflahsjdkfhklasfhjkasdfhasfjkasdhfklsdhalghhaf;hdklasfhjklashjklfa\"\n", "        + \"sdhfasdjklfhsdjklafsd;hkldadfjjklasdhfjasddfjklfhakjklasdjfkl;asdjfasfljasdfhjklasdfhjka\"\n", "        + \"ghjkashf;djfklasdjfkljasdklfjklasdjfkljasdfkljaklfj\",\n", "        \"\\u001BJ\\u0003\\u0000\\u008C\\u0094n\\u00DE\\u00B4\\u00D7\\u0096\\u00B1x\\u0086\\u00F2-\\u00E1\\u001A\"\n", "        + \"\\u00BC\\u000B\\u001C\\u00BA\\u00A9\\u00C7\\u00F7\\u00CCn\\u00B2B4QD\\u008BN\\u0013\\b\\u00A0\\u00CDn\"\n", "        + \"\\u00E8,\\u00A5S\\u00A1\\u009C],\\u001D#\\u001A\\u00D2V\\u00BE\\u00DB\\u00EB&\\u00BA\\u0003e|\\u0096j\"\n", "        + \"\\u00A2v\\u00EC\\u00EF\\u0087G3\\u00D6\\'\\u000Ec\\u0095\\u00E2\\u001D\\u008D,\\u00C5\\u00D1(\\u009F`\"\n", "        + \"\\u0094o\\u0002\\u008B\\u00DD\\u00AAd\\u0094,\\u001E;e|\\u0007EZ\\u00B2\\u00E2\\u00FCI\\u0081,\\u009F\"\n", "        + \"@\\u00AE\\u00EFh\\u0081\\u00AC\\u0016z\\u000F\\u00F5;m\\u001C\\u00B9\\u001E-_\\u00D5\\u00C8\\u00AF^\"\n", "        + \"\\u0085\\u00AA\\u0005\\u00BESu\\u00C2\\u00B0\\\"\\u008A\\u0015\\u00C6\\u00A3\\u00B1\\u00E6B\\u0014\"\n", "        + \"\\u00F4\\u0084TS\\u0019_\\u00BE\\u00C3\\u00F2\\u001D\\u00D1\\u00B7\\u00E5\\u00DD\\u00B6\\u00D9#\\u00C6\"\n", "        + \"\\u00F6\\u009F\\u009E\\u00F6Me0\\u00FB\\u00C0qE\\u0004\\u00AD\\u0003\\u00B5\\u00BE\\u00C9\\u00CB\"\n", "        + \"\\u00FD\\u00E2PZFt\\u0004\\r\\u00FF \\u0004w\\u00B2m\\'\\u00BFG\\u00A9\\u009D\\u001B\\u0096,b\\u0090#\"\n", "        + \"\\u008B\\u00E0\\u00F8\\u001D\\u00CF\\u00AF\\u001D=\\u00EE\\u008A\\u00C8u#f\\u00DD\\u00DE\\u00D6m\"\n", "        + \"\\u00E3*\\u0082\\u008Ax\\u008A\\u00DB\\u00E6 L\\u00B7\\\\c\\u00BA0\\u00E3?\\u00B6\\u00EE\\u008C\\\"\"\n", "        + \"\\u00A2*\\u00B0\\\"\\n\\u0099\\u00FF=bQ\\u00EE\\b\\u00F6=J\\u00E4\\u00CC\\u00EF\\\"\\u0087\\u0011\\u00E2\"\n", "        + \"\\u0083(\\u00E4\\u00F5\\u008F5\\u0019c[\\u00E1Z\\u0092s\\u00DD\\u00A1P\\u009D8\\\\\\u00EB\\u00B5\\u0003\"\n", "        + \"jd\\u0090\\u0094\\u00C8\\u008D\\u00FB/\\u008A\\u0086\\\"\\u00CC\\u001D\\u0087\\u00E0H\\n\\u0096w\\u00909\"\n", "        + \"\\u00C6##H\\u00FB\\u0011GV\\u00CA \\u00E3B\\u0081\\u00F7w2\\u00C1\\u00A5\\\\@!e\\u0017@)\\u0017\\u0017\"\n", "        + \"lV2\\u00988\\u0006\\u00DC\\u0099M3)\\u00BB\\u0002\\u00DFL&\\u0093l\\u0017\\u0082\\u0086 \\u00D7\"\n", "        + \"\\u0003y}\\u009A\\u0000\\u00D7\\u0087\\u0000\\u00E7\\u000Bf\\u00E3Lfqg\\b2\\u00F9\\b>\\u00813\\u00CD\"\n", "        + \"\\u0017r1\\u00F0\\u00B8\\u0094RK\\u00901\\u008Eh\\u00C1\\u00EF\\u0090\\u00C9\\u00E5\\u00F2a\\tr%\"\n", "        + \"\\u00AD\\u00EC\\u00C5b\\u00C0\\u000B\\u0012\\u0005\\u00F7\\u0091u\\r\\u00EEa..\\u0019\\t\\u00C2\\u0003\"\n", "    );\n", "  }\n", "\n", "  @Test\n", "  public void testFox() throws IOException {\n", "    checkDecodeResource(\n", "        \"The quick brown fox jumps over the lazy dog\",\n", "        \"\\u001B*\\u0000\\u0000\\u0004\\u0004\\u00BAF:\\u0085\\u0003\\u00E9\\u00FA\\f\\u0091\\u0002H\\u0011,\"\n", "        + \"\\u00F3\\u008A:\\u00A3V\\u007F\\u001A\\u00AE\\u00BF\\u00A4\\u00AB\\u008EM\\u00BF\\u00ED\\u00E2\\u0004K\"\n", "        + \"\\u0091\\u00FF\\u0087\\u00E9\\u001E\");\n", "  }\n", "\n", "  @Test\n", "  public void testFoxFox() throws IOException {\n", "    checkDecodeResourceWithDictionary(\n", "        \"The quick brown fox jumps over the lazy dog\",\n", "        \"\\u001B*\\u0000\\u0000 \\u0000\\u00C2\\u0098\\u00B0\\u00CA\\u0001\",\n", "        \"The quick brown fox jumps over the lazy dog\");\n", "  }\n", "\n", "  @Test\n", "  public void testUtils() {\n", "    new Context();\n", "    new Decode();\n", "    new Dictionary();\n", "    new Huffman();\n", "    new Prefix();\n", "  }\n", "}\n"], "method_lines_dic": {"Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)": [50, 60], "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)": [62, 100], "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)": [105, 119], "Decode::::readBlockLength(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)": [121, 126], "Decode::::translateShortCodes(int,int[],int)": [128, 135], "Decode::::moveToFront(int[],int)": [137, 143], "Decode::::inverseMoveToFrontTransform(byte[],int)": [145, 157], "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)": [159, 216], "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)": [219, 288], "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)": [290, 332], "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)": [334, 356], "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)": [358, 367], "Decode::::decodeCommandBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)": [369, 372], "Decode::::decodeDistanceBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)": [374, 377], "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)": [379, 414], "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)": [421, 458], "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)": [460, 528], "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)": [530, 555], "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)": [557, 573], "Decode::::setCustomDictionary(com.itextpdf.io.codec.brotli.dec.State,byte[])": [575, 577], "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)": [582, 855]}, "test_method_lines_dic": {"DecodeTest::::decompress(byte[],boolean)": [26, 52], "DecodeTest::::decompressWithDictionary(byte[],byte[])": [54, 69], "DecodeTest::::checkDecodeResourceWithDictionary(java.lang.String,java.lang.String,java.lang.String)": [71, 78], "DecodeTest::::checkDecodeResource(java.lang.String,java.lang.String)": [80, 87], "DecodeTest::::testEmpty()": [89, 94], "DecodeTest::::testX()": [96, 101], "DecodeTest::::testX10Y10()": [103, 108], "DecodeTest::::testX64()": [110, 115], "DecodeTest::::testUkkonooa()": [117, 126], "DecodeTest::::testMonkey()": [128, 162], "DecodeTest::::testFox()": [164, 171], "DecodeTest::::testFoxFox()": [173, 179], "DecodeTest::::testUtils()": [181, 188]}, "reverse_method_lines_dic": {"50": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "51": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "52": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "53": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "54": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "55": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "56": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "57": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "58": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "59": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "60": "Decode::::decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader)", "62": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "63": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "64": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "65": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "66": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "67": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "68": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "69": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "70": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "71": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "72": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "73": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "74": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "75": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "76": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "77": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "78": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "79": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "80": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "81": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "82": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "83": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "84": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "85": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "86": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "87": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "88": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "89": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "90": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "91": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "92": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "93": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "94": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "95": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "96": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "97": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "98": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "99": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "100": "Decode::::decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State)", "105": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "106": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "107": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "108": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "109": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "110": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "111": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "112": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "113": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "114": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "115": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "116": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "117": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "118": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "119": "Decode::::readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "121": "Decode::::readBlockLength(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "122": "Decode::::readBlockLength(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "123": "Decode::::readBlockLength(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "124": "Decode::::readBlockLength(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "125": "Decode::::readBlockLength(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "126": "Decode::::readBlockLength(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "128": "Decode::::translateShortCodes(int,int[],int)", "129": "Decode::::translateShortCodes(int,int[],int)", "130": "Decode::::translateShortCodes(int,int[],int)", "131": "Decode::::translateShortCodes(int,int[],int)", "132": "Decode::::translateShortCodes(int,int[],int)", "133": "Decode::::translateShortCodes(int,int[],int)", "134": "Decode::::translateShortCodes(int,int[],int)", "135": "Decode::::translateShortCodes(int,int[],int)", "137": "Decode::::moveToFront(int[],int)", "138": "Decode::::moveToFront(int[],int)", "139": "Decode::::moveToFront(int[],int)", "140": "Decode::::moveToFront(int[],int)", "141": "Decode::::moveToFront(int[],int)", "142": "Decode::::moveToFront(int[],int)", "143": "Decode::::moveToFront(int[],int)", "145": "Decode::::inverseMoveToFrontTransform(byte[],int)", "146": "Decode::::inverseMoveToFrontTransform(byte[],int)", "147": "Decode::::inverseMoveToFrontTransform(byte[],int)", "148": "Decode::::inverseMoveToFrontTransform(byte[],int)", "149": "Decode::::inverseMoveToFrontTransform(byte[],int)", "150": "Decode::::inverseMoveToFrontTransform(byte[],int)", "151": "Decode::::inverseMoveToFrontTransform(byte[],int)", "152": "Decode::::inverseMoveToFrontTransform(byte[],int)", "153": "Decode::::inverseMoveToFrontTransform(byte[],int)", "154": "Decode::::inverseMoveToFrontTransform(byte[],int)", "155": "Decode::::inverseMoveToFrontTransform(byte[],int)", "156": "Decode::::inverseMoveToFrontTransform(byte[],int)", "157": "Decode::::inverseMoveToFrontTransform(byte[],int)", "159": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "160": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "161": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "162": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "163": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "164": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "165": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "166": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "167": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "168": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "169": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "170": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "171": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "172": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "173": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "174": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "175": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "176": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "177": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "178": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "179": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "180": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "181": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "182": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "183": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "184": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "185": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "186": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "187": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "188": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "189": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "190": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "191": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "192": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "193": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "194": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "195": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "196": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "197": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "198": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "199": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "200": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "201": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "202": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "203": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "204": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "205": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "206": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "207": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "208": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "209": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "210": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "211": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "212": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "213": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "214": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "215": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "216": "Decode::::readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader)", "219": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "220": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "221": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "222": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "223": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "224": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "225": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "226": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "227": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "228": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "229": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "230": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "231": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "232": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "233": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "234": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "235": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "236": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "237": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "238": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "239": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "240": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "241": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "242": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "243": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "244": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "245": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "246": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "247": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "248": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "249": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "250": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "251": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "252": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "253": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "254": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "255": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "256": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "257": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "258": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "259": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "260": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "261": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "262": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "263": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "264": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "265": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "266": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "267": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "268": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "269": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "270": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "271": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "272": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "273": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "274": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "275": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "276": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "277": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "278": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "279": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "280": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "281": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "282": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "283": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "284": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "285": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "286": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "287": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "288": "Decode::::readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader)", "290": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "291": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "292": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "293": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "294": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "295": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "296": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "297": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "298": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "299": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "300": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "301": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "302": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "303": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "304": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "305": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "306": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "307": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "308": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "309": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "310": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "311": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "312": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "313": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "314": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "315": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "316": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "317": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "318": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "319": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "320": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "321": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "322": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "323": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "324": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "325": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "326": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "327": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "328": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "329": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "330": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "331": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "332": "Decode::::decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader)", "334": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "335": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "336": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "337": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "338": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "339": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "340": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "341": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "342": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "343": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "344": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "345": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "346": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "347": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "348": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "349": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "350": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "351": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "352": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "353": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "354": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "355": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "356": "Decode::::decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int)", "358": "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "359": "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "360": "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "361": "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "362": "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "363": "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "364": "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "365": "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "366": "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "367": "Decode::::decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "369": "Decode::::decodeCommandBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "370": "Decode::::decodeCommandBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "371": "Decode::::decodeCommandBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "372": "Decode::::decodeCommandBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "374": "Decode::::decodeDistanceBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "375": "Decode::::decodeDistanceBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "376": "Decode::::decodeDistanceBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "377": "Decode::::decodeDistanceBlockSwitch(com.itextpdf.io.codec.brotli.dec.State)", "379": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "380": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "381": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "382": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "383": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "384": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "385": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "386": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "387": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "388": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "389": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "390": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "391": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "392": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "393": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "394": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "395": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "396": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "397": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "398": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "399": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "400": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "401": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "402": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "403": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "404": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "405": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "406": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "407": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "408": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "409": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "410": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "411": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "412": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "413": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "414": "Decode::::maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "421": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "422": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "423": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "424": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "425": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "426": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "427": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "428": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "429": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "430": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "431": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "432": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "433": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "434": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "435": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "436": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "437": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "438": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "439": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "440": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "441": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "442": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "443": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "444": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "445": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "446": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "447": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "448": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "449": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "450": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "451": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "452": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "453": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "454": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "455": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "456": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "457": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "458": "Decode::::readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State)", "460": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "461": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "462": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "463": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "464": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "465": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "466": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "467": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "468": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "469": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "470": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "471": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "472": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "473": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "474": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "475": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "476": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "477": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "478": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "479": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "480": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "481": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "482": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "483": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "484": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "485": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "486": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "487": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "488": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "489": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "490": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "491": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "492": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "493": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "494": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "495": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "496": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "497": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "498": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "499": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "500": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "501": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "502": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "503": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "504": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "505": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "506": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "507": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "508": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "509": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "510": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "511": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "512": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "513": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "514": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "515": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "516": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "517": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "518": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "519": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "520": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "521": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "522": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "523": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "524": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "525": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "526": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "527": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "528": "Decode::::readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State)", "530": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "531": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "532": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "533": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "534": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "535": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "536": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "537": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "538": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "539": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "540": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "541": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "542": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "543": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "544": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "545": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "546": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "547": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "548": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "549": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "550": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "551": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "552": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "553": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "554": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "555": "Decode::::copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State)", "557": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "558": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "559": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "560": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "561": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "562": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "563": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "564": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "565": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "566": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "567": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "568": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "569": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "570": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "571": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "572": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "573": "Decode::::writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State)", "575": "Decode::::setCustomDictionary(com.itextpdf.io.codec.brotli.dec.State,byte[])", "576": "Decode::::setCustomDictionary(com.itextpdf.io.codec.brotli.dec.State,byte[])", "577": "Decode::::setCustomDictionary(com.itextpdf.io.codec.brotli.dec.State,byte[])", "582": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "583": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "584": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "585": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "586": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "587": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "588": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "589": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "590": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "591": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "592": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "593": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "594": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "595": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "596": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "597": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "598": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "599": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "600": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "601": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "602": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "603": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "604": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "605": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "606": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "607": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "608": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "609": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "610": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "611": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "612": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "613": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "614": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "615": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "616": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "617": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "618": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "619": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "620": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "621": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "622": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "623": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "624": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "625": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "626": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "627": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "628": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "629": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "630": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "631": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "632": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "633": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "634": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "635": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "636": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "637": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "638": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "639": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "640": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "641": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "642": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "643": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "644": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "645": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "646": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "647": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "648": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "649": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "650": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "651": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "652": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "653": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "654": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "655": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "656": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "657": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "658": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "659": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "660": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "661": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "662": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "663": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "664": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "665": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "666": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "667": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "668": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "669": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "670": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "671": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "672": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "673": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "674": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "675": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "676": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "677": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "678": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "679": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "680": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "681": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "682": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "683": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "684": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "685": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "686": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "687": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "688": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "689": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "690": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "691": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "692": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "693": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "694": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "695": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "696": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "697": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "698": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "699": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "700": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "701": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "702": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "703": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "704": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "705": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "706": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "707": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "708": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "709": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "710": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "711": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "712": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "713": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "714": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "715": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "716": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "717": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "718": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "719": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "720": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "721": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "722": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "723": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "724": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "725": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "726": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "727": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "728": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "729": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "730": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "731": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "732": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "733": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "734": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "735": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "736": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "737": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "738": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "739": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "740": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "741": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "742": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "743": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "744": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "745": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "746": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "747": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "748": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "749": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "750": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "751": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "752": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "753": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "754": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "755": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "756": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "757": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "758": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "759": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "760": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "761": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "762": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "763": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "764": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "765": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "766": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "767": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "768": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "769": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "770": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "771": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "772": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "773": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "774": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "775": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "776": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "777": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "778": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "779": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "780": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "781": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "782": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "783": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "784": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "785": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "786": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "787": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "788": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "789": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "790": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "791": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "792": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "793": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "794": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "795": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "796": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "797": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "798": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "799": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "800": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "801": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "802": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "803": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "804": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "805": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "806": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "807": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "808": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "809": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "810": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "811": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "812": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "813": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "814": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "815": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "816": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "817": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "818": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "819": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "820": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "821": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "822": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "823": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "824": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "825": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "826": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "827": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "828": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "829": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "830": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "831": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "832": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "833": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "834": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "835": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "836": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "837": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "838": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "839": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "840": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "841": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "842": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "843": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "844": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "845": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "846": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "847": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "848": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "849": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "850": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "851": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "852": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "853": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "854": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)", "855": "Decode::::decompress(com.itextpdf.io.codec.brotli.dec.State)"}, "test_reverse_method_lines_dic": {"26": "DecodeTest::::decompress(byte[],boolean)", "27": "DecodeTest::::decompress(byte[],boolean)", "28": "DecodeTest::::decompress(byte[],boolean)", "29": "DecodeTest::::decompress(byte[],boolean)", "30": "DecodeTest::::decompress(byte[],boolean)", "31": "DecodeTest::::decompress(byte[],boolean)", "32": "DecodeTest::::decompress(byte[],boolean)", "33": "DecodeTest::::decompress(byte[],boolean)", "34": "DecodeTest::::decompress(byte[],boolean)", "35": "DecodeTest::::decompress(byte[],boolean)", "36": "DecodeTest::::decompress(byte[],boolean)", "37": "DecodeTest::::decompress(byte[],boolean)", "38": "DecodeTest::::decompress(byte[],boolean)", "39": "DecodeTest::::decompress(byte[],boolean)", "40": "DecodeTest::::decompress(byte[],boolean)", "41": "DecodeTest::::decompress(byte[],boolean)", "42": "DecodeTest::::decompress(byte[],boolean)", "43": "DecodeTest::::decompress(byte[],boolean)", "44": "DecodeTest::::decompress(byte[],boolean)", "45": "DecodeTest::::decompress(byte[],boolean)", "46": "DecodeTest::::decompress(byte[],boolean)", "47": "DecodeTest::::decompress(byte[],boolean)", "48": "DecodeTest::::decompress(byte[],boolean)", "49": "DecodeTest::::decompress(byte[],boolean)", "50": "DecodeTest::::decompress(byte[],boolean)", "51": "DecodeTest::::decompress(byte[],boolean)", "52": "DecodeTest::::decompress(byte[],boolean)", "54": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "55": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "56": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "57": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "58": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "59": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "60": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "61": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "62": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "63": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "64": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "65": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "66": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "67": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "68": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "69": "DecodeTest::::decompressWithDictionary(byte[],byte[])", "71": "DecodeTest::::checkDecodeResourceWithDictionary(java.lang.String,java.lang.String,java.lang.String)", "72": "DecodeTest::::checkDecodeResourceWithDictionary(java.lang.String,java.lang.String,java.lang.String)", "73": "DecodeTest::::checkDecodeResourceWithDictionary(java.lang.String,java.lang.String,java.lang.String)", "74": "DecodeTest::::checkDecodeResourceWithDictionary(java.lang.String,java.lang.String,java.lang.String)", "75": "DecodeTest::::checkDecodeResourceWithDictionary(java.lang.String,java.lang.String,java.lang.String)", "76": "DecodeTest::::checkDecodeResourceWithDictionary(java.lang.String,java.lang.String,java.lang.String)", "77": "DecodeTest::::checkDecodeResourceWithDictionary(java.lang.String,java.lang.String,java.lang.String)", "78": "DecodeTest::::checkDecodeResourceWithDictionary(java.lang.String,java.lang.String,java.lang.String)", "80": "DecodeTest::::checkDecodeResource(java.lang.String,java.lang.String)", "81": "DecodeTest::::checkDecodeResource(java.lang.String,java.lang.String)", "82": "DecodeTest::::checkDecodeResource(java.lang.String,java.lang.String)", "83": "DecodeTest::::checkDecodeResource(java.lang.String,java.lang.String)", "84": "DecodeTest::::checkDecodeResource(java.lang.String,java.lang.String)", "85": "DecodeTest::::checkDecodeResource(java.lang.String,java.lang.String)", "86": "DecodeTest::::checkDecodeResource(java.lang.String,java.lang.String)", "87": "DecodeTest::::checkDecodeResource(java.lang.String,java.lang.String)", "89": "DecodeTest::::testEmpty()", "90": "DecodeTest::::testEmpty()", "91": "DecodeTest::::testEmpty()", "92": "DecodeTest::::testEmpty()", "93": "DecodeTest::::testEmpty()", "94": "DecodeTest::::testEmpty()", "96": "DecodeTest::::testX()", "97": "DecodeTest::::testX()", "98": "DecodeTest::::testX()", "99": "DecodeTest::::testX()", "100": "DecodeTest::::testX()", "101": "DecodeTest::::testX()", "103": "DecodeTest::::testX10Y10()", "104": "DecodeTest::::testX10Y10()", "105": "DecodeTest::::testX10Y10()", "106": "DecodeTest::::testX10Y10()", "107": "DecodeTest::::testX10Y10()", "108": "DecodeTest::::testX10Y10()", "110": "DecodeTest::::testX64()", "111": "DecodeTest::::testX64()", "112": "DecodeTest::::testX64()", "113": "DecodeTest::::testX64()", "114": "DecodeTest::::testX64()", "115": "DecodeTest::::testX64()", "117": "DecodeTest::::testUkkonooa()", "118": "DecodeTest::::testUkkonooa()", "119": "DecodeTest::::testUkkonooa()", "120": "DecodeTest::::testUkkonooa()", "121": "DecodeTest::::testUkkonooa()", "122": "DecodeTest::::testUkkonooa()", "123": "DecodeTest::::testUkkonooa()", "124": "DecodeTest::::testUkkonooa()", "125": "DecodeTest::::testUkkonooa()", "126": "DecodeTest::::testUkkonooa()", "128": "DecodeTest::::testMonkey()", "129": "DecodeTest::::testMonkey()", "130": "DecodeTest::::testMonkey()", "131": "DecodeTest::::testMonkey()", "132": "DecodeTest::::testMonkey()", "133": "DecodeTest::::testMonkey()", "134": "DecodeTest::::testMonkey()", "135": "DecodeTest::::testMonkey()", "136": "DecodeTest::::testMonkey()", "137": "DecodeTest::::testMonkey()", "138": "DecodeTest::::testMonkey()", "139": "DecodeTest::::testMonkey()", "140": "DecodeTest::::testMonkey()", "141": "DecodeTest::::testMonkey()", "142": "DecodeTest::::testMonkey()", "143": "DecodeTest::::testMonkey()", "144": "DecodeTest::::testMonkey()", "145": "DecodeTest::::testMonkey()", "146": "DecodeTest::::testMonkey()", "147": "DecodeTest::::testMonkey()", "148": "DecodeTest::::testMonkey()", "149": "DecodeTest::::testMonkey()", "150": "DecodeTest::::testMonkey()", "151": "DecodeTest::::testMonkey()", "152": "DecodeTest::::testMonkey()", "153": "DecodeTest::::testMonkey()", "154": "DecodeTest::::testMonkey()", "155": "DecodeTest::::testMonkey()", "156": "DecodeTest::::testMonkey()", "157": "DecodeTest::::testMonkey()", "158": "DecodeTest::::testMonkey()", "159": "DecodeTest::::testMonkey()", "160": "DecodeTest::::testMonkey()", "161": "DecodeTest::::testMonkey()", "162": "DecodeTest::::testMonkey()", "164": "DecodeTest::::testFox()", "165": "DecodeTest::::testFox()", "166": "DecodeTest::::testFox()", "167": "DecodeTest::::testFox()", "168": "DecodeTest::::testFox()", "169": "DecodeTest::::testFox()", "170": "DecodeTest::::testFox()", "171": "DecodeTest::::testFox()", "173": "DecodeTest::::testFoxFox()", "174": "DecodeTest::::testFoxFox()", "175": "DecodeTest::::testFoxFox()", "176": "DecodeTest::::testFoxFox()", "177": "DecodeTest::::testFoxFox()", "178": "DecodeTest::::testFoxFox()", "179": "DecodeTest::::testFoxFox()", "181": "DecodeTest::::testUtils()", "182": "DecodeTest::::testUtils()", "183": "DecodeTest::::testUtils()", "184": "DecodeTest::::testUtils()", "185": "DecodeTest::::testUtils()", "186": "DecodeTest::::testUtils()", "187": "DecodeTest::::testUtils()", "188": "DecodeTest::::testUtils()"}, "tests": [{"test_lines": [89, 94], "covered_lines": [26, 31, 35, 42, 63, 64, 65, 66, 67, 68, 422, 424, 425, 426, 427, 428, 429, 432, 433, 434, 435, 436, 437, 439, 440, 441, 442, 559, 563, 565, 572, 583, 586, 589, 590, 591, 593, 595, 597, 600, 602, 603, 604, 833, 837, 840, 841, 842, 848, 849, 852, 853, 855]}, {"test_lines": [96, 101], "covered_lines": [26, 31, 35, 42, 63, 64, 65, 66, 67, 68, 70, 71, 88, 89, 90, 93, 96, 97, 98, 100, 380, 381, 383, 384, 385, 387, 388, 391, 394, 395, 396, 400, 412, 413, 414, 422, 424, 425, 426, 427, 428, 429, 432, 433, 434, 435, 436, 437, 439, 440, 441, 442, 444, 445, 446, 451, 454, 455, 456, 458, 531, 532, 535, 541, 542, 543, 544, 545, 553, 554, 555, 559, 563, 565, 566, 568, 569, 572, 583, 586, 589, 590, 591, 593, 595, 597, 600, 602, 603, 604, 829, 830, 833, 837, 840, 841, 842, 848, 849, 852, 853, 855]}, {"test_lines": [103, 108], "covered_lines": [26, 31, 35, 42, 51, 59, 63, 64, 65, 66, 67, 70, 71, 88, 89, 90, 93, 96, 97, 100, 106, 107, 108, 109, 110, 111, 112, 129, 130, 131, 132, 134, 220, 222, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 237, 238, 239, 241, 242, 244, 246, 247, 248, 264, 284, 287, 288, 291, 292, 294, 295, 296, 380, 381, 383, 384, 385, 387, 391, 394, 395, 396, 400, 412, 413, 414, 422, 424, 425, 426, 427, 428, 429, 432, 433, 434, 435, 436, 437, 439, 440, 441, 444, 448, 451, 454, 455, 456, 458, 461, 463, 464, 465, 466, 476, 477, 478, 479, 480, 481, 483, 484, 486, 487, 488, 490, 491, 494, 495, 497, 498, 499, 506, 507, 510, 511, 512, 514, 515, 516, 518, 519, 520, 521, 522, 523, 524, 526, 527, 528, 559, 563, 565, 566, 568, 569, 572, 583, 586, 589, 590, 591, 593, 595, 597, 600, 602, 603, 604, 607, 608, 612, 613, 614, 616, 617, 620, 621, 622, 623, 624, 625, 626, 627, 629, 630, 631, 632, 633, 634, 636, 637, 641, 642, 643, 644, 647, 648, 649, 650, 651, 652, 687, 690, 691, 695, 696, 697, 700, 701, 702, 705, 706, 707, 708, 709, 710, 711, 712, 718, 719, 723, 725, 730, 731, 736, 737, 738, 741, 744, 745, 748, 749, 750, 751, 752, 753, 755, 756, 757, 773, 774, 833, 837, 840, 841, 842, 848, 849, 852, 853, 855]}, {"test_lines": [110, 115], "covered_lines": [26, 31, 35, 42, 51, 59, 63, 64, 65, 66, 67, 70, 71, 88, 89, 90, 93, 96, 97, 100, 106, 107, 108, 109, 110, 111, 112, 129, 134, 220, 222, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 237, 238, 239, 241, 242, 244, 264, 284, 287, 288, 291, 292, 294, 295, 296, 380, 381, 383, 384, 385, 387, 391, 394, 395, 396, 400, 412, 413, 414, 422, 424, 425, 426, 427, 428, 429, 432, 433, 434, 435, 436, 437, 439, 440, 441, 444, 448, 451, 454, 455, 456, 458, 461, 463, 464, 465, 466, 476, 477, 478, 479, 480, 481, 483, 484, 486, 487, 488, 490, 491, 494, 495, 497, 498, 499, 506, 507, 510, 511, 512, 514, 515, 516, 518, 519, 520, 521, 522, 523, 524, 526, 527, 528, 559, 563, 565, 566, 568, 569, 572, 583, 586, 589, 590, 591, 593, 595, 597, 600, 602, 603, 604, 607, 608, 612, 613, 614, 616, 617, 620, 621, 622, 623, 624, 625, 626, 627, 629, 630, 631, 632, 633, 634, 636, 637, 641, 642, 643, 644, 647, 648, 649, 650, 651, 652, 687, 690, 691, 695, 696, 697, 700, 701, 702, 705, 706, 707, 708, 709, 710, 711, 712, 718, 719, 723, 725, 730, 731, 736, 737, 738, 741, 744, 745, 748, 749, 750, 751, 752, 753, 755, 756, 757, 773, 774, 833, 837, 840, 841, 842, 848, 849, 852, 853, 855]}, {"test_lines": [117, 126], "covered_lines": [26, 31, 35, 42, 51, 52, 53, 54, 59, 63, 64, 65, 66, 67, 70, 71, 88, 89, 90, 93, 96, 97, 100, 106, 107, 108, 109, 110, 111, 112, 129, 130, 131, 132, 134, 138, 139, 140, 142, 143, 146, 147, 148, 150, 151, 152, 153, 154, 157, 161, 162, 163, 164, 165, 166, 168, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 184, 185, 186, 189, 193, 194, 195, 196, 198, 199, 200, 203, 204, 206, 210, 211, 215, 216, 220, 222, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 237, 238, 239, 241, 242, 246, 247, 248, 250, 251, 264, 265, 266, 267, 268, 269, 270, 271, 273, 274, 275, 276, 277, 278, 281, 282, 284, 287, 288, 291, 292, 294, 295, 296, 299, 300, 301, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 324, 325, 327, 328, 329, 331, 380, 381, 383, 384, 385, 387, 391, 394, 395, 396, 400, 412, 413, 414, 422, 424, 425, 426, 427, 428, 429, 432, 433, 434, 435, 436, 437, 439, 440, 441, 444, 448, 451, 454, 455, 456, 458, 461, 463, 464, 465, 466, 476, 477, 478, 479, 480, 481, 483, 484, 486, 487, 488, 490, 491, 494, 495, 497, 498, 499, 506, 507, 510, 511, 512, 514, 515, 516, 518, 519, 520, 521, 522, 523, 524, 526, 527, 528, 559, 563, 565, 566, 568, 569, 572, 583, 586, 589, 590, 591, 593, 595, 597, 600, 602, 603, 604, 607, 608, 612, 613, 614, 616, 617, 620, 621, 622, 623, 624, 625, 626, 627, 629, 630, 631, 632, 633, 634, 636, 637, 641, 642, 643, 644, 647, 648, 649, 650, 651, 652, 687, 690, 691, 692, 693, 695, 696, 697, 700, 701, 702, 705, 706, 707, 708, 709, 710, 711, 712, 718, 719, 723, 725, 730, 731, 736, 737, 738, 741, 744, 745, 748, 749, 750, 751, 752, 753, 755, 756, 757, 773, 774, 833, 837, 840, 841, 842, 848, 849, 852, 853, 855]}, {"test_lines": [128, 162], "covered_lines": [26, 31, 35, 42, 51, 52, 53, 54, 59, 63, 64, 65, 66, 67, 70, 71, 88, 89, 90, 93, 96, 97, 100, 106, 107, 108, 109, 110, 111, 112, 129, 130, 131, 132, 134, 138, 139, 140, 142, 143, 146, 147, 148, 150, 151, 152, 153, 154, 157, 161, 162, 163, 164, 165, 166, 168, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 184, 185, 186, 187, 189, 190, 191, 193, 194, 195, 196, 198, 199, 200, 203, 204, 206, 207, 210, 211, 215, 216, 220, 222, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 237, 238, 239, 241, 242, 250, 251, 264, 265, 266, 267, 268, 269, 270, 271, 273, 274, 275, 276, 277, 278, 281, 282, 284, 287, 288, 291, 292, 294, 295, 296, 299, 300, 301, 302, 304, 305, 306, 307, 308, 309, 310, 313, 314, 315, 316, 319, 320, 321, 323, 324, 325, 327, 328, 329, 331, 380, 381, 383, 384, 385, 387, 391, 394, 395, 396, 400, 412, 413, 414, 422, 424, 425, 426, 427, 428, 429, 432, 433, 434, 435, 436, 437, 439, 440, 441, 444, 448, 451, 454, 455, 456, 458, 461, 463, 464, 465, 466, 476, 477, 478, 479, 480, 481, 483, 484, 486, 487, 488, 490, 491, 494, 495, 497, 498, 499, 500, 501, 506, 507, 510, 511, 512, 514, 515, 516, 518, 519, 520, 521, 522, 523, 524, 526, 527, 528, 559, 563, 565, 566, 568, 569, 572, 583, 586, 589, 590, 591, 593, 595, 597, 600, 602, 603, 604, 607, 608, 612, 613, 614, 616, 617, 620, 621, 622, 623, 624, 625, 626, 627, 629, 630, 631, 632, 633, 634, 636, 637, 641, 661, 662, 663, 664, 665, 668, 671, 672, 673, 674, 676, 677, 678, 685, 687, 690, 691, 695, 696, 697, 700, 701, 702, 705, 706, 707, 708, 709, 710, 711, 712, 718, 719, 723, 725, 730, 731, 732, 733, 736, 737, 738, 741, 744, 745, 748, 749, 750, 751, 752, 753, 755, 756, 757, 773, 774, 779, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 792, 793, 794, 795, 802, 805, 808, 809, 833, 837, 840, 841, 842, 848, 849, 852, 853, 855]}, {"test_lines": [164, 171], "covered_lines": [26, 31, 35, 42, 51, 59, 63, 64, 65, 66, 67, 70, 71, 88, 89, 90, 93, 96, 97, 100, 106, 107, 108, 109, 110, 111, 112, 161, 162, 163, 164, 165, 166, 168, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 184, 185, 186, 187, 189, 190, 191, 193, 194, 195, 196, 198, 199, 200, 203, 204, 206, 207, 210, 211, 215, 216, 220, 222, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 237, 238, 239, 241, 242, 244, 264, 265, 266, 267, 268, 269, 270, 271, 273, 274, 275, 276, 277, 278, 281, 282, 284, 287, 288, 291, 292, 294, 295, 296, 380, 381, 383, 384, 385, 387, 391, 394, 395, 396, 400, 412, 413, 414, 422, 424, 425, 426, 427, 428, 429, 432, 433, 434, 435, 436, 437, 439, 440, 441, 444, 448, 451, 454, 455, 456, 458, 461, 463, 464, 465, 466, 476, 477, 478, 479, 480, 481, 483, 484, 486, 487, 488, 490, 491, 494, 495, 497, 498, 499, 506, 507, 510, 511, 512, 514, 515, 516, 518, 519, 520, 521, 522, 523, 524, 526, 527, 528, 559, 563, 565, 566, 568, 569, 572, 583, 586, 589, 590, 591, 593, 595, 597, 600, 602, 603, 604, 607, 608, 612, 613, 614, 616, 617, 620, 621, 622, 623, 624, 625, 626, 627, 629, 630, 631, 632, 633, 634, 636, 637, 641, 642, 643, 644, 647, 648, 649, 650, 651, 652, 687, 690, 691, 692, 693, 833, 837, 840, 841, 842, 848, 849, 852, 853, 855]}, {"test_lines": [173, 179], "covered_lines": [26, 31, 35, 42, 51, 59, 63, 64, 65, 66, 67, 70, 71, 88, 89, 90, 93, 96, 97, 100, 106, 107, 108, 109, 110, 111, 112, 129, 134, 220, 222, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 237, 238, 239, 241, 242, 244, 264, 284, 287, 288, 291, 292, 294, 295, 296, 380, 381, 383, 384, 385, 387, 391, 394, 395, 396, 400, 401, 402, 403, 407, 408, 409, 412, 413, 414, 422, 424, 425, 426, 427, 428, 429, 432, 433, 434, 435, 436, 437, 439, 440, 441, 444, 448, 451, 454, 455, 456, 458, 461, 463, 464, 465, 466, 476, 477, 478, 479, 480, 481, 483, 484, 486, 487, 488, 490, 491, 494, 495, 497, 498, 499, 506, 507, 510, 511, 512, 514, 515, 516, 518, 519, 520, 521, 522, 523, 524, 526, 527, 528, 559, 560, 561, 563, 565, 566, 568, 569, 572, 576, 577, 583, 586, 589, 590, 591, 593, 595, 597, 600, 602, 603, 604, 607, 608, 612, 613, 614, 616, 617, 620, 621, 622, 623, 624, 625, 626, 627, 629, 630, 631, 632, 633, 634, 636, 637, 641, 642, 687, 690, 691, 695, 696, 697, 700, 701, 702, 705, 706, 707, 708, 709, 710, 711, 712, 718, 719, 723, 725, 730, 731, 736, 737, 738, 741, 744, 745, 748, 749, 750, 751, 752, 753, 755, 756, 757, 773, 774, 833, 837, 840, 841, 842, 848, 849, 852, 853, 855]}, {"test_lines": [181, 188], "covered_lines": [12, 26, 31, 35, 42]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/codec/brotli/dec/BitReader.java": {"class_content": ["/* Copyright 2015 Google Inc. All Rights Reserved.\n", "\n", "   Distributed under MIT license.\n", "   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n", "*/\n", "\n", "package com.itextpdf.io.codec.brotli.dec;\n", "\n", "import java.io.IOException;\n", "import java.io.InputStream;\n", "\n", "/**\n", " * Bit reading helpers.\n", " */\n", "final class BitReader {\n", "\n", "  /**\n", "   * Input byte buffer, consist of a ring-buffer and a \"slack\" region where bytes from the start of\n", "   * the ring-buffer are copied.\n", "   */\n", "  private static final int CAPACITY = 1024;\n", "  private static final int SLACK = 16;\n", "  private static final int INT_BUFFER_SIZE = CAPACITY + SLACK;\n", "  private static final int BYTE_READ_SIZE = CAPACITY << 2;\n", "  private static final int BYTE_BUFFER_SIZE = INT_BUFFER_SIZE << 2;\n", "\n", "  private final byte[] byteBuffer = new byte[BYTE_BUFFER_SIZE];\n", "  private final int[] intBuffer = new int[INT_BUFFER_SIZE];\n", "  private final IntReader intReader = new IntReader();\n", "\n", "  private InputStream input;\n", "\n", "  /**\n", "   * Input stream is finished.\n", "   */\n", "  private boolean endOfStreamReached;\n", "\n", "  /**\n", "   * Pre-fetched bits.\n", "   */\n", "  long accumulator;\n", "\n", "  /**\n", "   * Current bit-reading position in accumulator.\n", "   */\n", "  int bitOffset;\n", "\n", "  /**\n", "   * Offset of next item in intBuffer.\n", "   */\n", "  private int intOffset;\n", "\n", "  /* Number of bytes in unfinished \"int\" item. */\n", "  private int tailBytes = 0;\n", "\n", "  /**\n", "   * Fills up the input buffer.\n", "   *\n", "   * <p> No-op if there are at least 36 bytes present after current position.\n", "   *\n", "   * <p> After encountering the end of the input stream, 64 additional zero bytes are copied to the\n", "   * buffer.\n", "   */\n", "  // TODO: Split to check and read; move read outside of decoding loop.\n", "  static void readMoreInput(BitReader br) {\n", "    if (br.intOffset <= CAPACITY - 9) {\n", "      return;\n", "    }\n", "    if (br.endOfStreamReached) {\n", "      if (intAvailable(br) >= -2) {\n", "        return;\n", "      }\n", "      throw new BrotliRuntimeException(\"No more input\");\n", "    }\n", "    int readOffset = br.intOffset << 2;\n", "    int bytesRead = BYTE_READ_SIZE - readOffset;\n", "    System.arraycopy(br.byteBuffer, readOffset, br.byteBuffer, 0, bytesRead);\n", "    br.intOffset = 0;\n", "    try {\n", "      while (bytesRead < BYTE_READ_SIZE) {\n", "        int len = br.input.read(br.byteBuffer, bytesRead, BYTE_READ_SIZE - bytesRead);\n", "        // EOF is -1 in Java, but 0 in C#.\n", "        if (len <= 0) {\n", "          br.endOfStreamReached = true;\n", "          br.tailBytes = bytesRead;\n", "          bytesRead += 3;\n", "          break;\n", "        }\n", "        bytesRead += len;\n", "      }\n", "    } catch (IOException e) {\n", "      throw new BrotliRuntimeException(\"Failed to read input\", e);\n", "    }\n", "    IntReader.convert(br.intReader, bytesRead >> 2);\n", "  }\n", "\n", "  static void checkHealth(BitReader br, boolean endOfStream) {\n", "    if (!br.endOfStreamReached) {\n", "      return;\n", "    }\n", "    int byteOffset = (br.intOffset << 2) + ((br.bitOffset + 7) >> 3) - 8;\n", "    if (byteOffset > br.tailBytes) {\n", "      throw new BrotliRuntimeException(\"Read after end\");\n", "    }\n", "    if (endOfStream && (byteOffset != br.tailBytes)) {\n", "      throw new BrotliRuntimeException(\"Unused bytes after end\");\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Advances the Read buffer by 5 bytes to make room for reading next 24 bits.\n", "   */\n", "  static void fillBitWindow(BitReader br) {\n", "    if (br.bitOffset >= 32) {\n", "      br.accumulator = ((long) br.intBuffer[br.intOffset++] << 32) | (br.accumulator >>> 32);\n", "      br.bitOffset -= 32;\n", "    }\n", "  }\n", "\n", "  /**\n", "   * Reads the specified number of bits from Read Buffer.\n", "   */\n", "  static int readBits(BitReader br, int n) {\n", "    fillBitWindow(br);\n", "    int val = (int) (br.accumulator >>> br.bitOffset) & ((1 << n) - 1);\n", "    br.bitOffset += n;\n", "    return val;\n", "  }\n", "\n", "  /**\n", "   * Initialize bit reader.\n", "   *\n", "   * <p> Initialisation turns bit reader to a ready state. Also a number of bytes is prefetched to\n", "   * accumulator. Because of that this method may block until enough data could be read from input.\n", "   *\n", "   * @param br BitReader POJO\n", "   * @param input data source\n", "   */\n", "  static void init(BitReader br, InputStream input) {\n", "    if (br.input != null) {\n", "      throw new IllegalStateException(\"Bit reader already has associated input stream\");\n", "    }\n", "    IntReader.init(br.intReader, br.byteBuffer, br.intBuffer);\n", "    br.input = input;\n", "    br.accumulator = 0;\n", "    br.bitOffset = 64;\n", "    br.intOffset = CAPACITY;\n", "    br.endOfStreamReached = false;\n", "    prepare(br);\n", "  }\n", "\n", "  private static void prepare(BitReader br) {\n", "    readMoreInput(br);\n", "    checkHealth(br, false);\n", "    fillBitWindow(br);\n", "    fillBitWindow(br);\n", "  }\n", "\n", "  static void reload(BitReader br) {\n", "    if (br.bitOffset == 64) {\n", "      prepare(br);\n", "    }\n", "  }\n", "\n", "  static void close(BitReader br) throws IOException {\n", "    InputStream is = br.input;\n", "    br.input = null;\n", "    if (is != null) {\n", "      is.close();\n", "    }\n", "  }\n", "\n", "  static void jumpToByteBoundary(BitReader br) {\n", "    int padding = (64 - br.bitOffset) & 7;\n", "    if (padding != 0) {\n", "      int paddingBits = BitReader.readBits(br, padding);\n", "      if (paddingBits != 0) {\n", "        throw new BrotliRuntimeException(\"Corrupted padding bits\");\n", "      }\n", "    }\n", "  }\n", "\n", "  static int intAvailable(BitReader br) {\n", "    int limit = CAPACITY;\n", "    if (br.endOfStreamReached) {\n", "      limit = (br.tailBytes + 3) >> 2;\n", "    }\n", "    return limit - br.intOffset;\n", "  }\n", "\n", "  static void copyBytes(BitReader br, byte[] data, int offset, int length) {\n", "    if ((br.bitOffset & 7) != 0) {\n", "      throw new BrotliRuntimeException(\"Unaligned copyBytes\");\n", "    }\n", "\n", "    // Drain accumulator.\n", "    while ((br.bitOffset != 64) && (length != 0)) {\n", "      data[offset++] = (byte) (br.accumulator >>> br.bitOffset);\n", "      br.bitOffset += 8;\n", "      length--;\n", "    }\n", "    if (length == 0) {\n", "      return;\n", "    }\n", "\n", "    // Get data from shadow buffer with \"sizeof(int)\" granularity.\n", "    int copyInts = Math.min(intAvailable(br), length >> 2);\n", "    if (copyInts > 0) {\n", "      int readOffset = br.intOffset << 2;\n", "      System.arraycopy(br.byteBuffer, readOffset, data, offset, copyInts << 2);\n", "      offset += copyInts << 2;\n", "      length -= copyInts << 2;\n", "      br.intOffset += copyInts;\n", "    }\n", "    if (length == 0) {\n", "      return;\n", "    }\n", "\n", "    // Read tail bytes.\n", "    if (intAvailable(br) > 0) {\n", "      // length = 1..3\n", "      fillBitWindow(br);\n", "      while (length != 0) {\n", "        data[offset++] = (byte) (br.accumulator >>> br.bitOffset);\n", "        br.bitOffset += 8;\n", "        length--;\n", "      }\n", "      checkHealth(br, false);\n", "      return;\n", "    }\n", "\n", "    // Now it is possible to copy bytes directly.\n", "    try {\n", "      while (length > 0) {\n", "        int len = br.input.read(data, offset, length);\n", "        if (len == -1) {\n", "          throw new BrotliRuntimeException(\"Unexpected end of input\");\n", "        }\n", "        offset += len;\n", "        length -= len;\n", "      }\n", "    } catch (IOException e) {\n", "      throw new BrotliRuntimeException(\"Failed to read input\", e);\n", "    }\n", "  }\n", "}\n"], "test_content": ["/* Copyright 2015 Google Inc. All Rights Reserved.\n", "\n", "   Distributed under MIT license.\n", "   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n", "*/\n", "\n", "package com.itextpdf.io.codec.brotli.dec;\n", "\n", "import static org.junit.Assert.fail;\n", "\n", "import java.io.ByteArrayInputStream;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "/**\n", " * Tests for {@link BitReader}.\n", " */\n", "@Category(UnitTest.class)\n", "public class BitReaderTest extends ExtendedITextTest{\n", "\n", "  @Test\n", "  public void testReadAfterEos() {\n", "    BitReader reader = new BitReader();\n", "    BitReader.init(reader, new ByteArrayInputStream(new byte[1]));\n", "    BitReader.readBits(reader, 9);\n", "    try {\n", "      BitReader.checkHealth(reader, false);\n", "    } catch (BrotliRuntimeException ex) {\n", "      // This exception is expected.\n", "      return;\n", "    }\n", "    fail(\"BrotliRuntimeException should have been thrown by BitReader.checkHealth\");\n", "  }\n", "}\n"], "method_lines_dic": {"BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)": [65, 95], "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)": [97, 108], "BitReader::::fillBitWindow(com.itextpdf.io.codec.brotli.dec.BitReader)": [113, 118], "BitReader::::readBits(com.itextpdf.io.codec.brotli.dec.BitReader,int)": [123, 128], "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)": [139, 150], "BitReader::::prepare(com.itextpdf.io.codec.brotli.dec.BitReader)": [152, 157], "BitReader::::reload(com.itextpdf.io.codec.brotli.dec.BitReader)": [159, 163], "BitReader::::close(com.itextpdf.io.codec.brotli.dec.BitReader)": [165, 171], "BitReader::::jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader)": [173, 181], "BitReader::::intAvailable(com.itextpdf.io.codec.brotli.dec.BitReader)": [183, 189], "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)": [191, 245]}, "test_method_lines_dic": {"BitReaderTest::::testReadAfterEos()": [24, 36]}, "reverse_method_lines_dic": {"65": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "66": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "67": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "68": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "69": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "70": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "71": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "72": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "73": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "74": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "75": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "76": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "77": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "78": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "79": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "80": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "81": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "82": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "83": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "84": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "85": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "86": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "87": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "88": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "89": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "90": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "91": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "92": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "93": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "94": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "95": "BitReader::::readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader)", "97": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "98": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "99": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "100": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "101": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "102": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "103": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "104": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "105": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "106": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "107": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "108": "BitReader::::checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean)", "113": "BitReader::::fillBitWindow(com.itextpdf.io.codec.brotli.dec.BitReader)", "114": "BitReader::::fillBitWindow(com.itextpdf.io.codec.brotli.dec.BitReader)", "115": "BitReader::::fillBitWindow(com.itextpdf.io.codec.brotli.dec.BitReader)", "116": "BitReader::::fillBitWindow(com.itextpdf.io.codec.brotli.dec.BitReader)", "117": "BitReader::::fillBitWindow(com.itextpdf.io.codec.brotli.dec.BitReader)", "118": "BitReader::::fillBitWindow(com.itextpdf.io.codec.brotli.dec.BitReader)", "123": "BitReader::::readBits(com.itextpdf.io.codec.brotli.dec.BitReader,int)", "124": "BitReader::::readBits(com.itextpdf.io.codec.brotli.dec.BitReader,int)", "125": "BitReader::::readBits(com.itextpdf.io.codec.brotli.dec.BitReader,int)", "126": "BitReader::::readBits(com.itextpdf.io.codec.brotli.dec.BitReader,int)", "127": "BitReader::::readBits(com.itextpdf.io.codec.brotli.dec.BitReader,int)", "128": "BitReader::::readBits(com.itextpdf.io.codec.brotli.dec.BitReader,int)", "139": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "140": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "141": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "142": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "143": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "144": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "145": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "146": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "147": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "148": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "149": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "150": "BitReader::::init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream)", "152": "BitReader::::prepare(com.itextpdf.io.codec.brotli.dec.BitReader)", "153": "BitReader::::prepare(com.itextpdf.io.codec.brotli.dec.BitReader)", "154": "BitReader::::prepare(com.itextpdf.io.codec.brotli.dec.BitReader)", "155": "BitReader::::prepare(com.itextpdf.io.codec.brotli.dec.BitReader)", "156": "BitReader::::prepare(com.itextpdf.io.codec.brotli.dec.BitReader)", "157": "BitReader::::prepare(com.itextpdf.io.codec.brotli.dec.BitReader)", "159": "BitReader::::reload(com.itextpdf.io.codec.brotli.dec.BitReader)", "160": "BitReader::::reload(com.itextpdf.io.codec.brotli.dec.BitReader)", "161": "BitReader::::reload(com.itextpdf.io.codec.brotli.dec.BitReader)", "162": "BitReader::::reload(com.itextpdf.io.codec.brotli.dec.BitReader)", "163": "BitReader::::reload(com.itextpdf.io.codec.brotli.dec.BitReader)", "165": "BitReader::::close(com.itextpdf.io.codec.brotli.dec.BitReader)", "166": "BitReader::::close(com.itextpdf.io.codec.brotli.dec.BitReader)", "167": "BitReader::::close(com.itextpdf.io.codec.brotli.dec.BitReader)", "168": "BitReader::::close(com.itextpdf.io.codec.brotli.dec.BitReader)", "169": "BitReader::::close(com.itextpdf.io.codec.brotli.dec.BitReader)", "170": "BitReader::::close(com.itextpdf.io.codec.brotli.dec.BitReader)", "171": "BitReader::::close(com.itextpdf.io.codec.brotli.dec.BitReader)", "173": "BitReader::::jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader)", "174": "BitReader::::jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader)", "175": "BitReader::::jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader)", "176": "BitReader::::jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader)", "177": "BitReader::::jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader)", "178": "BitReader::::jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader)", "179": "BitReader::::jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader)", "180": "BitReader::::jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader)", "181": "BitReader::::jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader)", "183": "BitReader::::intAvailable(com.itextpdf.io.codec.brotli.dec.BitReader)", "184": "BitReader::::intAvailable(com.itextpdf.io.codec.brotli.dec.BitReader)", "185": "BitReader::::intAvailable(com.itextpdf.io.codec.brotli.dec.BitReader)", "186": "BitReader::::intAvailable(com.itextpdf.io.codec.brotli.dec.BitReader)", "187": "BitReader::::intAvailable(com.itextpdf.io.codec.brotli.dec.BitReader)", "188": "BitReader::::intAvailable(com.itextpdf.io.codec.brotli.dec.BitReader)", "189": "BitReader::::intAvailable(com.itextpdf.io.codec.brotli.dec.BitReader)", "191": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "192": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "193": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "194": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "195": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "196": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "197": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "198": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "199": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "200": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "201": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "202": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "203": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "204": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "205": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "206": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "207": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "208": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "209": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "210": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "211": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "212": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "213": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "214": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "215": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "216": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "217": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "218": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "219": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "220": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "221": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "222": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "223": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "224": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "225": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "226": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "227": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "228": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "229": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "230": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "231": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "232": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "233": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "234": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "235": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "236": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "237": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "238": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "239": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "240": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "241": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "242": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "243": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "244": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)", "245": "BitReader::::copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int)"}, "test_reverse_method_lines_dic": {"24": "BitReaderTest::::testReadAfterEos()", "25": "BitReaderTest::::testReadAfterEos()", "26": "BitReaderTest::::testReadAfterEos()", "27": "BitReaderTest::::testReadAfterEos()", "28": "BitReaderTest::::testReadAfterEos()", "29": "BitReaderTest::::testReadAfterEos()", "30": "BitReaderTest::::testReadAfterEos()", "31": "BitReaderTest::::testReadAfterEos()", "32": "BitReaderTest::::testReadAfterEos()", "33": "BitReaderTest::::testReadAfterEos()", "34": "BitReaderTest::::testReadAfterEos()", "35": "BitReaderTest::::testReadAfterEos()", "36": "BitReaderTest::::testReadAfterEos()"}, "tests": [{"test_lines": [24, 36], "covered_lines": [15, 27, 28, 29, 54, 66, 69, 75, 76, 77, 78, 80, 81, 83, 84, 85, 86, 87, 89, 90, 93, 94, 95, 98, 101, 102, 103, 105, 108, 114, 115, 116, 118, 124, 125, 126, 127, 140, 143, 144, 145, 146, 147, 148, 149, 150, 153, 154, 155, 156, 157]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/codec/brotli/dec/Dictionary.java": {"class_content": ["/* Copyright 2015 Google Inc. All Rights Reserved.\n", "\n", "   Distributed under MIT license.\n", "   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n", "*/\n", "\n", "package com.itextpdf.io.codec.brotli.dec;\n", "\n", "import java.nio.ByteBuffer;\n", "\n", "/**\n", " * Collection of static dictionary words.\n", " *\n", " * <p>Dictionary content is loaded from binary resource when {@link #getData()} is executed for the\n", " * first time. Consequently, it saves memory and CPU in case dictionary is not required.\n", " *\n", " * <p>One possible drawback is that multiple threads that need dictionary data may be blocked (only\n", " * once in each classworld). To avoid this, it is enough to call {@link #getData()} proactively.\n", " */\n", "public final class Dictionary {\n", "  private static volatile ByteBuffer data;\n", "\n", "  private static class DataLoader {\n", "    static final boolean OK;\n", "\n", "    static {\n", "      boolean ok = true;\n", "      try {\n", "        Class.forName(Dictionary.class.getPackage().getName() + \".DictionaryData\");\n", "      } catch (Throwable ex) {\n", "        ok = false;\n", "      }\n", "      OK = ok;\n", "    }\n", "  }\n", "\n", "  public static void setData(ByteBuffer data) {\n", "    Dictionary.data = data;\n", "  }\n", "\n", "  public static ByteBuffer getData() {\n", "    if (data != null) {\n", "      return data;\n", "    }\n", "    if (!DataLoader.OK) {\n", "      throw new BrotliRuntimeException(\"brotli dictionary is not set\");\n", "    }\n", "    /* Might have been set when {@link DictionaryData} was loaded.*/\n", "    return data;\n", "  }\n", "\n", "  static final int[] OFFSETS_BY_LENGTH = {\n", "    0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032, 53248, 63488, 74752, 87040, 93696, 100864,\n", "    104704, 106752, 108928, 113536, 115968, 118528, 119872, 121280, 122016\n", "  };\n", "\n", "  static final int[] SIZE_BITS_BY_LENGTH = {\n", "    0, 0, 0, 0, 10, 10, 11, 11, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7, 8, 7, 7, 6, 6, 5, 5\n", "  };\n", "\n", "  static final int MIN_WORD_LENGTH = 4;\n", "\n", "  static final int MAX_WORD_LENGTH = 24;\n", "\n", "  static final int MAX_TRANSFORMED_WORD_LENGTH = 5 + MAX_WORD_LENGTH + 8;\n", "}\n"], "test_content": ["/* Copyright 2015 Google Inc. All Rights Reserved.\n", "\n", "   Distributed under MIT license.\n", "   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n", "*/\n", "\n", "package com.itextpdf.io.codec.brotli.dec;\n", "\n", "import static org.junit.Assert.assertEquals;\n", "\n", "import java.nio.ByteBuffer;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "import org.junit.runner.RunWith;\n", "import org.junit.runners.JUnit4;\n", "\n", "/**\n", " * Tests for {@link Dictionary}.\n", " */\n", "@Category(UnitTest.class)\n", "@RunWith(JUnit4.class)\n", "public class DictionaryTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void testGetData() {\n", "        assertEquals(37084801881332636L, crc64(Dictionary.getData()));\n", "    }\n", "\n", "    private static long crc64(ByteBuffer data) {\n", "        long crc = -1;\n", "        for (int i = 0; i < data.capacity(); ++i) {\n", "            long c = (crc ^ (long) (data.get(i) & 0xFF)) & 0xFF;\n", "            for (int k = 0; k < 8; k++) {\n", "                c = (c >>> 1) ^ (-(c & 1L) & -3932672073523589310L);\n", "            }\n", "            crc = c ^ (crc >>> 8);\n", "        }\n", "        return ~crc;\n", "    }\n", "}"], "method_lines_dic": {"Dictionary::::setData(java.nio.ByteBuffer)": [37, 39], "Dictionary::::getData()": [41, 50]}, "test_method_lines_dic": {"DictionaryTest::::testGetData()": [28, 31], "DictionaryTest::::crc64(java.nio.ByteBuffer)": [33, 43]}, "reverse_method_lines_dic": {"37": "Dictionary::::setData(java.nio.ByteBuffer)", "38": "Dictionary::::setData(java.nio.ByteBuffer)", "39": "Dictionary::::setData(java.nio.ByteBuffer)", "41": "Dictionary::::getData()", "42": "Dictionary::::getData()", "43": "Dictionary::::getData()", "44": "Dictionary::::getData()", "45": "Dictionary::::getData()", "46": "Dictionary::::getData()", "47": "Dictionary::::getData()", "48": "Dictionary::::getData()", "49": "Dictionary::::getData()", "50": "Dictionary::::getData()"}, "test_reverse_method_lines_dic": {"28": "DictionaryTest::::testGetData()", "29": "DictionaryTest::::testGetData()", "30": "DictionaryTest::::testGetData()", "31": "DictionaryTest::::testGetData()", "33": "DictionaryTest::::crc64(java.nio.ByteBuffer)", "34": "DictionaryTest::::crc64(java.nio.ByteBuffer)", "35": "DictionaryTest::::crc64(java.nio.ByteBuffer)", "36": "DictionaryTest::::crc64(java.nio.ByteBuffer)", "37": "DictionaryTest::::crc64(java.nio.ByteBuffer)", "38": "DictionaryTest::::crc64(java.nio.ByteBuffer)", "39": "DictionaryTest::::crc64(java.nio.ByteBuffer)", "40": "DictionaryTest::::crc64(java.nio.ByteBuffer)", "41": "DictionaryTest::::crc64(java.nio.ByteBuffer)", "42": "DictionaryTest::::crc64(java.nio.ByteBuffer)", "43": "DictionaryTest::::crc64(java.nio.ByteBuffer)"}, "tests": [{"test_lines": [28, 31], "covered_lines": [27, 29, 32, 33, 34, 38, 39, 42, 45, 49, 52, 57]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/util/IntHashtable.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "\n", "import java.util.Arrays;\n", "\n", "/**\n", " * A hash map that uses primitive ints for the key rather than objects.\n", " * <p>\n", " * Note that this class is for internal optimization purposes only, and may\n", " * not be supported in future releases of Jakarta Commons Lang.  Utilities of\n", " * this sort may be included in future releases of Jakarta Commons Collections.\n", " */\n", "public class IntHashtable implements Cloneable {\n", "\n", "\n", "    /***\n", "     * The total number of entries in the hash table.\n", "     */\n", "    int count;\n", "\n", "    /***\n", "     * The hash table data.\n", "     */\n", "    private Entry[] table;\n", "\n", "    /***\n", "     * The table is rehashed when its size exceeds this threshold.  (The\n", "     * value of this field is (int)(capacity * loadFactor).)\n", "     *\n", "     * @serial\n", "     */\n", "    private int threshold;\n", "\n", "    /***\n", "     * The load factor for the hashtable.\n", "     *\n", "     * @serial\n", "     */\n", "    private float loadFactor;\n", "\n", "    /***\n", "     * Constructs a new, empty hashtable with a default capacity and load\n", "     * factor, which is <code>20</code> and <code>0.75</code> respectively.\n", "     */\n", "    public IntHashtable() {\n", "        this(150, 0.75f);\n", "    }\n", "\n", "    /***\n", "     * Constructs a new, empty hashtable with the specified initial capacity\n", "     * and default load factor, which is <code>0.75</code>.\n", "     *\n", "     * @param  initialCapacity the initial capacity of the hashtable.\n", "     * @throws IllegalArgumentException if the initial capacity is less\n", "     *   than zero.\n", "     */\n", "    public IntHashtable(int initialCapacity) {\n", "        this(initialCapacity, 0.75f);\n", "    }\n", "\n", "    /***\n", "     * Constructs a new, empty hashtable with the specified initial\n", "     * capacity and the specified load factor.\n", "     *\n", "     * @param initialCapacity the initial capacity of the hashtable.\n", "     * @param loadFactor the load factor of the hashtable.\n", "     * @throws IllegalArgumentException  if the initial capacity is less\n", "     *             than zero, or if the load factor is nonpositive.\n", "     */\n", "    public IntHashtable(int initialCapacity, float loadFactor) {\n", "        if (initialCapacity < 0) {\n", "            throw new IllegalArgumentException(MessageFormatUtil.format(\"Illegal Capacity: {0}\", initialCapacity));\n", "        }\n", "        if (loadFactor <= 0) {\n", "            throw new IllegalArgumentException(MessageFormatUtil.format(\"Illegal Load: {0}\", loadFactor));\n", "        }\n", "        if (initialCapacity == 0) {\n", "            initialCapacity = 1;\n", "        }\n", "        this.loadFactor = loadFactor;\n", "        table = new Entry[initialCapacity];\n", "        threshold = (int) (initialCapacity * loadFactor);\n", "    }\n", "\n", "    public IntHashtable(IntHashtable o) {\n", "        this(o.table.length, o.loadFactor);\n", "    }\n", "\n", "    /***\n", "     * Returns the number of keys in this hashtable.\n", "     *\n", "     * @return  the number of keys in this hashtable.\n", "     */\n", "    public int size() {\n", "        return count;\n", "    }\n", "\n", "    /***\n", "     * Tests if this hashtable maps no keys to values.\n", "     *\n", "     * @return  <code>true</code> if this hashtable maps no keys to values;\n", "     *          <code>false</code> otherwise.\n", "     */\n", "    public boolean isEmpty() {\n", "        return count == 0;\n", "    }\n", "\n", "    /***\n", "     * Tests if some key maps into the specified value in this hashtable.\n", "     * This operation is more expensive than the <code>containsKey</code>\n", "     * method.\n", "     * <p>\n", "     * Note that this method is identical in functionality to containsValue,\n", "     * (which is part of the Map interface in the collections framework).\n", "     *\n", "     * @param      value   a value to search for.\n", "     * @return     <code>true</code> if and only if some key maps to the\n", "     *             <code>value</code> argument in this hashtable as\n", "     *             determined by the <tt>equals</tt> method;\n", "     *             <code>false</code> otherwise.\n", "     * @throws  NullPointerException  if the value is <code>null</code>.\n", "     * @see        #containsKey(int)\n", "     * @see        #containsValue(int)\n", "     * @see        java.util.Map\n", "     */\n", "    public boolean contains(int value) {\n", "\n", "        Entry[] tab = table;\n", "        for (int i = tab.length; i-- > 0;) {\n", "            for (Entry e = tab[i]; e != null; e = e.next) {\n", "                if (e.value == value) {\n", "                    return true;\n", "                }\n", "            }\n", "        }\n", "        return false;\n", "    }\n", "\n", "    /***\n", "     * Returns <code>true</code> if this HashMap maps one or more keys\n", "     * to this value.\n", "     * <p>\n", "     * Note that this method is identical in functionality to contains\n", "     * (which predates the Map interface).\n", "     *\n", "     * @param value value whose presence in this HashMap is to be tested.\n", "     * @return boolean <code>true</code> if the value is contained\n", "     * @see    java.util.Map\n", "     */\n", "    public boolean containsValue(int value) {\n", "        return contains(value);\n", "    }\n", "\n", "    /***\n", "     * Tests if the specified int is a key in this hashtable.\n", "     *\n", "     * @param  key  possible key.\n", "     * @return <code>true</code> if and only if the specified int is a\n", "     *    key in this hashtable, as determined by the <tt>equals</tt>\n", "     *    method; <code>false</code> otherwise.\n", "     * @see #contains(int)\n", "     */\n", "    public boolean containsKey(int key) {\n", "        Entry[] tab = table;\n", "        int index = (key & 0x7FFFFFFF) % tab.length;\n", "        for (Entry e = tab[index]; e != null; e = e.next) {\n", "            if (e.key == key) {\n", "                return true;\n", "            }\n", "        }\n", "        return false;\n", "    }\n", "\n", "    /***\n", "     * Returns the value to which the specified key is mapped in this map.\n", "     *\n", "     * @param   key   a key in the hashtable.\n", "     * @return  the value to which the key is mapped in this hashtable;\n", "     *          0 if the key is not mapped to any value in\n", "     *          this hashtable.\n", "     * @see     #put(int, int)\n", "     */\n", "    public int get(int key) {\n", "        Entry[] tab = table;\n", "        int index = (key & 0x7FFFFFFF) % tab.length;\n", "        for (Entry e = tab[index]; e != null; e = e.next) {\n", "            if (e.key == key) {\n", "                return e.value;\n", "            }\n", "        }\n", "        return 0;\n", "    }\n", "\n", "    /***\n", "     * Returns thes value to which the specified key is mapped in this map.\n", "     *\n", "     * @param   key   a key in the hashtable.\n", "     * @return  the values to which the key is mapped in this hashtable;\n", "     *          <code>null</code> if the key is not mapped to any value in\n", "     *          this hashtable.\n", "     * @see     #put(int, int)\n", "    public ArrayList<Integer> getValues(int key) {\n", "    Entry[] tab = table;\n", "    int index = (key & 0x7FFFFFFF) % tab.length;\n", "    for (Entry e = tab[index]; e != null; e = e.next) {\n", "    if (e.key == key) {\n", "    return e.values;\n", "    }\n", "    }\n", "    return null;\n", "    }\n", "     */\n", "\n", "    /***\n", "     * Increases the capacity of and internally reorganizes this\n", "     * hashtable, in order to accommodate and access its entries more\n", "     * efficiently.\n", "     * <p>\n", "     * This method is called automatically when the number of keys\n", "     * in the hashtable exceeds this hashtable's capacity and load\n", "     * factor.\n", "     */\n", "    protected void rehash() {\n", "        int oldCapacity = table.length;\n", "        Entry[] oldMap = table;\n", "\n", "        int newCapacity = oldCapacity * 2 + 1;\n", "        Entry[] newMap = new Entry[newCapacity];\n", "\n", "        threshold = (int) (newCapacity * loadFactor);\n", "        table = newMap;\n", "\n", "        for (int i = oldCapacity; i-- > 0;) {\n", "            for (Entry old = oldMap[i]; old != null;) {\n", "                Entry e = old;\n", "                old = old.next;\n", "\n", "                int index = (e.key & 0x7FFFFFFF) % newCapacity;\n", "                e.next = newMap[index];\n", "                newMap[index] = e;\n", "            }\n", "        }\n", "    }\n", "\n", "    /***\n", "     * Maps the specified <code>key</code> to the specified\n", "     * <code>value</code> in this hashtable. The key cannot be\n", "     * <code>null</code>.\n", "     * <p>\n", "     * The value can be retrieved by calling the <code>get</code> method\n", "     * with a key that is equal to the original key.\n", "     *\n", "     * @param key     the hashtable key.\n", "     * @param value   the value.\n", "     * @return the previous value of the specified key in this hashtable,\n", "     *         or <code>null</code> if it did not have one.\n", "     * @throws  NullPointerException  if the key is <code>null</code>.\n", "     * @see     #get(int)\n", "     */\n", "    public int put(int key, int value) {\n", "        // Makes sure the key is not already in the hashtable.\n", "        Entry[] tab = table;\n", "        int index = (key & 0x7FFFFFFF) % tab.length;\n", "        for (Entry e = tab[index]; e != null; e = e.next) {\n", "            if (e.key == key) {\n", "                int old = e.value;\n", "                //e.addValue(old);\n", "                e.value = value;\n", "                return old;\n", "            }\n", "        }\n", "\n", "        if (count >= threshold) {\n", "            // Rehash the table if the threshold is exceeded\n", "            rehash();\n", "\n", "            tab = table;\n", "            index = (key & 0x7FFFFFFF) % tab.length;\n", "        }\n", "\n", "        // Creates the new entry.\n", "        Entry e = new Entry(key, value, tab[index]);\n", "        tab[index] = e;\n", "        count++;\n", "        return 0;\n", "    }\n", "\n", "    /***\n", "     * Removes the key (and its corresponding value) from this\n", "     * hashtable.\n", "     * <p>\n", "     * This method does nothing if the key is not present in the\n", "     * hashtable.\n", "     *\n", "     * @param   key   the key that needs to be removed.\n", "     * @return  the value to which the key had been mapped in this hashtable,\n", "     *          or <code>null</code> if the key did not have a mapping.\n", "     */\n", "    public int remove(int key) {\n", "        Entry[] tab = table;\n", "        int index = (key & 0x7FFFFFFF) % tab.length;\n", "        Entry e;\n", "        Entry prev;\n", "        for (e = tab[index], prev = null; e != null; prev = e, e = e.next) {\n", "            if (e.key == key) {\n", "                if (prev != null) {\n", "                    prev.next = e.next;\n", "                } else {\n", "                    tab[index] = e.next;\n", "                }\n", "                count--;\n", "                int oldValue = e.value;\n", "                e.value = 0;\n", "                return oldValue;\n", "            }\n", "        }\n", "        return 0;\n", "    }\n", "\n", "    /***\n", "     * Clears this hashtable so that it contains no keys.\n", "     */\n", "    public void clear() {\n", "        Entry[] tab = table;\n", "        for (int index = tab.length; --index >= 0;) {\n", "            tab[index] = null;\n", "        }\n", "        count = 0;\n", "    }\n", "\n", "    /***\n", "     * Innerclass that acts as a datastructure to create a new entry in the\n", "     * table.\n", "     */\n", "    public static class Entry {\n", "        int key;\n", "        int value;\n", "        //ArrayList<Integer> values = new ArrayList<Integer>();\n", "        Entry next;\n", "\n", "        /**\n", "         * Create a new entry with the given values.\n", "         *\n", "         * @param key The key used to enter this in the table\n", "         * @param value The value for this key\n", "         * @param next A reference to the next entry in the table\n", "         */\n", "        Entry(int key, int value, Entry next) {\n", "            this.key = key;\n", "            this.value = value;\n", "            this.next = next;\n", "            //values.add(value);\n", "        }\n", "\n", "        // extra methods for inner class Entry by Paulo\n", "        public int getKey() {\n", "            return key;\n", "        }\n", "\n", "        public int getValue() {\n", "            return value;\n", "        }\n", "\n", "        @Override\n", "        protected Object clone() {\n", "            return new Entry(key, value, next != null ? (Entry)next.clone() : null);\n", "        }\n", "\n", "        @Override\n", "        public String toString() {\n", "            return MessageFormatUtil.format(\"{0}={1}\", key, value);\n", "        }\n", "    }\n", "\n", "    public int[] toOrderedKeys() {\n", "        int[] res = getKeys();\n", "        Arrays.sort(res);\n", "        return res;\n", "    }\n", "\n", "    public int[] getKeys() {\n", "        int[] res = new int[count];\n", "        int ptr = 0;\n", "        int index = table.length;\n", "        Entry entry = null;\n", "        while (true) {\n", "            if (entry == null)\n", "                while (index-- > 0 && (entry = table[index]) == null);\n", "            if (entry == null)\n", "                break;\n", "            Entry e = entry;\n", "            entry = e.next;\n", "            res[ptr++] = e.key;\n", "        }\n", "        return res;\n", "    }\n", "\n", "    public int getOneKey() {\n", "        if (count == 0)\n", "            return 0;\n", "        int index = table.length;\n", "        Entry entry = null;\n", "        while (index-- > 0 && (entry = table[index]) == null);\n", "        if (entry == null)\n", "            return 0;\n", "        return entry.key;\n", "    }\n", "\n", "    @Override\n", "    public Object clone() {\n", "        IntHashtable t = new IntHashtable(this);\n", "        t.table = new Entry[table.length];\n", "        for (int i = table.length ; i-- > 0 ; ) {\n", "            t.table[i] = table[i] != null\n", "                    ? (Entry)table[i].clone() : null;\n", "        }\n", "        t.count = count;\n", "        return t;\n", "    }\n", "}\n", "\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class IntHashtableTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void cloneTest() throws CloneNotSupportedException {\n", "        IntHashtable hashtable = fillTable();\n", "        IntHashtable clonedTable = (IntHashtable) hashtable.clone();\n", "        int[] keysArray = hashtable.getKeys();\n", "        int[] clonedKeysArray = clonedTable.getKeys();\n", "        Assert.assertEquals(keysArray.length, clonedKeysArray.length);\n", "        for (int i = 0; i < keysArray.length; i++) {\n", "            Assert.assertEquals(keysArray[i], clonedKeysArray[i]);\n", "            Assert.assertEquals(hashtable.get(keysArray[i]), clonedTable.get(clonedKeysArray[i]));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void countIsEqualTest() throws CloneNotSupportedException {\n", "        IntHashtable hashtable = fillTable();\n", "        IntHashtable clonedTable = (IntHashtable) hashtable.clone();\n", "        Assert.assertEquals(hashtable.count, clonedTable.count);\n", "    }\n", "\n", "    private static IntHashtable fillTable() {\n", "        IntHashtable hashtable = new IntHashtable();\n", "        hashtable.put(1, 0);\n", "        hashtable.put(0, 1);\n", "        hashtable.put(-1, 2);\n", "        hashtable.put(2, -1);\n", "        return hashtable;\n", "    }\n", "}\n"], "method_lines_dic": {"IntHashtable::::size()": [117, 119], "IntHashtable::::isEmpty()": [127, 129], "IntHashtable::::contains(int)": [149, 160], "IntHashtable::::containsValue(int)": [173, 175], "IntHashtable::::containsKey(int)": [186, 195], "IntHashtable::::get(int)": [206, 215], "IntHashtable::::rehash()": [246, 266], "IntHashtable::::put(int,int)": [283, 309], "IntHashtable::::remove(int)": [322, 341], "IntHashtable::::clear()": [346, 352], "IntHashtable.Entry::::getKey()": [379, 381], "IntHashtable.Entry::::getValue()": [383, 385], "IntHashtable.Entry::::clone()": [387, 390], "IntHashtable.Entry::::toString()": [392, 395], "IntHashtable::::toOrderedKeys()": [398, 402], "IntHashtable::::getKeys()": [404, 419], "IntHashtable::::getOneKey()": [421, 430], "IntHashtable::::clone()": [432, 442]}, "test_method_lines_dic": {"IntHashtableTest::::cloneTest()": [35, 46], "IntHashtableTest::::countIsEqualTest()": [48, 53], "IntHashtableTest::::fillTable()": [55, 62]}, "reverse_method_lines_dic": {"117": "IntHashtable::::size()", "118": "IntHashtable::::size()", "119": "IntHashtable::::size()", "127": "IntHashtable::::isEmpty()", "128": "IntHashtable::::isEmpty()", "129": "IntHashtable::::isEmpty()", "149": "IntHashtable::::contains(int)", "150": "IntHashtable::::contains(int)", "151": "IntHashtable::::contains(int)", "152": "IntHashtable::::contains(int)", "153": "IntHashtable::::contains(int)", "154": "IntHashtable::::contains(int)", "155": "IntHashtable::::contains(int)", "156": "IntHashtable::::contains(int)", "157": "IntHashtable::::contains(int)", "158": "IntHashtable::::contains(int)", "159": "IntHashtable::::contains(int)", "160": "IntHashtable::::contains(int)", "173": "IntHashtable::::containsValue(int)", "174": "IntHashtable::::containsValue(int)", "175": "IntHashtable::::containsValue(int)", "186": "IntHashtable::::containsKey(int)", "187": "IntHashtable::::containsKey(int)", "188": "IntHashtable::::containsKey(int)", "189": "IntHashtable::::containsKey(int)", "190": "IntHashtable::::containsKey(int)", "191": "IntHashtable::::containsKey(int)", "192": "IntHashtable::::containsKey(int)", "193": "IntHashtable::::containsKey(int)", "194": "IntHashtable::::containsKey(int)", "195": "IntHashtable::::containsKey(int)", "206": "IntHashtable::::get(int)", "207": "IntHashtable::::get(int)", "208": "IntHashtable::::get(int)", "209": "IntHashtable::::get(int)", "210": "IntHashtable::::get(int)", "211": "IntHashtable::::get(int)", "212": "IntHashtable::::get(int)", "213": "IntHashtable::::get(int)", "214": "IntHashtable::::get(int)", "215": "IntHashtable::::get(int)", "246": "IntHashtable::::rehash()", "247": "IntHashtable::::rehash()", "248": "IntHashtable::::rehash()", "249": "IntHashtable::::rehash()", "250": "IntHashtable::::rehash()", "251": "IntHashtable::::rehash()", "252": "IntHashtable::::rehash()", "253": "IntHashtable::::rehash()", "254": "IntHashtable::::rehash()", "255": "IntHashtable::::rehash()", "256": "IntHashtable::::rehash()", "257": "IntHashtable::::rehash()", "258": "IntHashtable::::rehash()", "259": "IntHashtable::::rehash()", "260": "IntHashtable::::rehash()", "261": "IntHashtable::::rehash()", "262": "IntHashtable::::rehash()", "263": "IntHashtable::::rehash()", "264": "IntHashtable::::rehash()", "265": "IntHashtable::::rehash()", "266": "IntHashtable::::rehash()", "283": "IntHashtable::::put(int,int)", "284": "IntHashtable::::put(int,int)", "285": "IntHashtable::::put(int,int)", "286": "IntHashtable::::put(int,int)", "287": "IntHashtable::::put(int,int)", "288": "IntHashtable::::put(int,int)", "289": "IntHashtable::::put(int,int)", "290": "IntHashtable::::put(int,int)", "291": "IntHashtable::::put(int,int)", "292": "IntHashtable::::put(int,int)", "293": "IntHashtable::::put(int,int)", "294": "IntHashtable::::put(int,int)", "295": "IntHashtable::::put(int,int)", "296": "IntHashtable::::put(int,int)", "297": "IntHashtable::::put(int,int)", "298": "IntHashtable::::put(int,int)", "299": "IntHashtable::::put(int,int)", "300": "IntHashtable::::put(int,int)", "301": "IntHashtable::::put(int,int)", "302": "IntHashtable::::put(int,int)", "303": "IntHashtable::::put(int,int)", "304": "IntHashtable::::put(int,int)", "305": "IntHashtable::::put(int,int)", "306": "IntHashtable::::put(int,int)", "307": "IntHashtable::::put(int,int)", "308": "IntHashtable::::put(int,int)", "309": "IntHashtable::::put(int,int)", "322": "IntHashtable::::remove(int)", "323": "IntHashtable::::remove(int)", "324": "IntHashtable::::remove(int)", "325": "IntHashtable::::remove(int)", "326": "IntHashtable::::remove(int)", "327": "IntHashtable::::remove(int)", "328": "IntHashtable::::remove(int)", "329": "IntHashtable::::remove(int)", "330": "IntHashtable::::remove(int)", "331": "IntHashtable::::remove(int)", "332": "IntHashtable::::remove(int)", "333": "IntHashtable::::remove(int)", "334": "IntHashtable::::remove(int)", "335": "IntHashtable::::remove(int)", "336": "IntHashtable::::remove(int)", "337": "IntHashtable::::remove(int)", "338": "IntHashtable::::remove(int)", "339": "IntHashtable::::remove(int)", "340": "IntHashtable::::remove(int)", "341": "IntHashtable::::remove(int)", "346": "IntHashtable::::clear()", "347": "IntHashtable::::clear()", "348": "IntHashtable::::clear()", "349": "IntHashtable::::clear()", "350": "IntHashtable::::clear()", "351": "IntHashtable::::clear()", "352": "IntHashtable::::clear()", "379": "IntHashtable.Entry::::getKey()", "380": "IntHashtable.Entry::::getKey()", "381": "IntHashtable.Entry::::getKey()", "383": "IntHashtable.Entry::::getValue()", "384": "IntHashtable.Entry::::getValue()", "385": "IntHashtable.Entry::::getValue()", "387": "IntHashtable.Entry::::clone()", "388": "IntHashtable.Entry::::clone()", "389": "IntHashtable.Entry::::clone()", "390": "IntHashtable.Entry::::clone()", "392": "IntHashtable.Entry::::toString()", "393": "IntHashtable.Entry::::toString()", "394": "IntHashtable.Entry::::toString()", "395": "IntHashtable.Entry::::toString()", "398": "IntHashtable::::toOrderedKeys()", "399": "IntHashtable::::toOrderedKeys()", "400": "IntHashtable::::toOrderedKeys()", "401": "IntHashtable::::toOrderedKeys()", "402": "IntHashtable::::toOrderedKeys()", "404": "IntHashtable::::getKeys()", "405": "IntHashtable::::getKeys()", "406": "IntHashtable::::getKeys()", "407": "IntHashtable::::getKeys()", "408": "IntHashtable::::getKeys()", "409": "IntHashtable::::getKeys()", "410": "IntHashtable::::getKeys()", "411": "IntHashtable::::getKeys()", "412": "IntHashtable::::getKeys()", "413": "IntHashtable::::getKeys()", "414": "IntHashtable::::getKeys()", "415": "IntHashtable::::getKeys()", "416": "IntHashtable::::getKeys()", "417": "IntHashtable::::getKeys()", "418": "IntHashtable::::getKeys()", "419": "IntHashtable::::getKeys()", "421": "IntHashtable::::getOneKey()", "422": "IntHashtable::::getOneKey()", "423": "IntHashtable::::getOneKey()", "424": "IntHashtable::::getOneKey()", "425": "IntHashtable::::getOneKey()", "426": "IntHashtable::::getOneKey()", "427": "IntHashtable::::getOneKey()", "428": "IntHashtable::::getOneKey()", "429": "IntHashtable::::getOneKey()", "430": "IntHashtable::::getOneKey()", "432": "IntHashtable::::clone()", "433": "IntHashtable::::clone()", "434": "IntHashtable::::clone()", "435": "IntHashtable::::clone()", "436": "IntHashtable::::clone()", "437": "IntHashtable::::clone()", "438": "IntHashtable::::clone()", "439": "IntHashtable::::clone()", "440": "IntHashtable::::clone()", "441": "IntHashtable::::clone()", "442": "IntHashtable::::clone()"}, "test_reverse_method_lines_dic": {"35": "IntHashtableTest::::cloneTest()", "36": "IntHashtableTest::::cloneTest()", "37": "IntHashtableTest::::cloneTest()", "38": "IntHashtableTest::::cloneTest()", "39": "IntHashtableTest::::cloneTest()", "40": "IntHashtableTest::::cloneTest()", "41": "IntHashtableTest::::cloneTest()", "42": "IntHashtableTest::::cloneTest()", "43": "IntHashtableTest::::cloneTest()", "44": "IntHashtableTest::::cloneTest()", "45": "IntHashtableTest::::cloneTest()", "46": "IntHashtableTest::::cloneTest()", "48": "IntHashtableTest::::countIsEqualTest()", "49": "IntHashtableTest::::countIsEqualTest()", "50": "IntHashtableTest::::countIsEqualTest()", "51": "IntHashtableTest::::countIsEqualTest()", "52": "IntHashtableTest::::countIsEqualTest()", "53": "IntHashtableTest::::countIsEqualTest()", "55": "IntHashtableTest::::fillTable()", "56": "IntHashtableTest::::fillTable()", "57": "IntHashtableTest::::fillTable()", "58": "IntHashtableTest::::fillTable()", "59": "IntHashtableTest::::fillTable()", "60": "IntHashtableTest::::fillTable()", "61": "IntHashtableTest::::fillTable()", "62": "IntHashtableTest::::fillTable()"}, "tests": [{"test_lines": [35, 46], "covered_lines": [69, 70, 93, 94, 97, 100, 103, 104, 105, 106, 109, 110, 207, 208, 209, 210, 211, 285, 286, 287, 296, 305, 306, 307, 308, 371, 372, 373, 374, 376, 389, 405, 406, 407, 408, 410, 411, 412, 413, 414, 415, 416, 417, 418, 434, 435, 436, 437, 438, 440, 441]}, {"test_lines": [48, 53], "covered_lines": [69, 70, 93, 94, 97, 100, 103, 104, 105, 106, 109, 110, 285, 286, 287, 296, 305, 306, 307, 308, 371, 372, 373, 374, 376, 389, 434, 435, 436, 437, 438, 440, 441]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/util/EnumUtil.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import java.util.Arrays;\n", "import java.util.List;\n", "\n", "/**\n", " * This file is a helper class for internal usage only.\n", " * Be aware that its API and functionality may be changed in future.\n", " */\n", "public final class EnumUtil {\n", "    private EnumUtil() {\n", "    }\n", "\n", "    public static <T extends Enum<T>> T throwIfNull(T enumInstance) {\n", "        if (enumInstance == null) {\n", "            throw new RuntimeException(\"Expected not null enum instance\");\n", "        }\n", "        return enumInstance;\n", "    }\n", "\n", "    public static <T extends Enum<T>> List<T> getAllValuesOfEnum(Class<T> enumInstance) {\n", "        if (enumInstance == null) {\n", "            throw new RuntimeException(\"Expected not null enum instance\");\n", "        }\n", "        return Arrays.asList(enumInstance.getEnumConstants());\n", "    }\n", "\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.util.List;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class EnumUtilTest extends ExtendedITextTest {\n", "    @Test\n", "    public void testEnumUtilSameAmount() {\n", "        Assert.assertEquals(3, EnumUtil.getAllValuesOfEnum(TestEnum1.class).size());\n", "    }\n", "\n", "    @Test\n", "    public void testEnumUtilSameValues() {\n", "        List<TestEnum1> list = EnumUtil.getAllValuesOfEnum(TestEnum1.class);\n", "        Assert.assertTrue(list.contains(TestEnum1.A));\n", "        Assert.assertTrue(list.contains(TestEnum1.B));\n", "        Assert.assertTrue(list.contains(TestEnum1.C));\n", "        Assert.assertEquals(TestEnum1.A, list.get(0));\n", "        Assert.assertEquals(TestEnum1.B, list.get(1));\n", "        Assert.assertEquals(TestEnum1.C, list.get(2));\n", "    }\n", "}\n", "\n", "enum TestEnum1 {\n", "    A, B, C\n", "}\n"], "method_lines_dic": {"EnumUtil::::throwIfNull(T)": [36, 41], "EnumUtil::::getAllValuesOfEnum(java.lang.Class<T>)": [43, 48]}, "test_method_lines_dic": {"EnumUtilTest::::testEnumUtilSameAmount()": [35, 38], "EnumUtilTest::::testEnumUtilSameValues()": [40, 49]}, "reverse_method_lines_dic": {"36": "EnumUtil::::throwIfNull(T)", "37": "EnumUtil::::throwIfNull(T)", "38": "EnumUtil::::throwIfNull(T)", "39": "EnumUtil::::throwIfNull(T)", "40": "EnumUtil::::throwIfNull(T)", "41": "EnumUtil::::throwIfNull(T)", "43": "EnumUtil::::getAllValuesOfEnum(java.lang.Class<T>)", "44": "EnumUtil::::getAllValuesOfEnum(java.lang.Class<T>)", "45": "EnumUtil::::getAllValuesOfEnum(java.lang.Class<T>)", "46": "EnumUtil::::getAllValuesOfEnum(java.lang.Class<T>)", "47": "EnumUtil::::getAllValuesOfEnum(java.lang.Class<T>)", "48": "EnumUtil::::getAllValuesOfEnum(java.lang.Class<T>)"}, "test_reverse_method_lines_dic": {"35": "EnumUtilTest::::testEnumUtilSameAmount()", "36": "EnumUtilTest::::testEnumUtilSameAmount()", "37": "EnumUtilTest::::testEnumUtilSameAmount()", "38": "EnumUtilTest::::testEnumUtilSameAmount()", "40": "EnumUtilTest::::testEnumUtilSameValues()", "41": "EnumUtilTest::::testEnumUtilSameValues()", "42": "EnumUtilTest::::testEnumUtilSameValues()", "43": "EnumUtilTest::::testEnumUtilSameValues()", "44": "EnumUtilTest::::testEnumUtilSameValues()", "45": "EnumUtilTest::::testEnumUtilSameValues()", "46": "EnumUtilTest::::testEnumUtilSameValues()", "47": "EnumUtilTest::::testEnumUtilSameValues()", "48": "EnumUtilTest::::testEnumUtilSameValues()", "49": "EnumUtilTest::::testEnumUtilSameValues()"}, "tests": [{"test_lines": [35, 38], "covered_lines": [44, 47]}, {"test_lines": [40, 49], "covered_lines": [44, 47]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/util/TextUtil.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.io.font.otf.Glyph;\n", "import com.itextpdf.io.font.otf.GlyphLine;\n", "\n", "import java.nio.charset.Charset;\n", "import java.util.ArrayList;\n", "import java.util.List;\n", "\n", "/**\n", " * This file is a helper class for internal usage only.\n", " * Be aware that its API and functionality may be changed in future.\n", " */\n", "public final class TextUtil {\n", "\n", "    private TextUtil() {\n", "    }\n", "\n", "    /**\n", "     * Checks if the passed code point corresponds to diacritic.\n", "     *\n", "     * @param codePoint the code point to check\n", "     *\n", "     * @return {@code true} if passed code point is diacritic, {@code false} otherwise\n", "     */\n", "    public static boolean isDiacritic(int codePoint) {\n", "        return codePoint > 0x0300 && codePoint <= 0x036F;\n", "    }\n", "\n", "    /**\n", "     * Check if the value of a character belongs to a certain interval\n", "     * that indicates it's the higher part of a surrogate pair.\n", "     *\n", "     * @param c the character\n", "     * @return true if the character belongs to the interval\n", "     */\n", "    public static boolean isSurrogateHigh(char c) {\n", "        return c >= '\\ud800' && c <= '\\udbff';\n", "    }\n", "\n", "    /**\n", "     * Check if the value of a character belongs to a certain interval\n", "     * that indicates it's the lower part of a surrogate pair.\n", "     *\n", "     * @param c the character\n", "     * @return true if the character belongs to the interval\n", "     */\n", "    public static boolean isSurrogateLow(char c) {\n", "        return c >= '\\udc00' && c <= '\\udfff';\n", "    }\n", "\n", "    public static char highSurrogate(int codePoint) {\n", "        return (char) ((codePoint >>> 10)\n", "                + ('\\uD800' - (0x010000 >>> 10)));\n", "    }\n", "\n", "    public static char lowSurrogate(int codePoint) {\n", "        return (char) ((codePoint & 0x3ff) + '\\uDC00');\n", "    }\n", "\n", "    /**\n", "     * Checks if two subsequent characters in a String are\n", "     * the higher and the lower character in a surrogate\n", "     * pair (and therefore eligible for conversion to a UTF 32 character).\n", "     *\n", "     * @param text the String with the high and low surrogate characters\n", "     * @param idx  the index of the 'high' character in the pair\n", "     * @return true if the characters are surrogate pairs\n", "     */\n", "    public static boolean isSurrogatePair(String text, int idx) {\n", "        return !(idx < 0 || idx > text.length() - 2)\n", "                && isSurrogateHigh(text.charAt(idx))\n", "                && isSurrogateLow(text.charAt(idx + 1));\n", "    }\n", "\n", "    /**\n", "     * Checks if two subsequent characters in a character array are\n", "     * the higher and the lower character in a surrogate\n", "     * pair (and therefore eligible for conversion to a UTF 32 character).\n", "     *\n", "     * @param text the character array with the high and low surrogate characters\n", "     * @param idx  the index of the 'high' character in the pair\n", "     * @return true if the characters are surrogate pairs\n", "     */\n", "    public static boolean isSurrogatePair(char[] text, int idx) {\n", "        return !(idx < 0 || idx > text.length - 2)\n", "                && isSurrogateHigh(text[idx])\n", "                && isSurrogateLow(text[idx + 1]);\n", "    }\n", "\n", "    /**\n", "     * Returns the code point of a UTF32 character corresponding with\n", "     * a high and a low surrogate value.\n", "     *\n", "     * @param highSurrogate the high surrogate value\n", "     * @param lowSurrogate  the low surrogate value\n", "     * @return a code point value\n", "     */\n", "    public static int convertToUtf32(char highSurrogate, char lowSurrogate) {\n", "        return (highSurrogate - 0xd800) * 0x400 + lowSurrogate - 0xdc00 + 0x10000;\n", "    }\n", "\n", "    /**\n", "     * Converts a unicode character in a character array to a UTF 32 code point value.\n", "     *\n", "     * @param text a character array that has the unicode character(s)\n", "     * @param idx  the index of the 'high' character\n", "     * @return the code point value\n", "     */\n", "    public static int convertToUtf32(char[] text, int idx) {\n", "        return (text[idx] - 0xd800) * 0x400 + text[idx + 1] - 0xdc00 + 0x10000;\n", "    }\n", "\n", "    /**\n", "     * Converts a unicode character in a String to a UTF32 code point value\n", "     *\n", "     * @param text a String that has the unicode character(s)\n", "     * @param idx  the index of the 'high' character\n", "     * @return the codepoint value\n", "     */\n", "    public static int convertToUtf32(String text, int idx) {\n", "        return (text.charAt(idx) - 0xd800) * 0x400 + text.charAt(idx + 1) - 0xdc00 + 0x10000;\n", "    }\n", "\n", "    public static int[] convertToUtf32(String text) {\n", "        if (text == null) {\n", "            return null;\n", "        }\n", "        List<Integer> charCodes = new ArrayList<>(text.length());\n", "        int pos = 0;\n", "        while (pos < text.length()) {\n", "            if (isSurrogatePair(text, pos)) {\n", "                charCodes.add(convertToUtf32(text, pos));\n", "                pos += 2;\n", "            } else {\n", "                charCodes.add((int) text.charAt(pos));\n", "                pos++;\n", "            }\n", "        }\n", "        return ArrayUtil.toIntArray(charCodes);\n", "    }\n", "\n", "    /**\n", "     * Converts a UTF32 code point value to a char array with the corresponding character(s).\n", "     *\n", "     * @param codePoint a Unicode value\n", "     * @return the corresponding char array\n", "     */\n", "    public static char[] convertFromUtf32(int codePoint) {\n", "        if (codePoint < 0x10000) {\n", "            return new char[]{(char) codePoint};\n", "        }\n", "        codePoint -= 0x10000;\n", "        return new char[]{(char) (codePoint / 0x400 + 0xd800), (char) (codePoint % 0x400 + 0xdc00)};\n", "    }\n", "\n", "    /**\n", "     * /**\n", "     * Converts a UTF32 code point sequence to a String with the corresponding character(s).\n", "     *\n", "     * @param text     a Unicode text sequence\n", "     * @param startPos start position of text to convert, inclusive\n", "     * @param endPos   end position of txt to convert, exclusive\n", "     * @return the corresponding characters in a String\n", "     */\n", "    public static String convertFromUtf32(int[] text, int startPos, int endPos) {\n", "        StringBuilder sb = new StringBuilder();\n", "        for (int i = startPos; i < endPos; i++) {\n", "            sb.append(convertFromUtf32ToCharArray(text[i]));\n", "        }\n", "        return sb.toString();\n", "    }\n", "\n", "    /**\n", "     * Converts a UTF32 code point value to a char array with the corresponding character(s).\n", "     *\n", "     * @param codePoint a Unicode value\n", "     * @return the corresponding characters in a char arrat\n", "     */\n", "    public static char[] convertFromUtf32ToCharArray(int codePoint) {\n", "        if (codePoint < 0x10000) {\n", "            return new char[]{(char) codePoint};\n", "        }\n", "        codePoint -= 0x10000;\n", "        return new char[]{(char) (codePoint / 0x400 + 0xd800), (char) (codePoint % 0x400 + 0xdc00)};\n", "    }\n", "\n", "    public static String charToString(char ch) {\n", "        return String.valueOf(ch);\n", "    }\n", "\n", "    /**\n", "     * Check if a glyph is a newline by checking if it's unicode value is a newline\n", "     *\n", "     * @param glyph glyph to check\n", "     * @return True if the glyph represents a newline, false otherwise\n", "     */\n", "    public static boolean isNewLine(Glyph glyph) {\n", "        int unicode = glyph.getUnicode();\n", "        return isNewLine(unicode);\n", "    }\n", "\n", "    /**\n", "     * Check if a character is a newline by checking if it's integer value is a newline in unicode\n", "     *\n", "     * @param c character to check\n", "     * @return True if the character represents a newline, false otherwise\n", "     */\n", "    public static boolean isNewLine(char c) {\n", "        int unicode = (int) c;\n", "        return isNewLine(unicode);\n", "    }\n", "\n", "    /**\n", "     * Check if a character is a newline by checking if it's integer value is a newline in unicode\n", "     *\n", "     * @param unicode unicode value to check\n", "     * @return True if the character represents a newline, false otherwise\n", "     */\n", "    public static boolean isNewLine(int unicode) {\n", "        return unicode == '\\n' || unicode == '\\r';\n", "    }\n", "\n", "    public static boolean isCarriageReturnFollowedByLineFeed(GlyphLine glyphLine, int carriageReturnPosition) {\n", "        return glyphLine.size() > 1\n", "                && carriageReturnPosition <= glyphLine.size() - 2\n", "                && glyphLine.get(carriageReturnPosition).getUnicode() == '\\r'\n", "                && glyphLine.get(carriageReturnPosition + 1).getUnicode() == '\\n';\n", "    }\n", "\n", "    public static boolean isSpaceOrWhitespace(Glyph glyph) {\n", "        //\\r, \\n, and \\t are whitespaces, but not space chars.\n", "        //\\u00a0 is SpaceChar, but not whitespace.\n", "        return Character.isSpaceChar((char) glyph.getUnicode()) || Character.isWhitespace((char) glyph.getUnicode());\n", "    }\n", "\n", "    public static boolean isWhitespace(Glyph glyph) {\n", "        return Character.isWhitespace(glyph.getUnicode());\n", "    }\n", "\n", "    public static boolean isNonBreakingHyphen(Glyph glyph) {\n", "        return '\\u2011' == glyph.getUnicode();\n", "    }\n", "\n", "    public static boolean isSpace(Glyph glyph) {\n", "        return Character.isSpaceChar((char) glyph.getUnicode());\n", "    }\n", "\n", "    public static boolean isUni0020(Glyph g) {\n", "        return g.getUnicode() == ' ';\n", "    }\n", "\n", "    public static boolean isNonPrintable(int c) {\n", "        return Character.isIdentifierIgnorable(c) || c == '\\u00AD';\n", "    }\n", "\n", "    public static boolean isWhitespaceOrNonPrintable(int code) {\n", "        return Character.isWhitespace(code) || isNonPrintable(code);\n", "    }\n", "\n", "    public static boolean isLetterOrDigit(Glyph glyph) {\n", "        return Character.isLetterOrDigit(glyph.getUnicode());\n", "    }\n", "\n", "    public static boolean isMark(Glyph glyph) {\n", "        int unicode = glyph.getUnicode();\n", "        return ((((1 << Character.NON_SPACING_MARK) |\n", "                (1 << Character.COMBINING_SPACING_MARK) |\n", "                (1 << Character.ENCLOSING_MARK)) >> Character.getType(unicode)) & 1) != 0;\n", "    }\n", "\n", "    public static boolean charsetIsSupported(String charsetName) {\n", "        try {\n", "            return Charset.isSupported(charsetName);\n", "        } catch (IllegalArgumentException e) {\n", "            return false;\n", "        }\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.io.font.otf.Glyph;\n", "import com.itextpdf.io.font.otf.GlyphLine;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.util.Arrays;\n", "import org.junit.Assert;\n", "import org.junit.Before;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class TextUtilTest extends ExtendedITextTest {\n", "\n", "    private Glyph carriageReturn;\n", "    private Glyph lineFeed;\n", "\n", "    @Before\n", "    public void before() {\n", "        this.carriageReturn = new Glyph(0, 0, '\\r');\n", "        this.lineFeed = new Glyph(0, 0, '\\n');\n", "    }\n", "\n", "    @Test\n", "    public void carriageReturnFollowedByLineFeedTest() {\n", "        helper(true, 0,\n", "                carriageReturn, lineFeed);\n", "    }\n", "\n", "    @Test\n", "    public void carriageReturnFollowedByCarriageReturnAndThenLineFeedTest() {\n", "        helper(false, 0,\n", "                carriageReturn, carriageReturn, lineFeed);\n", "    }\n", "\n", "    @Test\n", "    public void carriageReturnPrecededByCarriageReturnAndFollowedByLineFeedTest() {\n", "        helper(true, 1,\n", "                carriageReturn, carriageReturn, lineFeed);\n", "    }\n", "\n", "    @Test\n", "    public void carriageReturnFollowedByNothingTest() {\n", "        helper(false, 0,\n", "                carriageReturn);\n", "    }\n", "\n", "    @Test\n", "    public void carriageReturnPrecededByLineFeedTest() {\n", "        helper(false, 0,\n", "                lineFeed, carriageReturn);\n", "    }\n", "\n", "    @Test\n", "    public void carriageReturnPrecededByTextFollowedByLineFeedTest() {\n", "        helper(true, 1,\n", "                new Glyph(0,0, 'a'), carriageReturn, lineFeed);\n", "    }\n", "\n", "    @Test\n", "    public void isLetterPositiveTest() {\n", "        Glyph glyph = new Glyph(0, 0, 'a');\n", "        Assert.assertTrue(TextUtil.isLetterOrDigit(glyph));\n", "    }\n", "\n", "    @Test\n", "    public void isDigitPositiveTest() {\n", "        Glyph glyph = new Glyph(0, 0, '8');\n", "        Assert.assertTrue(TextUtil.isLetterOrDigit(glyph));\n", "    }\n", "\n", "    @Test\n", "    public void isLetterOrDigitNegativeTest() {\n", "        Glyph glyph = new Glyph(0, 0, '-');\n", "        Assert.assertFalse(TextUtil.isLetterOrDigit(glyph));\n", "    }\n", "\n", "    @Test\n", "    public void isMarkPositiveTest() {\n", "        // TAI THAM SIGN KHUEN TONE-3\n", "        Glyph glyph = new Glyph(0, 0, 0x1A77);\n", "        Assert.assertTrue(TextUtil.isMark(glyph));\n", "    }\n", "\n", "    @Test\n", "    public void isMarkNegativeTest() {\n", "        Glyph glyph = new Glyph(0, 0, '-');\n", "        Assert.assertFalse(TextUtil.isMark(glyph));\n", "    }\n", "\n", "    @Test\n", "    public void isDiacriticTest() {\n", "        Assert.assertTrue(TextUtil.isDiacritic(\"\\u0303\".charAt(0)));\n", "        Assert.assertFalse(TextUtil.isDiacritic(\"\\u006b\".charAt(0)));\n", "    }\n", "\n", "    private void helper(boolean expected, int currentCRPosition, Glyph...glyphs) {\n", "        GlyphLine glyphLine = new GlyphLine(Arrays.asList(glyphs));\n", "        Assert.assertTrue(expected == TextUtil.isCarriageReturnFollowedByLineFeed(glyphLine, currentCRPosition));\n", "    }\n", "}\n"], "method_lines_dic": {"TextUtil::::isDiacritic(int)": [48, 50], "TextUtil::::isSurrogateHigh(char)": [59, 61], "TextUtil::::isSurrogateLow(char)": [70, 72], "TextUtil::::highSurrogate(int)": [74, 77], "TextUtil::::lowSurrogate(int)": [79, 81], "TextUtil::::isSurrogatePair(java.lang.String,int)": [92, 96], "TextUtil::::isSurrogatePair(char[],int)": [107, 111], "TextUtil::::convertToUtf32(char,char)": [121, 123], "TextUtil::::convertToUtf32(char[],int)": [132, 134], "TextUtil::::convertToUtf32(java.lang.String,int)": [143, 145], "TextUtil::::convertToUtf32(java.lang.String)": [147, 163], "TextUtil::::convertFromUtf32(int)": [171, 177], "TextUtil::::convertFromUtf32(int[],int,int)": [188, 194], "TextUtil::::convertFromUtf32ToCharArray(int)": [202, 208], "TextUtil::::charToString(char)": [210, 212], "TextUtil::::isNewLine(com.itextpdf.io.font.otf.Glyph)": [220, 223], "TextUtil::::isNewLine(char)": [231, 234], "TextUtil::::isNewLine(int)": [242, 244], "TextUtil::::isCarriageReturnFollowedByLineFeed(com.itextpdf.io.font.otf.GlyphLine,int)": [246, 251], "TextUtil::::isSpaceOrWhitespace(com.itextpdf.io.font.otf.Glyph)": [253, 257], "TextUtil::::isWhitespace(com.itextpdf.io.font.otf.Glyph)": [259, 261], "TextUtil::::isNonBreakingHyphen(com.itextpdf.io.font.otf.Glyph)": [263, 265], "TextUtil::::isSpace(com.itextpdf.io.font.otf.Glyph)": [267, 269], "TextUtil::::isUni0020(com.itextpdf.io.font.otf.Glyph)": [271, 273], "TextUtil::::isNonPrintable(int)": [275, 277], "TextUtil::::isWhitespaceOrNonPrintable(int)": [279, 281], "TextUtil::::isLetterOrDigit(com.itextpdf.io.font.otf.Glyph)": [283, 285], "TextUtil::::isMark(com.itextpdf.io.font.otf.Glyph)": [287, 292], "TextUtil::::charsetIsSupported(java.lang.String)": [294, 300]}, "test_method_lines_dic": {"TextUtilTest::::before()": [42, 46], "TextUtilTest::::carriageReturnFollowedByLineFeedTest()": [48, 52], "TextUtilTest::::carriageReturnFollowedByCarriageReturnAndThenLineFeedTest()": [54, 58], "TextUtilTest::::carriageReturnPrecededByCarriageReturnAndFollowedByLineFeedTest()": [60, 64], "TextUtilTest::::carriageReturnFollowedByNothingTest()": [66, 70], "TextUtilTest::::carriageReturnPrecededByLineFeedTest()": [72, 76], "TextUtilTest::::carriageReturnPrecededByTextFollowedByLineFeedTest()": [78, 82], "TextUtilTest::::isLetterPositiveTest()": [84, 88], "TextUtilTest::::isDigitPositiveTest()": [90, 94], "TextUtilTest::::isLetterOrDigitNegativeTest()": [96, 100], "TextUtilTest::::isMarkPositiveTest()": [102, 107], "TextUtilTest::::isMarkNegativeTest()": [109, 113], "TextUtilTest::::isDiacriticTest()": [115, 119]}, "reverse_method_lines_dic": {"48": "TextUtil::::isDiacritic(int)", "49": "TextUtil::::isDiacritic(int)", "50": "TextUtil::::isDiacritic(int)", "59": "TextUtil::::isSurrogateHigh(char)", "60": "TextUtil::::isSurrogateHigh(char)", "61": "TextUtil::::isSurrogateHigh(char)", "70": "TextUtil::::isSurrogateLow(char)", "71": "TextUtil::::isSurrogateLow(char)", "72": "TextUtil::::isSurrogateLow(char)", "74": "TextUtil::::highSurrogate(int)", "75": "TextUtil::::highSurrogate(int)", "76": "TextUtil::::highSurrogate(int)", "77": "TextUtil::::highSurrogate(int)", "79": "TextUtil::::lowSurrogate(int)", "80": "TextUtil::::lowSurrogate(int)", "81": "TextUtil::::lowSurrogate(int)", "92": "TextUtil::::isSurrogatePair(java.lang.String,int)", "93": "TextUtil::::isSurrogatePair(java.lang.String,int)", "94": "TextUtil::::isSurrogatePair(java.lang.String,int)", "95": "TextUtil::::isSurrogatePair(java.lang.String,int)", "96": "TextUtil::::isSurrogatePair(java.lang.String,int)", "107": "TextUtil::::isSurrogatePair(char[],int)", "108": "TextUtil::::isSurrogatePair(char[],int)", "109": "TextUtil::::isSurrogatePair(char[],int)", "110": "TextUtil::::isSurrogatePair(char[],int)", "111": "TextUtil::::isSurrogatePair(char[],int)", "121": "TextUtil::::convertToUtf32(char,char)", "122": "TextUtil::::convertToUtf32(char,char)", "123": "TextUtil::::convertToUtf32(char,char)", "132": "TextUtil::::convertToUtf32(char[],int)", "133": "TextUtil::::convertToUtf32(char[],int)", "134": "TextUtil::::convertToUtf32(char[],int)", "143": "TextUtil::::convertToUtf32(java.lang.String,int)", "144": "TextUtil::::convertToUtf32(java.lang.String,int)", "145": "TextUtil::::convertToUtf32(java.lang.String,int)", "147": "TextUtil::::convertToUtf32(java.lang.String)", "148": "TextUtil::::convertToUtf32(java.lang.String)", "149": "TextUtil::::convertToUtf32(java.lang.String)", "150": "TextUtil::::convertToUtf32(java.lang.String)", "151": "TextUtil::::convertToUtf32(java.lang.String)", "152": "TextUtil::::convertToUtf32(java.lang.String)", "153": "TextUtil::::convertToUtf32(java.lang.String)", "154": "TextUtil::::convertToUtf32(java.lang.String)", "155": "TextUtil::::convertToUtf32(java.lang.String)", "156": "TextUtil::::convertToUtf32(java.lang.String)", "157": "TextUtil::::convertToUtf32(java.lang.String)", "158": "TextUtil::::convertToUtf32(java.lang.String)", "159": "TextUtil::::convertToUtf32(java.lang.String)", "160": "TextUtil::::convertToUtf32(java.lang.String)", "161": "TextUtil::::convertToUtf32(java.lang.String)", "162": "TextUtil::::convertToUtf32(java.lang.String)", "163": "TextUtil::::convertToUtf32(java.lang.String)", "171": "TextUtil::::convertFromUtf32(int)", "172": "TextUtil::::convertFromUtf32(int)", "173": "TextUtil::::convertFromUtf32(int)", "174": "TextUtil::::convertFromUtf32(int)", "175": "TextUtil::::convertFromUtf32(int)", "176": "TextUtil::::convertFromUtf32(int)", "177": "TextUtil::::convertFromUtf32(int)", "188": "TextUtil::::convertFromUtf32(int[],int,int)", "189": "TextUtil::::convertFromUtf32(int[],int,int)", "190": "TextUtil::::convertFromUtf32(int[],int,int)", "191": "TextUtil::::convertFromUtf32(int[],int,int)", "192": "TextUtil::::convertFromUtf32(int[],int,int)", "193": "TextUtil::::convertFromUtf32(int[],int,int)", "194": "TextUtil::::convertFromUtf32(int[],int,int)", "202": "TextUtil::::convertFromUtf32ToCharArray(int)", "203": "TextUtil::::convertFromUtf32ToCharArray(int)", "204": "TextUtil::::convertFromUtf32ToCharArray(int)", "205": "TextUtil::::convertFromUtf32ToCharArray(int)", "206": "TextUtil::::convertFromUtf32ToCharArray(int)", "207": "TextUtil::::convertFromUtf32ToCharArray(int)", "208": "TextUtil::::convertFromUtf32ToCharArray(int)", "210": "TextUtil::::charToString(char)", "211": "TextUtil::::charToString(char)", "212": "TextUtil::::charToString(char)", "220": "TextUtil::::isNewLine(com.itextpdf.io.font.otf.Glyph)", "221": "TextUtil::::isNewLine(com.itextpdf.io.font.otf.Glyph)", "222": "TextUtil::::isNewLine(com.itextpdf.io.font.otf.Glyph)", "223": "TextUtil::::isNewLine(com.itextpdf.io.font.otf.Glyph)", "231": "TextUtil::::isNewLine(char)", "232": "TextUtil::::isNewLine(char)", "233": "TextUtil::::isNewLine(char)", "234": "TextUtil::::isNewLine(char)", "242": "TextUtil::::isNewLine(int)", "243": "TextUtil::::isNewLine(int)", "244": "TextUtil::::isNewLine(int)", "246": "TextUtil::::isCarriageReturnFollowedByLineFeed(com.itextpdf.io.font.otf.GlyphLine,int)", "247": "TextUtil::::isCarriageReturnFollowedByLineFeed(com.itextpdf.io.font.otf.GlyphLine,int)", "248": "TextUtil::::isCarriageReturnFollowedByLineFeed(com.itextpdf.io.font.otf.GlyphLine,int)", "249": "TextUtil::::isCarriageReturnFollowedByLineFeed(com.itextpdf.io.font.otf.GlyphLine,int)", "250": "TextUtil::::isCarriageReturnFollowedByLineFeed(com.itextpdf.io.font.otf.GlyphLine,int)", "251": "TextUtil::::isCarriageReturnFollowedByLineFeed(com.itextpdf.io.font.otf.GlyphLine,int)", "253": "TextUtil::::isSpaceOrWhitespace(com.itextpdf.io.font.otf.Glyph)", "254": "TextUtil::::isSpaceOrWhitespace(com.itextpdf.io.font.otf.Glyph)", "255": "TextUtil::::isSpaceOrWhitespace(com.itextpdf.io.font.otf.Glyph)", "256": "TextUtil::::isSpaceOrWhitespace(com.itextpdf.io.font.otf.Glyph)", "257": "TextUtil::::isSpaceOrWhitespace(com.itextpdf.io.font.otf.Glyph)", "259": "TextUtil::::isWhitespace(com.itextpdf.io.font.otf.Glyph)", "260": "TextUtil::::isWhitespace(com.itextpdf.io.font.otf.Glyph)", "261": "TextUtil::::isWhitespace(com.itextpdf.io.font.otf.Glyph)", "263": "TextUtil::::isNonBreakingHyphen(com.itextpdf.io.font.otf.Glyph)", "264": "TextUtil::::isNonBreakingHyphen(com.itextpdf.io.font.otf.Glyph)", "265": "TextUtil::::isNonBreakingHyphen(com.itextpdf.io.font.otf.Glyph)", "267": "TextUtil::::isSpace(com.itextpdf.io.font.otf.Glyph)", "268": "TextUtil::::isSpace(com.itextpdf.io.font.otf.Glyph)", "269": "TextUtil::::isSpace(com.itextpdf.io.font.otf.Glyph)", "271": "TextUtil::::isUni0020(com.itextpdf.io.font.otf.Glyph)", "272": "TextUtil::::isUni0020(com.itextpdf.io.font.otf.Glyph)", "273": "TextUtil::::isUni0020(com.itextpdf.io.font.otf.Glyph)", "275": "TextUtil::::isNonPrintable(int)", "276": "TextUtil::::isNonPrintable(int)", "277": "TextUtil::::isNonPrintable(int)", "279": "TextUtil::::isWhitespaceOrNonPrintable(int)", "280": "TextUtil::::isWhitespaceOrNonPrintable(int)", "281": "TextUtil::::isWhitespaceOrNonPrintable(int)", "283": "TextUtil::::isLetterOrDigit(com.itextpdf.io.font.otf.Glyph)", "284": "TextUtil::::isLetterOrDigit(com.itextpdf.io.font.otf.Glyph)", "285": "TextUtil::::isLetterOrDigit(com.itextpdf.io.font.otf.Glyph)", "287": "TextUtil::::isMark(com.itextpdf.io.font.otf.Glyph)", "288": "TextUtil::::isMark(com.itextpdf.io.font.otf.Glyph)", "289": "TextUtil::::isMark(com.itextpdf.io.font.otf.Glyph)", "290": "TextUtil::::isMark(com.itextpdf.io.font.otf.Glyph)", "291": "TextUtil::::isMark(com.itextpdf.io.font.otf.Glyph)", "292": "TextUtil::::isMark(com.itextpdf.io.font.otf.Glyph)", "294": "TextUtil::::charsetIsSupported(java.lang.String)", "295": "TextUtil::::charsetIsSupported(java.lang.String)", "296": "TextUtil::::charsetIsSupported(java.lang.String)", "297": "TextUtil::::charsetIsSupported(java.lang.String)", "298": "TextUtil::::charsetIsSupported(java.lang.String)", "299": "TextUtil::::charsetIsSupported(java.lang.String)", "300": "TextUtil::::charsetIsSupported(java.lang.String)"}, "test_reverse_method_lines_dic": {"42": "TextUtilTest::::before()", "43": "TextUtilTest::::before()", "44": "TextUtilTest::::before()", "45": "TextUtilTest::::before()", "46": "TextUtilTest::::before()", "48": "TextUtilTest::::carriageReturnFollowedByLineFeedTest()", "49": "TextUtilTest::::carriageReturnFollowedByLineFeedTest()", "50": "TextUtilTest::::carriageReturnFollowedByLineFeedTest()", "51": "TextUtilTest::::carriageReturnFollowedByLineFeedTest()", "52": "TextUtilTest::::carriageReturnFollowedByLineFeedTest()", "54": "TextUtilTest::::carriageReturnFollowedByCarriageReturnAndThenLineFeedTest()", "55": "TextUtilTest::::carriageReturnFollowedByCarriageReturnAndThenLineFeedTest()", "56": "TextUtilTest::::carriageReturnFollowedByCarriageReturnAndThenLineFeedTest()", "57": "TextUtilTest::::carriageReturnFollowedByCarriageReturnAndThenLineFeedTest()", "58": "TextUtilTest::::carriageReturnFollowedByCarriageReturnAndThenLineFeedTest()", "60": "TextUtilTest::::carriageReturnPrecededByCarriageReturnAndFollowedByLineFeedTest()", "61": "TextUtilTest::::carriageReturnPrecededByCarriageReturnAndFollowedByLineFeedTest()", "62": "TextUtilTest::::carriageReturnPrecededByCarriageReturnAndFollowedByLineFeedTest()", "63": "TextUtilTest::::carriageReturnPrecededByCarriageReturnAndFollowedByLineFeedTest()", "64": "TextUtilTest::::carriageReturnPrecededByCarriageReturnAndFollowedByLineFeedTest()", "66": "TextUtilTest::::carriageReturnFollowedByNothingTest()", "67": "TextUtilTest::::carriageReturnFollowedByNothingTest()", "68": "TextUtilTest::::carriageReturnFollowedByNothingTest()", "69": "TextUtilTest::::carriageReturnFollowedByNothingTest()", "70": "TextUtilTest::::carriageReturnFollowedByNothingTest()", "72": "TextUtilTest::::carriageReturnPrecededByLineFeedTest()", "73": "TextUtilTest::::carriageReturnPrecededByLineFeedTest()", "74": "TextUtilTest::::carriageReturnPrecededByLineFeedTest()", "75": "TextUtilTest::::carriageReturnPrecededByLineFeedTest()", "76": "TextUtilTest::::carriageReturnPrecededByLineFeedTest()", "78": "TextUtilTest::::carriageReturnPrecededByTextFollowedByLineFeedTest()", "79": "TextUtilTest::::carriageReturnPrecededByTextFollowedByLineFeedTest()", "80": "TextUtilTest::::carriageReturnPrecededByTextFollowedByLineFeedTest()", "81": "TextUtilTest::::carriageReturnPrecededByTextFollowedByLineFeedTest()", "82": "TextUtilTest::::carriageReturnPrecededByTextFollowedByLineFeedTest()", "84": "TextUtilTest::::isLetterPositiveTest()", "85": "TextUtilTest::::isLetterPositiveTest()", "86": "TextUtilTest::::isLetterPositiveTest()", "87": "TextUtilTest::::isLetterPositiveTest()", "88": "TextUtilTest::::isLetterPositiveTest()", "90": "TextUtilTest::::isDigitPositiveTest()", "91": "TextUtilTest::::isDigitPositiveTest()", "92": "TextUtilTest::::isDigitPositiveTest()", "93": "TextUtilTest::::isDigitPositiveTest()", "94": "TextUtilTest::::isDigitPositiveTest()", "96": "TextUtilTest::::isLetterOrDigitNegativeTest()", "97": "TextUtilTest::::isLetterOrDigitNegativeTest()", "98": "TextUtilTest::::isLetterOrDigitNegativeTest()", "99": "TextUtilTest::::isLetterOrDigitNegativeTest()", "100": "TextUtilTest::::isLetterOrDigitNegativeTest()", "102": "TextUtilTest::::isMarkPositiveTest()", "103": "TextUtilTest::::isMarkPositiveTest()", "104": "TextUtilTest::::isMarkPositiveTest()", "105": "TextUtilTest::::isMarkPositiveTest()", "106": "TextUtilTest::::isMarkPositiveTest()", "107": "TextUtilTest::::isMarkPositiveTest()", "109": "TextUtilTest::::isMarkNegativeTest()", "110": "TextUtilTest::::isMarkNegativeTest()", "111": "TextUtilTest::::isMarkNegativeTest()", "112": "TextUtilTest::::isMarkNegativeTest()", "113": "TextUtilTest::::isMarkNegativeTest()", "115": "TextUtilTest::::isDiacriticTest()", "116": "TextUtilTest::::isDiacriticTest()", "117": "TextUtilTest::::isDiacriticTest()", "118": "TextUtilTest::::isDiacriticTest()", "119": "TextUtilTest::::isDiacriticTest()"}, "tests": [{"test_lines": [48, 52], "covered_lines": [172, 173, 247, 248, 249, 250]}, {"test_lines": [54, 58], "covered_lines": [172, 173, 247, 248, 249, 250]}, {"test_lines": [60, 64], "covered_lines": [172, 173, 247, 248, 249, 250]}, {"test_lines": [66, 70], "covered_lines": [172, 173, 247, 250]}, {"test_lines": [72, 76], "covered_lines": [172, 173, 247, 248, 249, 250]}, {"test_lines": [78, 82], "covered_lines": [172, 173, 247, 248, 249, 250]}, {"test_lines": [84, 88], "covered_lines": [172, 173, 284]}, {"test_lines": [90, 94], "covered_lines": [172, 173, 284]}, {"test_lines": [96, 100], "covered_lines": [172, 173, 284]}, {"test_lines": [102, 107], "covered_lines": [172, 173, 288, 289, 291]}, {"test_lines": [109, 113], "covered_lines": [172, 173, 288, 289, 291]}, {"test_lines": [115, 119], "covered_lines": [49, 172, 173]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/util/ImageMagickHelper.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.commons.utils.ProcessInfo;\n", "import com.itextpdf.commons.utils.SystemUtil;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "\n", "import java.io.IOException;\n", "import java.util.regex.Matcher;\n", "import java.util.regex.Pattern;\n", "\n", "/**\n", " * A utility class that is used as an interface to run 3rd-party tool ImageMagick.\n", " * ImageMagick among other things allows to compare images and this class provides means to utilize this feature.\n", " *\n", " * <p>\n", " * The ImageMagick needs to be installed independently on the system. This class provides a convenient\n", " * way to run it by passing a terminal command. The command can either be specified explicitly or by a mean\n", " * of environment variable {@link #MAGICK_COMPARE_ENVIRONMENT_VARIABLE}.\n", " */\n", "public class ImageMagickHelper {\n", "    /**\n", "     * The name of the environment variable with the command to execute ImageMagic comparison operations.\n", "     */\n", "    public static final String MAGICK_COMPARE_ENVIRONMENT_VARIABLE = \"ITEXT_MAGICK_COMPARE_EXEC\";\n", "\n", "    @Deprecated\n", "    static final String MAGICK_COMPARE_ENVIRONMENT_VARIABLE_LEGACY = \"compareExec\";\n", "\n", "    static final String MAGICK_COMPARE_KEYWORD = \"ImageMagick Studio LLC\";\n", "\n", "    private static final String TEMP_FILE_PREFIX = \"itext_im_io_temp\";\n", "    private static final String DIFF_PIXELS_OUTPUT_REGEXP = \"^\\\\d+\\\\.*\\\\d*(e\\\\+\\\\d+)?\";\n", "\n", "    private static final Pattern pattern = Pattern.compile(DIFF_PIXELS_OUTPUT_REGEXP);\n", "\n", "    private String compareExec;\n", "\n", "    /**\n", "     * Creates new instance that will rely on ImageMagick execution command defined by {@link\n", "     * #MAGICK_COMPARE_ENVIRONMENT_VARIABLE} environment variable.\n", "     */\n", "    public ImageMagickHelper() {\n", "        this(null);\n", "    }\n", "\n", "    /**\n", "     * Creates new instance that will rely on ImageMagick execution command defined as passed argument.\n", "     *\n", "     * @param newCompareExec the ImageMagick execution command; if null - environment variables will be used instead\n", "     */\n", "    public ImageMagickHelper(String newCompareExec) {\n", "        compareExec = newCompareExec;\n", "        if (compareExec == null) {\n", "            compareExec = SystemUtil.getPropertyOrEnvironmentVariable(MAGICK_COMPARE_ENVIRONMENT_VARIABLE);\n", "            if (compareExec == null) {\n", "                compareExec = SystemUtil.getPropertyOrEnvironmentVariable(MAGICK_COMPARE_ENVIRONMENT_VARIABLE_LEGACY);\n", "            }\n", "        }\n", "\n", "        if (!CliCommandUtil.isVersionCommandExecutable(compareExec, MAGICK_COMPARE_KEYWORD)) {\n", "            throw new IllegalArgumentException(IoExceptionMessageConstant.COMPARE_COMMAND_SPECIFIED_INCORRECTLY);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Returns a command that is used to run the utility.\n", "     * This command doesn't contain command parameters. Parameters are added on specific\n", "     * methods invocation.\n", "     *\n", "     * @return a string command\n", "     */\n", "    public String getCliExecutionCommand() {\n", "        return compareExec;\n", "    }\n", "\n", "    /**\n", "     * Runs imageMagick to visually compare images and generate difference output.\n", "     * \n", "     * <p>\n", "     * Note, that this method may create temporary files.\n", "     *\n", "     * @param outImageFilePath Path to the output image file\n", "     * @param cmpImageFilePath Path to the cmp image file\n", "     * @param diffImageName    Path to the difference output image file\n", "     * @return boolean result of comparing: true - images are visually equal\n", "     * @throws IOException          if there are file's reading/writing issues\n", "     * @throws InterruptedException if there is thread interruption while executing ImageMagick.\n", "     */\n", "    public boolean runImageMagickImageCompare(String outImageFilePath, String cmpImageFilePath, String diffImageName)\n", "            throws IOException, InterruptedException {\n", "        return runImageMagickImageCompare(outImageFilePath, cmpImageFilePath, diffImageName, null);\n", "    }\n", "\n", "    /**\n", "     * Runs imageMagick to visually compare images with the specified fuzziness value and generate difference output.\n", "     * \n", "     * <p>\n", "     * Note, that this method may create temporary files.\n", "     *\n", "     * @param outImageFilePath Path to the output image file\n", "     * @param cmpImageFilePath Path to the cmp image file\n", "     * @param diffImageName    Path to the difference output image file\n", "     * @param fuzzValue        String fuzziness value to compare images. Should be formatted as string with integer\n", "     *                         or decimal number. Can be null, if it is not required to use fuzziness\n", "     * @return boolean result of comparing: true - images are visually equal\n", "     * @throws IOException          if there are file's reading/writing issues\n", "     * @throws InterruptedException if there is thread interruption while executing ImageMagick.\n", "     */\n", "    public boolean runImageMagickImageCompare(String outImageFilePath, String cmpImageFilePath,\n", "            String diffImageName, String fuzzValue) throws IOException, InterruptedException {\n", "        ImageMagickCompareResult compareResult = runImageMagickImageCompareAndGetResult(outImageFilePath,\n", "                cmpImageFilePath, diffImageName, fuzzValue);\n", "\n", "        return compareResult.isComparingResultSuccessful();\n", "    }\n", "\n", "    /**\n", "     * Runs imageMagick to visually compare images with the specified fuzziness value and given threshold\n", "     * and generate difference output.\n", "     * \n", "     * <p>\n", "     * Note, that this method may create temporary files.\n", "     *\n", "     * @param outImageFilePath Path to the output image file\n", "     * @param cmpImageFilePath Path to the cmp image file\n", "     * @param diffImageName    Path to the difference output image file\n", "     * @param fuzzValue        String fuzziness value to compare images. Should be formatted as string with integer\n", "     *                         or decimal number. Can be null, if it is not required to use fuzziness\n", "     * @param threshold        Long value of accepted threshold.\n", "     *\n", "     * @return boolean result of comparing: true - images are visually equal\n", "     *\n", "     * @throws IOException          if there are file's reading/writing issues\n", "     * @throws InterruptedException if there is thread interruption while executing ImageMagick.\n", "     */\n", "    public boolean runImageMagickImageCompareWithThreshold(String outImageFilePath, String cmpImageFilePath,\n", "            String diffImageName, String fuzzValue, long threshold) throws IOException, InterruptedException {\n", "        ImageMagickCompareResult compareResult = runImageMagickImageCompareAndGetResult(outImageFilePath,\n", "                cmpImageFilePath, diffImageName, fuzzValue);\n", "\n", "        if (compareResult.isComparingResultSuccessful()) {\n", "            return true;\n", "        } else {\n", "            return compareResult.getDiffPixels() <= threshold;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Runs imageMagick to visually compare images with the specified fuzziness value and generate difference output.\n", "     * This method returns an object of {@link ImageMagickCompareResult}, containing comparing result information,\n", "     * such as boolean result value and the number of different pixels.\n", "     * \n", "     * <p>\n", "     * Note, that this method may create temporary files.\n", "     *\n", "     * @param outImageFilePath Path to the output image file\n", "     * @param cmpImageFilePath Path to the cmp image file\n", "     * @param diffImageName    Path to the difference output image file\n", "     * @param fuzzValue        String fuzziness value to compare images. Should be formatted as string with integer\n", "     *                         or decimal number. Can be null, if it is not required to use fuzziness\n", "     *\n", "     * @return an object of {@link ImageMagickCompareResult}. containing comparing result information.\n", "     *\n", "     * @throws IOException          if there are file's reading/writing issues\n", "     * @throws InterruptedException if there is thread interruption while executing ImageMagick.\n", "     */\n", "    public ImageMagickCompareResult runImageMagickImageCompareAndGetResult(String outImageFilePath,\n", "            String cmpImageFilePath, String diffImageName, String fuzzValue) throws IOException, InterruptedException {\n", "        if (!validateFuzziness(fuzzValue)) {\n", "            throw new IllegalArgumentException(\"Invalid fuzziness value: \" + fuzzValue);\n", "        }\n", "        fuzzValue = (fuzzValue == null) ? \"\" : \" -metric AE -fuzz <fuzzValue>%\".replace(\"<fuzzValue>\", fuzzValue);\n", "\n", "        String replacementOutFile = null;\n", "        String replacementCmpFile = null;\n", "        String replacementDiff = null;\n", "        try {\n", "            replacementOutFile = FileUtil.createTempCopy(outImageFilePath, TEMP_FILE_PREFIX, null);\n", "            replacementCmpFile = FileUtil.createTempCopy(cmpImageFilePath, TEMP_FILE_PREFIX, null);\n", "\n", "            // ImageMagick generates difference images in .png format, therefore we can specify it.\n", "            // For some reason .webp comparison fails if the extension of diff image is not specified.\n", "            replacementDiff = FileUtil.createTempFile(TEMP_FILE_PREFIX, \".png\").getAbsolutePath();\n", "            String currCompareParams = fuzzValue + \" '\"\n", "                    + replacementOutFile + \"' '\"\n", "                    + replacementCmpFile + \"' '\"\n", "                    + replacementDiff + \"'\";\n", "            ProcessInfo processInfo = SystemUtil.runProcessAndGetProcessInfo(compareExec, currCompareParams);\n", "            boolean comparingResult = processInfo.getExitCode() == 0;\n", "            long diffPixels = parseImageMagickProcessOutput(processInfo.getProcessErrOutput());\n", "            ImageMagickCompareResult resultInfo = new ImageMagickCompareResult(comparingResult, diffPixels);\n", "\n", "            if (FileUtil.fileExists(replacementDiff)) {\n", "                FileUtil.copy(replacementDiff, diffImageName);\n", "            }\n", "            return resultInfo;\n", "        } finally {\n", "            FileUtil.removeFiles(new String[] {replacementOutFile, replacementCmpFile, replacementDiff});\n", "        }\n", "    }\n", "\n", "    static boolean validateFuzziness(String fuzziness) {\n", "        if (null == fuzziness) {\n", "            return true;\n", "        } else {\n", "            try {\n", "                return Double.parseDouble(fuzziness) >= 0;\n", "            } catch (NumberFormatException e) {\n", "                // In case of an exception the string could not be parsed to double,\n", "                // therefore it is considered to be invalid.\n", "                return false;\n", "            }\n", "        }\n", "    }\n", "\n", "    private static long parseImageMagickProcessOutput(String processOutput) throws IOException {\n", "        if (null == processOutput) {\n", "            throw new IllegalArgumentException(IoExceptionMessageConstant.IMAGE_MAGICK_OUTPUT_IS_NULL);\n", "        }\n", "\n", "        if (processOutput.isEmpty()) {\n", "            return 0L;\n", "        }\n", "\n", "        String[] processOutputLines = processOutput.split(\"\\n\");\n", "\n", "        for (String line : processOutputLines) {\n", "            try {\n", "                Matcher matcher = pattern.matcher(line);\n", "                if (matcher.find()) {\n", "                    return (long) Double.valueOf(matcher.group()).longValue();\n", "                }\n", "            } catch (NumberFormatException e) {\n", "                // Nothing should be done here because of the exception, that will be thrown later.\n", "            }\n", "        }\n", "\n", "        throw new IOException(IoExceptionMessageConstant.IMAGE_MAGICK_PROCESS_EXECUTION_FAILED + processOutput);\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.commons.utils.SystemUtil;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.io.ByteArrayOutputStream;\n", "import java.io.IOException;\n", "import java.io.PrintStream;\n", "import org.junit.Assert;\n", "import org.junit.Before;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "// Android-Conversion-Skip-File (imagemagick isn't available on Android)\n", "public class ImageMagickHelperTest extends ExtendedITextTest {\n", "    private static final String SOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/util/ImageMagickHelperTest/\";\n", "    private static final String DESTINATION_FOLDER = \"./target/test/com/itextpdf/io/ImageMagickHelperTest/\";\n", "\n", "    // In some of the test we will check whether ImageMagick has printed something to the console.\n", "    // For this reason the standard output stream will be customized. In .NET, however,\n", "    // on the contrary to Java the name of the test gets to this stream, hence we cannot check\n", "    // its length against zero and need to introduce some threshold, which should be definitely\n", "    // less than the length of the help message.\n", "    private static final int SYSTEM_OUT_LENGTH_LIMIT = 50;\n", "\n", "    @Before\n", "    public void setUp() {\n", "        createOrClearDestinationFolder(DESTINATION_FOLDER);\n", "    }\n", "\n", "    @Test\n", "    public void imageMagickEnvVarIsDefault() {\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        Assert.assertNotNull(imageMagickHelper.getCliExecutionCommand());\n", "    }\n", "\n", "    @Test\n", "    public void imageMagickEnvVarIsExplicitlySpecified() {\n", "        String compareExec = SystemUtil\n", "                .getPropertyOrEnvironmentVariable(ImageMagickHelper.MAGICK_COMPARE_ENVIRONMENT_VARIABLE);\n", "        if (compareExec == null) {\n", "            compareExec = SystemUtil\n", "                    .getPropertyOrEnvironmentVariable(ImageMagickHelper.MAGICK_COMPARE_ENVIRONMENT_VARIABLE_LEGACY);\n", "        }\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper(compareExec);\n", "\n", "        Assert.assertNotNull(imageMagickHelper.getCliExecutionCommand());\n", "    }\n", "\n", "    @Test\n", "    public void imageMagickEnvVarIsNull() throws IOException, InterruptedException {\n", "        String inputImage = SOURCE_FOLDER + \"image.png\";\n", "        String cmpImage = SOURCE_FOLDER + \"cmp_image.png\";\n", "        String diff = DESTINATION_FOLDER + \"diff.png\";\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper(null);\n", "        boolean result = imageMagickHelper.runImageMagickImageCompare(inputImage, cmpImage, diff);\n", "\n", "        Assert.assertTrue(result);\n", "        Assert.assertTrue(FileUtil.fileExists(diff));\n", "    }\n", "\n", "    @Test\n", "    public void imageMagickEnvVarIsIncorrect() {\n", "        Exception e = Assert.assertThrows(IllegalArgumentException.class,\n", "                () -> new ImageMagickHelper(\"-\")\n", "        );\n", "        Assert.assertEquals(IoExceptionMessageConstant.COMPARE_COMMAND_SPECIFIED_INCORRECTLY, e.getMessage());\n", "    }\n", "\n", "    @Test\n", "    public void runImageMagickForEqualImages() throws IOException, InterruptedException {\n", "        String inputImage = SOURCE_FOLDER + \"image.png\";\n", "        String cmpImage = SOURCE_FOLDER + \"cmp_image.png\";\n", "        String diff = DESTINATION_FOLDER + \"diff_equalImages.png\";\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        boolean result = imageMagickHelper.runImageMagickImageCompare(inputImage, cmpImage, diff);\n", "\n", "        Assert.assertTrue(result);\n", "        Assert.assertTrue(FileUtil.fileExists(diff));\n", "    }\n", "\n", "    @Test\n", "    public void runImageMagickForEqualImagesWithFuzzParam() throws IOException, InterruptedException {\n", "        String inputImage = SOURCE_FOLDER + \"image.png\";\n", "        String cmpImage = SOURCE_FOLDER + \"cmp_image.png\";\n", "        String diff = DESTINATION_FOLDER + \"diff_equalImagesFuzzParam.png\";\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        boolean result = imageMagickHelper.runImageMagickImageCompare(inputImage, cmpImage, diff, \"0.5\");\n", "\n", "        Assert.assertTrue(result);\n", "        Assert.assertTrue(FileUtil.fileExists(diff));\n", "    }\n", "\n", "    @Test\n", "    public void runImageMagickForDifferentImages() throws IOException, InterruptedException {\n", "        String inputImage = SOURCE_FOLDER + \"Im1_1.jpg\";\n", "        String cmpImage = SOURCE_FOLDER + \"cmp_Im1_1.jpg\";\n", "        String diff = DESTINATION_FOLDER + \"diff_differentImages.png\";\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        boolean result = imageMagickHelper.runImageMagickImageCompare(inputImage, cmpImage, diff);\n", "\n", "        Assert.assertFalse(result);\n", "        Assert.assertTrue(FileUtil.fileExists(diff));\n", "    }\n", "\n", "    @Test\n", "    public void runImageMagickForDifferentImagesWithFuzzParamNotEqual() throws IOException, InterruptedException {\n", "        String inputImage = SOURCE_FOLDER + \"Im1_1.jpg\";\n", "        String cmpImage = SOURCE_FOLDER + \"cmp_Im1_1.jpg\";\n", "        String diff = DESTINATION_FOLDER + \"diff_differentImagesFuzzNotEnough.png\";\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        boolean result = imageMagickHelper.runImageMagickImageCompare(inputImage, cmpImage, diff, \"0.1\");\n", "\n", "        Assert.assertFalse(result);\n", "        Assert.assertTrue(FileUtil.fileExists(diff));\n", "    }\n", "\n", "    @Test\n", "    public void runImageMagickForDifferentImagesWithFuzzParamEqual() throws IOException, InterruptedException {\n", "        String inputImage = SOURCE_FOLDER + \"Im1_1.jpg\";\n", "        String cmpImage = SOURCE_FOLDER + \"cmp_Im1_1.jpg\";\n", "        String diff = DESTINATION_FOLDER + \"diff_differentImagesFuzzEnough.png\";\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        boolean result = imageMagickHelper.runImageMagickImageCompare(inputImage, cmpImage, diff, \"2.1\");\n", "\n", "        Assert.assertTrue(result);\n", "        Assert.assertTrue(FileUtil.fileExists(diff));\n", "    }\n", "\n", "    @Test\n", "    public void outImageCallsHelpTest() {\n", "        String cmpImage = SOURCE_FOLDER + \"cmp_Im1_1.jpg\";\n", "        String diff = DESTINATION_FOLDER + \"diff.png\";\n", "\n", "        String outImage = SOURCE_FOLDER + \"Im1_1.jpg' -help '\" + cmpImage + \"' '\" + diff;\n", "\n", "        Object storedPrintStream = System.out;\n", "        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n", "            System.setOut(new PrintStream(baos));\n", "\n", "            ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "\n", "            // In .NET the type of the thrown exception is different, therefore we just check here that\n", "            // any exception has been thrown.\n", "            Assert.assertThrows(Exception.class,\n", "                    () -> imageMagickHelper.runImageMagickImageCompare(outImage, cmpImage, diff));\n", "\n", "            // Previously a lengthy help message was printed\n", "            System.out.flush();\n", "            Assert.assertTrue(baos.toByteArray().length < SYSTEM_OUT_LENGTH_LIMIT);\n", "        } catch (IOException e) {\n", "            Assert.fail(\"No exception is excepted here.\");\n", "        } finally {\n", "            StandardOutUtil.restoreStandardOut(storedPrintStream);\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void cmpImageCallsHelpTest() {\n", "        String outImage = SOURCE_FOLDER + \"Im1_1.jpg\";\n", "        String diff = DESTINATION_FOLDER + \"diff.png\";\n", "        String cmpImage = SOURCE_FOLDER + \"cmp_Im1_1.jpg' -help '\" + diff;\n", "\n", "        Object storedPrintStream = System.out;\n", "        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n", "            System.setOut(new PrintStream(baos));\n", "\n", "            ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "\n", "            // In .NET the type of the thrown exception is different, therefore we just check here that\n", "            // any exception has been thrown.\n", "            Assert.assertThrows(Exception.class,\n", "                    () -> imageMagickHelper.runImageMagickImageCompare(outImage, cmpImage, diff));\n", "\n", "            // Previously a lengthy help message was printed\n", "            System.out.flush();\n", "            Assert.assertTrue(baos.toByteArray().length < SYSTEM_OUT_LENGTH_LIMIT);\n", "        } catch (IOException e) {\n", "            Assert.fail(\"No exception is excepted here.\");\n", "        } finally {\n", "            StandardOutUtil.restoreStandardOut(storedPrintStream);\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void fuzzinessCallsHelpTest() {\n", "        String outImage = SOURCE_FOLDER + \"Im1_1.jpg\";\n", "        String diff = DESTINATION_FOLDER + \"diff.png\";\n", "        String cmpImage = SOURCE_FOLDER + \"cmp_Im1_1.jpg\";\n", "\n", "        String fuzziness = \"1% -help \";\n", "\n", "        Object storedPrintStream = System.out;\n", "        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n", "            System.setOut(new PrintStream(baos));\n", "\n", "            ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "\n", "            // In .NET the type of the thrown exception is different, therefore we just check here that\n", "            // any exception has been thrown.\n", "            Assert.assertThrows(Exception.class,\n", "                    () -> imageMagickHelper.runImageMagickImageCompare(outImage, cmpImage, diff, fuzziness));\n", "\n", "            // Previously a lengthy help message was printed\n", "            System.out.flush();\n", "            Assert.assertTrue(baos.toByteArray().length < SYSTEM_OUT_LENGTH_LIMIT);\n", "        } catch (IOException e) {\n", "            Assert.fail(\"No exception is excepted here.\");\n", "        } finally {\n", "            StandardOutUtil.restoreStandardOut(storedPrintStream);\n", "        }\n", "    }\n", "\n", "    @Test\n", "    // In this test we will pass several arguments as the first one. Previously that resulted in\n", "    // different rather than equal images being compared. Now we expect an exception\n", "    public void passOutAndCmpAndDiffAsOutTest() throws IOException, InterruptedException {\n", "        String image = SOURCE_FOLDER + \"image.png\";\n", "        String differentImage = SOURCE_FOLDER + \"Im1_1.jpg\";\n", "\n", "        String diff = DESTINATION_FOLDER + \"diff_equalImages.png\";\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        Assert.assertThrows(Exception.class,\n", "                () -> imageMagickHelper.runImageMagickImageCompare(\n", "                        image + \"' '\" + differentImage + \"' '\" + diff,\n", "                        image,\n", "                        diff));\n", "    }\n", "\n", "    @Test\n", "    // In this test we will pass several arguments as the second one. Previously that resulted in\n", "    // diff being overridden (second diff was used). Now we expect an exception\n", "    public void passCmpAndDiffAsDiffTest() throws IOException, InterruptedException {\n", "        String image = SOURCE_FOLDER + \"image.png\";\n", "\n", "        String diff = DESTINATION_FOLDER + \"diff_equalImages.png\";\n", "        String secondDiff = DESTINATION_FOLDER + \"diff_secondEqualImages.png\";\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        Assert.assertThrows(Exception.class,\n", "                () -> imageMagickHelper.runImageMagickImageCompare(\n", "                        image,\n", "                        image + \"' '\" + secondDiff,\n", "                        diff));\n", "    }\n", "\n", "    @Test\n", "    // In this test we will pass several arguments, including fuzziness, as the first one.\n", "    // Previously that resulted in different images being compared and the number of different bytes\n", "    // being printed to System.out. Now we expect an exception\n", "    public void passFuzzinessAsOutTest() {\n", "        String image = SOURCE_FOLDER + \"image.png\";\n", "        String differentImage = SOURCE_FOLDER + \"Im1_1.jpg\";\n", "\n", "        String diff = DESTINATION_FOLDER + \"diff.png\";\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        Assert.assertThrows(Exception.class, () ->\n", "                imageMagickHelper.runImageMagickImageCompare(\n", "                        image + \"' -metric AE -fuzz 1% '\" + differentImage + \"' '\" + diff,\n", "                        image,\n", "                        diff));\n", "    }\n", "\n", "    @Test\n", "    // When fuzziness is specified, ImageMagick prints to standard output the number of different bytes.\n", "    // Since we compare equal images, we expect this number to be zero.\n", "    public void compareEqualsImagesAndCheckFuzzinessTest() {\n", "        String image = SOURCE_FOLDER + \"image.png\";\n", "        String diff = DESTINATION_FOLDER + \"diff_equalImages.png\";\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        Object storedPrintStream = System.out;\n", "        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();) {\n", "            System.setOut(new PrintStream(baos));\n", "            boolean result = imageMagickHelper.runImageMagickImageCompare(\n", "                    image,\n", "                    image,\n", "                    diff, \"1\");\n", "\n", "            Assert.assertTrue(result);\n", "            Assert.assertTrue(FileUtil.fileExists(diff));\n", "\n", "            System.out.flush();\n", "            String output = new String(baos.toByteArray()).trim();\n", "\n", "            // This check is implemented in such a peculiar way because of .NET autoporting\n", "            Assert.assertEquals('0', output.charAt(output.length() - 1));\n", "            if (output.length() > 1) {\n", "                Assert.assertFalse(Character.isDigit(output.charAt(output.length() - 2)));\n", "            }\n", "        } catch (Exception e) {\n", "            Assert.fail(\"No exception is expected here.\");\n", "        } finally {\n", "            StandardOutUtil.restoreStandardOut(storedPrintStream);\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void compareEqualImagesAndGetResult() throws InterruptedException, IOException {\n", "        String image = SOURCE_FOLDER + \"image.png\";\n", "        String diff = DESTINATION_FOLDER + \"diff_equalImages_result.png\";\n", "\n", "        ImageMagickCompareResult result = new ImageMagickHelper().runImageMagickImageCompareAndGetResult(\n", "                image,\n", "                image,\n", "                diff,\n", "                \"1\");\n", "\n", "        Assert.assertTrue(result.isComparingResultSuccessful());\n", "        Assert.assertEquals(0, result.getDiffPixels());\n", "    }\n", "\n", "    @Test\n", "    public void compareDifferentImagesAndGetResult() throws InterruptedException, IOException {\n", "        String image = SOURCE_FOLDER + \"image.png\";\n", "        String image2 = SOURCE_FOLDER + \"Im1_1.jpg\";\n", "        String diff = DESTINATION_FOLDER + \"diff_equalImages.png\";\n", "\n", "        ImageMagickCompareResult result = new ImageMagickHelper().runImageMagickImageCompareAndGetResult(\n", "                image,\n", "                image2,\n", "                diff, \"1\");\n", "\n", "        Assert.assertFalse(result.isComparingResultSuccessful());\n", "    }\n", "\n", "    @Test\n", "    public void runImageMagickImageCompareEqualWithThreshold() throws IOException, InterruptedException {\n", "        String image = SOURCE_FOLDER + \"image.png\";\n", "        String image2 = SOURCE_FOLDER + \"image.png\";\n", "        String diff = DESTINATION_FOLDER + \"diff_equalImages.png\";\n", "\n", "        boolean result = new ImageMagickHelper().runImageMagickImageCompareWithThreshold(\n", "                image,\n", "                image2,\n", "                diff,\n", "                \"0\",\n", "                0);\n", "\n", "        Assert.assertTrue(result);\n", "    }\n", "\n", "    @Test\n", "    public void runImageMagickImageCompareWithEnoughThreshold() throws IOException, InterruptedException {\n", "        String image = SOURCE_FOLDER + \"image.png\";\n", "        String image2 = SOURCE_FOLDER + \"Im1_1.jpg\";\n", "        String diff = DESTINATION_FOLDER + \"diff_equalImages.png\";\n", "\n", "        boolean result = new ImageMagickHelper().runImageMagickImageCompareWithThreshold(\n", "                image,\n", "                image2,\n", "                diff,\n", "                \"20\",\n", "                2000000);\n", "\n", "        Assert.assertTrue(result);\n", "    }\n", "\n", "    @Test\n", "    public void runImageMagickImageCompareWithNotEnoughThreshold() throws IOException, InterruptedException {\n", "        String image = SOURCE_FOLDER + \"image.png\";\n", "        String image2 = SOURCE_FOLDER + \"Im1_1.jpg\";\n", "        String diff = DESTINATION_FOLDER + \"diff_equalImages.png\";\n", "\n", "        boolean result = new ImageMagickHelper().runImageMagickImageCompareWithThreshold(\n", "                image,\n", "                image2,\n", "                diff,\n", "                \"20\",\n", "                2000);\n", "\n", "        Assert.assertFalse(result);\n", "    }\n", "\n", "}\n"], "method_lines_dic": {"ImageMagickHelper::::getCliExecutionCommand()": [95, 97], "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String)": [112, 115], "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String,java.lang.String)": [132, 138], "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)": [159, 169], "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)": [190, 223], "ImageMagickHelper::::validateFuzziness(java.lang.String)": [225, 237], "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)": [239, 262]}, "test_method_lines_dic": {"ImageMagickHelperTest::::setUp()": [52, 55], "ImageMagickHelperTest::::imageMagickEnvVarIsDefault()": [57, 61], "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()": [63, 75], "ImageMagickHelperTest::::imageMagickEnvVarIsNull()": [77, 88], "ImageMagickHelperTest::::imageMagickEnvVarIsIncorrect()": [90, 96], "ImageMagickHelperTest::::runImageMagickForEqualImages()": [98, 109], "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()": [111, 122], "ImageMagickHelperTest::::runImageMagickForDifferentImages()": [124, 135], "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()": [137, 148], "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()": [150, 161], "ImageMagickHelperTest::::outImageCallsHelpTest()": [163, 189], "ImageMagickHelperTest::::cmpImageCallsHelpTest()": [191, 216], "ImageMagickHelperTest::::fuzzinessCallsHelpTest()": [218, 245], "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()": [247, 262], "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()": [264, 279], "ImageMagickHelperTest::::passFuzzinessAsOutTest()": [281, 297], "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()": [299, 331], "ImageMagickHelperTest::::compareEqualImagesAndGetResult()": [333, 346], "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()": [348, 360], "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()": [362, 376], "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()": [378, 392], "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()": [394, 408]}, "reverse_method_lines_dic": {"95": "ImageMagickHelper::::getCliExecutionCommand()", "96": "ImageMagickHelper::::getCliExecutionCommand()", "97": "ImageMagickHelper::::getCliExecutionCommand()", "112": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String)", "113": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String)", "114": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String)", "115": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String)", "132": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "133": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "134": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "135": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "136": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "137": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "138": "ImageMagickHelper::::runImageMagickImageCompare(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "159": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "160": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "161": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "162": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "163": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "164": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "165": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "166": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "167": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "168": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "169": "ImageMagickHelper::::runImageMagickImageCompareWithThreshold(java.lang.String,java.lang.String,java.lang.String,java.lang.String,long)", "190": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "191": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "192": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "193": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "194": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "195": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "196": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "197": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "198": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "199": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "200": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "201": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "202": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "203": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "204": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "205": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "206": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "207": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "208": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "209": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "210": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "211": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "212": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "213": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "214": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "215": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "216": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "217": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "218": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "219": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "220": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "221": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "222": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "223": "ImageMagickHelper::::runImageMagickImageCompareAndGetResult(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "225": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "226": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "227": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "228": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "229": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "230": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "231": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "232": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "233": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "234": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "235": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "236": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "237": "ImageMagickHelper::::validateFuzziness(java.lang.String)", "239": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "240": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "241": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "242": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "243": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "244": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "245": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "246": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "247": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "248": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "249": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "250": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "251": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "252": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "253": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "254": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "255": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "256": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "257": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "258": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "259": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "260": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "261": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)", "262": "ImageMagickHelper::::parseImageMagickProcessOutput(java.lang.String)"}, "test_reverse_method_lines_dic": {"52": "ImageMagickHelperTest::::setUp()", "53": "ImageMagickHelperTest::::setUp()", "54": "ImageMagickHelperTest::::setUp()", "55": "ImageMagickHelperTest::::setUp()", "57": "ImageMagickHelperTest::::imageMagickEnvVarIsDefault()", "58": "ImageMagickHelperTest::::imageMagickEnvVarIsDefault()", "59": "ImageMagickHelperTest::::imageMagickEnvVarIsDefault()", "60": "ImageMagickHelperTest::::imageMagickEnvVarIsDefault()", "61": "ImageMagickHelperTest::::imageMagickEnvVarIsDefault()", "63": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "64": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "65": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "66": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "67": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "68": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "69": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "70": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "71": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "72": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "73": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "74": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "75": "ImageMagickHelperTest::::imageMagickEnvVarIsExplicitlySpecified()", "77": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "78": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "79": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "80": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "81": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "82": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "83": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "84": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "85": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "86": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "87": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "88": "ImageMagickHelperTest::::imageMagickEnvVarIsNull()", "90": "ImageMagickHelperTest::::imageMagickEnvVarIsIncorrect()", "91": "ImageMagickHelperTest::::imageMagickEnvVarIsIncorrect()", "92": "ImageMagickHelperTest::::imageMagickEnvVarIsIncorrect()", "93": "ImageMagickHelperTest::::imageMagickEnvVarIsIncorrect()", "94": "ImageMagickHelperTest::::imageMagickEnvVarIsIncorrect()", "95": "ImageMagickHelperTest::::imageMagickEnvVarIsIncorrect()", "96": "ImageMagickHelperTest::::imageMagickEnvVarIsIncorrect()", "98": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "99": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "100": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "101": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "102": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "103": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "104": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "105": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "106": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "107": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "108": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "109": "ImageMagickHelperTest::::runImageMagickForEqualImages()", "111": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "112": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "113": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "114": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "115": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "116": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "117": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "118": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "119": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "120": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "121": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "122": "ImageMagickHelperTest::::runImageMagickForEqualImagesWithFuzzParam()", "124": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "125": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "126": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "127": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "128": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "129": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "130": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "131": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "132": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "133": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "134": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "135": "ImageMagickHelperTest::::runImageMagickForDifferentImages()", "137": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "138": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "139": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "140": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "141": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "142": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "143": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "144": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "145": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "146": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "147": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "148": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamNotEqual()", "150": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "151": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "152": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "153": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "154": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "155": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "156": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "157": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "158": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "159": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "160": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "161": "ImageMagickHelperTest::::runImageMagickForDifferentImagesWithFuzzParamEqual()", "163": "ImageMagickHelperTest::::outImageCallsHelpTest()", "164": "ImageMagickHelperTest::::outImageCallsHelpTest()", "165": "ImageMagickHelperTest::::outImageCallsHelpTest()", "166": "ImageMagickHelperTest::::outImageCallsHelpTest()", "167": "ImageMagickHelperTest::::outImageCallsHelpTest()", "168": "ImageMagickHelperTest::::outImageCallsHelpTest()", "169": "ImageMagickHelperTest::::outImageCallsHelpTest()", "170": "ImageMagickHelperTest::::outImageCallsHelpTest()", "171": "ImageMagickHelperTest::::outImageCallsHelpTest()", "172": "ImageMagickHelperTest::::outImageCallsHelpTest()", "173": "ImageMagickHelperTest::::outImageCallsHelpTest()", "174": "ImageMagickHelperTest::::outImageCallsHelpTest()", "175": "ImageMagickHelperTest::::outImageCallsHelpTest()", "176": "ImageMagickHelperTest::::outImageCallsHelpTest()", "177": "ImageMagickHelperTest::::outImageCallsHelpTest()", "178": "ImageMagickHelperTest::::outImageCallsHelpTest()", "179": "ImageMagickHelperTest::::outImageCallsHelpTest()", "180": "ImageMagickHelperTest::::outImageCallsHelpTest()", "181": "ImageMagickHelperTest::::outImageCallsHelpTest()", "182": "ImageMagickHelperTest::::outImageCallsHelpTest()", "183": "ImageMagickHelperTest::::outImageCallsHelpTest()", "184": "ImageMagickHelperTest::::outImageCallsHelpTest()", "185": "ImageMagickHelperTest::::outImageCallsHelpTest()", "186": "ImageMagickHelperTest::::outImageCallsHelpTest()", "187": "ImageMagickHelperTest::::outImageCallsHelpTest()", "188": "ImageMagickHelperTest::::outImageCallsHelpTest()", "189": "ImageMagickHelperTest::::outImageCallsHelpTest()", "191": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "192": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "193": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "194": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "195": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "196": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "197": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "198": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "199": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "200": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "201": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "202": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "203": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "204": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "205": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "206": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "207": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "208": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "209": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "210": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "211": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "212": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "213": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "214": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "215": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "216": "ImageMagickHelperTest::::cmpImageCallsHelpTest()", "218": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "219": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "220": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "221": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "222": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "223": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "224": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "225": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "226": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "227": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "228": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "229": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "230": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "231": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "232": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "233": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "234": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "235": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "236": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "237": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "238": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "239": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "240": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "241": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "242": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "243": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "244": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "245": "ImageMagickHelperTest::::fuzzinessCallsHelpTest()", "247": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "248": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "249": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "250": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "251": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "252": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "253": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "254": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "255": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "256": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "257": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "258": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "259": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "260": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "261": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "262": "ImageMagickHelperTest::::passOutAndCmpAndDiffAsOutTest()", "264": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "265": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "266": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "267": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "268": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "269": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "270": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "271": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "272": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "273": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "274": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "275": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "276": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "277": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "278": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "279": "ImageMagickHelperTest::::passCmpAndDiffAsDiffTest()", "281": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "282": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "283": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "284": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "285": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "286": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "287": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "288": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "289": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "290": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "291": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "292": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "293": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "294": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "295": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "296": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "297": "ImageMagickHelperTest::::passFuzzinessAsOutTest()", "299": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "300": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "301": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "302": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "303": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "304": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "305": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "306": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "307": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "308": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "309": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "310": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "311": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "312": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "313": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "314": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "315": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "316": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "317": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "318": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "319": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "320": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "321": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "322": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "323": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "324": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "325": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "326": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "327": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "328": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "329": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "330": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "331": "ImageMagickHelperTest::::compareEqualsImagesAndCheckFuzzinessTest()", "333": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "334": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "335": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "336": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "337": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "338": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "339": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "340": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "341": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "342": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "343": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "344": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "345": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "346": "ImageMagickHelperTest::::compareEqualImagesAndGetResult()", "348": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "349": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "350": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "351": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "352": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "353": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "354": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "355": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "356": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "357": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "358": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "359": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "360": "ImageMagickHelperTest::::compareDifferentImagesAndGetResult()", "362": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "363": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "364": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "365": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "366": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "367": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "368": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "369": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "370": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "371": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "372": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "373": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "374": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "375": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "376": "ImageMagickHelperTest::::runImageMagickImageCompareEqualWithThreshold()", "378": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "379": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "380": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "381": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "382": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "383": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "384": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "385": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "386": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "387": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "388": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "389": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "390": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "391": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "392": "ImageMagickHelperTest::::runImageMagickImageCompareWithEnoughThreshold()", "394": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "395": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "396": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "397": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "398": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "399": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "400": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "401": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "402": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "403": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "404": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "405": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "406": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "407": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()", "408": "ImageMagickHelperTest::::runImageMagickImageCompareWithNotEnoughThreshold()"}, "tests": [{"test_lines": [90, 96], "covered_lines": [57, 74, 75, 76, 83, 84]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/util/XmlUtil.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "// Android-Conversion-Skip-Line (Directly use xerces library to unify behavior with vanilla java (where xerces is implemented into JRE))\n", "// Android-Conversion-Replace import org.apache.xerces.jaxp.DocumentBuilderFactoryImpl;\n", "// Android-Conversion-Replace import org.apache.xerces.jaxp.SAXParserFactoryImpl;\n", "import org.w3c.dom.Document;\n", "\n", "import javax.xml.parsers.DocumentBuilderFactory;\n", "import javax.xml.parsers.ParserConfigurationException;\n", "import javax.xml.parsers.SAXParserFactory;\n", "\n", "/**\n", " * This file is a helper class for internal usage only.\n", " * Be aware that its API and functionality may be changed in future.\n", " */\n", "public final class XmlUtil {\n", "\n", "    private XmlUtil() {\n", "    }\n", "\n", "    /**\n", "     * Creates default document builder factory.\n", "     *\n", "     * @return document builder factory implementation\n", "     */\n", "    public static DocumentBuilderFactory getDocumentBuilderFactory() {\n", "        // Android-Conversion-Skip-Line (Directly use xerces library to unify behavior with vanilla java (where xerces is implemented into JRE))\n", "        return DocumentBuilderFactory.newInstance(); // Android-Conversion-Replace return new DocumentBuilderFactoryImpl();\n", "    }\n", "\n", "    /**\n", "     * Creates default SAX parser factory.\n", "     *\n", "     * @return SAX parser factory implementation\n", "     */\n", "    public static SAXParserFactory createSAXParserFactory() {\n", "        // Android-Conversion-Skip-Line (Directly use xerces library to unify behavior with vanilla java (where xerces is implemented into JRE))\n", "        return SAXParserFactory.newInstance(); // Android-Conversion-Replace return new SAXParserFactoryImpl();\n", "    }\n", "\n", "    /**\n", "     * This method creates a new empty Xml document.\n", "     *\n", "     * @return a new Xml document\n", "     * @throws ParserConfigurationException if an error occurs while creating the document\n", "     */\n", "    public static Document initNewXmlDocument() throws ParserConfigurationException {\n", "        return DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n", "    }\n", "\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "// Android-Conversion-Skip-Line (Directly use xerces library to unify behavior with vanilla java (where xerces is implemented into JRE))\n", "// Android-Conversion-Replace import org.apache.xerces.jaxp.DocumentBuilderFactoryImpl;\n", "// Android-Conversion-Replace import org.apache.xerces.jaxp.SAXParserFactoryImpl;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "import org.w3c.dom.Document;\n", "\n", "import javax.xml.parsers.DocumentBuilderFactory;\n", "import javax.xml.parsers.SAXParserFactory;\n", "\n", "@Category(UnitTest.class)\n", "public class XmlUtilTest extends ExtendedITextTest {\n", "\n", "    @Test\n", "    public void initNewXmlDocumentTest() throws Exception {\n", "        Document doc = XmlUtil.initNewXmlDocument();\n", "        Assert.assertNotNull(doc);\n", "    }\n", "\n", "    @Test\n", "    public void getDocumentBuilderFactoryTest() {\n", "        DocumentBuilderFactory factory = XmlUtil.getDocumentBuilderFactory();\n", "\n", "        // Android-Conversion-Skip-Line (Directly use xerces library to unify behavior with vanilla java (where xerces is implemented into JRE))\n", "        Assert.assertEquals(DocumentBuilderFactory.newInstance().getClass(), factory.getClass()); // Android-Conversion-Replace Assert.assertEquals(DocumentBuilderFactoryImpl.class, factory.getClass());\n", "    }\n", "\n", "    @Test\n", "    public void createSAXParserFactoryTest() {\n", "        SAXParserFactory factory = XmlUtil.createSAXParserFactory();\n", "\n", "        // Android-Conversion-Skip-Line (Directly use xerces library to unify behavior with vanilla java (where xerces is implemented into JRE))\n", "        Assert.assertEquals(SAXParserFactory.newInstance().getClass(), factory.getClass()); // Android-Conversion-Replace Assert.assertEquals(SAXParserFactoryImpl.class, factory.getClass());\n", "    }\n", "}\n"], "method_lines_dic": {"XmlUtil::::getDocumentBuilderFactory()": [48, 51], "XmlUtil::::createSAXParserFactory()": [58, 61], "XmlUtil::::initNewXmlDocument()": [69, 71]}, "test_method_lines_dic": {"XmlUtilTest::::initNewXmlDocumentTest()": [41, 45], "XmlUtilTest::::getDocumentBuilderFactoryTest()": [47, 53], "XmlUtilTest::::createSAXParserFactoryTest()": [55, 61]}, "reverse_method_lines_dic": {"48": "XmlUtil::::getDocumentBuilderFactory()", "49": "XmlUtil::::getDocumentBuilderFactory()", "50": "XmlUtil::::getDocumentBuilderFactory()", "51": "XmlUtil::::getDocumentBuilderFactory()", "58": "XmlUtil::::createSAXParserFactory()", "59": "XmlUtil::::createSAXParserFactory()", "60": "XmlUtil::::createSAXParserFactory()", "61": "XmlUtil::::createSAXParserFactory()", "69": "XmlUtil::::initNewXmlDocument()", "70": "XmlUtil::::initNewXmlDocument()", "71": "XmlUtil::::initNewXmlDocument()"}, "test_reverse_method_lines_dic": {"41": "XmlUtilTest::::initNewXmlDocumentTest()", "42": "XmlUtilTest::::initNewXmlDocumentTest()", "43": "XmlUtilTest::::initNewXmlDocumentTest()", "44": "XmlUtilTest::::initNewXmlDocumentTest()", "45": "XmlUtilTest::::initNewXmlDocumentTest()", "47": "XmlUtilTest::::getDocumentBuilderFactoryTest()", "48": "XmlUtilTest::::getDocumentBuilderFactoryTest()", "49": "XmlUtilTest::::getDocumentBuilderFactoryTest()", "50": "XmlUtilTest::::getDocumentBuilderFactoryTest()", "51": "XmlUtilTest::::getDocumentBuilderFactoryTest()", "52": "XmlUtilTest::::getDocumentBuilderFactoryTest()", "53": "XmlUtilTest::::getDocumentBuilderFactoryTest()", "55": "XmlUtilTest::::createSAXParserFactoryTest()", "56": "XmlUtilTest::::createSAXParserFactoryTest()", "57": "XmlUtilTest::::createSAXParserFactoryTest()", "58": "XmlUtilTest::::createSAXParserFactoryTest()", "59": "XmlUtilTest::::createSAXParserFactoryTest()", "60": "XmlUtilTest::::createSAXParserFactoryTest()", "61": "XmlUtilTest::::createSAXParserFactoryTest()"}, "tests": [{"test_lines": [41, 45], "covered_lines": [70]}, {"test_lines": [47, 53], "covered_lines": [50]}, {"test_lines": [55, 61], "covered_lines": [60]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/util/GhostscriptHelper.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "import com.itextpdf.commons.utils.SystemUtil;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "\n", "import java.io.IOException;\n", "import java.nio.file.Paths;\n", "import java.util.regex.Pattern;\n", "\n", "/**\n", " * A utility class that is used as an interface to run 3rd-party tool Ghostscript.\n", " * Ghostscript is an interpreter for the PostScript language and PDF files, it allows to render them\n", " * as images.\n", " *\n", " * <p>\n", " * The Ghostscript needs to be installed independently on the system. This class provides a convenient\n", " * way to run it by passing a terminal command. The command can either be specified explicitly or by a mean\n", " * of environment variable {@link #GHOSTSCRIPT_ENVIRONMENT_VARIABLE}.\n", " */\n", "public class GhostscriptHelper {\n", "    /**\n", "     * The name of the environment variable with the command to execute Ghostscript operations.\n", "     */\n", "    public static final String GHOSTSCRIPT_ENVIRONMENT_VARIABLE = \"ITEXT_GS_EXEC\";\n", "\n", "    @Deprecated\n", "    static final String GHOSTSCRIPT_ENVIRONMENT_VARIABLE_LEGACY = \"gsExec\";\n", "\n", "    static final String GHOSTSCRIPT_KEYWORD = \"GPL Ghostscript\";\n", "    private static final String TEMP_FILE_PREFIX = \"itext_gs_io_temp\";\n", "\n", "    private static final String RENDERED_IMAGE_EXTENSION = \"png\";\n", "    private static final String GHOSTSCRIPT_PARAMS = \" -dSAFER -dNOPAUSE -dBATCH -sDEVICE=\"\n", "            + RENDERED_IMAGE_EXTENSION + \"16m -r150 {0} -sOutputFile=\\\"{1}\\\" \\\"{2}\\\"\";\n", "    private static final String PAGE_NUMBER_PATTERN = \"%03d\";\n", "\n", "    private static final Pattern PAGE_LIST_REGEX = Pattern.compile(\"^(\\\\d+,)*\\\\d+$\");\n", "\n", "    private String gsExec;\n", "\n", "    /**\n", "     * Creates new instance that will rely on Ghostscript execution command defined by {@link\n", "     * #GHOSTSCRIPT_ENVIRONMENT_VARIABLE} environment variable.\n", "     */\n", "    public GhostscriptHelper() {\n", "        this(null);\n", "    }\n", "\n", "    /**\n", "     * Creates new instance that will rely on Ghostscript execution command defined as passed argument.\n", "     *\n", "     * @param newGsExec the Ghostscript execution command; if null - environment variables will be used instead\n", "     */\n", "    public GhostscriptHelper(String newGsExec) {\n", "        gsExec = newGsExec;\n", "        if (gsExec == null) {\n", "            gsExec = SystemUtil.getPropertyOrEnvironmentVariable(GHOSTSCRIPT_ENVIRONMENT_VARIABLE);\n", "\n", "            if (gsExec == null) {\n", "                gsExec = SystemUtil.getPropertyOrEnvironmentVariable(GHOSTSCRIPT_ENVIRONMENT_VARIABLE_LEGACY);\n", "            }\n", "        }\n", "\n", "        if (!CliCommandUtil.isVersionCommandExecutable(gsExec, GHOSTSCRIPT_KEYWORD)) {\n", "            throw new IllegalArgumentException(IoExceptionMessageConstant.GS_ENVIRONMENT_VARIABLE_IS_NOT_SPECIFIED);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Returns a command that is used to run the utility.\n", "     * This command doesn't contain command parameters. Parameters are added on specific\n", "     * methods invocation.\n", "     *\n", "     * @return a string command\n", "     */\n", "    public String getCliExecutionCommand() {\n", "        return gsExec;\n", "    }\n", "\n", "    /**\n", "     * Runs Ghostscript to render the PDF's pages as PNG images.\n", "     * \n", "     * <p>\n", "     * Note, that this method  may create temporary directory and files.\n", "     *\n", "     * @param pdf    Path to the PDF file to be rendered\n", "     * @param outDir Path to the output directory, in which the rendered pages will be stored\n", "     * @param image  String which defines the name of the resultant images. This string will be\n", "     *               concatenated with the number of the rendered page from the start of the\n", "     *               PDF in \"-%03d\" format, e.g. \"-011\" for the eleventh rendered page and so on.\n", "     *               This number may not correspond to the actual page number: for example,\n", "     *               if the passed pageList equals to \"5,3\", then images with postfixes \"-001.png\"\n", "     *               and \"-002.png\" will be created: the former for the third page, the latter\n", "     *               for the fifth page. \"%\" sign in the passed name is prohibited.\n", "     *\n", "     * @throws IOException          if there are file's reading/writing issues\n", "     * @throws InterruptedException if there is thread interruption while executing GhostScript.\n", "     */\n", "    public void runGhostScriptImageGeneration(String pdf, String outDir, String image)\n", "            throws IOException, InterruptedException {\n", "        runGhostScriptImageGeneration(pdf, outDir, image, null);\n", "    }\n", "\n", "    /**\n", "     * Runs Ghostscript to render the PDF's pages as PNG images.\n", "     * \n", "     * <p>\n", "     * Note, that this method  may create temporary directory and files.\n", "     *\n", "     * @param pdf    Path to the PDF file to be rendered\n", "     * @param outDir Path to the output directory, in which the rendered pages will be stored\n", "     * @param image  String which defines the name of the resultant images. This string will be\n", "     *               concatenated with the number of the rendered page from the start of the\n", "     *               PDF in \"-%03d\" format, e.g. \"-011\" for the eleventh rendered page and so on.\n", "     *               This number may not correspond to the actual page number: for example,\n", "     *               if the passed pageList equals to \"5,3\", then images with postfixes \"-001.png\"\n", "     *               and \"-002.png\" will be created: the former for the third page, the latter\n", "     *               for the fifth page. \"%\" sign in the passed name is prohibited.\n", "     * @param pageList String with numbers of the required pages to be rendered as images.\n", "     *                 This string should be formatted as a string with numbers, separated by commas,\n", "     *                 without whitespaces. Can be null, if it is required to render all the PDF's pages.\n", "     *\n", "     * @throws IOException          if there are file's reading/writing issues\n", "     * @throws InterruptedException if there is thread interruption while executing GhostScript.\n", "     */\n", "    public void runGhostScriptImageGeneration(String pdf, String outDir, String image, String pageList)\n", "            throws IOException, InterruptedException {\n", "        if (!FileUtil.directoryExists(outDir)) {\n", "            throw new IllegalArgumentException(\n", "                    IoExceptionMessageConstant.CANNOT_OPEN_OUTPUT_DIRECTORY.replace(\"<filename>\", pdf));\n", "        }\n", "        if (!validateImageFilePattern(image)) {\n", "            throw new IllegalArgumentException(\"Invalid output image pattern: \" + image);\n", "        }\n", "        if (!validatePageList(pageList)) {\n", "            throw new IllegalArgumentException(\"Invalid page list: \" + pageList);\n", "        }\n", "        String formattedPageList = (pageList == null) ? \"\" : \"-sPageList=<pagelist>\".replace(\"<pagelist>\", pageList);\n", "\n", "        String replacementPdf = null;\n", "        String replacementImagesDirectory = null;\n", "        String[] temporaryOutputImages = null;\n", "        try {\n", "            replacementPdf = FileUtil.createTempCopy(pdf, TEMP_FILE_PREFIX, null);\n", "            replacementImagesDirectory = FileUtil.createTempDirectory(TEMP_FILE_PREFIX);\n", "            String currGsParams = MessageFormatUtil.format(GHOSTSCRIPT_PARAMS, formattedPageList,\n", "                    Paths.get(replacementImagesDirectory,\n", "                            TEMP_FILE_PREFIX + PAGE_NUMBER_PATTERN + \".\" + RENDERED_IMAGE_EXTENSION).toString(),\n", "                    replacementPdf);\n", "\n", "            if (!SystemUtil.runProcessAndWait(gsExec, currGsParams)) {\n", "                temporaryOutputImages = FileUtil\n", "                        .listFilesInDirectory(replacementImagesDirectory, false);\n", "                throw new GhostscriptExecutionException(\n", "                        IoExceptionMessageConstant.GHOSTSCRIPT_FAILED.replace(\"<filename>\", pdf));\n", "            }\n", "\n", "            temporaryOutputImages = FileUtil\n", "                    .listFilesInDirectory(replacementImagesDirectory, false);\n", "            if (null != temporaryOutputImages) {\n", "                for (int i = 0; i < temporaryOutputImages.length; i++) {\n", "                    FileUtil.copy(temporaryOutputImages[i],\n", "                            Paths.get(\n", "                                    outDir,\n", "                                    image + \"-\" + formatImageNumber(i + 1) + \".\" + RENDERED_IMAGE_EXTENSION\n", "                            ).toString());\n", "                }\n", "            }\n", "        } finally {\n", "            if (null != temporaryOutputImages) {\n", "                FileUtil.removeFiles(temporaryOutputImages);\n", "            }\n", "            FileUtil.removeFiles(new String[] {replacementImagesDirectory, replacementPdf});\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Exceptions thrown when errors occur during generation and comparison of images obtained on the basis of pdf\n", "     * files.\n", "     */\n", "    public static class GhostscriptExecutionException extends RuntimeException {\n", "        /**\n", "         * Creates a new {@link GhostscriptExecutionException}.\n", "         *\n", "         * @param msg the detail message.\n", "         */\n", "        public GhostscriptExecutionException(String msg) {\n", "            super(msg);\n", "        }\n", "    }\n", "\n", "    static boolean validatePageList(String pageList) {\n", "        return null == pageList\n", "                || PAGE_LIST_REGEX.matcher(pageList).matches();\n", "    }\n", "\n", "    static boolean validateImageFilePattern(String imageFilePattern) {\n", "        return null != imageFilePattern\n", "                && !imageFilePattern.trim().isEmpty()\n", "                && !imageFilePattern.contains(\"%\");\n", "    }\n", "\n", "    static String formatImageNumber(int pageNumber) {\n", "        StringBuilder stringBuilder = new StringBuilder();\n", "        int zeroFiller = pageNumber;\n", "        while (0 == zeroFiller / 100) {\n", "            stringBuilder.append('0');\n", "            zeroFiller *= 10;\n", "        }\n", "        stringBuilder.append(pageNumber);\n", "        return stringBuilder.toString();\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.commons.utils.SystemUtil;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.IntegrationTest;\n", "\n", "import java.io.ByteArrayOutputStream;\n", "import java.io.File;\n", "import java.io.IOException;\n", "import java.io.PrintStream;\n", "import org.junit.Assert;\n", "import org.junit.Before;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(IntegrationTest.class)\n", "// Android-Conversion-Skip-File (ghostscript isn't available on Android)\n", "public class GhostscriptHelperTest extends ExtendedITextTest {\n", "    private final static String SOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/util/GhostscriptHelperTest/\";\n", "    private static final String DESTINATION_FOLDER = \"./target/test/com/itextpdf/io/GhostscriptHelperTest/\";\n", "\n", "    // In some of the test we will check whether Ghostscript has printed its help message to the console.\n", "    // The value of this threshold should be definitely less than the length of the help message.\n", "    private static final int SYSTEM_OUT_LENGTH_LIMIT = 450;\n", "\n", "    @Before\n", "    public void setUp() {\n", "        createOrClearDestinationFolder(DESTINATION_FOLDER);\n", "    }\n", "\n", "    @Test\n", "    public void ghostScriptEnvVarIsDefault() {\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "        Assert.assertNotNull(ghostscriptHelper.getCliExecutionCommand());\n", "    }\n", "\n", "    @Test\n", "    public void ghostScriptEnvVarIsExplicitlySpecified() {\n", "        String gsExec = SystemUtil.getPropertyOrEnvironmentVariable(GhostscriptHelper.GHOSTSCRIPT_ENVIRONMENT_VARIABLE);\n", "        if (gsExec == null) {\n", "            gsExec = SystemUtil\n", "                    .getPropertyOrEnvironmentVariable(GhostscriptHelper.GHOSTSCRIPT_ENVIRONMENT_VARIABLE_LEGACY);\n", "        }\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper(gsExec);\n", "\n", "        Assert.assertNotNull(ghostscriptHelper.getCliExecutionCommand());\n", "    }\n", "\n", "    @Test\n", "    public void ghostScriptEnvVarIsNull() {\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper(null);\n", "\n", "        Assert.assertNotNull(ghostscriptHelper.getCliExecutionCommand());\n", "    }\n", "\n", "    @Test\n", "    public void ghostScriptEnvVarIsIncorrect() {\n", "        Exception e = Assert.assertThrows(IllegalArgumentException.class,\n", "                () -> new GhostscriptHelper(\"-\")\n", "        );\n", "        Assert.assertEquals(IoExceptionMessageConstant.GS_ENVIRONMENT_VARIABLE_IS_NOT_SPECIFIED, e.getMessage());\n", "    }\n", "\n", "    @Test\n", "    public void runGhostScriptIncorrectOutputDirectory() throws IOException, InterruptedException {\n", "        String inputPdf = SOURCE_FOLDER + \"imageHandlerUtilTest.pdf\";\n", "        String exceptionMessage = \"Cannot open output directory for \" + inputPdf;\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "\n", "        Exception e = Assert.assertThrows(IllegalArgumentException.class,\n", "                () -> ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, \"-\",\n", "                        \"outputPageImage.png\", \"1\")\n", "        );\n", "        Assert.assertEquals(exceptionMessage, e.getMessage());\n", "    }\n", "\n", "    @Test\n", "    public void runGhostScriptIncorrectParams() {\n", "        String inputPdf = SOURCE_FOLDER + \"imageHandlerUtilTest.pdf\";\n", "        String invalidPageList = \"q@W\";\n", "        String exceptionMessage = \"Invalid page list: \" + invalidPageList;\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "\n", "        Exception e = Assert.assertThrows(IllegalArgumentException.class,\n", "                () -> ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER,\n", "                        \"outputPageImage.png\", invalidPageList)\n", "        );\n", "        Assert.assertEquals(exceptionMessage, e.getMessage());\n", "    }\n", "\n", "    @Test\n", "    public void runGhostScriptTestForSpecificPage() throws IOException, InterruptedException {\n", "        String inputPdf = SOURCE_FOLDER + \"imageHandlerUtilTest.pdf\";\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "        ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER,\n", "                \"specificPage\", \"1\");\n", "\n", "        Assert.assertEquals(1, FileUtil.listFilesInDirectory(DESTINATION_FOLDER, true).length);\n", "        Assert.assertTrue(FileUtil.fileExists(DESTINATION_FOLDER + \"specificPage-001.png\"));\n", "    }\n", "\n", "    @Test\n", "    public void runGhostScriptTestForSeveralSpecificPages() throws IOException, InterruptedException {\n", "        String inputPdf = SOURCE_FOLDER + \"imageHandlerUtilTest.pdf\";\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "        String imageFileName = new File(inputPdf).getName() + \"_severalSpecificPages\";\n", "        ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER,\n", "                imageFileName, \"1,3\");\n", "\n", "        Assert.assertEquals(2, FileUtil.listFilesInDirectory(DESTINATION_FOLDER, true).length);\n", "        Assert.assertTrue(\n", "                FileUtil.fileExists(DESTINATION_FOLDER + \"imageHandlerUtilTest.pdf_severalSpecificPages-001.png\"));\n", "        Assert.assertTrue(\n", "                FileUtil.fileExists(DESTINATION_FOLDER + \"imageHandlerUtilTest.pdf_severalSpecificPages-002.png\"));\n", "    }\n", "\n", "    @Test\n", "    public void runGhostScriptTestForAllPages() throws IOException, InterruptedException {\n", "        String inputPdf = SOURCE_FOLDER + \"imageHandlerUtilTest.pdf\";\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "        String imageFileName = new File(inputPdf).getName() + \"_allPages\";\n", "        ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER, imageFileName);\n", "\n", "        Assert.assertEquals(3, FileUtil.listFilesInDirectory(DESTINATION_FOLDER, true).length);\n", "        Assert.assertTrue(FileUtil.fileExists(DESTINATION_FOLDER + \"imageHandlerUtilTest.pdf_allPages-001.png\"));\n", "        Assert.assertTrue(FileUtil.fileExists(DESTINATION_FOLDER + \"imageHandlerUtilTest.pdf_allPages-002.png\"));\n", "        Assert.assertTrue(FileUtil.fileExists(DESTINATION_FOLDER + \"imageHandlerUtilTest.pdf_allPages-003.png\"));\n", "    }\n", "\n", "    @Test\n", "    public void dSaferParamInGhostScriptHelperTest() throws IOException, InterruptedException {\n", "        String input = SOURCE_FOLDER + \"unsafePostScript.ps\";\n", "        String outputName = \"unsafePostScript.png\";\n", "\n", "        try {\n", "            GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "            ghostscriptHelper.runGhostScriptImageGeneration(input, DESTINATION_FOLDER, outputName);\n", "        } catch (GhostscriptHelper.GhostscriptExecutionException e) {\n", "            System.out.println(\"Error code was returned on processing of malicious script with -dSAFER option enabled. \"\n", "                    + \"This is expected for some environments and ghostscript versions. \"\n", "                    + \"We assert only the absence of malicious script result (created file).\\n\");\n", "        }\n", "\n", "        // If we had not set -dSAFER option, the following files would be created\n", "        String maliciousResult1 = DESTINATION_FOLDER + \"output1.txt\";\n", "        String maliciousResult2 = DESTINATION_FOLDER + \"output2.txt\";\n", "\n", "        Assert.assertFalse(FileUtil.fileExists(maliciousResult1));\n", "        Assert.assertFalse(FileUtil.fileExists(maliciousResult2));\n", "    }\n", "\n", "    @Test\n", "    public void ghostScriptImageGenerationTest() throws IOException, InterruptedException {\n", "        String name = \"resultantImage\";\n", "        String filename = name + \".png\";\n", "        String psFile = SOURCE_FOLDER + \"simple.ps\";\n", "        String resultantImage = DESTINATION_FOLDER + name + \"-001.png\";\n", "        String cmpResultantImage = SOURCE_FOLDER + \"cmp_\" + filename;\n", "        String diff = DESTINATION_FOLDER + \"diff_\" + filename;\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "        ghostscriptHelper.runGhostScriptImageGeneration(psFile, DESTINATION_FOLDER, name);\n", "        Assert.assertTrue(FileUtil.fileExists(resultantImage));\n", "\n", "        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();\n", "        Assert.assertTrue(imageMagickHelper.runImageMagickImageCompare(resultantImage, cmpResultantImage, diff));\n", "    }\n", "\n", "    @Test\n", "    // Previously this test printed help message. Now an exception should be thrown.\n", "    public void pdfCallsHelpTest() {\n", "        String inputPdf = SOURCE_FOLDER + \"../test.pdf -h\";\n", "        String outputImagePattern = \"image\";\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "\n", "        // In .NET the type of the thrown exception is different, therefore we just check here that\n", "        // any exception has been thrown.\n", "        Assert.assertThrows(Exception.class, () ->\n", "                ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER, outputImagePattern));\n", "    }\n", "\n", "    @Test\n", "    public void outputImageCallsHelpTest() throws IOException {\n", "        String inputPdf = SOURCE_FOLDER + \"../test.pdf\";\n", "        String outputImagePattern = \"justSomeText \\\" -h\";\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "\n", "        Object storedPrintStream = System.out;\n", "        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n", "        try {\n", "            System.setOut(new PrintStream(baos));\n", "            ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER, outputImagePattern);\n", "        } catch (Exception e) {\n", "            // This test fails on Windows, but works on Linux. So our goal is not to check\n", "            // whether an exception was thrown, but whether there is the help message in the output\n", "        } finally {\n", "            System.out.flush();\n", "            StandardOutUtil.restoreStandardOut(storedPrintStream);\n", "            Assert.assertTrue(baos.toByteArray().length < SYSTEM_OUT_LENGTH_LIMIT);\n", "            baos.close();\n", "        }\n", "    }\n", "\n", "    @Test\n", "    // Previously this test printed help message. Now an exception should be thrown.\n", "    public void pageListCallsHelpTest() {\n", "        String inputPdf = SOURCE_FOLDER + \"../test.pdf\";\n", "        String outputImagePattern = \"justSomeText\";\n", "        String pageList = \"1 -h\";\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "\n", "        // In .NET the type of the thrown exception is different, therefore we just check here that\n", "        // any exception has been thrown.\n", "        Assert.assertThrows(Exception.class, () ->\n", "                ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER,\n", "                        outputImagePattern, pageList));\n", "    }\n", "\n", "    @Test\n", "    public void nonExistingDestinationFolder() {\n", "        String inputPdf = SOURCE_FOLDER + \"../test.pdf\";\n", "        String outputImagePattern = \"justSomeText\";\n", "        String destinationFolder = \"notExistingFolder\";\n", "\n", "        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();\n", "\n", "        // In .NET the type of the thrown exception is different, therefore we just check here that\n", "        // any exception has been thrown.\n", "        Assert.assertThrows(Exception.class,\n", "                () -> ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, destinationFolder,\n", "                        outputImagePattern));\n", "    }\n", "}\n"], "method_lines_dic": {"GhostscriptHelper::::getCliExecutionCommand()": [100, 102], "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String)": [123, 126], "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)": [150, 199], "GhostscriptHelper::::validatePageList(java.lang.String)": [216, 219], "GhostscriptHelper::::validateImageFilePattern(java.lang.String)": [221, 225], "GhostscriptHelper::::formatImageNumber(int)": [227, 236]}, "test_method_lines_dic": {"GhostscriptHelperTest::::setUp()": [50, 53], "GhostscriptHelperTest::::ghostScriptEnvVarIsDefault()": [55, 59], "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()": [61, 72], "GhostscriptHelperTest::::ghostScriptEnvVarIsNull()": [74, 79], "GhostscriptHelperTest::::ghostScriptEnvVarIsIncorrect()": [81, 87], "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()": [89, 101], "GhostscriptHelperTest::::runGhostScriptIncorrectParams()": [103, 116], "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()": [118, 128], "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()": [130, 144], "GhostscriptHelperTest::::runGhostScriptTestForAllPages()": [146, 158], "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()": [160, 180], "GhostscriptHelperTest::::ghostScriptImageGenerationTest()": [182, 197], "GhostscriptHelperTest::::pdfCallsHelpTest()": [199, 211], "GhostscriptHelperTest::::outputImageCallsHelpTest()": [213, 234], "GhostscriptHelperTest::::pageListCallsHelpTest()": [236, 250], "GhostscriptHelperTest::::nonExistingDestinationFolder()": [252, 265]}, "reverse_method_lines_dic": {"100": "GhostscriptHelper::::getCliExecutionCommand()", "101": "GhostscriptHelper::::getCliExecutionCommand()", "102": "GhostscriptHelper::::getCliExecutionCommand()", "123": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String)", "124": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String)", "125": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String)", "126": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String)", "150": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "151": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "152": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "153": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "154": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "155": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "156": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "157": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "158": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "159": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "160": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "161": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "162": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "163": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "164": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "165": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "166": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "167": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "168": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "169": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "170": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "171": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "172": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "173": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "174": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "175": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "176": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "177": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "178": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "179": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "180": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "181": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "182": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "183": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "184": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "185": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "186": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "187": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "188": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "189": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "190": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "191": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "192": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "193": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "194": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "195": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "196": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "197": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "198": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "199": "GhostscriptHelper::::runGhostScriptImageGeneration(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "216": "GhostscriptHelper::::validatePageList(java.lang.String)", "217": "GhostscriptHelper::::validatePageList(java.lang.String)", "218": "GhostscriptHelper::::validatePageList(java.lang.String)", "219": "GhostscriptHelper::::validatePageList(java.lang.String)", "221": "GhostscriptHelper::::validateImageFilePattern(java.lang.String)", "222": "GhostscriptHelper::::validateImageFilePattern(java.lang.String)", "223": "GhostscriptHelper::::validateImageFilePattern(java.lang.String)", "224": "GhostscriptHelper::::validateImageFilePattern(java.lang.String)", "225": "GhostscriptHelper::::validateImageFilePattern(java.lang.String)", "227": "GhostscriptHelper::::formatImageNumber(int)", "228": "GhostscriptHelper::::formatImageNumber(int)", "229": "GhostscriptHelper::::formatImageNumber(int)", "230": "GhostscriptHelper::::formatImageNumber(int)", "231": "GhostscriptHelper::::formatImageNumber(int)", "232": "GhostscriptHelper::::formatImageNumber(int)", "233": "GhostscriptHelper::::formatImageNumber(int)", "234": "GhostscriptHelper::::formatImageNumber(int)", "235": "GhostscriptHelper::::formatImageNumber(int)", "236": "GhostscriptHelper::::formatImageNumber(int)"}, "test_reverse_method_lines_dic": {"50": "GhostscriptHelperTest::::setUp()", "51": "GhostscriptHelperTest::::setUp()", "52": "GhostscriptHelperTest::::setUp()", "53": "GhostscriptHelperTest::::setUp()", "55": "GhostscriptHelperTest::::ghostScriptEnvVarIsDefault()", "56": "GhostscriptHelperTest::::ghostScriptEnvVarIsDefault()", "57": "GhostscriptHelperTest::::ghostScriptEnvVarIsDefault()", "58": "GhostscriptHelperTest::::ghostScriptEnvVarIsDefault()", "59": "GhostscriptHelperTest::::ghostScriptEnvVarIsDefault()", "61": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "62": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "63": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "64": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "65": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "66": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "67": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "68": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "69": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "70": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "71": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "72": "GhostscriptHelperTest::::ghostScriptEnvVarIsExplicitlySpecified()", "74": "GhostscriptHelperTest::::ghostScriptEnvVarIsNull()", "75": "GhostscriptHelperTest::::ghostScriptEnvVarIsNull()", "76": "GhostscriptHelperTest::::ghostScriptEnvVarIsNull()", "77": "GhostscriptHelperTest::::ghostScriptEnvVarIsNull()", "78": "GhostscriptHelperTest::::ghostScriptEnvVarIsNull()", "79": "GhostscriptHelperTest::::ghostScriptEnvVarIsNull()", "81": "GhostscriptHelperTest::::ghostScriptEnvVarIsIncorrect()", "82": "GhostscriptHelperTest::::ghostScriptEnvVarIsIncorrect()", "83": "GhostscriptHelperTest::::ghostScriptEnvVarIsIncorrect()", "84": "GhostscriptHelperTest::::ghostScriptEnvVarIsIncorrect()", "85": "GhostscriptHelperTest::::ghostScriptEnvVarIsIncorrect()", "86": "GhostscriptHelperTest::::ghostScriptEnvVarIsIncorrect()", "87": "GhostscriptHelperTest::::ghostScriptEnvVarIsIncorrect()", "89": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "90": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "91": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "92": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "93": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "94": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "95": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "96": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "97": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "98": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "99": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "100": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "101": "GhostscriptHelperTest::::runGhostScriptIncorrectOutputDirectory()", "103": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "104": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "105": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "106": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "107": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "108": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "109": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "110": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "111": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "112": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "113": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "114": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "115": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "116": "GhostscriptHelperTest::::runGhostScriptIncorrectParams()", "118": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "119": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "120": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "121": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "122": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "123": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "124": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "125": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "126": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "127": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "128": "GhostscriptHelperTest::::runGhostScriptTestForSpecificPage()", "130": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "131": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "132": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "133": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "134": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "135": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "136": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "137": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "138": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "139": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "140": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "141": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "142": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "143": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "144": "GhostscriptHelperTest::::runGhostScriptTestForSeveralSpecificPages()", "146": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "147": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "148": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "149": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "150": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "151": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "152": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "153": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "154": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "155": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "156": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "157": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "158": "GhostscriptHelperTest::::runGhostScriptTestForAllPages()", "160": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "161": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "162": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "163": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "164": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "165": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "166": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "167": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "168": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "169": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "170": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "171": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "172": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "173": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "174": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "175": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "176": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "177": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "178": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "179": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "180": "GhostscriptHelperTest::::dSaferParamInGhostScriptHelperTest()", "182": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "183": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "184": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "185": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "186": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "187": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "188": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "189": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "190": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "191": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "192": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "193": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "194": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "195": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "196": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "197": "GhostscriptHelperTest::::ghostScriptImageGenerationTest()", "199": "GhostscriptHelperTest::::pdfCallsHelpTest()", "200": "GhostscriptHelperTest::::pdfCallsHelpTest()", "201": "GhostscriptHelperTest::::pdfCallsHelpTest()", "202": "GhostscriptHelperTest::::pdfCallsHelpTest()", "203": "GhostscriptHelperTest::::pdfCallsHelpTest()", "204": "GhostscriptHelperTest::::pdfCallsHelpTest()", "205": "GhostscriptHelperTest::::pdfCallsHelpTest()", "206": "GhostscriptHelperTest::::pdfCallsHelpTest()", "207": "GhostscriptHelperTest::::pdfCallsHelpTest()", "208": "GhostscriptHelperTest::::pdfCallsHelpTest()", "209": "GhostscriptHelperTest::::pdfCallsHelpTest()", "210": "GhostscriptHelperTest::::pdfCallsHelpTest()", "211": "GhostscriptHelperTest::::pdfCallsHelpTest()", "213": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "214": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "215": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "216": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "217": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "218": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "219": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "220": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "221": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "222": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "223": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "224": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "225": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "226": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "227": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "228": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "229": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "230": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "231": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "232": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "233": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "234": "GhostscriptHelperTest::::outputImageCallsHelpTest()", "236": "GhostscriptHelperTest::::pageListCallsHelpTest()", "237": "GhostscriptHelperTest::::pageListCallsHelpTest()", "238": "GhostscriptHelperTest::::pageListCallsHelpTest()", "239": "GhostscriptHelperTest::::pageListCallsHelpTest()", "240": "GhostscriptHelperTest::::pageListCallsHelpTest()", "241": "GhostscriptHelperTest::::pageListCallsHelpTest()", "242": "GhostscriptHelperTest::::pageListCallsHelpTest()", "243": "GhostscriptHelperTest::::pageListCallsHelpTest()", "244": "GhostscriptHelperTest::::pageListCallsHelpTest()", "245": "GhostscriptHelperTest::::pageListCallsHelpTest()", "246": "GhostscriptHelperTest::::pageListCallsHelpTest()", "247": "GhostscriptHelperTest::::pageListCallsHelpTest()", "248": "GhostscriptHelperTest::::pageListCallsHelpTest()", "249": "GhostscriptHelperTest::::pageListCallsHelpTest()", "250": "GhostscriptHelperTest::::pageListCallsHelpTest()", "252": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "253": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "254": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "255": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "256": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "257": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "258": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "259": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "260": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "261": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "262": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "263": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "264": "GhostscriptHelperTest::::nonExistingDestinationFolder()", "265": "GhostscriptHelperTest::::nonExistingDestinationFolder()"}, "tests": [{"test_lines": [81, 87], "covered_lines": [61, 78, 79, 80, 88, 89]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/util/PdfNameUtil.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.io.source.ByteBuffer;\n", "\n", "/**\n", " * This file is a helper class for internal usage only.\n", " * Be aware that its API and functionality may be changed in future.\n", " */\n", "public final class PdfNameUtil {\n", "    private PdfNameUtil() {\n", "        // Do nothing\n", "    }\n", "\n", "    public static String decodeName(byte[] content) {\n", "        StringBuilder buf = new StringBuilder();\n", "        try {\n", "            for (int k = 0; k < content.length; ++k) {\n", "                char c = (char) content[k];\n", "                if (c == '#') {\n", "                    byte c1 = content[k + 1];\n", "                    byte c2 = content[k + 2];\n", "                    c = (char) ((ByteBuffer.getHex(c1) << 4) + ByteBuffer.getHex(c2));\n", "                    k += 2;\n", "                }\n", "                buf.append(c);\n", "            }\n", "        } catch (IndexOutOfBoundsException e) {\n", "            // empty on purpose\n", "        }\n", "        return buf.toString();\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class PdfNameUtilTest extends ExtendedITextTest {\n", "    @Test\n", "    public void decodeNameTest(){\n", "        // /#C3#9Cberschrift_1\n", "        byte[] name1Content = new byte[] {35, 67, 51, 35, 57, 67, 98, 101, 114, 115, 99, 104, 114, 105, 102, 116, 95, 49};\n", "        Assert.assertEquals(\"\u00c3\\u009Cberschrift_1\", PdfNameUtil.decodeName(name1Content));\n", "        // /TOC-1\n", "        byte[] name2Content = new byte[] {84, 79, 67, 45, 49};\n", "        Assert.assertEquals(\"TOC-1\", PdfNameUtil.decodeName(name2Content));\n", "        // /NormalParagraphStyle\n", "        byte[] name3Content = new byte[] {78, 111, 114, 109, 97, 108, 80, 97, 114, 97, 103, 114, 97, 112, 104, 83, 116, 121, 108, 101};\n", "        Assert.assertEquals(\"NormalParagraphStyle\", PdfNameUtil.decodeName(name3Content));\n", "    }\n", "}\n"], "method_lines_dic": {"PdfNameUtil::::decodeName(byte[])": [36, 53]}, "test_method_lines_dic": {"PdfNameUtilTest::::decodeNameTest()": [34, 45]}, "reverse_method_lines_dic": {"36": "PdfNameUtil::::decodeName(byte[])", "37": "PdfNameUtil::::decodeName(byte[])", "38": "PdfNameUtil::::decodeName(byte[])", "39": "PdfNameUtil::::decodeName(byte[])", "40": "PdfNameUtil::::decodeName(byte[])", "41": "PdfNameUtil::::decodeName(byte[])", "42": "PdfNameUtil::::decodeName(byte[])", "43": "PdfNameUtil::::decodeName(byte[])", "44": "PdfNameUtil::::decodeName(byte[])", "45": "PdfNameUtil::::decodeName(byte[])", "46": "PdfNameUtil::::decodeName(byte[])", "47": "PdfNameUtil::::decodeName(byte[])", "48": "PdfNameUtil::::decodeName(byte[])", "49": "PdfNameUtil::::decodeName(byte[])", "50": "PdfNameUtil::::decodeName(byte[])", "51": "PdfNameUtil::::decodeName(byte[])", "52": "PdfNameUtil::::decodeName(byte[])", "53": "PdfNameUtil::::decodeName(byte[])"}, "test_reverse_method_lines_dic": {"34": "PdfNameUtilTest::::decodeNameTest()", "35": "PdfNameUtilTest::::decodeNameTest()", "36": "PdfNameUtilTest::::decodeNameTest()", "37": "PdfNameUtilTest::::decodeNameTest()", "38": "PdfNameUtilTest::::decodeNameTest()", "39": "PdfNameUtilTest::::decodeNameTest()", "40": "PdfNameUtilTest::::decodeNameTest()", "41": "PdfNameUtilTest::::decodeNameTest()", "42": "PdfNameUtilTest::::decodeNameTest()", "43": "PdfNameUtilTest::::decodeNameTest()", "44": "PdfNameUtilTest::::decodeNameTest()", "45": "PdfNameUtilTest::::decodeNameTest()"}, "tests": [{"test_lines": [34, 45], "covered_lines": [37, 39, 40, 41, 42, 43, 44, 45, 47, 51, 52]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/util/UrlUtil.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import java.io.File;\n", "import java.io.IOException;\n", "import java.io.InputStream;\n", "import java.net.MalformedURLException;\n", "import java.net.URI;\n", "import java.net.URL;\n", "import java.net.URLConnection;\n", "\n", "/**\n", " * This file is a helper class for internal usage only.\n", " * Be aware that its API and functionality may be changed in future.\n", " */\n", "public final class UrlUtil {\n", "\n", "    private UrlUtil() {\n", "    }\n", "\n", "    /**\n", "     * This method makes a valid URL from a given filename.\n", "     * <p>\n", "     * This method makes the conversion of this library from the JAVA 2 platform\n", "     * to a JDK1.1.x-version easier.\n", "     * @param filename a given filename\n", "     * @return a valid URL\n", "     * @throws java.net.MalformedURLException\n", "     */\n", "    public static URL toURL(String filename) throws MalformedURLException {\n", "        URL url;\n", "        try {\n", "            url = new URL(filename);\n", "        } catch (MalformedURLException e) {\n", "            url = new File(filename).toURI().toURL();\n", "        }\n", "        return url;\n", "    }\n", "\n", "    /**\n", "     * This method makes a normalized URI from a given filename.\n", "     * @param filename a given filename\n", "     * @return a valid URI\n", "     */\n", "    public static URI toNormalizedURI(String filename) {\n", "        return toNormalizedURI(new File(filename));\n", "    }\n", "\n", "    /**\n", "     * This method makes a normalized URI from a given file.\n", "     * @param file a given filename\n", "     * @return a valid URI\n", "     */\n", "    public static URI toNormalizedURI(File file) {\n", "        return file.toURI().normalize();\n", "    }\n", "\n", "    /**\n", "     * Get the entire URI string which is properly encoded.\n", "     *\n", "     * @param uri URI which convert to string\n", "     * @return URI string representation\n", "     */\n", "    public static String toAbsoluteURI(URI uri) {\n", "        return uri.toString();\n", "    }\n", "\n", "    public static InputStream openStream(URL url) throws IOException {\n", "        return url.openStream();\n", "    }\n", "\n", "    /**\n", "     * This method gets uri string from a file.\n", "     * @param filename a given filename\n", "     * @return a uri string\n", "     */\n", "    public static String getFileUriString(String filename) throws MalformedURLException {\n", "        return new File(filename).toURI().toURL().toExternalForm();\n", "    }\n", "\n", "    /**\n", "     * This method gets normalized uri string from a file.\n", "     * @param filename a given filename\n", "     * @return a normalized uri string\n", "     */\n", "    public static String getNormalizedFileUriString(String filename) {\n", "        return \"file://\" + UrlUtil.toNormalizedURI(filename).getPath();\n", "    }\n", "\n", "    /**\n", "     * Gets the input stream of connection related to last redirected url. You should manually close input stream after\n", "     * calling this method to not hold any open resources.\n", "     *\n", "     * @param initialUrl an initial URL.\n", "     *\n", "     * @return an input stream of connection related to the last redirected url.\n", "     *\n", "     * @throws IOException signals that an I/O exception has occurred.\n", "     */\n", "    public static InputStream getInputStreamOfFinalConnection(URL initialUrl) throws IOException {\n", "        final URLConnection finalConnection = getFinalConnection(initialUrl);\n", "        return finalConnection.getInputStream();\n", "    }\n", "\n", "    /**\n", "     * Gets the connection related to the last redirected url. You should close connection manually after calling\n", "     * this method, to not hold any open resources.\n", "     *\n", "     * @param initialUrl an initial URL.\n", "     *\n", "     * @return connection related to the last redirected url.\n", "     *\n", "     * @throws IOException signals that an I/O exception has occurred.\n", "     */\n", "     static URLConnection getFinalConnection(URL initialUrl) throws IOException {\n", "        URL nextUrl = initialUrl;\n", "        URLConnection connection = null;\n", "        while (nextUrl != null) {\n", "            connection = nextUrl.openConnection();\n", "            final String location = connection.getHeaderField(\"location\");\n", "            nextUrl = location == null ? null : new URL(location);\n", "            if (nextUrl != null) {\n", "                // close input stream deliberately to close the handle which is created during getHeaderField invocation\n", "                connection.getInputStream().close();\n", "            }\n", "        }\n", "        return connection;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.util;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.File;\n", "import java.io.IOException;\n", "import java.io.InputStream;\n", "import java.net.URI;\n", "import java.net.URISyntaxException;\n", "import java.net.URL;\n", "import java.net.URLConnection;\n", "import java.net.UnknownHostException;\n", "import java.nio.charset.StandardCharsets;\n", "import java.nio.file.Paths;\n", "// Android-Conversion-Skip-Line (Security provider is required for working getFinalConnection through SSL on Android)\n", "// Android-Conversion-Replace import java.security.Security;\n", "// Android-Conversion-Replace import org.bouncycastle.jce.provider.BouncyCastleProvider;\n", "import org.junit.Assert;\n", "import org.junit.BeforeClass;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class UrlUtilTest extends ExtendedITextTest {\n", "\n", "    private static final String destinationFolder = \"./target/test/com/itextpdf/io/UrlUtilTest/\";\n", "\n", "    @BeforeClass\n", "    public static void beforeClass() {\n", "        // Android-Conversion-Skip-Line (Security provider is required for working getFinalConnection through SSL on Android)\n", "        // Android-Conversion-Replace Security.addProvider(new BouncyCastleProvider());\n", "        createDestinationFolder(destinationFolder);\n", "    }\n", "\n", "    // Tests, that getFinalConnection will be redirected some times for other urls, and initialUrl will be different\n", "    // from final url.\n", "    @Test\n", "    public void getFinalConnectionWhileRedirectingTest() throws IOException {\n", "        URL initialUrl = new URL(\"http://itextpdf.com\");\n", "        URL expectedURL = new URL(\"https://itextpdf.com/\");\n", "        URLConnection finalConnection = null;\n", "\n", "        try {\n", "            finalConnection = UrlUtil.getFinalConnection(initialUrl);\n", "\n", "            Assert.assertNotNull(finalConnection);\n", "            Assert.assertNotEquals(initialUrl, finalConnection.getURL());\n", "            Assert.assertEquals(expectedURL, finalConnection.getURL());\n", "        } finally {\n", "            finalConnection.getInputStream().close();\n", "        }\n", "    }\n", "\n", "    // This test checks that when we pass invalid url and trying get stream related to final redirected url,exception\n", "    // would be thrown.\n", "    @Test\n", "    public void getInputStreamOfFinalConnectionThrowExceptionTest() throws IOException {\n", "        URL invalidUrl = new URL(\"http://itextpdf\");\n", "\n", "        Assert.assertThrows(UnknownHostException.class, () -> UrlUtil.getInputStreamOfFinalConnection(invalidUrl));\n", "    }\n", "\n", "    // This test checks that when we pass valid url and trying get stream related to final redirected url, it would\n", "    // not be null.\n", "    @Test\n", "    public void getInputStreamOfFinalConnectionTest() throws IOException {\n", "        URL initialUrl = new URL(\"http://itextpdf.com\");\n", "        InputStream streamOfFinalConnectionOfInvalidUrl = UrlUtil.getInputStreamOfFinalConnection(initialUrl);\n", "\n", "        Assert.assertNotNull(streamOfFinalConnectionOfInvalidUrl);\n", "    }\n", "\n", "    @Test\n", "    // Android-Conversion-Ignore-Test (TODO DEVSIX-7371 investigate different behavior of a few iTextCore tests on Java and Android)\n", "    public void getBaseUriTest() throws IOException {\n", "        String absolutePathRoot = Paths.get(\"\").toAbsolutePath().toUri().toURL().toExternalForm();\n", "        // Android-Conversion-Skip-Line (TODO DEVSIX-7371 investigate different behavior of a few iTextCore tests on Java and Android)\n", "        String expected = absolutePathRoot + destinationFolder; // Android-Conversion-Replace String expected = absolutePathRoot + destinationFolder.substring(1);\n", "        File tempFile = FileUtil.createTempFile(destinationFolder);\n", "        Assert.assertEquals(expected, FileUtil.getParentDirectoryUri(tempFile));\n", "    }\n", "\n", "    @Test\n", "    public void nullBaseUriTest() throws IOException {\n", "        String expected = \"\";\n", "        File tempFile = null;\n", "        Assert.assertEquals(expected, FileUtil.getParentDirectoryUri(tempFile));\n", "    }\n", "\n", "    @Test\n", "    public void toAbsoluteUriTest() throws IOException, URISyntaxException {\n", "        String expected = \"http://itextpdf.com/\";\n", "        Assert.assertEquals(expected, UrlUtil.toAbsoluteURI(new URI(expected)));\n", "    }\n", "\n", "    @Test\n", "    public void openStreamTest() throws IOException {\n", "        String resPath = \"./src/test/resources/com/itextpdf/io/util/textFile.dat\";\n", "        InputStream openStream = UrlUtil.openStream(new File(resPath).toURI().toURL());\n", "\n", "        String actual = new String(StreamUtil.inputStreamToArray(openStream), StandardCharsets.UTF_8);\n", "        Assert.assertEquals(\"Hello world from text file!\", actual);\n", "\n", "    }\n", "}\n"], "method_lines_dic": {"UrlUtil::::toURL(java.lang.String)": [51, 59], "UrlUtil::::toNormalizedURI(java.lang.String)": [66, 68], "UrlUtil::::toNormalizedURI(java.io.File)": [75, 77], "UrlUtil::::toAbsoluteURI(java.net.URI)": [85, 87], "UrlUtil::::openStream(java.net.URL)": [89, 91], "UrlUtil::::getFileUriString(java.lang.String)": [98, 100], "UrlUtil::::getNormalizedFileUriString(java.lang.String)": [107, 109], "UrlUtil::::getInputStreamOfFinalConnection(java.net.URL)": [121, 124], "UrlUtil::::getFinalConnection(java.net.URL)": [136, 149]}, "test_method_lines_dic": {"UrlUtilTest::::beforeClass()": [52, 57], "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()": [61, 76], "UrlUtilTest::::getInputStreamOfFinalConnectionThrowExceptionTest()": [80, 85], "UrlUtilTest::::getInputStreamOfFinalConnectionTest()": [89, 95], "UrlUtilTest::::getBaseUriTest()": [97, 105], "UrlUtilTest::::nullBaseUriTest()": [107, 112], "UrlUtilTest::::toAbsoluteUriTest()": [114, 118], "UrlUtilTest::::openStreamTest()": [120, 128]}, "reverse_method_lines_dic": {"51": "UrlUtil::::toURL(java.lang.String)", "52": "UrlUtil::::toURL(java.lang.String)", "53": "UrlUtil::::toURL(java.lang.String)", "54": "UrlUtil::::toURL(java.lang.String)", "55": "UrlUtil::::toURL(java.lang.String)", "56": "UrlUtil::::toURL(java.lang.String)", "57": "UrlUtil::::toURL(java.lang.String)", "58": "UrlUtil::::toURL(java.lang.String)", "59": "UrlUtil::::toURL(java.lang.String)", "66": "UrlUtil::::toNormalizedURI(java.lang.String)", "67": "UrlUtil::::toNormalizedURI(java.lang.String)", "68": "UrlUtil::::toNormalizedURI(java.lang.String)", "75": "UrlUtil::::toNormalizedURI(java.io.File)", "76": "UrlUtil::::toNormalizedURI(java.io.File)", "77": "UrlUtil::::toNormalizedURI(java.io.File)", "85": "UrlUtil::::toAbsoluteURI(java.net.URI)", "86": "UrlUtil::::toAbsoluteURI(java.net.URI)", "87": "UrlUtil::::toAbsoluteURI(java.net.URI)", "89": "UrlUtil::::openStream(java.net.URL)", "90": "UrlUtil::::openStream(java.net.URL)", "91": "UrlUtil::::openStream(java.net.URL)", "98": "UrlUtil::::getFileUriString(java.lang.String)", "99": "UrlUtil::::getFileUriString(java.lang.String)", "100": "UrlUtil::::getFileUriString(java.lang.String)", "107": "UrlUtil::::getNormalizedFileUriString(java.lang.String)", "108": "UrlUtil::::getNormalizedFileUriString(java.lang.String)", "109": "UrlUtil::::getNormalizedFileUriString(java.lang.String)", "121": "UrlUtil::::getInputStreamOfFinalConnection(java.net.URL)", "122": "UrlUtil::::getInputStreamOfFinalConnection(java.net.URL)", "123": "UrlUtil::::getInputStreamOfFinalConnection(java.net.URL)", "124": "UrlUtil::::getInputStreamOfFinalConnection(java.net.URL)", "136": "UrlUtil::::getFinalConnection(java.net.URL)", "137": "UrlUtil::::getFinalConnection(java.net.URL)", "138": "UrlUtil::::getFinalConnection(java.net.URL)", "139": "UrlUtil::::getFinalConnection(java.net.URL)", "140": "UrlUtil::::getFinalConnection(java.net.URL)", "141": "UrlUtil::::getFinalConnection(java.net.URL)", "142": "UrlUtil::::getFinalConnection(java.net.URL)", "143": "UrlUtil::::getFinalConnection(java.net.URL)", "144": "UrlUtil::::getFinalConnection(java.net.URL)", "145": "UrlUtil::::getFinalConnection(java.net.URL)", "146": "UrlUtil::::getFinalConnection(java.net.URL)", "147": "UrlUtil::::getFinalConnection(java.net.URL)", "148": "UrlUtil::::getFinalConnection(java.net.URL)", "149": "UrlUtil::::getFinalConnection(java.net.URL)"}, "test_reverse_method_lines_dic": {"52": "UrlUtilTest::::beforeClass()", "53": "UrlUtilTest::::beforeClass()", "54": "UrlUtilTest::::beforeClass()", "55": "UrlUtilTest::::beforeClass()", "56": "UrlUtilTest::::beforeClass()", "57": "UrlUtilTest::::beforeClass()", "61": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "62": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "63": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "64": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "65": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "66": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "67": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "68": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "69": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "70": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "71": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "72": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "73": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "74": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "75": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "76": "UrlUtilTest::::getFinalConnectionWhileRedirectingTest()", "80": "UrlUtilTest::::getInputStreamOfFinalConnectionThrowExceptionTest()", "81": "UrlUtilTest::::getInputStreamOfFinalConnectionThrowExceptionTest()", "82": "UrlUtilTest::::getInputStreamOfFinalConnectionThrowExceptionTest()", "83": "UrlUtilTest::::getInputStreamOfFinalConnectionThrowExceptionTest()", "84": "UrlUtilTest::::getInputStreamOfFinalConnectionThrowExceptionTest()", "85": "UrlUtilTest::::getInputStreamOfFinalConnectionThrowExceptionTest()", "89": "UrlUtilTest::::getInputStreamOfFinalConnectionTest()", "90": "UrlUtilTest::::getInputStreamOfFinalConnectionTest()", "91": "UrlUtilTest::::getInputStreamOfFinalConnectionTest()", "92": "UrlUtilTest::::getInputStreamOfFinalConnectionTest()", "93": "UrlUtilTest::::getInputStreamOfFinalConnectionTest()", "94": "UrlUtilTest::::getInputStreamOfFinalConnectionTest()", "95": "UrlUtilTest::::getInputStreamOfFinalConnectionTest()", "97": "UrlUtilTest::::getBaseUriTest()", "98": "UrlUtilTest::::getBaseUriTest()", "99": "UrlUtilTest::::getBaseUriTest()", "100": "UrlUtilTest::::getBaseUriTest()", "101": "UrlUtilTest::::getBaseUriTest()", "102": "UrlUtilTest::::getBaseUriTest()", "103": "UrlUtilTest::::getBaseUriTest()", "104": "UrlUtilTest::::getBaseUriTest()", "105": "UrlUtilTest::::getBaseUriTest()", "107": "UrlUtilTest::::nullBaseUriTest()", "108": "UrlUtilTest::::nullBaseUriTest()", "109": "UrlUtilTest::::nullBaseUriTest()", "110": "UrlUtilTest::::nullBaseUriTest()", "111": "UrlUtilTest::::nullBaseUriTest()", "112": "UrlUtilTest::::nullBaseUriTest()", "114": "UrlUtilTest::::toAbsoluteUriTest()", "115": "UrlUtilTest::::toAbsoluteUriTest()", "116": "UrlUtilTest::::toAbsoluteUriTest()", "117": "UrlUtilTest::::toAbsoluteUriTest()", "118": "UrlUtilTest::::toAbsoluteUriTest()", "120": "UrlUtilTest::::openStreamTest()", "121": "UrlUtilTest::::openStreamTest()", "122": "UrlUtilTest::::openStreamTest()", "123": "UrlUtilTest::::openStreamTest()", "124": "UrlUtilTest::::openStreamTest()", "125": "UrlUtilTest::::openStreamTest()", "126": "UrlUtilTest::::openStreamTest()", "127": "UrlUtilTest::::openStreamTest()", "128": "UrlUtilTest::::openStreamTest()"}, "tests": [{"test_lines": [61, 76], "covered_lines": [137, 138, 139, 140, 141, 142, 143, 145, 147, 148]}, {"test_lines": [80, 85], "covered_lines": [122, 137, 138, 139, 140, 141, 142, 143, 147, 148]}, {"test_lines": [89, 95], "covered_lines": [122, 123, 137, 138, 139, 140, 141, 142, 143, 145, 147, 148]}, {"test_lines": [114, 118], "covered_lines": [86]}, {"test_lines": [120, 128], "covered_lines": [90]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/source/RAFRandomAccessSource.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import java.io.RandomAccessFile;\n", "\n", "/**\n", " * A RandomAccessSource that uses a {@link java.io.RandomAccessFile} as it's source\n", " * Note: Unlike most of the RandomAccessSource implementations, this class is not thread safe\n", " */\n", "class RAFRandomAccessSource implements IRandomAccessSource {\n", "    /**\n", "     * The source\n", "     */\n", "    private final RandomAccessFile raf;\n", "\n", "    /**\n", "     * The length of the underling RAF.  Note that the length is cached at construction time to avoid the possibility\n", "     * of {@link java.io.IOException}s when reading the length.\n", "     */\n", "    private final long length;\n", "\n", "    /**\n", "     * Creates this object\n", "     * @param raf the source for this RandomAccessSource\n", "     * @throws java.io.IOException if the RAF can't be read\n", "     */\n", "    public RAFRandomAccessSource(RandomAccessFile raf) throws java.io.IOException {\n", "        this.raf = raf;\n", "        length = raf.length();\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     */\n", "    public int get(long position) throws java.io.IOException {\n", "        if (position > length)\n", "            return -1;\n", "\n", "        // Not thread safe!\n", "        if (raf.getFilePointer() != position) {\n", "            raf.seek(position);\n", "        }\n", "\n", "        return raf.read();\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     */\n", "    public int get(long position, byte[] bytes, int off, int len) throws java.io.IOException {\n", "        if (position > length)\n", "            return -1;\n", "\n", "        // Not thread safe!\n", "        if (raf.getFilePointer() != position) {\n", "            raf.seek(position);\n", "        }\n", "\n", "        return raf.read(bytes, off, len);\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     * Note: the length is determined when the {@link RAFRandomAccessSource} is constructed.  If the file length changes\n", "     * after construction, that change will not be reflected in this call.\n", "     */\n", "    public long length() {\n", "        return length;\n", "    }\n", "\n", "    /**\n", "     * Closes the underlying RandomAccessFile\n", "     */\n", "    public void close() throws java.io.IOException {\n", "        raf.close();\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.File;\n", "import java.io.IOException;\n", "import java.io.RandomAccessFile;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class RAFRandomAccessSourceTest extends ExtendedITextTest {\n", "    private final static String SOURCE_FILE = \"./src/test/resources/com/itextpdf/io/source/RAF.txt\";\n", "\n", "    private final byte[] content = \"Hello, world!\".getBytes();\n", "\n", "    @Test\n", "    public void getByIndexTest() throws IOException {\n", "        File file = new File(SOURCE_FILE);\n", "\n", "        try (RandomAccessFile raf = FileUtil.getRandomAccessFile(file)) {\n", "            RAFRandomAccessSource source = new RAFRandomAccessSource(raf);\n", "            for (int i = 0; i < content.length; i++) {\n", "                Assert.assertEquals(content[i], source.get(i));\n", "            }\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void getByIndexOutOfBoundsTest() throws IOException {\n", "        File file = new File(SOURCE_FILE);\n", "        int indexOutOfBounds = content.length;\n", "\n", "        try (RandomAccessFile raf = FileUtil.getRandomAccessFile(file)) {\n", "            RAFRandomAccessSource source = new RAFRandomAccessSource(raf);\n", "            Assert.assertNotEquals(-1, source.get(indexOutOfBounds - 1));\n", "            Assert.assertEquals(-1, source.get(indexOutOfBounds));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void getArrayByIndexesTest() throws IOException {\n", "        File file = new File(SOURCE_FILE);\n", "        final int beginIndex = 7;\n", "        final int length = 5;\n", "\n", "        try (RandomAccessFile raf = FileUtil.getRandomAccessFile(file)) {\n", "            RAFRandomAccessSource source = new RAFRandomAccessSource(raf);\n", "            byte[] dest = new byte[24];\n", "\n", "            int read = source.get(beginIndex, dest, 0, length);\n", "\n", "            Assert.assertEquals(length, read);\n", "            for (int i = 0; i < length; i++) {\n", "                Assert.assertEquals(content[beginIndex + i], dest[i]);\n", "            }\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void getArrayByIndexesNotEnoughBytesTest() throws IOException {\n", "        File file = new File(SOURCE_FILE);\n", "        final int beginIndex = 7;\n", "        final int length = 24;\n", "        final int expectedLength = 6;\n", "\n", "        try (RandomAccessFile raf = FileUtil.getRandomAccessFile(file)) {\n", "            RAFRandomAccessSource source = new RAFRandomAccessSource(raf);\n", "            byte[] dest = new byte[24];\n", "\n", "            int read = source.get(beginIndex, dest, 0, length);\n", "            Assert.assertEquals(expectedLength, read);\n", "            for (int i = 0; i < expectedLength; i++) {\n", "                Assert.assertEquals(content[beginIndex + i], dest[i]);\n", "            }\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void getArrayByIndexesWithOffsetTest() throws IOException {\n", "        File file = new File(SOURCE_FILE);\n", "        final int beginIndex = 7;\n", "        final int length = 5;\n", "        final int offset = 2;\n", "\n", "        try (RandomAccessFile raf = FileUtil.getRandomAccessFile(file)) {\n", "            RAFRandomAccessSource source = new RAFRandomAccessSource(raf);\n", "            byte[] dest = new byte[24];\n", "\n", "            int read = source.get(beginIndex, dest, offset, length);\n", "\n", "            Assert.assertEquals(length, read);\n", "            for (int i = 0; i < length; i++) {\n", "                Assert.assertEquals(content[beginIndex + i], dest[offset + i]);\n", "            }\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void getArrayByIndexesOutOfBounds() throws IOException {\n", "        File file = new File(SOURCE_FILE);\n", "        final int beginIndex = content.length;\n", "        final int length = 5;\n", "\n", "        try (RandomAccessFile raf = FileUtil.getRandomAccessFile(file)) {\n", "            RAFRandomAccessSource source = new RAFRandomAccessSource(raf);\n", "            byte[] dest = new byte[24];\n", "\n", "            int read = source.get(beginIndex, dest, 0, length);\n", "\n", "            Assert.assertEquals(-1, read);\n", "            for (int i = 0; i < dest.length; i++) {\n", "                Assert.assertEquals(0, dest[i]);\n", "            }\n", "        }\n", "    }\n", "}\n"], "method_lines_dic": {"RAFRandomAccessSource::::get(long)": [56, 66], "RAFRandomAccessSource::::get(long,byte[],int,int)": [71, 81], "RAFRandomAccessSource::::length()": [88, 90], "RAFRandomAccessSource::::close()": [95, 97]}, "test_method_lines_dic": {"RAFRandomAccessSourceTest::::getByIndexTest()": [42, 52], "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()": [54, 64], "RAFRandomAccessSourceTest::::getArrayByIndexesTest()": [66, 83], "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()": [85, 102], "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()": [104, 122], "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()": [124, 141]}, "reverse_method_lines_dic": {"56": "RAFRandomAccessSource::::get(long)", "57": "RAFRandomAccessSource::::get(long)", "58": "RAFRandomAccessSource::::get(long)", "59": "RAFRandomAccessSource::::get(long)", "60": "RAFRandomAccessSource::::get(long)", "61": "RAFRandomAccessSource::::get(long)", "62": "RAFRandomAccessSource::::get(long)", "63": "RAFRandomAccessSource::::get(long)", "64": "RAFRandomAccessSource::::get(long)", "65": "RAFRandomAccessSource::::get(long)", "66": "RAFRandomAccessSource::::get(long)", "71": "RAFRandomAccessSource::::get(long,byte[],int,int)", "72": "RAFRandomAccessSource::::get(long,byte[],int,int)", "73": "RAFRandomAccessSource::::get(long,byte[],int,int)", "74": "RAFRandomAccessSource::::get(long,byte[],int,int)", "75": "RAFRandomAccessSource::::get(long,byte[],int,int)", "76": "RAFRandomAccessSource::::get(long,byte[],int,int)", "77": "RAFRandomAccessSource::::get(long,byte[],int,int)", "78": "RAFRandomAccessSource::::get(long,byte[],int,int)", "79": "RAFRandomAccessSource::::get(long,byte[],int,int)", "80": "RAFRandomAccessSource::::get(long,byte[],int,int)", "81": "RAFRandomAccessSource::::get(long,byte[],int,int)", "88": "RAFRandomAccessSource::::length()", "89": "RAFRandomAccessSource::::length()", "90": "RAFRandomAccessSource::::length()", "95": "RAFRandomAccessSource::::close()", "96": "RAFRandomAccessSource::::close()", "97": "RAFRandomAccessSource::::close()"}, "test_reverse_method_lines_dic": {"42": "RAFRandomAccessSourceTest::::getByIndexTest()", "43": "RAFRandomAccessSourceTest::::getByIndexTest()", "44": "RAFRandomAccessSourceTest::::getByIndexTest()", "45": "RAFRandomAccessSourceTest::::getByIndexTest()", "46": "RAFRandomAccessSourceTest::::getByIndexTest()", "47": "RAFRandomAccessSourceTest::::getByIndexTest()", "48": "RAFRandomAccessSourceTest::::getByIndexTest()", "49": "RAFRandomAccessSourceTest::::getByIndexTest()", "50": "RAFRandomAccessSourceTest::::getByIndexTest()", "51": "RAFRandomAccessSourceTest::::getByIndexTest()", "52": "RAFRandomAccessSourceTest::::getByIndexTest()", "54": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "55": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "56": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "57": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "58": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "59": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "60": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "61": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "62": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "63": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "64": "RAFRandomAccessSourceTest::::getByIndexOutOfBoundsTest()", "66": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "67": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "68": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "69": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "70": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "71": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "72": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "73": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "74": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "75": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "76": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "77": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "78": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "79": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "80": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "81": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "82": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "83": "RAFRandomAccessSourceTest::::getArrayByIndexesTest()", "85": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "86": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "87": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "88": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "89": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "90": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "91": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "92": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "93": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "94": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "95": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "96": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "97": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "98": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "99": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "100": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "101": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "102": "RAFRandomAccessSourceTest::::getArrayByIndexesNotEnoughBytesTest()", "104": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "105": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "106": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "107": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "108": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "109": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "110": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "111": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "112": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "113": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "114": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "115": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "116": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "117": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "118": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "119": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "120": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "121": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "122": "RAFRandomAccessSourceTest::::getArrayByIndexesWithOffsetTest()", "124": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "125": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "126": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "127": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "128": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "129": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "130": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "131": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "132": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "133": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "134": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "135": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "136": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "137": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "138": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "139": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "140": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()", "141": "RAFRandomAccessSourceTest::::getArrayByIndexesOutOfBounds()"}, "tests": [{"test_lines": [42, 52], "covered_lines": [48, 49, 50, 51, 57, 61, 65]}, {"test_lines": [54, 64], "covered_lines": [48, 49, 50, 51, 57, 61, 62, 65]}, {"test_lines": [66, 83], "covered_lines": [48, 49, 50, 51, 72, 76, 77, 80]}, {"test_lines": [85, 102], "covered_lines": [48, 49, 50, 51, 72, 76, 77, 80]}, {"test_lines": [104, 122], "covered_lines": [48, 49, 50, 51, 72, 76, 77, 80]}, {"test_lines": [124, 141], "covered_lines": [48, 49, 50, 51, 72, 76, 77, 80]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/source/PagedChannelRandomAccessSource.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import com.itextpdf.io.logs.IoLogMessageConstant;\n", "\n", "import java.nio.channels.FileChannel;\n", "import java.util.Iterator;\n", "import java.util.LinkedList;\n", "import org.slf4j.Logger;\n", "import org.slf4j.LoggerFactory;\n", "\n", "/**\n", " * A RandomAccessSource that is based on an underlying {@link java.nio.channels.FileChannel}.  The channel is mapped into memory using a paging scheme to allow for efficient reads of very large files.\n", " * As an implementation detail, we use {@link GroupedRandomAccessSource} functionality, but override to make determination of the underlying\n", " * mapped page more efficient - and to close each page as another is opened\n", " */\n", "class PagedChannelRandomAccessSource extends GroupedRandomAccessSource implements IRandomAccessSource {\n", "    // these values were selected based on parametric testing with extracting text content from a 2.3GB file.  These settings resulted in the best improvement over\n", "    // the single size MRU case (24% speed improvement)\n", "    public static final int DEFAULT_TOTAL_BUFSIZE = 1 << 26;\n", "    public static final int DEFAULT_MAX_OPEN_BUFFERS = 16;\n", "\n", "    /**\n", "     * The size of each of the buffers to use when mapping files into memory.  This must be greater than 0 and less than {@link Integer#MAX_VALUE}\n", "     */\n", "    private final int bufferSize;\n", "\n", "    /**\n", "     * The channel this source is based on\n", "     */\n", "    private final FileChannel channel;\n", "\n", "    /**\n", "     * Most recently used list used to hold a number of mapped pages open at a time\n", "     */\n", "    private final MRU<IRandomAccessSource> mru;\n", "\n", "    /**\n", "     * Constructs a new {@link PagedChannelRandomAccessSource} based on the specified FileChannel, with a default buffer configuration.\n", "     * The default buffer configuration is currently 2^26 total paged bytes, spread across a maximum of 16 active buffers. This arrangement\n", "     * resulted in a 24% speed improvement over the single buffer case in parametric tests extracting text from a 2.3 GB file.\n", "     * @param channel the channel to use as the backing store\n", "     * @throws java.io.IOException if the channel cannot be opened or mapped\n", "     */\n", "    public PagedChannelRandomAccessSource(FileChannel channel) throws java.io.IOException {\n", "        this(channel, DEFAULT_TOTAL_BUFSIZE, DEFAULT_MAX_OPEN_BUFFERS);\n", "    }\n", "\n", "    /**\n", "     * Constructs a new {@link PagedChannelRandomAccessSource} based on the specified FileChannel, with a specific buffer size\n", "     * @param channel the channel to use as the backing store\n", "     * @param totalBufferSize total buffer size\n", "     * @param maxOpenBuffers open buffers\n", "     * @throws java.io.IOException if the channel cannot be opened or mapped\n", "     */\n", "    public PagedChannelRandomAccessSource(FileChannel channel, int totalBufferSize, int maxOpenBuffers) throws java.io.IOException {\n", "        super(buildSources(channel, totalBufferSize/maxOpenBuffers));\n", "        this.channel = channel;\n", "        this.bufferSize = totalBufferSize/maxOpenBuffers;\n", "        this.mru = new MRU<IRandomAccessSource>(maxOpenBuffers);\n", "    }\n", "\n", "    /**\n", "     * Constructs a set of {@link MappedChannelRandomAccessSource}s for each page (of size bufferSize) of the underlying channel\n", "     * @param channel the underlying channel\n", "     * @param bufferSize the size of each page (the last page may be shorter)\n", "     * @return a list of sources that represent the pages of the channel\n", "     * @throws java.io.IOException if IO fails for any reason\n", "     */\n", "    private static IRandomAccessSource[] buildSources(FileChannel channel, int bufferSize) throws java.io.IOException{\n", "        long size = channel.size();\n", "        if (size <= 0)\n", "            throw new java.io.IOException(\"File size must be greater than zero\");\n", "\n", "        int bufferCount = (int)(size/bufferSize) + (size % bufferSize == 0 ? 0 : 1);\n", "\n", "        MappedChannelRandomAccessSource[] sources = new MappedChannelRandomAccessSource[bufferCount];\n", "        for (int i = 0; i < bufferCount; i++){\n", "            long pageOffset = (long)i*bufferSize;\n", "            long pageLength = Math.min(size - pageOffset, bufferSize);\n", "            sources[i] = new MappedChannelRandomAccessSource(channel, pageOffset, pageLength);\n", "        }\n", "        return sources;\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     */\n", "    @Override\n", "    protected int getStartingSourceIndex(long offset) {\n", "        return (int) (offset / bufferSize);\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     * For now, close the source that is no longer being used.  In the future, we may implement an MRU that allows multiple pages to be opened at a time\n", "     */\n", "    @Override\n", "    protected void sourceReleased(IRandomAccessSource source) throws java.io.IOException {\n", "        IRandomAccessSource old = mru.enqueue(source);\n", "        if (old != null)\n", "            old.close();\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     * Ensure that the source is mapped.  In the future, we may implement an MRU that allows multiple pages to be opened at a time\n", "     */\n", "    @Override\n", "    protected void sourceInUse(IRandomAccessSource source) throws java.io.IOException {\n", "        ((MappedChannelRandomAccessSource)source).open();\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     * Cleans the mapped bytebuffers and closes the channel\n", "     */\n", "    @Override\n", "    public void close() throws java.io.IOException {\n", "        try {\n", "            super.close();\n", "        } finally {\n", "            try {\n", "                channel.close();\n", "            } catch (Exception ex) {\n", "                Logger logger = LoggerFactory.getLogger(PagedChannelRandomAccessSource.class);\n", "                logger.error(IoLogMessageConstant.FILE_CHANNEL_CLOSING_FAILED, ex);\n", "            }\n", "        }\n", "    }\n", "\n", "    private static class MRU<E> {\n", "        /**\n", "         * The maximum number of entries held by this MRU\n", "         */\n", "        private final int limit;\n", "\n", "        /**\n", "         * Backing list for managing the MRU\n", "         */\n", "        private LinkedList<E> queue = new LinkedList<>();\n", "\n", "        /**\n", "         * Constructs an MRU with the specified size\n", "         * @param limit the limit\n", "         */\n", "        public MRU(int limit) {\n", "            this.limit = limit;\n", "        }\n", "\n", "        /**\n", "         * Adds an element to the MRU.  If the element is already in the MRU, it is moved to the top.\n", "         * @param newElement the element to add\n", "         * @return the element that was removed from the MRU to make room for the new element, or null if no element needed to be removed\n", "         */\n", "        public E enqueue(E newElement){\n", "            if (!queue.isEmpty() && queue.getFirst() == newElement) {\n", "                return null;\n", "            }\n", "\n", "            for (Iterator<E> it = queue.iterator(); it.hasNext();) {\n", "                E element = it.next();\n", "                if (newElement == element) {\n", "                    it.remove();\n", "                    queue.addFirst(newElement);\n", "                    return null;\n", "                }\n", "            }\n", "            queue.addFirst(newElement);\n", "\n", "            if (queue.size() > limit) {\n", "                return queue.removeLast();\n", "            }\n", "\n", "            return null;\n", "        }\n", "    }\n", "}\n", "\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "import java.io.IOException;\n", "import java.io.RandomAccessFile;\n", "import java.nio.ByteBuffer;\n", "import java.nio.channels.FileChannel;\n", "\n", "@Category(UnitTest.class)\n", "public class PagedChannelRandomAccessSourceTest  extends ExtendedITextTest {\n", "\n", "    private final static String SOURCE_FILE = \"./src/test/resources/com/itextpdf/io/source/RAF.txt\";\n", "    @Test\n", "    public void readBytesFromFileTest() throws IOException {\n", "        PagedChannelRandomAccessSource source;\n", "        try (RandomAccessFile raf = new RandomAccessFile(SOURCE_FILE, \"r\")) {\n", "            FileChannel channel = raf.getChannel();\n", "            source = new PagedChannelRandomAccessSource(channel);\n", "            byte[] expected = new byte[] {72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33};\n", "            byte[] result = new byte[13];\n", "            source.get(0, result, 0, 13);\n", "            Assert.assertArrayEquals(expected, result);\n", "\n", "            expected = new byte[] {111, 44, 32, 119, 111, 114, 108, 100};\n", "            result = new byte[8];\n", "            source.get(4, result, 0, 8);\n", "            Assert.assertArrayEquals(expected, result);\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void readIntFromFileTest() throws IOException {\n", "        PagedChannelRandomAccessSource source;\n", "        try (RandomAccessFile raf = new RandomAccessFile(SOURCE_FILE, \"r\")) {\n", "            FileChannel channel = raf.getChannel();\n", "            source = new PagedChannelRandomAccessSource(channel, 10, 1);\n", "            Assert.assertEquals(13, source.length());\n", "            Assert.assertEquals(72, source.get(0));\n", "            Assert.assertEquals(44, source.get(5));\n", "            Assert.assertEquals(33, source.get(12));\n", "            Assert.assertEquals(100, source.get(11));\n", "            Assert.assertEquals(-1, source.get(13));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void sourceReleaseAndOpenTest() throws IOException {\n", "        PagedChannelRandomAccessSource source;\n", "        try (RandomAccessFile raf = new RandomAccessFile(SOURCE_FILE, \"r\")) {\n", "            FileChannel channel = raf.getChannel();\n", "            source = new PagedChannelRandomAccessSource(channel);\n", "            IRandomAccessSource sourceToClose = new ByteBufferRandomAccessSource(ByteBuffer.allocate(10));\n", "            //assert no exception is thrown\n", "            source.sourceReleased(sourceToClose);\n", "            source.sourceReleased(sourceToClose);\n", "            source.sourceReleased(new ByteBufferRandomAccessSource(ByteBuffer.allocate(10)));\n", "            source.sourceReleased(sourceToClose);\n", "\n", "            MappedChannelRandomAccessSource sourceToOpen = new MappedChannelRandomAccessSource(channel, 0, channel.size());\n", "            source.sourceInUse(sourceToOpen);\n", "            source.close();\n", "        }\n", "    }\n", "}\n"], "method_lines_dic": {"PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)": [91, 105], "PagedChannelRandomAccessSource::::getStartingSourceIndex(long)": [110, 113], "PagedChannelRandomAccessSource::::sourceReleased(com.itextpdf.io.source.IRandomAccessSource)": [119, 124], "PagedChannelRandomAccessSource::::sourceInUse(com.itextpdf.io.source.IRandomAccessSource)": [130, 133], "PagedChannelRandomAccessSource::::close()": [139, 151], "PagedChannelRandomAccessSource.MRU::::enqueue(E)": [177, 197]}, "test_method_lines_dic": {"PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()": [40, 56], "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()": [58, 71], "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()": [73, 90]}, "reverse_method_lines_dic": {"91": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "92": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "93": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "94": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "95": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "96": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "97": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "98": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "99": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "100": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "101": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "102": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "103": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "104": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "105": "PagedChannelRandomAccessSource::::buildSources(java.nio.channels.FileChannel,int)", "110": "PagedChannelRandomAccessSource::::getStartingSourceIndex(long)", "111": "PagedChannelRandomAccessSource::::getStartingSourceIndex(long)", "112": "PagedChannelRandomAccessSource::::getStartingSourceIndex(long)", "113": "PagedChannelRandomAccessSource::::getStartingSourceIndex(long)", "119": "PagedChannelRandomAccessSource::::sourceReleased(com.itextpdf.io.source.IRandomAccessSource)", "120": "PagedChannelRandomAccessSource::::sourceReleased(com.itextpdf.io.source.IRandomAccessSource)", "121": "PagedChannelRandomAccessSource::::sourceReleased(com.itextpdf.io.source.IRandomAccessSource)", "122": "PagedChannelRandomAccessSource::::sourceReleased(com.itextpdf.io.source.IRandomAccessSource)", "123": "PagedChannelRandomAccessSource::::sourceReleased(com.itextpdf.io.source.IRandomAccessSource)", "124": "PagedChannelRandomAccessSource::::sourceReleased(com.itextpdf.io.source.IRandomAccessSource)", "130": "PagedChannelRandomAccessSource::::sourceInUse(com.itextpdf.io.source.IRandomAccessSource)", "131": "PagedChannelRandomAccessSource::::sourceInUse(com.itextpdf.io.source.IRandomAccessSource)", "132": "PagedChannelRandomAccessSource::::sourceInUse(com.itextpdf.io.source.IRandomAccessSource)", "133": "PagedChannelRandomAccessSource::::sourceInUse(com.itextpdf.io.source.IRandomAccessSource)", "139": "PagedChannelRandomAccessSource::::close()", "140": "PagedChannelRandomAccessSource::::close()", "141": "PagedChannelRandomAccessSource::::close()", "142": "PagedChannelRandomAccessSource::::close()", "143": "PagedChannelRandomAccessSource::::close()", "144": "PagedChannelRandomAccessSource::::close()", "145": "PagedChannelRandomAccessSource::::close()", "146": "PagedChannelRandomAccessSource::::close()", "147": "PagedChannelRandomAccessSource::::close()", "148": "PagedChannelRandomAccessSource::::close()", "149": "PagedChannelRandomAccessSource::::close()", "150": "PagedChannelRandomAccessSource::::close()", "151": "PagedChannelRandomAccessSource::::close()", "177": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "178": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "179": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "180": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "181": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "182": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "183": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "184": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "185": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "186": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "187": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "188": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "189": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "190": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "191": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "192": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "193": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "194": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "195": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "196": "PagedChannelRandomAccessSource.MRU::::enqueue(E)", "197": "PagedChannelRandomAccessSource.MRU::::enqueue(E)"}, "test_reverse_method_lines_dic": {"40": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "41": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "42": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "43": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "44": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "45": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "46": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "47": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "48": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "49": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "50": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "51": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "52": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "53": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "54": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "55": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "56": "PagedChannelRandomAccessSourceTest::::readBytesFromFileTest()", "58": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "59": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "60": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "61": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "62": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "63": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "64": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "65": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "66": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "67": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "68": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "69": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "70": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "71": "PagedChannelRandomAccessSourceTest::::readIntFromFileTest()", "73": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "74": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "75": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "76": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "77": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "78": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "79": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "80": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "81": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "82": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "83": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "84": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "85": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "86": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "87": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "88": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "89": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()", "90": "PagedChannelRandomAccessSourceTest::::sourceReleaseAndOpenTest()"}, "tests": [{"test_lines": [40, 56], "covered_lines": [67, 68, 78, 79, 80, 81, 82, 92, 93, 96, 98, 99, 100, 101, 102, 104, 132, 133, 162, 168, 169, 170]}, {"test_lines": [58, 71], "covered_lines": [78, 79, 80, 81, 82, 92, 93, 96, 98, 99, 100, 101, 102, 104, 112, 121, 122, 123, 124, 132, 133, 162, 168, 169, 170, 178, 182, 183, 184, 189, 190, 192, 193, 196]}, {"test_lines": [73, 90], "covered_lines": [67, 68, 78, 79, 80, 81, 82, 92, 93, 96, 98, 99, 100, 101, 102, 104, 121, 122, 124, 132, 133, 142, 145, 149, 151, 162, 168, 169, 170, 178, 179, 182, 183, 184, 185, 186, 187, 189, 190, 192, 196]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/source/RandomAccessSourceFactory.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.util.ResourceUtil;\n", "import com.itextpdf.io.util.StreamUtil;\n", "\n", "import java.io.File;\n", "import java.io.InputStream;\n", "import java.io.RandomAccessFile;\n", "import java.net.URL;\n", "import java.nio.channels.FileChannel;\n", "\n", "/**\n", " * Factory to create {@link IRandomAccessSource} objects based on various types of sources\n", " */\n", "public final class RandomAccessSourceFactory {\n", "\n", "    /**\n", "     * The default value for the forceRead flag\n", "     */\n", "    private static boolean forceReadDefaultValue = false;\n", "\n", "    /**\n", "     * Whether the full content of the source should be read into memory at construction\n", "     */\n", "    private boolean forceRead = forceReadDefaultValue;\n", "\n", "    /**\n", "     * Whether {@link java.io.RandomAccessFile} should be used instead of a {@link java.nio.channels.FileChannel}, where applicable\n", "     */\n", "    private boolean usePlainRandomAccess = false;\n", "\n", "    /**\n", "     * Whether the underlying file should have a RW lock on it or just an R lock\n", "     */\n", "    private boolean exclusivelyLockFile = false;\n", "\n", "    /**\n", "     * Creates a factory that will give preference to accessing the underling data source using memory mapped files\n", "     */\n", "    public RandomAccessSourceFactory() {\n", "    }\n", "\n", "    /**\n", "     * Determines the default value for the forceRead flag\n", "     * @param forceRead true if by default the full content will be read, false otherwise\n", "     */\n", "    public static void setForceReadDefaultValue(boolean forceRead) {\n", "        forceReadDefaultValue = forceRead;\n", "    }\n", "\n", "    /**\n", "     * Determines whether the full content of the source will be read into memory\n", "     * @param forceRead true if the full content will be read, false otherwise\n", "     * @return this object (this allows chaining of method calls)\n", "     */\n", "    public RandomAccessSourceFactory setForceRead(boolean forceRead){\n", "        this.forceRead = forceRead;\n", "        return this;\n", "    }\n", "\n", "    /**\n", "     * Determines whether {@link java.io.RandomAccessFile} should be used as the primary data access mechanism\n", "     * @param usePlainRandomAccess whether {@link java.io.RandomAccessFile} should be used as the primary data access mechanism\n", "     * @return this object (this allows chaining of method calls)\n", "     */\n", "    public RandomAccessSourceFactory setUsePlainRandomAccess(boolean usePlainRandomAccess){\n", "        this.usePlainRandomAccess = usePlainRandomAccess;\n", "        return this;\n", "    }\n", "\n", "    public RandomAccessSourceFactory setExclusivelyLockFile(boolean exclusivelyLockFile){\n", "        this.exclusivelyLockFile = exclusivelyLockFile;\n", "        return this;\n", "    }\n", "\n", "    /**\n", "     * Creates a {@link IRandomAccessSource} based on a byte array\n", "     * @param data the byte array\n", "     * @return the newly created {@link IRandomAccessSource}\n", "     */\n", "    public IRandomAccessSource createSource(byte[] data){\n", "        return new ArrayRandomAccessSource(data);\n", "    }\n", "\n", "    public IRandomAccessSource createSource(RandomAccessFile raf) throws java.io.IOException {\n", "        return new RAFRandomAccessSource(raf);\n", "    }\n", "\n", "    /**\n", "     * Creates a {@link IRandomAccessSource} based on a URL.  The data available at the URL is read into memory and used\n", "     * as the source for the {@link IRandomAccessSource}\n", "     * @param url the url to read from\n", "     * @return the newly created {@link IRandomAccessSource}\n", "     * @throws java.io.IOException in case of any I/O error.\n", "     */\n", "    public IRandomAccessSource createSource(URL url) throws java.io.IOException{\n", "        InputStream stream = url.openStream();\n", "        try {\n", "            return createSource(stream);\n", "        }\n", "        finally {\n", "            try {\n", "                stream.close();\n", "            } catch(java.io.IOException ignored) { }\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Creates or extracts a {@link IRandomAccessSource} based on an {@link InputStream}.\n", "     *\n", "     * <p>\n", "     * If the InputStream is an instance of {@link RASInputStream} then extracts the source from it.\n", "     * Otherwise The full content of the InputStream is read into memory and used\n", "     * as the source for the {@link IRandomAccessSource}\n", "     *\n", "     * @param inputStream the stream to read from\n", "     *\n", "     * @return the newly created or extracted {@link IRandomAccessSource}\n", "     *\n", "     * @throws java.io.IOException in case of any I/O error.\n", "     */\n", "    public IRandomAccessSource extractOrCreateSource(InputStream inputStream) throws java.io.IOException {\n", "        if (inputStream instanceof RASInputStream) {\n", "            return ((RASInputStream) inputStream).getSource();\n", "        }\n", "        return createSource(StreamUtil.inputStreamToArray(inputStream));\n", "    }\n", "\n", "    /**\n", "     * Creates a {@link IRandomAccessSource} based on an {@link InputStream}.\n", "     *\n", "     * <p>\n", "     * The full content of the InputStream is read into memory and used\n", "     * as the source for the {@link IRandomAccessSource}\n", "     *\n", "     * @param inputStream the stream to read from\n", "     *\n", "     * @return the newly created {@link IRandomAccessSource}\n", "     *\n", "     * @throws java.io.IOException in case of any I/O error.\n", "     */\n", "    public IRandomAccessSource createSource(InputStream inputStream) throws java.io.IOException{\n", "        return createSource(StreamUtil.inputStreamToArray(inputStream));\n", "    }\n", "\n", "    /**\n", "     * Creates a {@link IRandomAccessSource} based on a filename string.\n", "     * If the filename describes a URL, a URL based source is created\n", "     * If the filename describes a file on disk, the contents may be read into memory (if {@code forceRead} is true),\n", "     * opened using memory mapped file channel (if usePlainRandomAccess is false), or\n", "     * opened using {@link RandomAccessFile} access (if usePlainRandomAccess is true)\n", "     * This call will automatically fail over to using {@link RandomAccessFile} if the memory map operation fails\n", "     * @param filename the name of the file or resource to create the {@link IRandomAccessSource} for\n", "     * @return the newly created {@link IRandomAccessSource}\n", "     * @throws java.io.IOException in case of any I/O error\n", "     */\n", "    public IRandomAccessSource createBestSource(String filename) throws java.io.IOException{\n", "        File file = new File(filename);\n", "        if (!file.canRead()) {\n", "            if (filename.startsWith(\"file:/\")\n", "                    || filename.startsWith(\"http://\")\n", "                    || filename.startsWith(\"https://\")\n", "                    || filename.startsWith(\"jar:\")\n", "                    || filename.startsWith(\"wsjar:\")\n", "                    || filename.startsWith(\"vfszip:\")) {\n", "                return createSource(new URL(filename));\n", "            } else {\n", "                return createByReadingToMemory(filename);\n", "            }\n", "        }\n", "\n", "        if (forceRead){\n", "            return createByReadingToMemory(FileUtil.getInputStreamForFile(filename));\n", "        }\n", "\n", "        String openMode = exclusivelyLockFile ? \"rw\" : \"r\";\n", "\n", "        RandomAccessFile raf = new RandomAccessFile(file, openMode);\n", "        if (exclusivelyLockFile){\n", "            raf.getChannel().lock();\n", "        }\n", "\n", "        if (usePlainRandomAccess){\n", "            return new RAFRandomAccessSource(raf);\n", "        }\n", "\n", "        try{\n", "\n", "            // files with zero length can't be mapped and will throw an IllegalArgumentException.\n", "            // Just open using a simple RAF source.\n", "            if (raf.length() <= 0)\n", "                return new RAFRandomAccessSource(raf);\n", "\n", "            try {\n", "\n", "                // ownership of the RAF passes to whatever source is created by createBestSource.\n", "                return createBestSource(raf.getChannel());\n", "            } catch (java.io.IOException e){\n", "                if (exceptionIsMapFailureException(e)) {\n", "                    return new RAFRandomAccessSource(raf);\n", "                }\n", "                throw e;\n", "            }\n", "        } catch (Exception e) {\n", "            // If RAFRandomAccessSource constructor or createBestSource throws, then we must close the RAF we created.\n", "\n", "            try {\n", "                raf.close();\n", "            } catch (java.io.IOException ignore){}\n", "            throw e;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Creates a {@link IRandomAccessSource} based on memory mapping a file channel.\n", "     * Unless you are explicitly working with a {@code FileChannel} already, it is better to use\n", "     * {@link RandomAccessSourceFactory#createBestSource(String)}.\n", "     * If the file is large, it will be opened using a paging strategy.\n", "     * @param channel the name of the file or resource to create the {@link IRandomAccessSource} for\n", "     * @return the newly created {@link IRandomAccessSource}\n", "     * @throws java.io.IOException in case of any I/O error\n", "     */\n", "    public IRandomAccessSource createBestSource(FileChannel channel) throws java.io.IOException {\n", "\n", "        // if less than the fully mapped usage of PagedFileChannelRandomAccessSource,\n", "        // just map the whole thing and be done with it\n", "        if (channel.size() <= PagedChannelRandomAccessSource.DEFAULT_TOTAL_BUFSIZE){\n", "            return new GetBufferedRandomAccessSource(new FileChannelRandomAccessSource(channel));\n", "        } else {\n", "            return new GetBufferedRandomAccessSource(new PagedChannelRandomAccessSource(channel));\n", "        }\n", "    }\n", "\n", "    public IRandomAccessSource createRanged(IRandomAccessSource source, long[] ranges) throws java.io.IOException {\n", "        IRandomAccessSource[] sources = new IRandomAccessSource[ranges.length/2];\n", "        for(int i = 0; i < ranges.length; i+=2){\n", "            sources[i/2] = new WindowRandomAccessSource(source, ranges[i], ranges[i+1]);\n", "        }\n", "        return new GroupedRandomAccessSource(sources);\n", "    }\n", "\n", "    /**\n", "     * Creates a new {@link IRandomAccessSource} by reading the specified file/resource into memory\n", "     * @param filename the name of the resource to read\n", "     * @return the newly created {@link IRandomAccessSource}\n", "     * @throws java.io.IOException if reading the underling file or stream fails\n", "     */\n", "    private IRandomAccessSource createByReadingToMemory(String filename) throws java.io.IOException {\n", "        InputStream stream = ResourceUtil.getResourceStream(filename);\n", "        if (stream == null) {\n", "            throw new java.io.IOException(MessageFormatUtil.format(IoExceptionMessageConstant.NOT_FOUND_AS_FILE_OR_RESOURCE, filename));\n", "        }\n", "        return createByReadingToMemory(stream);\n", "    }\n", "\n", "    /**\n", "     * Creates a new {@link IRandomAccessSource} by reading the specified file/resource into memory\n", "     * @param stream the name of the resource to read\n", "     * @return the newly created {@link IRandomAccessSource}\n", "     * @throws java.io.IOException if reading the underling file or stream fails\n", "     */\n", "    private IRandomAccessSource createByReadingToMemory(InputStream stream) throws java.io.IOException {\n", "        try {\n", "            return new ArrayRandomAccessSource(StreamUtil.inputStreamToArray(stream));\n", "        }\n", "        finally {\n", "            try {\n", "                stream.close();\n", "            } catch (java.io.IOException ignored) { }\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Utility method that determines whether a given java.io.IOException is the result\n", "     * of a failure to map a memory mapped file.  It would be better if the runtime\n", "     * provided a special exception for this case, but it doesn't, so we have to rely\n", "     * on parsing the exception message.\n", "     * @param e the exception to check\n", "     * @return true if the exception was the result of a failure to map a memory mapped file\n", "     */\n", "    private static boolean exceptionIsMapFailureException(java.io.IOException e){\n", "        if (e.getMessage() != null && e.getMessage().contains(\"Map failed\"))\n", "            return true;\n", "        return false;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import com.itextpdf.commons.utils.FileUtil;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import java.io.InputStream;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class RandomAccessSourceFactoryTest extends ExtendedITextTest {\n", "\n", "    private final static String SOURCE_FILE = \"./src/test/resources/com/itextpdf/io/source/RAF.txt\";\n", "\n", "    @Test\n", "    public void readRASInputStreamClosedTest() throws IOException {\n", "        String fileName = SOURCE_FILE;\n", "        try (InputStream pdfStream = FileUtil.getInputStreamForFile(fileName)) {\n", "\n", "            IRandomAccessSource randomAccessSource = new RandomAccessSourceFactory()\n", "                    .extractOrCreateSource(pdfStream);\n", "            RASInputStream rasInputStream = new RASInputStream(randomAccessSource);\n", "            IRandomAccessSource extractedRandomAccessSource = new RandomAccessSourceFactory()\n", "                .extractOrCreateSource(rasInputStream);\n", "\n", "            extractedRandomAccessSource.close();\n", "\n", "            Exception e = Assert.assertThrows(IllegalStateException.class, () -> rasInputStream.read());\n", "            Assert.assertEquals(IoExceptionMessageConstant.ALREADY_CLOSED, e.getMessage());\n", "\n", "            e = Assert.assertThrows(IllegalStateException.class,\n", "                    () -> randomAccessSource.get(0));\n", "            Assert.assertEquals(IoExceptionMessageConstant.ALREADY_CLOSED, e.getMessage());\n", "            e = Assert.assertThrows(IllegalStateException.class,\n", "                    () -> randomAccessSource.get(0, new byte[10], 0, 10));\n", "            Assert.assertEquals(IoExceptionMessageConstant.ALREADY_CLOSED, e.getMessage());\n", "            e = Assert.assertThrows(IllegalStateException.class,\n", "                    () -> randomAccessSource.length());\n", "            Assert.assertEquals(IoExceptionMessageConstant.ALREADY_CLOSED, e.getMessage());\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void readRASInputStreamTest() throws IOException {\n", "        String fileName = SOURCE_FILE;\n", "        try (InputStream pdfStream = FileUtil.getInputStreamForFile(fileName)) {\n", "            IRandomAccessSource randomAccessSource = new RandomAccessSourceFactory()\n", "                    .extractOrCreateSource(pdfStream);\n", "            RASInputStream rasInputStream = new RASInputStream(randomAccessSource);\n", "            IRandomAccessSource extractedRandomAccessSource = new RandomAccessSourceFactory()\n", "                    .extractOrCreateSource(rasInputStream);\n", "\n", "            Assert.assertEquals(72, rasInputStream.read());\n", "            Assert.assertEquals(72, extractedRandomAccessSource.get(0));\n", "            Assert.assertEquals(extractedRandomAccessSource, rasInputStream.getSource());\n", "        }\n", "    }\n", "}\n"], "method_lines_dic": {"RandomAccessSourceFactory::::setForceReadDefaultValue(boolean)": [72, 74], "RandomAccessSourceFactory::::setForceRead(boolean)": [81, 84], "RandomAccessSourceFactory::::setUsePlainRandomAccess(boolean)": [91, 94], "RandomAccessSourceFactory::::setExclusivelyLockFile(boolean)": [96, 99], "RandomAccessSourceFactory::::createSource(byte[])": [106, 108], "RandomAccessSourceFactory::::createSource(java.io.RandomAccessFile)": [110, 112], "RandomAccessSourceFactory::::createSource(java.net.URL)": [121, 131], "RandomAccessSourceFactory::::extractOrCreateSource(java.io.InputStream)": [147, 152], "RandomAccessSourceFactory::::createSource(java.io.InputStream)": [167, 169], "RandomAccessSourceFactory::::createBestSource(java.lang.String)": [182, 237], "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)": [248, 257], "RandomAccessSourceFactory::::createRanged(com.itextpdf.io.source.IRandomAccessSource,long[])": [259, 265], "RandomAccessSourceFactory::::createByReadingToMemory(java.lang.String)": [273, 279], "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)": [287, 296], "RandomAccessSourceFactory::::exceptionIsMapFailureException(java.io.IOException)": [306, 310]}, "test_method_lines_dic": {"RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()": [41, 67], "RandomAccessSourceFactoryTest::::readRASInputStreamTest()": [69, 83]}, "reverse_method_lines_dic": {"72": "RandomAccessSourceFactory::::setForceReadDefaultValue(boolean)", "73": "RandomAccessSourceFactory::::setForceReadDefaultValue(boolean)", "74": "RandomAccessSourceFactory::::setForceReadDefaultValue(boolean)", "81": "RandomAccessSourceFactory::::setForceRead(boolean)", "82": "RandomAccessSourceFactory::::setForceRead(boolean)", "83": "RandomAccessSourceFactory::::setForceRead(boolean)", "84": "RandomAccessSourceFactory::::setForceRead(boolean)", "91": "RandomAccessSourceFactory::::setUsePlainRandomAccess(boolean)", "92": "RandomAccessSourceFactory::::setUsePlainRandomAccess(boolean)", "93": "RandomAccessSourceFactory::::setUsePlainRandomAccess(boolean)", "94": "RandomAccessSourceFactory::::setUsePlainRandomAccess(boolean)", "96": "RandomAccessSourceFactory::::setExclusivelyLockFile(boolean)", "97": "RandomAccessSourceFactory::::setExclusivelyLockFile(boolean)", "98": "RandomAccessSourceFactory::::setExclusivelyLockFile(boolean)", "99": "RandomAccessSourceFactory::::setExclusivelyLockFile(boolean)", "106": "RandomAccessSourceFactory::::createSource(byte[])", "107": "RandomAccessSourceFactory::::createSource(byte[])", "108": "RandomAccessSourceFactory::::createSource(byte[])", "110": "RandomAccessSourceFactory::::createSource(java.io.RandomAccessFile)", "111": "RandomAccessSourceFactory::::createSource(java.io.RandomAccessFile)", "112": "RandomAccessSourceFactory::::createSource(java.io.RandomAccessFile)", "121": "RandomAccessSourceFactory::::createSource(java.net.URL)", "122": "RandomAccessSourceFactory::::createSource(java.net.URL)", "123": "RandomAccessSourceFactory::::createSource(java.net.URL)", "124": "RandomAccessSourceFactory::::createSource(java.net.URL)", "125": "RandomAccessSourceFactory::::createSource(java.net.URL)", "126": "RandomAccessSourceFactory::::createSource(java.net.URL)", "127": "RandomAccessSourceFactory::::createSource(java.net.URL)", "128": "RandomAccessSourceFactory::::createSource(java.net.URL)", "129": "RandomAccessSourceFactory::::createSource(java.net.URL)", "130": "RandomAccessSourceFactory::::createSource(java.net.URL)", "131": "RandomAccessSourceFactory::::createSource(java.net.URL)", "147": "RandomAccessSourceFactory::::extractOrCreateSource(java.io.InputStream)", "148": "RandomAccessSourceFactory::::extractOrCreateSource(java.io.InputStream)", "149": "RandomAccessSourceFactory::::extractOrCreateSource(java.io.InputStream)", "150": "RandomAccessSourceFactory::::extractOrCreateSource(java.io.InputStream)", "151": "RandomAccessSourceFactory::::extractOrCreateSource(java.io.InputStream)", "152": "RandomAccessSourceFactory::::extractOrCreateSource(java.io.InputStream)", "167": "RandomAccessSourceFactory::::createSource(java.io.InputStream)", "168": "RandomAccessSourceFactory::::createSource(java.io.InputStream)", "169": "RandomAccessSourceFactory::::createSource(java.io.InputStream)", "182": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "183": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "184": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "185": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "186": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "187": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "188": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "189": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "190": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "191": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "192": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "193": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "194": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "195": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "196": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "197": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "198": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "199": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "200": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "201": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "202": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "203": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "204": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "205": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "206": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "207": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "208": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "209": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "210": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "211": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "212": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "213": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "214": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "215": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "216": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "217": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "218": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "219": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "220": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "221": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "222": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "223": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "224": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "225": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "226": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "227": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "228": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "229": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "230": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "231": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "232": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "233": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "234": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "235": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "236": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "237": "RandomAccessSourceFactory::::createBestSource(java.lang.String)", "248": "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)", "249": "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)", "250": "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)", "251": "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)", "252": "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)", "253": "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)", "254": "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)", "255": "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)", "256": "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)", "257": "RandomAccessSourceFactory::::createBestSource(java.nio.channels.FileChannel)", "259": "RandomAccessSourceFactory::::createRanged(com.itextpdf.io.source.IRandomAccessSource,long[])", "260": "RandomAccessSourceFactory::::createRanged(com.itextpdf.io.source.IRandomAccessSource,long[])", "261": "RandomAccessSourceFactory::::createRanged(com.itextpdf.io.source.IRandomAccessSource,long[])", "262": "RandomAccessSourceFactory::::createRanged(com.itextpdf.io.source.IRandomAccessSource,long[])", "263": "RandomAccessSourceFactory::::createRanged(com.itextpdf.io.source.IRandomAccessSource,long[])", "264": "RandomAccessSourceFactory::::createRanged(com.itextpdf.io.source.IRandomAccessSource,long[])", "265": "RandomAccessSourceFactory::::createRanged(com.itextpdf.io.source.IRandomAccessSource,long[])", "273": "RandomAccessSourceFactory::::createByReadingToMemory(java.lang.String)", "274": "RandomAccessSourceFactory::::createByReadingToMemory(java.lang.String)", "275": "RandomAccessSourceFactory::::createByReadingToMemory(java.lang.String)", "276": "RandomAccessSourceFactory::::createByReadingToMemory(java.lang.String)", "277": "RandomAccessSourceFactory::::createByReadingToMemory(java.lang.String)", "278": "RandomAccessSourceFactory::::createByReadingToMemory(java.lang.String)", "279": "RandomAccessSourceFactory::::createByReadingToMemory(java.lang.String)", "287": "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)", "288": "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)", "289": "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)", "290": "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)", "291": "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)", "292": "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)", "293": "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)", "294": "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)", "295": "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)", "296": "RandomAccessSourceFactory::::createByReadingToMemory(java.io.InputStream)", "306": "RandomAccessSourceFactory::::exceptionIsMapFailureException(java.io.IOException)", "307": "RandomAccessSourceFactory::::exceptionIsMapFailureException(java.io.IOException)", "308": "RandomAccessSourceFactory::::exceptionIsMapFailureException(java.io.IOException)", "309": "RandomAccessSourceFactory::::exceptionIsMapFailureException(java.io.IOException)", "310": "RandomAccessSourceFactory::::exceptionIsMapFailureException(java.io.IOException)"}, "test_reverse_method_lines_dic": {"41": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "42": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "43": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "44": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "45": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "46": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "47": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "48": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "49": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "50": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "51": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "52": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "53": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "54": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "55": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "56": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "57": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "58": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "59": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "60": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "61": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "62": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "63": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "64": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "65": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "66": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "67": "RandomAccessSourceFactoryTest::::readRASInputStreamClosedTest()", "69": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "70": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "71": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "72": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "73": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "74": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "75": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "76": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "77": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "78": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "79": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "80": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "81": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "82": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()", "83": "RandomAccessSourceFactoryTest::::readRASInputStreamTest()"}, "tests": [{"test_lines": [41, 67], "covered_lines": [45, 50, 55, 60, 65, 66, 107, 148, 149, 151]}, {"test_lines": [69, 83], "covered_lines": [45, 50, 55, 60, 65, 66, 107, 148, 149, 151]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/source/ByteBufferRandomAccessSource.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import java.lang.reflect.Method;\n", "import java.nio.BufferUnderflowException;\n", "import java.security.AccessController;\n", "import java.security.PrivilegedAction;\n", "import org.slf4j.Logger;\n", "import org.slf4j.LoggerFactory;\n", "\n", "/**\n", " * A RandomAccessSource that is based on an underlying {@link java.nio.ByteBuffer}.  This class takes steps to ensure\n", " * that the byte buffer\n", " * is completely freed from memory during {@link ByteBufferRandomAccessSource#close()} if unmapping functionality is enabled\n", " */\n", "class ByteBufferRandomAccessSource implements IRandomAccessSource {\n", "\n", "    /**\n", "     * A flag to allow unmapping hack for cleaning mapped buffer\n", "     */\n", "    private static boolean allowUnmapping = true;\n", "\n", "    /**\n", "     * Internal cache of memory mapped buffers\n", "     */\n", "    private final java.nio.ByteBuffer byteBuffer;\n", "\n", "    /**\n", "     * Constructs a new {@link ByteBufferRandomAccessSource} based on the specified ByteBuffer\n", "     *\n", "     * @param byteBuffer the buffer to use as the backing store\n", "     */\n", "    public ByteBufferRandomAccessSource(java.nio.ByteBuffer byteBuffer) {\n", "        this.byteBuffer = byteBuffer;\n", "    }\n", "\n", "    /**\n", "     * Enables ByteBuffer memory unmapping hack\n", "     */\n", "    public static void enableByteBufferMemoryUnmapping() {\n", "        allowUnmapping = false;\n", "    }\n", "\n", "    /**\n", "     * Disables ByteBuffer memory unmapping hack\n", "     */\n", "    public static void disableByteBufferMemoryUnmapping() {\n", "        allowUnmapping = false;\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     * <p>\n", "     * Note: Because ByteBuffers don't support long indexing, the position must be a valid positive int\n", "     *\n", "     * @param position the position to read the byte from - must be less than Integer.MAX_VALUE\n", "     */\n", "    public int get(long position) {\n", "        if (position > Integer.MAX_VALUE) {\n", "            throw new IllegalArgumentException(\"Position must be less than Integer.MAX_VALUE\");\n", "        }\n", "        try {\n", "\n", "            if (position >= byteBuffer.limit()) {\n", "                return -1;\n", "            }\n", "            return byteBuffer.duplicate().get((int) position) & 0xff;\n", "        } catch (BufferUnderflowException e) {\n", "            // EOF\n", "            return -1;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     * <p>\n", "     * Note: Because ByteBuffers don't support long indexing, the position must be a valid positive int\n", "     *\n", "     * @param position the position to read the byte from - must be less than Integer.MAX_VALUE\n", "     */\n", "    public int get(long position, byte[] bytes, int off, int len) {\n", "        if (position > Integer.MAX_VALUE) {\n", "            throw new IllegalArgumentException(\"Position must be less than Integer.MAX_VALUE\");\n", "        }\n", "\n", "        if (position >= byteBuffer.limit()) {\n", "            return -1;\n", "        }\n", "\n", "        final java.nio.ByteBuffer byteBufferCopy = byteBuffer.duplicate();\n", "        byteBufferCopy.position((int) position);\n", "        final int bytesFromThisBuffer = Math.min(len, byteBufferCopy.remaining());\n", "        byteBufferCopy.get(bytes, off, bytesFromThisBuffer);\n", "\n", "        return bytesFromThisBuffer;\n", "    }\n", "\n", "\n", "    /**\n", "     * {@inheritDoc}\n", "     */\n", "    public long length() {\n", "        return byteBuffer.limit();\n", "    }\n", "\n", "    /**\n", "     * @see java.io.RandomAccessFile#close()\n", "     * Cleans the mapped bytebuffers and closes the channel if unmapping functionality is enabled\n", "     */\n", "    public void close() throws java.io.IOException {\n", "        if (allowUnmapping) {\n", "            clean(byteBuffer);\n", "        }\n", "    }\n", "\n", "\n", "    /**\n", "     * <code>true</code>, if this platform supports unmapping mmapped files.\n", "     */\n", "    public static final boolean UNMAP_SUPPORTED;\n", "\n", "    /**\n", "     * Reference to a BufferCleaner that does unmapping; {@code null} if not supported.\n", "     */\n", "    private static final BufferCleaner CLEANER;\n", "\n", "    static {\n", "        final Object hack = AccessController.doPrivileged(\n", "                (PrivilegedAction<Object>) BufferCleaner::unmapHackImpl);\n", "        if (hack instanceof BufferCleaner) {\n", "            CLEANER = (BufferCleaner) hack;\n", "            UNMAP_SUPPORTED = true;\n", "        } else {\n", "            CLEANER = null;\n", "            UNMAP_SUPPORTED = false;\n", "        }\n", "    }\n", "\n", "    /**\n", "     * invokes the clean method on the ByteBuffer's cleaner\n", "     *\n", "     * @param buffer ByteBuffer\n", "     *\n", "     * @return boolean true on success\n", "     */\n", "    private static boolean clean(final java.nio.ByteBuffer buffer) {\n", "        if (buffer == null || !buffer.isDirect()) {\n", "            return false;\n", "        }\n", "\n", "        return AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> cleanByUnmapping(buffer));\n", "    }\n", "\n", "    private static boolean cleanByUnmapping(final java.nio.ByteBuffer buffer) {\n", "        Boolean success = Boolean.FALSE;\n", "        try {\n", "            // java 9\n", "            if (UNMAP_SUPPORTED) {\n", "                CLEANER.freeBuffer(buffer.toString(), buffer);\n", "            }\n", "            // java 8 and lower\n", "            else {\n", "                Method getCleanerMethod = buffer.getClass().getMethod(\"cleaner\", (Class<?>[]) null);\n", "                getCleanerMethod.setAccessible(true);\n", "                Object cleaner = getCleanerMethod.invoke(buffer, (Object[]) null);\n", "                Method clean = cleaner.getClass().getMethod(\"clean\", (Class<?>[]) null);\n", "                clean.invoke(cleaner, (Object[]) null);\n", "            }\n", "            success = Boolean.TRUE;\n", "        } catch (Exception e) {\n", "            // This really is a show stopper on windows\n", "            Logger logger = LoggerFactory.getLogger(ByteBufferRandomAccessSource.class);\n", "            logger.debug(e.getMessage());\n", "        }\n", "        return success;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import com.itextpdf.test.AssertUtil;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import java.io.RandomAccessFile;\n", "import java.nio.ByteBuffer;\n", "import java.nio.channels.FileChannel;\n", "import java.util.ArrayList;\n", "import java.util.Arrays;\n", "import java.util.List;\n", "import java.util.concurrent.Callable;\n", "import java.util.concurrent.ExecutionException;\n", "import java.util.concurrent.ExecutorService;\n", "import java.util.concurrent.Executors;\n", "import java.util.concurrent.Future;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "@Category(UnitTest.class)\n", "public class ByteBufferRandomAccessSourceTest extends ExtendedITextTest {\n", "\n", "    private final static String SOURCE_FILE = \"./src/test/resources/com/itextpdf/io/source/RAF.txt\";\n", "\n", "    @Test\n", "    public void heapByteBufferTest() {\n", "        IRandomAccessSource source = new ByteBufferRandomAccessSource(ByteBuffer.allocate(10));\n", "        AssertUtil.doesNotThrow(source::close);\n", "    }\n", "\n", "    @Test\n", "    public void nullByteBufferTest() {\n", "        IRandomAccessSource source = new ByteBufferRandomAccessSource(null);\n", "        AssertUtil.doesNotThrow(source::close);\n", "    }\n", "\n", "    @Test\n", "    public void disableUnmappingTest() throws IOException {\n", "        ByteBufferRandomAccessSource.disableByteBufferMemoryUnmapping();\n", "        IRandomAccessSource source;\n", "        try (RandomAccessFile raf = new RandomAccessFile(SOURCE_FILE, \"r\")) {\n", "            FileChannel channel = raf.getChannel();\n", "\n", "            source = new ByteBufferRandomAccessSource(\n", "                    channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size()));\n", "        }\n", "        AssertUtil.doesNotThrow(() -> source.get(0));\n", "\n", "        source.close();\n", "        AssertUtil.doesNotThrow(() -> source.get(0));\n", "\n", "        ByteBufferRandomAccessSource.enableByteBufferMemoryUnmapping();\n", "    }\n", "\n", "    @Test\n", "    public void readIntFromFile() throws IOException {\n", "        try (RandomAccessFile raf = new RandomAccessFile(SOURCE_FILE, \"r\")) {\n", "            FileChannel channel = raf.getChannel();\n", "\n", "            IRandomAccessSource source = new ByteBufferRandomAccessSource(\n", "                    channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size()));\n", "\n", "            Assert.assertEquals(13, source.length());\n", "            Assert.assertEquals(72, source.get(0));\n", "            Assert.assertEquals(44, source.get(5));\n", "            Assert.assertEquals(33, source.get(12));\n", "            Assert.assertEquals(100, source.get(11));\n", "            Assert.assertEquals(-1, source.get(13));\n", "\n", "            long position = Integer.MAX_VALUE + 1L;\n", "            Assert.assertThrows(IllegalArgumentException.class, () -> source.get(position));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void readBytesFromFile() throws IOException {\n", "        try (RandomAccessFile raf = new RandomAccessFile(SOURCE_FILE, \"r\")) {\n", "            FileChannel channel = raf.getChannel();\n", "\n", "            IRandomAccessSource source = new ByteBufferRandomAccessSource(\n", "                    channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size()));\n", "\n", "            byte[] expected = new byte[] {72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33};\n", "            byte[] result = new byte[13];\n", "            source.get(0, result, 0, 13);\n", "            Assert.assertArrayEquals(expected, result);\n", "\n", "            expected = new byte[] {111, 44, 32, 119, 111, 114, 108, 100};\n", "            result = new byte[8];\n", "            source.get(4, result, 0, 8);\n", "            Assert.assertArrayEquals(expected, result);\n", "\n", "            long position = Integer.MAX_VALUE + 1L;\n", "            Assert.assertThrows(IllegalArgumentException.class, () -> source.get(position, new byte[6], 2, 4));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void readFileWithMultipleThreadsTest() throws InterruptedException, ExecutionException, IOException {\n", "\n", "        try (RandomAccessFile raf = new RandomAccessFile(SOURCE_FILE, \"r\")) {\n", "            FileChannel channel = raf.getChannel();\n", "\n", "            IRandomAccessSource source = new ByteBufferRandomAccessSource(\n", "                    channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size()));\n", "\n", "            ReadFileTask task1 = new ReadFileTask(source);\n", "            ReadFileTask task2 = new ReadFileTask(source);\n", "\n", "            ExecutorService executor = Executors.newFixedThreadPool(2);\n", "            Future<List<Integer>> future1 = executor.submit(task1);\n", "            Future<List<Integer>> future2 = executor.submit(task2);\n", "\n", "            List<Integer> expected = Arrays.asList(13,\n", "                    72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33,\n", "                    33, 100, 108, 114, 111, 119, 32, 44, 111, 108, 108, 101, 72);\n", "\n", "            List<Integer> result1 = future1.get();\n", "            List<Integer> result2 = future2.get();\n", "\n", "            Assert.assertEquals(expected, result1);\n", "            Assert.assertEquals(expected, result2);\n", "        }\n", "    }\n", "\n", "    private static class ReadFileTask implements Callable<List<Integer>> {\n", "\n", "        final private IRandomAccessSource source;\n", "\n", "        ReadFileTask(IRandomAccessSource source) {\n", "            this.source = source;\n", "        }\n", "\n", "        public List<Integer> call() throws IOException {\n", "            List<Integer> result = new ArrayList<>();\n", "\n", "            result.add((int) source.length());\n", "            for (long position = 0; position < source.length(); ++position) {\n", "                result.add(source.get(position));\n", "            }\n", "            for (long position = source.length() - 1; position >= 0; --position) {\n", "                result.add(source.get(position));\n", "            }\n", "\n", "            return result;\n", "        }\n", "    }\n", "}\n"], "method_lines_dic": {"ByteBufferRandomAccessSource::::enableByteBufferMemoryUnmapping()": [61, 63], "ByteBufferRandomAccessSource::::disableByteBufferMemoryUnmapping()": [68, 70], "ByteBufferRandomAccessSource::::get(long)": [79, 93], "ByteBufferRandomAccessSource::::get(long,byte[],int,int)": [102, 117], "ByteBufferRandomAccessSource::::length()": [123, 125], "ByteBufferRandomAccessSource::::close()": [131, 135], "ByteBufferRandomAccessSource::::clean(java.nio.ByteBuffer)": [167, 173], "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)": [175, 197]}, "test_method_lines_dic": {"ByteBufferRandomAccessSourceTest::::heapByteBufferTest()": [50, 54], "ByteBufferRandomAccessSourceTest::::nullByteBufferTest()": [56, 60], "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()": [62, 78], "ByteBufferRandomAccessSourceTest::::readIntFromFile()": [80, 98], "ByteBufferRandomAccessSourceTest::::readBytesFromFile()": [100, 121], "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()": [123, 149], "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()": [159, 171]}, "reverse_method_lines_dic": {"61": "ByteBufferRandomAccessSource::::enableByteBufferMemoryUnmapping()", "62": "ByteBufferRandomAccessSource::::enableByteBufferMemoryUnmapping()", "63": "ByteBufferRandomAccessSource::::enableByteBufferMemoryUnmapping()", "68": "ByteBufferRandomAccessSource::::disableByteBufferMemoryUnmapping()", "69": "ByteBufferRandomAccessSource::::disableByteBufferMemoryUnmapping()", "70": "ByteBufferRandomAccessSource::::disableByteBufferMemoryUnmapping()", "79": "ByteBufferRandomAccessSource::::get(long)", "80": "ByteBufferRandomAccessSource::::get(long)", "81": "ByteBufferRandomAccessSource::::get(long)", "82": "ByteBufferRandomAccessSource::::get(long)", "83": "ByteBufferRandomAccessSource::::get(long)", "84": "ByteBufferRandomAccessSource::::get(long)", "85": "ByteBufferRandomAccessSource::::get(long)", "86": "ByteBufferRandomAccessSource::::get(long)", "87": "ByteBufferRandomAccessSource::::get(long)", "88": "ByteBufferRandomAccessSource::::get(long)", "89": "ByteBufferRandomAccessSource::::get(long)", "90": "ByteBufferRandomAccessSource::::get(long)", "91": "ByteBufferRandomAccessSource::::get(long)", "92": "ByteBufferRandomAccessSource::::get(long)", "93": "ByteBufferRandomAccessSource::::get(long)", "102": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "103": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "104": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "105": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "106": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "107": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "108": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "109": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "110": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "111": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "112": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "113": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "114": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "115": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "116": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "117": "ByteBufferRandomAccessSource::::get(long,byte[],int,int)", "123": "ByteBufferRandomAccessSource::::length()", "124": "ByteBufferRandomAccessSource::::length()", "125": "ByteBufferRandomAccessSource::::length()", "131": "ByteBufferRandomAccessSource::::close()", "132": "ByteBufferRandomAccessSource::::close()", "133": "ByteBufferRandomAccessSource::::close()", "134": "ByteBufferRandomAccessSource::::close()", "135": "ByteBufferRandomAccessSource::::close()", "167": "ByteBufferRandomAccessSource::::clean(java.nio.ByteBuffer)", "168": "ByteBufferRandomAccessSource::::clean(java.nio.ByteBuffer)", "169": "ByteBufferRandomAccessSource::::clean(java.nio.ByteBuffer)", "170": "ByteBufferRandomAccessSource::::clean(java.nio.ByteBuffer)", "171": "ByteBufferRandomAccessSource::::clean(java.nio.ByteBuffer)", "172": "ByteBufferRandomAccessSource::::clean(java.nio.ByteBuffer)", "173": "ByteBufferRandomAccessSource::::clean(java.nio.ByteBuffer)", "175": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "176": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "177": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "178": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "179": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "180": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "181": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "182": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "183": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "184": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "185": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "186": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "187": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "188": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "189": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "190": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "191": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "192": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "193": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "194": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "195": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "196": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)", "197": "ByteBufferRandomAccessSource::::cleanByUnmapping(java.nio.ByteBuffer)"}, "test_reverse_method_lines_dic": {"50": "ByteBufferRandomAccessSourceTest::::heapByteBufferTest()", "51": "ByteBufferRandomAccessSourceTest::::heapByteBufferTest()", "52": "ByteBufferRandomAccessSourceTest::::heapByteBufferTest()", "53": "ByteBufferRandomAccessSourceTest::::heapByteBufferTest()", "54": "ByteBufferRandomAccessSourceTest::::heapByteBufferTest()", "56": "ByteBufferRandomAccessSourceTest::::nullByteBufferTest()", "57": "ByteBufferRandomAccessSourceTest::::nullByteBufferTest()", "58": "ByteBufferRandomAccessSourceTest::::nullByteBufferTest()", "59": "ByteBufferRandomAccessSourceTest::::nullByteBufferTest()", "60": "ByteBufferRandomAccessSourceTest::::nullByteBufferTest()", "62": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "63": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "64": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "65": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "66": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "67": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "68": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "69": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "70": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "71": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "72": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "73": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "74": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "75": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "76": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "77": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "78": "ByteBufferRandomAccessSourceTest::::disableUnmappingTest()", "80": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "81": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "82": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "83": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "84": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "85": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "86": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "87": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "88": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "89": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "90": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "91": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "92": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "93": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "94": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "95": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "96": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "97": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "98": "ByteBufferRandomAccessSourceTest::::readIntFromFile()", "100": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "101": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "102": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "103": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "104": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "105": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "106": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "107": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "108": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "109": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "110": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "111": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "112": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "113": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "114": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "115": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "116": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "117": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "118": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "119": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "120": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "121": "ByteBufferRandomAccessSourceTest::::readBytesFromFile()", "123": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "124": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "125": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "126": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "127": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "128": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "129": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "130": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "131": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "132": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "133": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "134": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "135": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "136": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "137": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "138": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "139": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "140": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "141": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "142": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "143": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "144": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "145": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "146": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "147": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "148": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "149": "ByteBufferRandomAccessSourceTest::::readFileWithMultipleThreadsTest()", "159": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "160": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "161": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "162": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "163": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "164": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "165": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "166": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "167": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "168": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "169": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "170": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()", "171": "ByteBufferRandomAccessSourceTest.ReadFileTask::::call()"}, "tests": [{"test_lines": [50, 54], "covered_lines": [42, 54, 55, 56, 132, 133, 135, 149, 151, 155, 156, 158, 168, 169]}, {"test_lines": [56, 60], "covered_lines": [42, 54, 55, 56, 132, 133, 135, 149, 151, 155, 156, 158, 168, 169]}, {"test_lines": [62, 78], "covered_lines": [42, 54, 55, 56, 62, 63, 69, 70, 80, 85, 88, 132, 135, 149, 151, 155, 156, 158]}, {"test_lines": [80, 98], "covered_lines": [42, 54, 55, 56, 80, 81, 85, 86, 88, 124, 149, 151, 155, 156, 158]}, {"test_lines": [100, 121], "covered_lines": [42, 54, 55, 56, 103, 104, 107, 111, 112, 113, 114, 116, 149, 151, 155, 156, 158]}, {"test_lines": [123, 149], "covered_lines": [42, 54, 55, 56, 80, 85, 88, 124, 149, 151, 155, 156, 158]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/source/PdfTokenizer.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "import com.itextpdf.io.logs.IoLogMessageConstant;\n", "\n", "import java.io.Closeable;\n", "import java.util.Arrays;\n", "import org.slf4j.Logger;\n", "import org.slf4j.LoggerFactory;\n", "\n", "public class PdfTokenizer implements Closeable {\n", "\n", "\n", "    public enum TokenType {\n", "        Number,\n", "        String,\n", "        Name,\n", "        Comment,\n", "        StartArray,\n", "        EndArray,\n", "        StartDic,\n", "        EndDic,\n", "        Ref,\n", "        Obj,\n", "        EndObj,\n", "        Other,\n", "        EndOfFile\n", "    }\n", "\n", "    public static final boolean[] delims = {\n", "            true, true, false, false, false, false, false, false, false, false,\n", "            true, true, false, true, true, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, true, false, false, false, false, true, false,\n", "            false, true, true, false, false, false, false, false, true, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, true, false, true, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, true, false, true, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false, false, false, false,\n", "            false, false, false, false, false, false, false};\n", "\n", "\n", "    public static final byte[] Obj = ByteUtils.getIsoBytes(\"obj\");\n", "    public static final byte[] R = ByteUtils.getIsoBytes(\"R\");\n", "    public static final byte[] Xref = ByteUtils.getIsoBytes(\"xref\");\n", "    public static final byte[] Startxref = ByteUtils.getIsoBytes(\"startxref\");\n", "    public static final byte[] Stream = ByteUtils.getIsoBytes(\"stream\");\n", "    public static final byte[] Trailer = ByteUtils.getIsoBytes(\"trailer\");\n", "    public static final byte[] N = ByteUtils.getIsoBytes(\"n\");\n", "    public static final byte[] F = ByteUtils.getIsoBytes(\"f\");\n", "    public static final byte[] Null = ByteUtils.getIsoBytes(\"null\");\n", "    public static final byte[] True = ByteUtils.getIsoBytes(\"true\");\n", "    public static final byte[] False = ByteUtils.getIsoBytes(\"false\");\n", "\n", "    protected TokenType type;\n", "    protected int reference;\n", "    protected int generation;\n", "    protected boolean hexString;\n", "    protected ByteBuffer outBuf;\n", "\n", "    private final RandomAccessFileOrArray file;\n", "    /**\n", "     * Streams are closed automatically.\n", "     */\n", "    private boolean closeStream = true;\n", "\n", "    /**\n", "     * Creates a PdfTokenizer for the specified {@link RandomAccessFileOrArray}.\n", "     * The beginning of the file is read to determine the location of the header, and the data source is adjusted\n", "     * as necessary to account for any junk that occurs in the byte source before the header\n", "     *\n", "     * @param file the source\n", "     */\n", "    public PdfTokenizer(RandomAccessFileOrArray file) {\n", "        this.file = file;\n", "        this.outBuf = new ByteBuffer();\n", "    }\n", "\n", "    public void seek(long pos) {\n", "        file.seek(pos);\n", "    }\n", "\n", "    public void readFully(byte[] bytes) throws java.io.IOException {\n", "        file.readFully(bytes);\n", "    }\n", "\n", "    public long getPosition() {\n", "        return file.getPosition();\n", "    }\n", "\n", "    public void close() throws java.io.IOException {\n", "        if (closeStream)\n", "            file.close();\n", "    }\n", "\n", "    public long length() {\n", "        return file.length();\n", "    }\n", "\n", "    public int read() throws java.io.IOException {\n", "        return file.read();\n", "    }\n", "\n", "    public String readString(int size) throws java.io.IOException {\n", "        StringBuilder buf = new StringBuilder();\n", "        int ch;\n", "        while ((size--) > 0) {\n", "            ch = read();\n", "            if (ch == -1)\n", "                break;\n", "            buf.append((char) ch);\n", "        }\n", "        return buf.toString();\n", "    }\n", "\n", "    public TokenType getTokenType() {\n", "        return type;\n", "    }\n", "\n", "    public byte[] getByteContent() {\n", "        return outBuf.toByteArray();\n", "    }\n", "\n", "    public String getStringValue() {\n", "        return new String(outBuf.getInternalBuffer(), 0, outBuf.size());\n", "    }\n", "\n", "    public byte[] getDecodedStringContent() {\n", "        return decodeStringContent(outBuf.getInternalBuffer(), 0, outBuf.size() - 1, isHexString());\n", "    }\n", "\n", "    public boolean tokenValueEqualsTo(byte[] cmp) {\n", "        if (cmp == null)\n", "            return false;\n", "\n", "        int size = cmp.length;\n", "        if (outBuf.size() != size)\n", "            return false;\n", "\n", "        for (int i = 0; i < size; i++)\n", "            if (cmp[i] != outBuf.getInternalBuffer()[i])\n", "                return false;\n", "        return true;\n", "    }\n", "\n", "    public int getObjNr() {\n", "        return reference;\n", "    }\n", "\n", "    public int getGenNr() {\n", "        return generation;\n", "    }\n", "\n", "    public void backOnePosition(int ch) {\n", "        if (ch != -1)\n", "            file.pushBack((byte) ch);\n", "    }\n", "\n", "    public int getHeaderOffset() throws java.io.IOException {\n", "        String str = readString(1024);\n", "        int idx = str.indexOf(\"%PDF-\");\n", "        if (idx < 0) {\n", "            idx = str.indexOf(\"%FDF-\");\n", "            if (idx < 0)\n", "                throw new IOException(IoExceptionMessageConstant.PDF_HEADER_NOT_FOUND, this);\n", "        }\n", "\n", "        return idx;\n", "    }\n", "\n", "    public String checkPdfHeader() throws java.io.IOException {\n", "        file.seek(0);\n", "        String str = readString(1024);\n", "        int idx = str.indexOf(\"%PDF-\");\n", "        if (idx != 0)\n", "            throw new IOException(IoExceptionMessageConstant.PDF_HEADER_NOT_FOUND, this);\n", "        return str.substring(idx + 1, idx + 8);\n", "    }\n", "\n", "    public void checkFdfHeader() throws java.io.IOException {\n", "        file.seek(0);\n", "        String str = readString(1024);\n", "        int idx = str.indexOf(\"%FDF-\");\n", "        if (idx != 0)\n", "            throw new IOException(IoExceptionMessageConstant.FDF_STARTXREF_NOT_FOUND, this);\n", "    }\n", "\n", "    public long getStartxref() throws java.io.IOException {\n", "        int arrLength = 1024;\n", "        long fileLength = file.length();\n", "        long pos = fileLength - arrLength;\n", "        if (pos < 1) pos = 1;\n", "        while (pos > 0) {\n", "            file.seek(pos);\n", "            String str = readString(arrLength);\n", "            int idx = str.lastIndexOf(\"startxref\");\n", "            if (idx >= 0) return pos + idx;\n", "            // 9 = \"startxref\".length()\n", "            pos = pos - arrLength + 9;\n", "        }\n", "        throw new IOException(IoExceptionMessageConstant.PDF_STARTXREF_NOT_FOUND, this);\n", "    }\n", "\n", "    /**\n", "     * Gets next %%EOF marker in current PDF file.\n", "     *\n", "     * @return next %%EOF marker position\n", "     *\n", "     * @throws java.io.IOException in case of input-output related exceptions during PDF document reading\n", "     */\n", "    public long getNextEof() throws java.io.IOException {\n", "        int arrLength = 128;\n", "        String str;\n", "        do {\n", "            long currentPosition = file.getPosition();\n", "            str = readString(arrLength);\n", "            long eofPosition = str.indexOf(\"%%EOF\");\n", "            if (eofPosition >= 0) {\n", "                // 6 stands for '%%EOF' length + 1\n", "                return currentPosition + eofPosition + 6;\n", "            }\n", "        } while (!str.isEmpty());\n", "        throw new IOException(IoExceptionMessageConstant.PDF_EOF_NOT_FOUND, this);\n", "    }\n", "\n", "    public void nextValidToken() throws java.io.IOException {\n", "        int level = 0;\n", "        byte[] n1 = null;\n", "        byte[] n2 = null;\n", "        long ptr = 0;\n", "        while (nextToken()) {\n", "            if (type == TokenType.Comment)\n", "                continue;\n", "            switch (level) {\n", "                case 0: {\n", "                    if (type != TokenType.Number)\n", "                        return;\n", "                    ptr = file.getPosition();\n", "                    n1 = getByteContent();\n", "                    ++level;\n", "                    break;\n", "                }\n", "                case 1: {\n", "                    if (type != TokenType.Number) {\n", "                        file.seek(ptr);\n", "                        type = TokenType.Number;\n", "                        outBuf.reset().append(n1);\n", "                        return;\n", "                    }\n", "                    n2 = getByteContent();\n", "                    ++level;\n", "                    break;\n", "                }\n", "                case 2: {\n", "                    if (type == TokenType.Other) {\n", "                        if (tokenValueEqualsTo(R)) {\n", "                            assert n2 != null;\n", "                            type = TokenType.Ref;\n", "                            try {\n", "                                reference = Integer.parseInt(new String(n1));\n", "                                generation = Integer.parseInt(new String(n2));\n", "                            } catch (Exception ex) {\n", "                                //warn about incorrect reference number\n", "                                //Exception: NumberFormatException for java, FormatException or OverflowException for .NET\n", "                                Logger logger = LoggerFactory.getLogger(PdfTokenizer.class);\n", "                                logger.error(MessageFormatUtil.format(IoLogMessageConstant.INVALID_INDIRECT_REFERENCE,\n", "                                        new String(n1), new String(n2)));\n", "                                reference = -1;\n", "                                generation = 0;\n", "                            }\n", "                            return;\n", "                        } else if (tokenValueEqualsTo(Obj)) {\n", "                            assert n2 != null;\n", "                            type = TokenType.Obj;\n", "                            reference = Integer.parseInt(new String(n1));\n", "                            generation = Integer.parseInt(new String(n2));\n", "                            return;\n", "                        }\n", "                    }\n", "                    file.seek(ptr);\n", "                    type = TokenType.Number;\n", "                    outBuf.reset().append(n1);\n", "                    return;\n", "                }\n", "            }\n", "        }\n", "\n", "        // if the level 1 check returns EOF,\n", "        // then we are still looking at a number - set the type back to Number\n", "        if (level == 1) {\n", "            type = TokenType.Number;\n", "            outBuf.reset().append(n1);\n", "        }\n", "\n", "        // if we hit here, the file is either corrupt (stream ended unexpectedly),\n", "        // or the last token ended exactly at the end of a stream.  This last\n", "        // case can occur inside an Object Stream.\n", "    }\n", "\n", "    public boolean nextToken() throws java.io.IOException {\n", "        int ch;\n", "        outBuf.reset();\n", "        do {\n", "            ch = file.read();\n", "        } while (ch != -1 && isWhitespace(ch));\n", "        if (ch == -1) {\n", "            type = TokenType.EndOfFile;\n", "            return false;\n", "        }\n", "        switch (ch) {\n", "            case '[': {\n", "                type = TokenType.StartArray;\n", "                break;\n", "            }\n", "            case ']': {\n", "                type = TokenType.EndArray;\n", "                break;\n", "            }\n", "            case '/': {\n", "                type = TokenType.Name;\n", "                while (true) {\n", "                    ch = file.read();\n", "                    if (delims[ch + 1])\n", "                        break;\n", "                    outBuf.append(ch);\n", "                }\n", "                backOnePosition(ch);\n", "                break;\n", "            }\n", "            case '>': {\n", "                ch = file.read();\n", "                if (ch != '>')\n", "                    throwError(IoExceptionMessageConstant.GT_NOT_EXPECTED);\n", "                type = TokenType.EndDic;\n", "                break;\n", "            }\n", "            case '<': {\n", "                int v1 = file.read();\n", "                if (v1 == '<') {\n", "                    type = TokenType.StartDic;\n", "                    break;\n", "                }\n", "                type = TokenType.String;\n", "                hexString = true;\n", "                int v2 = 0;\n", "                while (true) {\n", "                    while (isWhitespace(v1))\n", "                        v1 = file.read();\n", "                    if (v1 == '>')\n", "                        break;\n", "                    outBuf.append(v1);\n", "                    v1 = ByteBuffer.getHex(v1);\n", "                    if (v1 < 0)\n", "                        break;\n", "                    v2 = file.read();\n", "                    while (isWhitespace(v2))\n", "                        v2 = file.read();\n", "                    if (v2 == '>') {\n", "                        break;\n", "                    }\n", "                    outBuf.append(v2);\n", "                    v2 = ByteBuffer.getHex(v2);\n", "                    if (v2 < 0)\n", "                        break;\n", "                    v1 = file.read();\n", "                }\n", "                if (v1 < 0 || v2 < 0)\n", "                    throwError(IoExceptionMessageConstant.ERROR_READING_STRING);\n", "                break;\n", "            }\n", "            case '%': {\n", "                type = TokenType.Comment;\n", "                do {\n", "                    ch = file.read();\n", "                } while (ch != -1 && ch != '\\r' && ch != '\\n');\n", "                break;\n", "            }\n", "            case '(': {\n", "                type = TokenType.String;\n", "                hexString = false;\n", "                int nesting = 0;\n", "                while (true) {\n", "                    ch = file.read();\n", "                    if (ch == -1)\n", "                        break;\n", "                    if (ch == '(') {\n", "                        ++nesting;\n", "                    } else if (ch == ')') {\n", "                        --nesting;\n", "                        if (nesting == -1)\n", "                            break;\n", "                    } else if (ch == '\\\\') {\n", "                        outBuf.append('\\\\');\n", "                        ch = file.read();\n", "                        if (ch < 0)\n", "                            break;\n", "                    }\n", "                    outBuf.append(ch);\n", "                }\n", "                if (ch == -1)\n", "                    throwError(IoExceptionMessageConstant.ERROR_READING_STRING);\n", "                break;\n", "            }\n", "            default: {\n", "                if (ch == '-' || ch == '+' || ch == '.' || (ch >= '0' && ch <= '9')) {\n", "                    type = TokenType.Number;\n", "                    boolean isReal = false;\n", "                    int numberOfMinuses = 0;\n", "                    if (ch == '-') {\n", "                        // Take care of number like \"--234\". If Acrobat can read them so must we.\n", "                        do {\n", "                            ++numberOfMinuses;\n", "                            ch = file.read();\n", "                        } while (ch == '-');\n", "                        outBuf.append('-');\n", "                    } else {\n", "                        outBuf.append(ch);\n", "                        // We don't need to check if the number is real over here\n", "                        // as we need to know that fact only in case if there are any minuses.\n", "                        ch = file.read();\n", "                    }\n", "                    while (ch >= '0' && ch <= '9') {\n", "                        outBuf.append(ch);\n", "                        ch = file.read();\n", "                    }\n", "\n", "                    if ( ch == '.'){\n", "                        isReal = true;\n", "                        outBuf.append(ch);\n", "                        ch = file.read();\n", "\n", "                        //verify if there is minus after '.'\n", "                        //In that case just ignore minus chars and everything after as Adobe Reader does\n", "                        int numberOfMinusesAfterDot = 0;\n", "                        if (ch == '-') {\n", "                            numberOfMinusesAfterDot++;\n", "                            ch = file.read();\n", "                        }\n", "                        while (ch >= '0' && ch <= '9') {\n", "                            if (numberOfMinusesAfterDot == 0) {\n", "                                outBuf.append(ch);\n", "                            }\n", "                            ch = file.read();\n", "                        }\n", "                    }\n", "\n", "                    if (numberOfMinuses > 1 && !isReal) {\n", "                        // Numbers of integer type and with more than one minus before them\n", "                        // are interpreted by Acrobat as zero.\n", "                        outBuf.reset();\n", "                        outBuf.append('0');\n", "                    }\n", "                } else {\n", "                    type = TokenType.Other;\n", "                    do {\n", "                        outBuf.append(ch);\n", "                        ch = file.read();\n", "                    } while (!delims[ch + 1]);\n", "                }\n", "                if (ch != -1)\n", "                    backOnePosition(ch);\n", "                break;\n", "            }\n", "        }\n", "        return true;\n", "    }\n", "\n", "    public long getLongValue() {\n", "        return Long.parseLong(getStringValue());\n", "    }\n", "\n", "    public int getIntValue() {\n", "        return Integer.parseInt(getStringValue());\n", "    }\n", "\n", "    public boolean isHexString() {\n", "        return this.hexString;\n", "    }\n", "\n", "    public boolean isCloseStream() {\n", "        return closeStream;\n", "    }\n", "\n", "    public void setCloseStream(boolean closeStream) {\n", "        this.closeStream = closeStream;\n", "    }\n", "\n", "    public RandomAccessFileOrArray getSafeFile() {\n", "        return file.createView();\n", "    }\n", "\n", "    /**\n", "     * Resolve escape symbols or hexadecimal symbols.\n", "     * <p>\n", "     * NOTE Due to PdfReference 1.7 part 3.2.3 String value contain ASCII characters,\n", "     * so we can convert it directly to byte array.\n", "     *\n", "     * @param content string bytes to be decoded\n", "     * @param from given start index\n", "     * @param to given end index\n", "     * @param hexWriting true if given string is hex-encoded, e.g. '&lt;69546578\u2026&gt;'.\n", "     *                   False otherwise, e.g. '((iText( some version)\u2026)'\n", "     * @return byte[] for decrypting or for creating {@link java.lang.String}.\n", "     */\n", "    protected static byte[] decodeStringContent(byte[] content, int from, int to, boolean hexWriting) {\n", "        ByteBuffer buffer = new ByteBuffer(to - from + 1);\n", "\n", "        // <6954657874ae...>\n", "        if (hexWriting) {\n", "            int i = from;\n", "            while (i <= to) {\n", "                int v1 = ByteBuffer.getHex(content[i++]);\n", "                if (i > to) {\n", "                    buffer.append(v1 << 4);\n", "                    break;\n", "                }\n", "                int v2 = content[i++];\n", "                v2 = ByteBuffer.getHex(v2);\n", "                buffer.append((v1 << 4) + v2);\n", "            }\n", "        } else {\n", "            // ((iText\\( some version)...)\n", "            int i = from;\n", "            while (i <= to) {\n", "                int ch = content[i++];\n", "                if (ch == '\\\\') {\n", "                    boolean lineBreak = false;\n", "                    ch = content[i++];\n", "                    switch (ch) {\n", "                        case 'n':\n", "                            ch = '\\n';\n", "                            break;\n", "                        case 'r':\n", "                            ch = '\\r';\n", "                            break;\n", "                        case 't':\n", "                            ch = '\\t';\n", "                            break;\n", "                        case 'b':\n", "                            ch = '\\b';\n", "                            break;\n", "                        case 'f':\n", "                            ch = '\\f';\n", "                            break;\n", "                        case '(':\n", "                        case ')':\n", "                        case '\\\\':\n", "                            break;\n", "                        case '\\r':\n", "                            lineBreak = true;\n", "                            if (i <= to && content[i++] != '\\n') {\n", "                                i--;\n", "                            }\n", "                            break;\n", "                        case '\\n':\n", "                            lineBreak = true;\n", "                            break;\n", "                        default: {\n", "                            if (ch < '0' || ch > '7') {\n", "                                break;\n", "                            }\n", "                            int octal = ch - '0';\n", "                            if (i > to) {\n", "                                ch = octal;\n", "                                break;\n", "                            }\n", "                            ch = content[i++];\n", "                            if (ch < '0' || ch > '7') {\n", "                                i--;\n", "                                ch = octal;\n", "                                break;\n", "                            }\n", "                            octal = (octal << 3) + ch - '0';\n", "\n", "                            if (i > to) {\n", "                                ch = octal;\n", "                                break;\n", "                            }\n", "                            ch = content[i++];\n", "                            if (ch < '0' || ch > '7') {\n", "                                i--;\n", "                                ch = octal;\n", "                                break;\n", "                            }\n", "                            octal = (octal << 3) + ch - '0';\n", "                            ch = octal & 0xff;\n", "                            break;\n", "                        }\n", "                    }\n", "                    if (lineBreak)\n", "                        continue;\n", "                } else if (ch == '\\r') {\n", "                    // in this case current char is '\\n' and we have to skip next '\\n' if it presents.\n", "                    ch = '\\n';\n", "                    if (i <= to && content[i++] != '\\n') {\n", "                        i--;\n", "                    }\n", "                }\n", "                buffer.append(ch);\n", "            }\n", "        }\n", "        return buffer.toByteArray();\n", "    }\n", "\n", "    /**\n", "     * Resolve escape symbols or hexadecimal symbols.\n", "     * <br>\n", "     * NOTE Due to PdfReference 1.7 part 3.2.3 String value contain ASCII characters,\n", "     * so we can convert it directly to byte array.\n", "     *\n", "     * @param content string bytes to be decoded\n", "     * @param hexWriting true if given string is hex-encoded, e.g. '&lt;69546578\u2026&gt;'.\n", "     *                   False otherwise, e.g. '((iText( some version)\u2026)'\n", "     * @return byte[] for decrypting or for creating {@link java.lang.String}.\n", "     */\n", "    public static byte[] decodeStringContent(byte[] content, boolean hexWriting) {\n", "        return decodeStringContent(content, 0, content.length - 1, hexWriting);\n", "    }\n", "\n", "        /**\n", "         * Is a certain character a whitespace? Currently checks on the following: '0', '9', '10', '12', '13', '32'.\n", "         * <br>\n", "         * The same as calling {@link #isWhitespace(int, boolean) isWhiteSpace(ch, true)}.\n", "         *\n", "         * @param ch int\n", "         * @return boolean\n", "         */\n", "    public static boolean isWhitespace(int ch) {\n", "        return isWhitespace(ch, true);\n", "    }\n", "\n", "    /**\n", "     * Checks whether a character is a whitespace. Currently checks on the following: '0', '9', '10', '12', '13', '32'.\n", "     *\n", "     * @param ch           int\n", "     * @param isWhitespace boolean\n", "     * @return boolean\n", "     */\n", "    protected static boolean isWhitespace(int ch, boolean isWhitespace) {\n", "        return ((isWhitespace && ch == 0) || ch == 9 || ch == 10 || ch == 12 || ch == 13 || ch == 32);\n", "    }\n", "\n", "    protected static boolean isDelimiter(int ch) {\n", "        return (ch == '(' || ch == ')' || ch == '<' || ch == '>' || ch == '[' || ch == ']' || ch == '/' || ch == '%');\n", "    }\n", "\n", "    protected static boolean isDelimiterWhitespace(int ch) {\n", "        return delims[ch + 1];\n", "    }\n", "\n", "    /**\n", "     * Helper method to handle content errors. Add file position to {@code PdfRuntimeException}.\n", "     * @param error message.\n", "     * @param messageParams error params.\n", "     * @throws IOException wrap error message into {@code PdfRuntimeException} and add position in file.\n", "     */\n", "    public void throwError(String error, Object... messageParams) {\n", "        throw new IOException(IoExceptionMessageConstant.ERROR_AT_FILE_POINTER, new IOException(error).setMessageParams(messageParams))\n", "                .setMessageParams(file.getPosition());\n", "    }\n", "\n", "    /**\n", "     * Checks whether {@code line} equals to 'trailer'.\n", "     *\n", "     * @param line for check\n", "     *\n", "     * @return true, if line is equals to 'trailer', otherwise false\n", "     */\n", "    public static boolean checkTrailer(ByteBuffer line) {\n", "        if (Trailer.length > line.size())\n", "            return false;\n", "        for (int i = 0; i < Trailer.length; i++) {\n", "            if (Trailer[i] != line.get(i))\n", "                return false;\n", "        }\n", "        return true;\n", "    }\n", "\n", "    /**\n", "     * Reads data into the provided byte[]. Checks on leading whitespace.\n", "     * See {@link #isWhitespace(int) isWhiteSpace(int)} or {@link #isWhitespace(int, boolean) isWhiteSpace(int, boolean)}\n", "     * for a list of whitespace characters.\n", "     * <br>\n", "     * The same as calling {@link #readLineSegment(com.itextpdf.io.source.ByteBuffer, boolean) readLineSegment(input, true)}.\n", "     *\n", "     * @param buffer a {@link ByteBuffer} to which the result of reading will be saved\n", "     * @return true, if something was read or if the end of the input stream is not reached\n", "     * @throws java.io.IOException in case of any reading error\n", "     */\n", "    public boolean readLineSegment(ByteBuffer buffer) throws java.io.IOException {\n", "        return readLineSegment(buffer, true);\n", "    }\n", "\n", "    /**\n", "     * Reads data into the provided byte[]. Checks on leading whitespace.\n", "     * See {@link #isWhitespace(int) isWhiteSpace(int)} or {@link #isWhitespace(int, boolean) isWhiteSpace(int, boolean)}\n", "     * for a list of whitespace characters.\n", "     *\n", "     * @param buffer a {@link ByteBuffer} to which the result of reading will be saved\n", "     * @param isNullWhitespace boolean to indicate whether '0' is whitespace or not.\n", "     *                         If in doubt, use true or overloaded method {@link #readLineSegment(com.itextpdf.io.source.ByteBuffer) readLineSegment(input)}\n", "     * @return true, if something was read or if the end of the input stream is not reached\n", "     * @throws java.io.IOException in case of any reading error\n", "     */\n", "    public boolean readLineSegment(ByteBuffer buffer, boolean isNullWhitespace) throws java.io.IOException {\n", "        int c;\n", "        boolean eol = false;\n", "        // ssteward, pdftk-1.10, 040922:\n", "        // skip initial whitespace; added this because PdfReader.rebuildXref()\n", "        // assumes that line provided by readLineSegment does not have init. whitespace;\n", "        while (isWhitespace((c = read()), isNullWhitespace)) ;\n", "\n", "        boolean prevWasWhitespace = false;\n", "        while (!eol) {\n", "            switch (c) {\n", "                case -1:\n", "                case '\\n':\n", "                    eol = true;\n", "                    break;\n", "                case '\\r':\n", "                    eol = true;\n", "                    long cur = getPosition();\n", "                    if ((read()) != '\\n') {\n", "                        seek(cur);\n", "                    }\n", "                    break;\n", "                case 9: //whitespaces\n", "                case 12:\n", "                case 32:\n", "                    if (prevWasWhitespace)\n", "                        break;\n", "                    prevWasWhitespace = true;\n", "                    buffer.append((byte) c);\n", "                    break;\n", "                default:\n", "                    prevWasWhitespace = false;\n", "                    buffer.append((byte) c);\n", "                    break;\n", "            }\n", "            // break loop? do it before we read() again\n", "            if (eol || buffer.size() == buffer.capacity()) {\n", "                eol = true;\n", "            } else {\n", "                c = read();\n", "            }\n", "        }\n", "        if (buffer.size() == buffer.capacity()) {\n", "            eol = false;\n", "            while (!eol) {\n", "                switch (c = read()) {\n", "                    case -1:\n", "                    case '\\n':\n", "                        eol = true;\n", "                        break;\n", "                    case '\\r':\n", "                        eol = true;\n", "                        long cur = getPosition();\n", "                        if ((read()) != '\\n') {\n", "                            seek(cur);\n", "                        }\n", "                        break;\n", "                }\n", "            }\n", "        }\n", "        return !(c == -1 && buffer.isEmpty());\n", "    }\n", "\n", "    /**\n", "     * Check whether line starts with object declaration.\n", "     * @param lineTokenizer tokenizer, built by single line.\n", "     * @return object number and generation if check is successful, otherwise - null.\n", "     */\n", "    public static int[] checkObjectStart(PdfTokenizer lineTokenizer) {\n", "        try {\n", "            lineTokenizer.seek(0);\n", "            if (!lineTokenizer.nextToken() || lineTokenizer.getTokenType() != TokenType.Number)\n", "                return null;\n", "            int num = lineTokenizer.getIntValue();\n", "            if (!lineTokenizer.nextToken() || lineTokenizer.getTokenType() != TokenType.Number)\n", "                return null;\n", "            int gen = lineTokenizer.getIntValue();\n", "            if (!lineTokenizer.nextToken())\n", "                return null;\n", "            if (!Arrays.equals(Obj, lineTokenizer.getByteContent()))\n", "                return null;\n", "            return new int[]{num, gen};\n", "        } catch (Exception ioe) {\n", "            // empty on purpose\n", "        }\n", "        return null;\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import com.itextpdf.commons.utils.MessageFormatUtil;\n", "import com.itextpdf.io.source.PdfTokenizer.TokenType;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.IOException;\n", "import java.nio.charset.StandardCharsets;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "import static com.itextpdf.io.exceptions.IoExceptionMessageConstant.ERROR_AT_FILE_POINTER;\n", "\n", "@Category(UnitTest.class)\n", "public class PdfTokenizerTest extends ExtendedITextTest {\n", "\n", "    private static final String sourceFolder = \"./src/test/resources/com/itextpdf/io/util/\";\n", "\n", "    @Test\n", "    public void seekTest() throws IOException {\n", "        String data = \"/Name1 70\";\n", "        TokenType[] expectedTypes = new TokenType[] {TokenType.Name, TokenType.Number, TokenType.EndOfFile};\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.seek(0);\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(expectedTypes[0], tok.getTokenType());\n", "        Assert.assertEquals(\"Name1\", tok.getStringValue());\n", "\n", "        tok.seek(7);\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(expectedTypes[1], tok.getTokenType());\n", "        Assert.assertEquals(\"70\", tok.getStringValue());\n", "\n", "        tok.seek(8);\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(expectedTypes[1], tok.getTokenType());\n", "        Assert.assertEquals(\"0\", tok.getStringValue());\n", "\n", "        tok.seek(9);\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(expectedTypes[2], tok.getTokenType());\n", "    }\n", "\n", "    @Test\n", "    public void getLongValueTest() throws IOException {\n", "        String data = \"21474836470\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(TokenType.Number, tok.getTokenType());\n", "        Assert.assertEquals(21474836470L, tok.getLongValue());\n", "    }\n", "\n", "    @Test\n", "    public void getIntValueTest() throws IOException {\n", "        String data = \"15\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(TokenType.Number, tok.getTokenType());\n", "        Assert.assertEquals(15, tok.getIntValue());\n", "    }\n", "\n", "    @Test\n", "    public void getPositionTest() throws IOException {\n", "        String data = \"/Name1 70\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        Assert.assertEquals(0, tok.getPosition());\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(6, tok.getPosition());\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(11, tok.getPosition());\n", "    }\n", "\n", "    @Test\n", "    public void lengthTest() throws IOException {\n", "        String data = \"/Name1\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        Assert.assertEquals(6, tok.length());\n", "    }\n", "\n", "    @Test\n", "    public void lengthTwoTokenTest() throws IOException {\n", "        String data = \"/Name1 15\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        Assert.assertEquals(9, tok.length());\n", "    }\n", "\n", "    @Test\n", "    public void readTest() throws IOException {\n", "        String data = \"/Name1 15\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        byte[] read = new byte[] {\n", "                (byte) tok.read(), (byte) tok.read(), (byte) tok.read(),\n", "                (byte) tok.read(), (byte) tok.read(), (byte) tok.read(),\n", "                (byte) tok.read()\n", "        };\n", "        Assert.assertEquals(\"/Name1 \", new String(read));\n", "    }\n", "\n", "    @Test\n", "    public void readStringFullTest() throws IOException {\n", "        String data = \"/Name1 15\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        Assert.assertEquals(data, tok.readString(data.length()));\n", "    }\n", "\n", "    @Test\n", "    public void readStringShortTest() throws IOException {\n", "        String data = \"/Name1 15\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        Assert.assertEquals(\"/Name\", tok.readString(5));\n", "    }\n", "\n", "    @Test\n", "    public void readStringLongerThenDataTest() throws IOException {\n", "        String data = \"/Name1 15\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        Assert.assertEquals(data, tok.readString(data.length() + 10));\n", "    }\n", "\n", "    @Test\n", "    public void readFullyPartThenReadStringTest() throws IOException {\n", "        String data = \"/Name1 15\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.readFully(new byte[6]);\n", "        Assert.assertEquals(\" 15\", tok.readString(data.length()));\n", "    }\n", "\n", "    @Test\n", "    public void readFullyThenReadStringTest() throws IOException {\n", "        String data = \"/Name1 15\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.readFully(new byte[7]);\n", "        Assert.assertEquals(\"15\", tok.readString(data.length()));\n", "    }\n", "\n", "    @Test\n", "    public void getNextEofShortTextTest() throws IOException {\n", "        String data = \"some text to test \\ngetting end of\\n file logic%%EOF\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        try (PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))))) {\n", "            long eofPosition = tok.getNextEof();\n", "            Assert.assertEquals(data.length() + 1, eofPosition);\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void getNextEofLongTextTest() throws IOException {\n", "        String data = \"some text to test \\ngetting end of\\n file logic\";\n", "        StringBuilder stringBuilder = new StringBuilder();\n", "        for (int i = 0; i < 20; ++i) {\n", "            stringBuilder.append(data);\n", "        }\n", "        stringBuilder.append(\"%%EOF\");\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        try (PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(stringBuilder.toString().getBytes(StandardCharsets.ISO_8859_1))))) {\n", "            long eofPosition = tok.getNextEof();\n", "            Assert.assertEquals(data.length() * 20 + 6, eofPosition);\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void getNextEofSeveralEofTest() throws IOException {\n", "        String data = \"some text %%EOFto test \\nget%%EOFting end of\\n fil%%EOFe logic%%EOF\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        try (PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))))) {\n", "            long eofPosition = tok.getNextEof();\n", "            Assert.assertEquals(data.indexOf(\"%%EOF\") + 6, eofPosition);\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void getDecodedStringContentTest() throws IOException {\n", "        String data = \"/Name1 15\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.nextToken();\n", "        Assert.assertEquals(\"Name1\", new String(tok.getDecodedStringContent()));\n", "\n", "        tok.nextToken();\n", "        Assert.assertEquals(\"15\", new String(tok.getDecodedStringContent()));\n", "\n", "        tok.nextToken();\n", "        Assert.assertEquals(\"\", new String(tok.getDecodedStringContent()));\n", "    }\n", "\n", "    @Test\n", "    public void getDecodedStringContentHexTest() throws IOException {\n", "        String data = \"<736f6d652068657820737472696e67>\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.nextToken();\n", "        Assert.assertTrue(tok.isHexString());\n", "        Assert.assertEquals(\"some hex string\", new String(tok.getDecodedStringContent()));\n", "    }\n", "\n", "    @Test\n", "    public void throwErrorTest() {\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(\n", "                factory.createSource(\"/Name1\".getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        Exception e = Assert.assertThrows(com.itextpdf.io.exceptions.IOException.class,\n", "                () ->  tok.throwError(ERROR_AT_FILE_POINTER, 0)\n", "        );\n", "        Assert.assertEquals(MessageFormatUtil.format(ERROR_AT_FILE_POINTER, 0), e.getMessage());\n", "    }\n", "\n", "    @Test\n", "    public void testOneNumber() throws Exception {\n", "        checkTokenTypes(\"/Name1 70\", TokenType.Name, TokenType.Number, TokenType.EndOfFile);\n", "    }\n", "\n", "    @Test\n", "    public void testTwoNumbers() throws Exception {\n", "        checkTokenTypes(\n", "                \"/Name1 70/Name 2\",\n", "                TokenType.Name, TokenType.Number, TokenType.Name, TokenType.Number, TokenType.EndOfFile\n", "        );\n", "    }\n", "\n", "    @Test\n", "    public void tokenTypesTest() throws Exception {\n", "        checkTokenTypes(\n", "                \"<</Size 70/Root 46 0 R/Info 44 0 R/ID[<8C2547D58D4BD2C6F3D32B830BE3259D><8F69587888569A458EB681A4285D5879>]/Prev 116 >>\",\n", "                TokenType.StartDic, TokenType.Name, TokenType.Number, TokenType.Name, TokenType.Ref, TokenType.Name,\n", "                TokenType.Ref, TokenType.Name, TokenType.StartArray, TokenType.String, TokenType.String,\n", "                TokenType.EndArray, TokenType.Name, TokenType.Number, TokenType.EndDic, TokenType.EndOfFile\n", "        );\n", "    }\n", "\n", "    @Test\n", "    public void numberValueInTheEndTest() throws Exception {\n", "        checkTokenValues(\n", "                \"123\",\n", "                new byte[]{49, 50, 51},\n", "                //EndOfFile buffer\n", "                new byte[]{}\n", "        );\n", "    }\n", "\n", "    @Test\n", "    public void tokenValueEqualsToTest() throws IOException {\n", "        String data = \"SomeString\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.nextToken();\n", "        Assert.assertTrue(tok.tokenValueEqualsTo(data.getBytes(StandardCharsets.ISO_8859_1)));\n", "    }\n", "\n", "    @Test\n", "    public void tokenValueEqualsToNullTest() throws IOException {\n", "        String data = \"SomeString\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.nextToken();\n", "        Assert.assertFalse(tok.tokenValueEqualsTo(null));\n", "    }\n", "\n", "    @Test\n", "    public void tokenValueEqualsToNotSameStringTest() throws IOException {\n", "        String data = \"SomeString\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.nextToken();\n", "        Assert.assertFalse(tok.tokenValueEqualsTo((data + \"s\").getBytes(StandardCharsets.ISO_8859_1)));\n", "    }\n", "\n", "    @Test\n", "    public void tokenValueEqualsToNotCaseSensitiveStringTest() throws IOException {\n", "        String data = \"SomeString\";\n", "\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.nextToken();\n", "        Assert.assertFalse(tok.tokenValueEqualsTo(\"Somestring\".getBytes(StandardCharsets.ISO_8859_1)));\n", "    }\n", "\n", "    @Test\n", "    public void checkPdfHeaderTest() throws IOException {\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(factory.createBestSource(sourceFolder + \"test.pdf\")));\n", "\n", "        Assert.assertEquals(\"PDF-1.7\", tok.checkPdfHeader());\n", "    }\n", "\n", "    @Test\n", "    public void getHeaderOffsetTest() throws IOException {\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(factory.createBestSource(sourceFolder + \"test.pdf\")));\n", "\n", "        Assert.assertEquals(0, tok.getHeaderOffset());\n", "    }\n", "\n", "    @Test\n", "    public void primitivesTest() throws Exception {\n", "        String data = \"<</Size 70.%comment\\n\" +\n", "                \"/Value#20 .1\" +\n", "                \"/Root 46 0 R\" +\n", "                \"/Info 44 0 R\" +\n", "                \"/ID[<736f6d652068657820737472696e672>(some simple string )<8C2547D58D4BD2C6F3D32B830BE3259D2>-70.1--0.2]\" +\n", "                \"/Name1 --15\" +\n", "                \"/Prev ---116.23 >>\";\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(factory.createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.StartDic, tok.getTokenType());\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Name, tok.getTokenType());\n", "        Assert.assertEquals(\"Size\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Number, tok.getTokenType());\n", "        Assert.assertEquals(\"70.\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Name, tok.getTokenType());\n", "        Assert.assertEquals(\"Value#20\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Number, tok.getTokenType());\n", "        Assert.assertEquals(\".1\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Name, tok.getTokenType());\n", "        Assert.assertEquals(\"Root\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Ref, tok.getTokenType());\n", "        Assert.assertEquals(\"46 0 R\", \"\" + tok.getObjNr() + \" \" + tok.getGenNr()\n", "                + \" \" + new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Name, tok.getTokenType());\n", "        Assert.assertEquals(\"Info\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Ref, tok.getTokenType());\n", "        Assert.assertEquals(\"44 0 R\", \"\" + tok.getObjNr() + \" \" + tok.getGenNr()\n", "                + \" \" + new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Name, tok.getTokenType());\n", "        Assert.assertEquals(\"ID\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.StartArray, tok.getTokenType());\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.String, tok.getTokenType());\n", "        Assert.assertTrue(tok.isHexString());\n", "        Assert.assertEquals(\"736f6d652068657820737472696e672\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.String, tok.getTokenType());\n", "        Assert.assertFalse(tok.isHexString());\n", "        Assert.assertEquals(\"some simple string \", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.String, tok.getTokenType());\n", "        Assert.assertTrue(tok.isHexString());\n", "        Assert.assertEquals(\"8C2547D58D4BD2C6F3D32B830BE3259D2\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Number, tok.getTokenType());\n", "        Assert.assertEquals(\"-70.1\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Number, tok.getTokenType());\n", "        Assert.assertEquals(\"-0.2\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.EndArray, tok.getTokenType());\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Name, tok.getTokenType());\n", "        Assert.assertEquals(\"Name1\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Number, tok.getTokenType());\n", "        Assert.assertEquals(\"0\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Name, tok.getTokenType());\n", "        Assert.assertEquals(\"Prev\", new String(tok.getByteContent()));\n", "\n", "        tok.nextValidToken();\n", "        Assert.assertEquals(PdfTokenizer.TokenType.Number, tok.getTokenType());\n", "        Assert.assertEquals(\"-116.23\", new String(tok.getByteContent()));\n", "    }\n", "\n", "    @Test\n", "    public void octalNumberLong1Test() {\n", "        // 49 equal to string \"1\", octal 1 equals to 1 in decimal\n", "        byte[] bytes = new byte[] {92, 49};\n", "        byte[] result = PdfTokenizer.decodeStringContent(bytes, false);\n", "        Assert.assertArrayEquals(new byte[] {1}, result);\n", "    }\n", "\n", "    @Test\n", "    public void octalNumberLong2Test() {\n", "        // 49 50 equal to string \"12\", octal 12 equals to 10 in decimal\n", "        byte[] bytes = new byte[] {92, 49, 50};\n", "        byte[] result = PdfTokenizer.decodeStringContent(bytes, false);\n", "        Assert.assertArrayEquals(new byte[] {10}, result);\n", "    }\n", "\n", "    @Test\n", "    public void octalNumberLong3Test() {\n", "        // 49 50 51 equal to string \"123\", octal 123 equals to 83 in decimal\n", "        byte[] bytes = new byte[] {92, 49, 50, 51};\n", "        byte[] result = PdfTokenizer.decodeStringContent(bytes, false);\n", "        Assert.assertArrayEquals(new byte[] {83}, result);\n", "    }\n", "\n", "    @Test\n", "    public void slashAfterShortOctalTest() {\n", "        // \\0\\(\n", "        byte[] bytes = new byte[] {92, 48, 92, 40};\n", "        byte[] result = PdfTokenizer.decodeStringContent(bytes, false);\n", "        Assert.assertArrayEquals(new byte[] {0, 40}, result);\n", "    }\n", "\n", "    @Test\n", "    public void notOctalAfterShortOctalTest() {\n", "        // \\0&\n", "        byte[] bytes = new byte[] {92, 48, 26};\n", "        byte[] result = PdfTokenizer.decodeStringContent(bytes, false);\n", "        Assert.assertArrayEquals(new byte[] {0, 26}, result);\n", "    }\n", "\n", "    @Test\n", "    public void notOctalAfterShortOctalTest2() {\n", "        // \\12&\n", "        byte[] bytes = new byte[] {92, 49, 50, 26};\n", "        byte[] result = PdfTokenizer.decodeStringContent(bytes, false);\n", "        Assert.assertArrayEquals(new byte[] {10, 26}, result);\n", "    }\n", "\n", "    @Test\n", "    public void twoShortOctalsWithGarbageTest() {\n", "        // \\0\\23 + 4 which should not be taken into account\n", "        byte[] bytes = new byte[] {92, 48, 92, 50, 51, 52};\n", "        byte[] result = PdfTokenizer.decodeStringContent(bytes, 0, 4, false);\n", "        Assert.assertArrayEquals(new byte[] {0, 19}, result);\n", "    }\n", "\n", "    private void checkTokenTypes(String data, TokenType... expectedTypes) throws Exception {\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(factory\n", "                .createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        for (int i = 0; i < expectedTypes.length; i++) {\n", "            tok.nextValidToken();\n", "            Assert.assertEquals(\"Position \" + i, expectedTypes[i], tok.getTokenType());\n", "        }\n", "    }\n", "\n", "    private void checkTokenValues(String data, byte[]... expectedValues) throws Exception {\n", "        RandomAccessSourceFactory factory = new RandomAccessSourceFactory();\n", "        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(factory\n", "                .createSource(data.getBytes(StandardCharsets.ISO_8859_1))));\n", "\n", "        for (int i = 0; i < expectedValues.length; i++) {\n", "            tok.nextValidToken();\n", "            Assert.assertArrayEquals(\"Position \" + i, expectedValues[i], tok.getByteContent());\n", "        }\n", "    }\n", "}\n"], "method_lines_dic": {"PdfTokenizer::::seek(long)": [119, 121], "PdfTokenizer::::readFully(byte[])": [123, 125], "PdfTokenizer::::getPosition()": [127, 129], "PdfTokenizer::::close()": [131, 134], "PdfTokenizer::::length()": [136, 138], "PdfTokenizer::::read()": [140, 142], "PdfTokenizer::::readString(int)": [144, 154], "PdfTokenizer::::getTokenType()": [156, 158], "PdfTokenizer::::getByteContent()": [160, 162], "PdfTokenizer::::getStringValue()": [164, 166], "PdfTokenizer::::getDecodedStringContent()": [168, 170], "PdfTokenizer::::tokenValueEqualsTo(byte[])": [172, 184], "PdfTokenizer::::getObjNr()": [186, 188], "PdfTokenizer::::getGenNr()": [190, 192], "PdfTokenizer::::backOnePosition(int)": [194, 197], "PdfTokenizer::::getHeaderOffset()": [199, 209], "PdfTokenizer::::checkPdfHeader()": [211, 218], "PdfTokenizer::::checkFdfHeader()": [220, 226], "PdfTokenizer::::getStartxref()": [228, 242], "PdfTokenizer::::getNextEof()": [251, 264], "PdfTokenizer::::nextValidToken()": [266, 338], "PdfTokenizer::::nextToken()": [340, 506], "PdfTokenizer::::getLongValue()": [508, 510], "PdfTokenizer::::getIntValue()": [512, 514], "PdfTokenizer::::isHexString()": [516, 518], "PdfTokenizer::::isCloseStream()": [520, 522], "PdfTokenizer::::setCloseStream(boolean)": [524, 526], "PdfTokenizer::::getSafeFile()": [528, 530], "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)": [545, 643], "PdfTokenizer::::decodeStringContent(byte[],boolean)": [656, 658], "PdfTokenizer::::isWhitespace(int)": [668, 670], "PdfTokenizer::::isWhitespace(int,boolean)": [679, 681], "PdfTokenizer::::isDelimiter(int)": [683, 685], "PdfTokenizer::::isDelimiterWhitespace(int)": [687, 689], "PdfTokenizer::::throwError(java.lang.String,java.lang.Object[])": [697, 700], "PdfTokenizer::::checkTrailer(com.itextpdf.io.source.ByteBuffer)": [709, 717], "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer)": [730, 732], "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)": [745, 806], "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)": [813, 831]}, "test_method_lines_dic": {"PdfTokenizerTest::::seekTest()": [42, 69], "PdfTokenizerTest::::getLongValueTest()": [71, 82], "PdfTokenizerTest::::getIntValueTest()": [84, 95], "PdfTokenizerTest::::getPositionTest()": [97, 110], "PdfTokenizerTest::::lengthTest()": [112, 121], "PdfTokenizerTest::::lengthTwoTokenTest()": [123, 132], "PdfTokenizerTest::::readTest()": [134, 148], "PdfTokenizerTest::::readStringFullTest()": [150, 159], "PdfTokenizerTest::::readStringShortTest()": [161, 170], "PdfTokenizerTest::::readStringLongerThenDataTest()": [172, 181], "PdfTokenizerTest::::readFullyPartThenReadStringTest()": [183, 193], "PdfTokenizerTest::::readFullyThenReadStringTest()": [195, 205], "PdfTokenizerTest::::getNextEofShortTextTest()": [207, 217], "PdfTokenizerTest::::getNextEofLongTextTest()": [219, 234], "PdfTokenizerTest::::getNextEofSeveralEofTest()": [236, 246], "PdfTokenizerTest::::getDecodedStringContentTest()": [248, 264], "PdfTokenizerTest::::getDecodedStringContentHexTest()": [266, 277], "PdfTokenizerTest::::throwErrorTest()": [279, 289], "PdfTokenizerTest::::testOneNumber()": [291, 294], "PdfTokenizerTest::::testTwoNumbers()": [296, 302], "PdfTokenizerTest::::tokenTypesTest()": [304, 312], "PdfTokenizerTest::::numberValueInTheEndTest()": [314, 322], "PdfTokenizerTest::::tokenValueEqualsToTest()": [324, 333], "PdfTokenizerTest::::tokenValueEqualsToNullTest()": [335, 344], "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()": [346, 355], "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()": [357, 366], "PdfTokenizerTest::::checkPdfHeaderTest()": [368, 374], "PdfTokenizerTest::::getHeaderOffsetTest()": [376, 382], "PdfTokenizerTest::::primitivesTest()": [384, 481], "PdfTokenizerTest::::octalNumberLong1Test()": [483, 489], "PdfTokenizerTest::::octalNumberLong2Test()": [491, 497], "PdfTokenizerTest::::octalNumberLong3Test()": [499, 505], "PdfTokenizerTest::::slashAfterShortOctalTest()": [507, 513], "PdfTokenizerTest::::notOctalAfterShortOctalTest()": [515, 521], "PdfTokenizerTest::::notOctalAfterShortOctalTest2()": [523, 529], "PdfTokenizerTest::::twoShortOctalsWithGarbageTest()": [531, 537], "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])": [550, 559]}, "reverse_method_lines_dic": {"119": "PdfTokenizer::::seek(long)", "120": "PdfTokenizer::::seek(long)", "121": "PdfTokenizer::::seek(long)", "123": "PdfTokenizer::::readFully(byte[])", "124": "PdfTokenizer::::readFully(byte[])", "125": "PdfTokenizer::::readFully(byte[])", "127": "PdfTokenizer::::getPosition()", "128": "PdfTokenizer::::getPosition()", "129": "PdfTokenizer::::getPosition()", "131": "PdfTokenizer::::close()", "132": "PdfTokenizer::::close()", "133": "PdfTokenizer::::close()", "134": "PdfTokenizer::::close()", "136": "PdfTokenizer::::length()", "137": "PdfTokenizer::::length()", "138": "PdfTokenizer::::length()", "140": "PdfTokenizer::::read()", "141": "PdfTokenizer::::read()", "142": "PdfTokenizer::::read()", "144": "PdfTokenizer::::readString(int)", "145": "PdfTokenizer::::readString(int)", "146": "PdfTokenizer::::readString(int)", "147": "PdfTokenizer::::readString(int)", "148": "PdfTokenizer::::readString(int)", "149": "PdfTokenizer::::readString(int)", "150": "PdfTokenizer::::readString(int)", "151": "PdfTokenizer::::readString(int)", "152": "PdfTokenizer::::readString(int)", "153": "PdfTokenizer::::readString(int)", "154": "PdfTokenizer::::readString(int)", "156": "PdfTokenizer::::getTokenType()", "157": "PdfTokenizer::::getTokenType()", "158": "PdfTokenizer::::getTokenType()", "160": "PdfTokenizer::::getByteContent()", "161": "PdfTokenizer::::getByteContent()", "162": "PdfTokenizer::::getByteContent()", "164": "PdfTokenizer::::getStringValue()", "165": "PdfTokenizer::::getStringValue()", "166": "PdfTokenizer::::getStringValue()", "168": "PdfTokenizer::::getDecodedStringContent()", "169": "PdfTokenizer::::getDecodedStringContent()", "170": "PdfTokenizer::::getDecodedStringContent()", "172": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "173": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "174": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "175": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "176": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "177": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "178": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "179": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "180": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "181": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "182": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "183": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "184": "PdfTokenizer::::tokenValueEqualsTo(byte[])", "186": "PdfTokenizer::::getObjNr()", "187": "PdfTokenizer::::getObjNr()", "188": "PdfTokenizer::::getObjNr()", "190": "PdfTokenizer::::getGenNr()", "191": "PdfTokenizer::::getGenNr()", "192": "PdfTokenizer::::getGenNr()", "194": "PdfTokenizer::::backOnePosition(int)", "195": "PdfTokenizer::::backOnePosition(int)", "196": "PdfTokenizer::::backOnePosition(int)", "197": "PdfTokenizer::::backOnePosition(int)", "199": "PdfTokenizer::::getHeaderOffset()", "200": "PdfTokenizer::::getHeaderOffset()", "201": "PdfTokenizer::::getHeaderOffset()", "202": "PdfTokenizer::::getHeaderOffset()", "203": "PdfTokenizer::::getHeaderOffset()", "204": "PdfTokenizer::::getHeaderOffset()", "205": "PdfTokenizer::::getHeaderOffset()", "206": "PdfTokenizer::::getHeaderOffset()", "207": "PdfTokenizer::::getHeaderOffset()", "208": "PdfTokenizer::::getHeaderOffset()", "209": "PdfTokenizer::::getHeaderOffset()", "211": "PdfTokenizer::::checkPdfHeader()", "212": "PdfTokenizer::::checkPdfHeader()", "213": "PdfTokenizer::::checkPdfHeader()", "214": "PdfTokenizer::::checkPdfHeader()", "215": "PdfTokenizer::::checkPdfHeader()", "216": "PdfTokenizer::::checkPdfHeader()", "217": "PdfTokenizer::::checkPdfHeader()", "218": "PdfTokenizer::::checkPdfHeader()", "220": "PdfTokenizer::::checkFdfHeader()", "221": "PdfTokenizer::::checkFdfHeader()", "222": "PdfTokenizer::::checkFdfHeader()", "223": "PdfTokenizer::::checkFdfHeader()", "224": "PdfTokenizer::::checkFdfHeader()", "225": "PdfTokenizer::::checkFdfHeader()", "226": "PdfTokenizer::::checkFdfHeader()", "228": "PdfTokenizer::::getStartxref()", "229": "PdfTokenizer::::getStartxref()", "230": "PdfTokenizer::::getStartxref()", "231": "PdfTokenizer::::getStartxref()", "232": "PdfTokenizer::::getStartxref()", "233": "PdfTokenizer::::getStartxref()", "234": "PdfTokenizer::::getStartxref()", "235": "PdfTokenizer::::getStartxref()", "236": "PdfTokenizer::::getStartxref()", "237": "PdfTokenizer::::getStartxref()", "238": "PdfTokenizer::::getStartxref()", "239": "PdfTokenizer::::getStartxref()", "240": "PdfTokenizer::::getStartxref()", "241": "PdfTokenizer::::getStartxref()", "242": "PdfTokenizer::::getStartxref()", "251": "PdfTokenizer::::getNextEof()", "252": "PdfTokenizer::::getNextEof()", "253": "PdfTokenizer::::getNextEof()", "254": "PdfTokenizer::::getNextEof()", "255": "PdfTokenizer::::getNextEof()", "256": "PdfTokenizer::::getNextEof()", "257": "PdfTokenizer::::getNextEof()", "258": "PdfTokenizer::::getNextEof()", "259": "PdfTokenizer::::getNextEof()", "260": "PdfTokenizer::::getNextEof()", "261": "PdfTokenizer::::getNextEof()", "262": "PdfTokenizer::::getNextEof()", "263": "PdfTokenizer::::getNextEof()", "264": "PdfTokenizer::::getNextEof()", "266": "PdfTokenizer::::nextValidToken()", "267": "PdfTokenizer::::nextValidToken()", "268": "PdfTokenizer::::nextValidToken()", "269": "PdfTokenizer::::nextValidToken()", "270": "PdfTokenizer::::nextValidToken()", "271": "PdfTokenizer::::nextValidToken()", "272": "PdfTokenizer::::nextValidToken()", "273": "PdfTokenizer::::nextValidToken()", "274": "PdfTokenizer::::nextValidToken()", "275": "PdfTokenizer::::nextValidToken()", "276": "PdfTokenizer::::nextValidToken()", "277": "PdfTokenizer::::nextValidToken()", "278": "PdfTokenizer::::nextValidToken()", "279": "PdfTokenizer::::nextValidToken()", "280": "PdfTokenizer::::nextValidToken()", "281": "PdfTokenizer::::nextValidToken()", "282": "PdfTokenizer::::nextValidToken()", "283": "PdfTokenizer::::nextValidToken()", "284": "PdfTokenizer::::nextValidToken()", "285": "PdfTokenizer::::nextValidToken()", "286": "PdfTokenizer::::nextValidToken()", "287": "PdfTokenizer::::nextValidToken()", "288": "PdfTokenizer::::nextValidToken()", "289": "PdfTokenizer::::nextValidToken()", "290": "PdfTokenizer::::nextValidToken()", "291": "PdfTokenizer::::nextValidToken()", "292": "PdfTokenizer::::nextValidToken()", "293": "PdfTokenizer::::nextValidToken()", "294": "PdfTokenizer::::nextValidToken()", "295": "PdfTokenizer::::nextValidToken()", "296": "PdfTokenizer::::nextValidToken()", "297": "PdfTokenizer::::nextValidToken()", "298": "PdfTokenizer::::nextValidToken()", "299": "PdfTokenizer::::nextValidToken()", "300": "PdfTokenizer::::nextValidToken()", "301": "PdfTokenizer::::nextValidToken()", "302": "PdfTokenizer::::nextValidToken()", "303": "PdfTokenizer::::nextValidToken()", "304": "PdfTokenizer::::nextValidToken()", "305": "PdfTokenizer::::nextValidToken()", "306": "PdfTokenizer::::nextValidToken()", "307": "PdfTokenizer::::nextValidToken()", "308": "PdfTokenizer::::nextValidToken()", "309": "PdfTokenizer::::nextValidToken()", "310": "PdfTokenizer::::nextValidToken()", "311": "PdfTokenizer::::nextValidToken()", "312": "PdfTokenizer::::nextValidToken()", "313": "PdfTokenizer::::nextValidToken()", "314": "PdfTokenizer::::nextValidToken()", "315": "PdfTokenizer::::nextValidToken()", "316": "PdfTokenizer::::nextValidToken()", "317": "PdfTokenizer::::nextValidToken()", "318": "PdfTokenizer::::nextValidToken()", "319": "PdfTokenizer::::nextValidToken()", "320": "PdfTokenizer::::nextValidToken()", "321": "PdfTokenizer::::nextValidToken()", "322": "PdfTokenizer::::nextValidToken()", "323": "PdfTokenizer::::nextValidToken()", "324": "PdfTokenizer::::nextValidToken()", "325": "PdfTokenizer::::nextValidToken()", "326": "PdfTokenizer::::nextValidToken()", "327": "PdfTokenizer::::nextValidToken()", "328": "PdfTokenizer::::nextValidToken()", "329": "PdfTokenizer::::nextValidToken()", "330": "PdfTokenizer::::nextValidToken()", "331": "PdfTokenizer::::nextValidToken()", "332": "PdfTokenizer::::nextValidToken()", "333": "PdfTokenizer::::nextValidToken()", "334": "PdfTokenizer::::nextValidToken()", "335": "PdfTokenizer::::nextValidToken()", "336": "PdfTokenizer::::nextValidToken()", "337": "PdfTokenizer::::nextValidToken()", "338": "PdfTokenizer::::nextValidToken()", "340": "PdfTokenizer::::nextToken()", "341": "PdfTokenizer::::nextToken()", "342": "PdfTokenizer::::nextToken()", "343": "PdfTokenizer::::nextToken()", "344": "PdfTokenizer::::nextToken()", "345": "PdfTokenizer::::nextToken()", "346": "PdfTokenizer::::nextToken()", "347": "PdfTokenizer::::nextToken()", "348": "PdfTokenizer::::nextToken()", "349": "PdfTokenizer::::nextToken()", "350": "PdfTokenizer::::nextToken()", "351": "PdfTokenizer::::nextToken()", "352": "PdfTokenizer::::nextToken()", "353": "PdfTokenizer::::nextToken()", "354": "PdfTokenizer::::nextToken()", "355": "PdfTokenizer::::nextToken()", "356": "PdfTokenizer::::nextToken()", "357": "PdfTokenizer::::nextToken()", "358": "PdfTokenizer::::nextToken()", "359": "PdfTokenizer::::nextToken()", "360": "PdfTokenizer::::nextToken()", "361": "PdfTokenizer::::nextToken()", "362": "PdfTokenizer::::nextToken()", "363": "PdfTokenizer::::nextToken()", "364": "PdfTokenizer::::nextToken()", "365": "PdfTokenizer::::nextToken()", "366": "PdfTokenizer::::nextToken()", "367": "PdfTokenizer::::nextToken()", "368": "PdfTokenizer::::nextToken()", "369": "PdfTokenizer::::nextToken()", "370": "PdfTokenizer::::nextToken()", "371": "PdfTokenizer::::nextToken()", "372": "PdfTokenizer::::nextToken()", "373": "PdfTokenizer::::nextToken()", "374": "PdfTokenizer::::nextToken()", "375": "PdfTokenizer::::nextToken()", "376": "PdfTokenizer::::nextToken()", "377": "PdfTokenizer::::nextToken()", "378": "PdfTokenizer::::nextToken()", "379": "PdfTokenizer::::nextToken()", "380": "PdfTokenizer::::nextToken()", "381": "PdfTokenizer::::nextToken()", "382": "PdfTokenizer::::nextToken()", "383": "PdfTokenizer::::nextToken()", "384": "PdfTokenizer::::nextToken()", "385": "PdfTokenizer::::nextToken()", "386": "PdfTokenizer::::nextToken()", "387": "PdfTokenizer::::nextToken()", "388": "PdfTokenizer::::nextToken()", "389": "PdfTokenizer::::nextToken()", "390": "PdfTokenizer::::nextToken()", "391": "PdfTokenizer::::nextToken()", "392": "PdfTokenizer::::nextToken()", "393": "PdfTokenizer::::nextToken()", "394": "PdfTokenizer::::nextToken()", "395": "PdfTokenizer::::nextToken()", "396": "PdfTokenizer::::nextToken()", "397": "PdfTokenizer::::nextToken()", "398": "PdfTokenizer::::nextToken()", "399": "PdfTokenizer::::nextToken()", "400": "PdfTokenizer::::nextToken()", "401": "PdfTokenizer::::nextToken()", "402": "PdfTokenizer::::nextToken()", "403": "PdfTokenizer::::nextToken()", "404": "PdfTokenizer::::nextToken()", "405": "PdfTokenizer::::nextToken()", "406": "PdfTokenizer::::nextToken()", "407": "PdfTokenizer::::nextToken()", "408": "PdfTokenizer::::nextToken()", "409": "PdfTokenizer::::nextToken()", "410": "PdfTokenizer::::nextToken()", "411": "PdfTokenizer::::nextToken()", "412": "PdfTokenizer::::nextToken()", "413": "PdfTokenizer::::nextToken()", "414": "PdfTokenizer::::nextToken()", "415": "PdfTokenizer::::nextToken()", "416": "PdfTokenizer::::nextToken()", "417": "PdfTokenizer::::nextToken()", "418": "PdfTokenizer::::nextToken()", "419": "PdfTokenizer::::nextToken()", "420": "PdfTokenizer::::nextToken()", "421": "PdfTokenizer::::nextToken()", "422": "PdfTokenizer::::nextToken()", "423": "PdfTokenizer::::nextToken()", "424": "PdfTokenizer::::nextToken()", "425": "PdfTokenizer::::nextToken()", "426": "PdfTokenizer::::nextToken()", "427": "PdfTokenizer::::nextToken()", "428": "PdfTokenizer::::nextToken()", "429": "PdfTokenizer::::nextToken()", "430": "PdfTokenizer::::nextToken()", "431": "PdfTokenizer::::nextToken()", "432": "PdfTokenizer::::nextToken()", "433": "PdfTokenizer::::nextToken()", "434": "PdfTokenizer::::nextToken()", "435": "PdfTokenizer::::nextToken()", "436": "PdfTokenizer::::nextToken()", "437": "PdfTokenizer::::nextToken()", "438": "PdfTokenizer::::nextToken()", "439": "PdfTokenizer::::nextToken()", "440": "PdfTokenizer::::nextToken()", "441": "PdfTokenizer::::nextToken()", "442": "PdfTokenizer::::nextToken()", "443": "PdfTokenizer::::nextToken()", "444": "PdfTokenizer::::nextToken()", "445": "PdfTokenizer::::nextToken()", "446": "PdfTokenizer::::nextToken()", "447": "PdfTokenizer::::nextToken()", "448": "PdfTokenizer::::nextToken()", "449": "PdfTokenizer::::nextToken()", "450": "PdfTokenizer::::nextToken()", "451": "PdfTokenizer::::nextToken()", "452": "PdfTokenizer::::nextToken()", "453": "PdfTokenizer::::nextToken()", "454": "PdfTokenizer::::nextToken()", "455": "PdfTokenizer::::nextToken()", "456": "PdfTokenizer::::nextToken()", "457": "PdfTokenizer::::nextToken()", "458": "PdfTokenizer::::nextToken()", "459": "PdfTokenizer::::nextToken()", "460": "PdfTokenizer::::nextToken()", "461": "PdfTokenizer::::nextToken()", "462": "PdfTokenizer::::nextToken()", "463": "PdfTokenizer::::nextToken()", "464": "PdfTokenizer::::nextToken()", "465": "PdfTokenizer::::nextToken()", "466": "PdfTokenizer::::nextToken()", "467": "PdfTokenizer::::nextToken()", "468": "PdfTokenizer::::nextToken()", "469": "PdfTokenizer::::nextToken()", "470": "PdfTokenizer::::nextToken()", "471": "PdfTokenizer::::nextToken()", "472": "PdfTokenizer::::nextToken()", "473": "PdfTokenizer::::nextToken()", "474": "PdfTokenizer::::nextToken()", "475": "PdfTokenizer::::nextToken()", "476": "PdfTokenizer::::nextToken()", "477": "PdfTokenizer::::nextToken()", "478": "PdfTokenizer::::nextToken()", "479": "PdfTokenizer::::nextToken()", "480": "PdfTokenizer::::nextToken()", "481": "PdfTokenizer::::nextToken()", "482": "PdfTokenizer::::nextToken()", "483": "PdfTokenizer::::nextToken()", "484": "PdfTokenizer::::nextToken()", "485": "PdfTokenizer::::nextToken()", "486": "PdfTokenizer::::nextToken()", "487": "PdfTokenizer::::nextToken()", "488": "PdfTokenizer::::nextToken()", "489": "PdfTokenizer::::nextToken()", "490": "PdfTokenizer::::nextToken()", "491": "PdfTokenizer::::nextToken()", "492": "PdfTokenizer::::nextToken()", "493": "PdfTokenizer::::nextToken()", "494": "PdfTokenizer::::nextToken()", "495": "PdfTokenizer::::nextToken()", "496": "PdfTokenizer::::nextToken()", "497": "PdfTokenizer::::nextToken()", "498": "PdfTokenizer::::nextToken()", "499": "PdfTokenizer::::nextToken()", "500": "PdfTokenizer::::nextToken()", "501": "PdfTokenizer::::nextToken()", "502": "PdfTokenizer::::nextToken()", "503": "PdfTokenizer::::nextToken()", "504": "PdfTokenizer::::nextToken()", "505": "PdfTokenizer::::nextToken()", "506": "PdfTokenizer::::nextToken()", "508": "PdfTokenizer::::getLongValue()", "509": "PdfTokenizer::::getLongValue()", "510": "PdfTokenizer::::getLongValue()", "512": "PdfTokenizer::::getIntValue()", "513": "PdfTokenizer::::getIntValue()", "514": "PdfTokenizer::::getIntValue()", "516": "PdfTokenizer::::isHexString()", "517": "PdfTokenizer::::isHexString()", "518": "PdfTokenizer::::isHexString()", "520": "PdfTokenizer::::isCloseStream()", "521": "PdfTokenizer::::isCloseStream()", "522": "PdfTokenizer::::isCloseStream()", "524": "PdfTokenizer::::setCloseStream(boolean)", "525": "PdfTokenizer::::setCloseStream(boolean)", "526": "PdfTokenizer::::setCloseStream(boolean)", "528": "PdfTokenizer::::getSafeFile()", "529": "PdfTokenizer::::getSafeFile()", "530": "PdfTokenizer::::getSafeFile()", "545": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "546": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "547": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "548": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "549": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "550": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "551": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "552": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "553": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "554": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "555": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "556": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "557": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "558": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "559": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "560": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "561": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "562": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "563": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "564": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "565": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "566": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "567": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "568": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "569": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "570": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "571": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "572": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "573": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "574": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "575": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "576": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "577": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "578": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "579": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "580": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "581": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "582": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "583": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "584": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "585": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "586": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "587": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "588": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "589": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "590": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "591": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "592": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "593": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "594": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "595": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "596": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "597": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "598": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "599": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "600": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "601": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "602": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "603": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "604": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "605": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "606": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "607": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "608": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "609": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "610": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "611": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "612": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "613": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "614": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "615": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "616": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "617": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "618": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "619": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "620": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "621": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "622": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "623": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "624": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "625": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "626": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "627": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "628": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "629": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "630": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "631": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "632": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "633": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "634": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "635": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "636": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "637": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "638": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "639": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "640": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "641": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "642": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "643": "PdfTokenizer::::decodeStringContent(byte[],int,int,boolean)", "656": "PdfTokenizer::::decodeStringContent(byte[],boolean)", "657": "PdfTokenizer::::decodeStringContent(byte[],boolean)", "658": "PdfTokenizer::::decodeStringContent(byte[],boolean)", "668": "PdfTokenizer::::isWhitespace(int)", "669": "PdfTokenizer::::isWhitespace(int)", "670": "PdfTokenizer::::isWhitespace(int)", "679": "PdfTokenizer::::isWhitespace(int,boolean)", "680": "PdfTokenizer::::isWhitespace(int,boolean)", "681": "PdfTokenizer::::isWhitespace(int,boolean)", "683": "PdfTokenizer::::isDelimiter(int)", "684": "PdfTokenizer::::isDelimiter(int)", "685": "PdfTokenizer::::isDelimiter(int)", "687": "PdfTokenizer::::isDelimiterWhitespace(int)", "688": "PdfTokenizer::::isDelimiterWhitespace(int)", "689": "PdfTokenizer::::isDelimiterWhitespace(int)", "697": "PdfTokenizer::::throwError(java.lang.String,java.lang.Object[])", "698": "PdfTokenizer::::throwError(java.lang.String,java.lang.Object[])", "699": "PdfTokenizer::::throwError(java.lang.String,java.lang.Object[])", "700": "PdfTokenizer::::throwError(java.lang.String,java.lang.Object[])", "709": "PdfTokenizer::::checkTrailer(com.itextpdf.io.source.ByteBuffer)", "710": "PdfTokenizer::::checkTrailer(com.itextpdf.io.source.ByteBuffer)", "711": "PdfTokenizer::::checkTrailer(com.itextpdf.io.source.ByteBuffer)", "712": "PdfTokenizer::::checkTrailer(com.itextpdf.io.source.ByteBuffer)", "713": "PdfTokenizer::::checkTrailer(com.itextpdf.io.source.ByteBuffer)", "714": "PdfTokenizer::::checkTrailer(com.itextpdf.io.source.ByteBuffer)", "715": "PdfTokenizer::::checkTrailer(com.itextpdf.io.source.ByteBuffer)", "716": "PdfTokenizer::::checkTrailer(com.itextpdf.io.source.ByteBuffer)", "717": "PdfTokenizer::::checkTrailer(com.itextpdf.io.source.ByteBuffer)", "730": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer)", "731": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer)", "732": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer)", "745": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "746": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "747": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "748": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "749": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "750": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "751": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "752": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "753": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "754": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "755": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "756": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "757": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "758": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "759": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "760": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "761": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "762": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "763": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "764": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "765": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "766": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "767": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "768": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "769": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "770": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "771": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "772": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "773": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "774": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "775": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "776": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "777": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "778": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "779": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "780": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "781": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "782": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "783": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "784": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "785": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "786": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "787": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "788": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "789": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "790": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "791": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "792": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "793": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "794": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "795": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "796": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "797": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "798": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "799": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "800": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "801": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "802": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "803": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "804": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "805": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "806": "PdfTokenizer::::readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean)", "813": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "814": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "815": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "816": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "817": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "818": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "819": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "820": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "821": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "822": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "823": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "824": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "825": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "826": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "827": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "828": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "829": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "830": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)", "831": "PdfTokenizer::::checkObjectStart(com.itextpdf.io.source.PdfTokenizer)"}, "test_reverse_method_lines_dic": {"42": "PdfTokenizerTest::::seekTest()", "43": "PdfTokenizerTest::::seekTest()", "44": "PdfTokenizerTest::::seekTest()", "45": "PdfTokenizerTest::::seekTest()", "46": "PdfTokenizerTest::::seekTest()", "47": "PdfTokenizerTest::::seekTest()", "48": "PdfTokenizerTest::::seekTest()", "49": "PdfTokenizerTest::::seekTest()", "50": "PdfTokenizerTest::::seekTest()", "51": "PdfTokenizerTest::::seekTest()", "52": "PdfTokenizerTest::::seekTest()", "53": "PdfTokenizerTest::::seekTest()", "54": "PdfTokenizerTest::::seekTest()", "55": "PdfTokenizerTest::::seekTest()", "56": "PdfTokenizerTest::::seekTest()", "57": "PdfTokenizerTest::::seekTest()", "58": "PdfTokenizerTest::::seekTest()", "59": "PdfTokenizerTest::::seekTest()", "60": "PdfTokenizerTest::::seekTest()", "61": "PdfTokenizerTest::::seekTest()", "62": "PdfTokenizerTest::::seekTest()", "63": "PdfTokenizerTest::::seekTest()", "64": "PdfTokenizerTest::::seekTest()", "65": "PdfTokenizerTest::::seekTest()", "66": "PdfTokenizerTest::::seekTest()", "67": "PdfTokenizerTest::::seekTest()", "68": "PdfTokenizerTest::::seekTest()", "69": "PdfTokenizerTest::::seekTest()", "71": "PdfTokenizerTest::::getLongValueTest()", "72": "PdfTokenizerTest::::getLongValueTest()", "73": "PdfTokenizerTest::::getLongValueTest()", "74": "PdfTokenizerTest::::getLongValueTest()", "75": "PdfTokenizerTest::::getLongValueTest()", "76": "PdfTokenizerTest::::getLongValueTest()", "77": "PdfTokenizerTest::::getLongValueTest()", "78": "PdfTokenizerTest::::getLongValueTest()", "79": "PdfTokenizerTest::::getLongValueTest()", "80": "PdfTokenizerTest::::getLongValueTest()", "81": "PdfTokenizerTest::::getLongValueTest()", "82": "PdfTokenizerTest::::getLongValueTest()", "84": "PdfTokenizerTest::::getIntValueTest()", "85": "PdfTokenizerTest::::getIntValueTest()", "86": "PdfTokenizerTest::::getIntValueTest()", "87": "PdfTokenizerTest::::getIntValueTest()", "88": "PdfTokenizerTest::::getIntValueTest()", "89": "PdfTokenizerTest::::getIntValueTest()", "90": "PdfTokenizerTest::::getIntValueTest()", "91": "PdfTokenizerTest::::getIntValueTest()", "92": "PdfTokenizerTest::::getIntValueTest()", "93": "PdfTokenizerTest::::getIntValueTest()", "94": "PdfTokenizerTest::::getIntValueTest()", "95": "PdfTokenizerTest::::getIntValueTest()", "97": "PdfTokenizerTest::::getPositionTest()", "98": "PdfTokenizerTest::::getPositionTest()", "99": "PdfTokenizerTest::::getPositionTest()", "100": "PdfTokenizerTest::::getPositionTest()", "101": "PdfTokenizerTest::::getPositionTest()", "102": "PdfTokenizerTest::::getPositionTest()", "103": "PdfTokenizerTest::::getPositionTest()", "104": "PdfTokenizerTest::::getPositionTest()", "105": "PdfTokenizerTest::::getPositionTest()", "106": "PdfTokenizerTest::::getPositionTest()", "107": "PdfTokenizerTest::::getPositionTest()", "108": "PdfTokenizerTest::::getPositionTest()", "109": "PdfTokenizerTest::::getPositionTest()", "110": "PdfTokenizerTest::::getPositionTest()", "112": "PdfTokenizerTest::::lengthTest()", "113": "PdfTokenizerTest::::lengthTest()", "114": "PdfTokenizerTest::::lengthTest()", "115": "PdfTokenizerTest::::lengthTest()", "116": "PdfTokenizerTest::::lengthTest()", "117": "PdfTokenizerTest::::lengthTest()", "118": "PdfTokenizerTest::::lengthTest()", "119": "PdfTokenizerTest::::lengthTest()", "120": "PdfTokenizerTest::::lengthTest()", "121": "PdfTokenizerTest::::lengthTest()", "123": "PdfTokenizerTest::::lengthTwoTokenTest()", "124": "PdfTokenizerTest::::lengthTwoTokenTest()", "125": "PdfTokenizerTest::::lengthTwoTokenTest()", "126": "PdfTokenizerTest::::lengthTwoTokenTest()", "127": "PdfTokenizerTest::::lengthTwoTokenTest()", "128": "PdfTokenizerTest::::lengthTwoTokenTest()", "129": "PdfTokenizerTest::::lengthTwoTokenTest()", "130": "PdfTokenizerTest::::lengthTwoTokenTest()", "131": "PdfTokenizerTest::::lengthTwoTokenTest()", "132": "PdfTokenizerTest::::lengthTwoTokenTest()", "134": "PdfTokenizerTest::::readTest()", "135": "PdfTokenizerTest::::readTest()", "136": "PdfTokenizerTest::::readTest()", "137": "PdfTokenizerTest::::readTest()", "138": "PdfTokenizerTest::::readTest()", "139": "PdfTokenizerTest::::readTest()", "140": "PdfTokenizerTest::::readTest()", "141": "PdfTokenizerTest::::readTest()", "142": "PdfTokenizerTest::::readTest()", "143": "PdfTokenizerTest::::readTest()", "144": "PdfTokenizerTest::::readTest()", "145": "PdfTokenizerTest::::readTest()", "146": "PdfTokenizerTest::::readTest()", "147": "PdfTokenizerTest::::readTest()", "148": "PdfTokenizerTest::::readTest()", "150": "PdfTokenizerTest::::readStringFullTest()", "151": "PdfTokenizerTest::::readStringFullTest()", "152": "PdfTokenizerTest::::readStringFullTest()", "153": "PdfTokenizerTest::::readStringFullTest()", "154": "PdfTokenizerTest::::readStringFullTest()", "155": "PdfTokenizerTest::::readStringFullTest()", "156": "PdfTokenizerTest::::readStringFullTest()", "157": "PdfTokenizerTest::::readStringFullTest()", "158": "PdfTokenizerTest::::readStringFullTest()", "159": "PdfTokenizerTest::::readStringFullTest()", "161": "PdfTokenizerTest::::readStringShortTest()", "162": "PdfTokenizerTest::::readStringShortTest()", "163": "PdfTokenizerTest::::readStringShortTest()", "164": "PdfTokenizerTest::::readStringShortTest()", "165": "PdfTokenizerTest::::readStringShortTest()", "166": "PdfTokenizerTest::::readStringShortTest()", "167": "PdfTokenizerTest::::readStringShortTest()", "168": "PdfTokenizerTest::::readStringShortTest()", "169": "PdfTokenizerTest::::readStringShortTest()", "170": "PdfTokenizerTest::::readStringShortTest()", "172": "PdfTokenizerTest::::readStringLongerThenDataTest()", "173": "PdfTokenizerTest::::readStringLongerThenDataTest()", "174": "PdfTokenizerTest::::readStringLongerThenDataTest()", "175": "PdfTokenizerTest::::readStringLongerThenDataTest()", "176": "PdfTokenizerTest::::readStringLongerThenDataTest()", "177": "PdfTokenizerTest::::readStringLongerThenDataTest()", "178": "PdfTokenizerTest::::readStringLongerThenDataTest()", "179": "PdfTokenizerTest::::readStringLongerThenDataTest()", "180": "PdfTokenizerTest::::readStringLongerThenDataTest()", "181": "PdfTokenizerTest::::readStringLongerThenDataTest()", "183": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "184": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "185": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "186": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "187": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "188": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "189": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "190": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "191": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "192": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "193": "PdfTokenizerTest::::readFullyPartThenReadStringTest()", "195": "PdfTokenizerTest::::readFullyThenReadStringTest()", "196": "PdfTokenizerTest::::readFullyThenReadStringTest()", "197": "PdfTokenizerTest::::readFullyThenReadStringTest()", "198": "PdfTokenizerTest::::readFullyThenReadStringTest()", "199": "PdfTokenizerTest::::readFullyThenReadStringTest()", "200": "PdfTokenizerTest::::readFullyThenReadStringTest()", "201": "PdfTokenizerTest::::readFullyThenReadStringTest()", "202": "PdfTokenizerTest::::readFullyThenReadStringTest()", "203": "PdfTokenizerTest::::readFullyThenReadStringTest()", "204": "PdfTokenizerTest::::readFullyThenReadStringTest()", "205": "PdfTokenizerTest::::readFullyThenReadStringTest()", "207": "PdfTokenizerTest::::getNextEofShortTextTest()", "208": "PdfTokenizerTest::::getNextEofShortTextTest()", "209": "PdfTokenizerTest::::getNextEofShortTextTest()", "210": "PdfTokenizerTest::::getNextEofShortTextTest()", "211": "PdfTokenizerTest::::getNextEofShortTextTest()", "212": "PdfTokenizerTest::::getNextEofShortTextTest()", "213": "PdfTokenizerTest::::getNextEofShortTextTest()", "214": "PdfTokenizerTest::::getNextEofShortTextTest()", "215": "PdfTokenizerTest::::getNextEofShortTextTest()", "216": "PdfTokenizerTest::::getNextEofShortTextTest()", "217": "PdfTokenizerTest::::getNextEofShortTextTest()", "219": "PdfTokenizerTest::::getNextEofLongTextTest()", "220": "PdfTokenizerTest::::getNextEofLongTextTest()", "221": "PdfTokenizerTest::::getNextEofLongTextTest()", "222": "PdfTokenizerTest::::getNextEofLongTextTest()", "223": "PdfTokenizerTest::::getNextEofLongTextTest()", "224": "PdfTokenizerTest::::getNextEofLongTextTest()", "225": "PdfTokenizerTest::::getNextEofLongTextTest()", "226": "PdfTokenizerTest::::getNextEofLongTextTest()", "227": "PdfTokenizerTest::::getNextEofLongTextTest()", "228": "PdfTokenizerTest::::getNextEofLongTextTest()", "229": "PdfTokenizerTest::::getNextEofLongTextTest()", "230": "PdfTokenizerTest::::getNextEofLongTextTest()", "231": "PdfTokenizerTest::::getNextEofLongTextTest()", "232": "PdfTokenizerTest::::getNextEofLongTextTest()", "233": "PdfTokenizerTest::::getNextEofLongTextTest()", "234": "PdfTokenizerTest::::getNextEofLongTextTest()", "236": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "237": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "238": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "239": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "240": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "241": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "242": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "243": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "244": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "245": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "246": "PdfTokenizerTest::::getNextEofSeveralEofTest()", "248": "PdfTokenizerTest::::getDecodedStringContentTest()", "249": "PdfTokenizerTest::::getDecodedStringContentTest()", "250": "PdfTokenizerTest::::getDecodedStringContentTest()", "251": "PdfTokenizerTest::::getDecodedStringContentTest()", "252": "PdfTokenizerTest::::getDecodedStringContentTest()", "253": "PdfTokenizerTest::::getDecodedStringContentTest()", "254": "PdfTokenizerTest::::getDecodedStringContentTest()", "255": "PdfTokenizerTest::::getDecodedStringContentTest()", "256": "PdfTokenizerTest::::getDecodedStringContentTest()", "257": "PdfTokenizerTest::::getDecodedStringContentTest()", "258": "PdfTokenizerTest::::getDecodedStringContentTest()", "259": "PdfTokenizerTest::::getDecodedStringContentTest()", "260": "PdfTokenizerTest::::getDecodedStringContentTest()", "261": "PdfTokenizerTest::::getDecodedStringContentTest()", "262": "PdfTokenizerTest::::getDecodedStringContentTest()", "263": "PdfTokenizerTest::::getDecodedStringContentTest()", "264": "PdfTokenizerTest::::getDecodedStringContentTest()", "266": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "267": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "268": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "269": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "270": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "271": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "272": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "273": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "274": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "275": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "276": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "277": "PdfTokenizerTest::::getDecodedStringContentHexTest()", "279": "PdfTokenizerTest::::throwErrorTest()", "280": "PdfTokenizerTest::::throwErrorTest()", "281": "PdfTokenizerTest::::throwErrorTest()", "282": "PdfTokenizerTest::::throwErrorTest()", "283": "PdfTokenizerTest::::throwErrorTest()", "284": "PdfTokenizerTest::::throwErrorTest()", "285": "PdfTokenizerTest::::throwErrorTest()", "286": "PdfTokenizerTest::::throwErrorTest()", "287": "PdfTokenizerTest::::throwErrorTest()", "288": "PdfTokenizerTest::::throwErrorTest()", "289": "PdfTokenizerTest::::throwErrorTest()", "291": "PdfTokenizerTest::::testOneNumber()", "292": "PdfTokenizerTest::::testOneNumber()", "293": "PdfTokenizerTest::::testOneNumber()", "294": "PdfTokenizerTest::::testOneNumber()", "296": "PdfTokenizerTest::::testTwoNumbers()", "297": "PdfTokenizerTest::::testTwoNumbers()", "298": "PdfTokenizerTest::::testTwoNumbers()", "299": "PdfTokenizerTest::::testTwoNumbers()", "300": "PdfTokenizerTest::::testTwoNumbers()", "301": "PdfTokenizerTest::::testTwoNumbers()", "302": "PdfTokenizerTest::::testTwoNumbers()", "304": "PdfTokenizerTest::::tokenTypesTest()", "305": "PdfTokenizerTest::::tokenTypesTest()", "306": "PdfTokenizerTest::::tokenTypesTest()", "307": "PdfTokenizerTest::::tokenTypesTest()", "308": "PdfTokenizerTest::::tokenTypesTest()", "309": "PdfTokenizerTest::::tokenTypesTest()", "310": "PdfTokenizerTest::::tokenTypesTest()", "311": "PdfTokenizerTest::::tokenTypesTest()", "312": "PdfTokenizerTest::::tokenTypesTest()", "314": "PdfTokenizerTest::::numberValueInTheEndTest()", "315": "PdfTokenizerTest::::numberValueInTheEndTest()", "316": "PdfTokenizerTest::::numberValueInTheEndTest()", "317": "PdfTokenizerTest::::numberValueInTheEndTest()", "318": "PdfTokenizerTest::::numberValueInTheEndTest()", "319": "PdfTokenizerTest::::numberValueInTheEndTest()", "320": "PdfTokenizerTest::::numberValueInTheEndTest()", "321": "PdfTokenizerTest::::numberValueInTheEndTest()", "322": "PdfTokenizerTest::::numberValueInTheEndTest()", "324": "PdfTokenizerTest::::tokenValueEqualsToTest()", "325": "PdfTokenizerTest::::tokenValueEqualsToTest()", "326": "PdfTokenizerTest::::tokenValueEqualsToTest()", "327": "PdfTokenizerTest::::tokenValueEqualsToTest()", "328": "PdfTokenizerTest::::tokenValueEqualsToTest()", "329": "PdfTokenizerTest::::tokenValueEqualsToTest()", "330": "PdfTokenizerTest::::tokenValueEqualsToTest()", "331": "PdfTokenizerTest::::tokenValueEqualsToTest()", "332": "PdfTokenizerTest::::tokenValueEqualsToTest()", "333": "PdfTokenizerTest::::tokenValueEqualsToTest()", "335": "PdfTokenizerTest::::tokenValueEqualsToNullTest()", "336": "PdfTokenizerTest::::tokenValueEqualsToNullTest()", "337": "PdfTokenizerTest::::tokenValueEqualsToNullTest()", "338": "PdfTokenizerTest::::tokenValueEqualsToNullTest()", "339": "PdfTokenizerTest::::tokenValueEqualsToNullTest()", "340": "PdfTokenizerTest::::tokenValueEqualsToNullTest()", "341": "PdfTokenizerTest::::tokenValueEqualsToNullTest()", "342": "PdfTokenizerTest::::tokenValueEqualsToNullTest()", "343": "PdfTokenizerTest::::tokenValueEqualsToNullTest()", "344": "PdfTokenizerTest::::tokenValueEqualsToNullTest()", "346": "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()", "347": "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()", "348": "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()", "349": "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()", "350": "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()", "351": "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()", "352": "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()", "353": "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()", "354": "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()", "355": "PdfTokenizerTest::::tokenValueEqualsToNotSameStringTest()", "357": "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()", "358": "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()", "359": "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()", "360": "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()", "361": "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()", "362": "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()", "363": "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()", "364": "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()", "365": "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()", "366": "PdfTokenizerTest::::tokenValueEqualsToNotCaseSensitiveStringTest()", "368": "PdfTokenizerTest::::checkPdfHeaderTest()", "369": "PdfTokenizerTest::::checkPdfHeaderTest()", "370": "PdfTokenizerTest::::checkPdfHeaderTest()", "371": "PdfTokenizerTest::::checkPdfHeaderTest()", "372": "PdfTokenizerTest::::checkPdfHeaderTest()", "373": "PdfTokenizerTest::::checkPdfHeaderTest()", "374": "PdfTokenizerTest::::checkPdfHeaderTest()", "376": "PdfTokenizerTest::::getHeaderOffsetTest()", "377": "PdfTokenizerTest::::getHeaderOffsetTest()", "378": "PdfTokenizerTest::::getHeaderOffsetTest()", "379": "PdfTokenizerTest::::getHeaderOffsetTest()", "380": "PdfTokenizerTest::::getHeaderOffsetTest()", "381": "PdfTokenizerTest::::getHeaderOffsetTest()", "382": "PdfTokenizerTest::::getHeaderOffsetTest()", "384": "PdfTokenizerTest::::primitivesTest()", "385": "PdfTokenizerTest::::primitivesTest()", "386": "PdfTokenizerTest::::primitivesTest()", "387": "PdfTokenizerTest::::primitivesTest()", "388": "PdfTokenizerTest::::primitivesTest()", "389": "PdfTokenizerTest::::primitivesTest()", "390": "PdfTokenizerTest::::primitivesTest()", "391": "PdfTokenizerTest::::primitivesTest()", "392": "PdfTokenizerTest::::primitivesTest()", "393": "PdfTokenizerTest::::primitivesTest()", "394": "PdfTokenizerTest::::primitivesTest()", "395": "PdfTokenizerTest::::primitivesTest()", "396": "PdfTokenizerTest::::primitivesTest()", "397": "PdfTokenizerTest::::primitivesTest()", "398": "PdfTokenizerTest::::primitivesTest()", "399": "PdfTokenizerTest::::primitivesTest()", "400": "PdfTokenizerTest::::primitivesTest()", "401": "PdfTokenizerTest::::primitivesTest()", "402": "PdfTokenizerTest::::primitivesTest()", "403": "PdfTokenizerTest::::primitivesTest()", "404": "PdfTokenizerTest::::primitivesTest()", "405": "PdfTokenizerTest::::primitivesTest()", "406": "PdfTokenizerTest::::primitivesTest()", "407": "PdfTokenizerTest::::primitivesTest()", "408": "PdfTokenizerTest::::primitivesTest()", "409": "PdfTokenizerTest::::primitivesTest()", "410": "PdfTokenizerTest::::primitivesTest()", "411": "PdfTokenizerTest::::primitivesTest()", "412": "PdfTokenizerTest::::primitivesTest()", "413": "PdfTokenizerTest::::primitivesTest()", "414": "PdfTokenizerTest::::primitivesTest()", "415": "PdfTokenizerTest::::primitivesTest()", "416": "PdfTokenizerTest::::primitivesTest()", "417": "PdfTokenizerTest::::primitivesTest()", "418": "PdfTokenizerTest::::primitivesTest()", "419": "PdfTokenizerTest::::primitivesTest()", "420": "PdfTokenizerTest::::primitivesTest()", "421": "PdfTokenizerTest::::primitivesTest()", "422": "PdfTokenizerTest::::primitivesTest()", "423": "PdfTokenizerTest::::primitivesTest()", "424": "PdfTokenizerTest::::primitivesTest()", "425": "PdfTokenizerTest::::primitivesTest()", "426": "PdfTokenizerTest::::primitivesTest()", "427": "PdfTokenizerTest::::primitivesTest()", "428": "PdfTokenizerTest::::primitivesTest()", "429": "PdfTokenizerTest::::primitivesTest()", "430": "PdfTokenizerTest::::primitivesTest()", "431": "PdfTokenizerTest::::primitivesTest()", "432": "PdfTokenizerTest::::primitivesTest()", "433": "PdfTokenizerTest::::primitivesTest()", "434": "PdfTokenizerTest::::primitivesTest()", "435": "PdfTokenizerTest::::primitivesTest()", "436": "PdfTokenizerTest::::primitivesTest()", "437": "PdfTokenizerTest::::primitivesTest()", "438": "PdfTokenizerTest::::primitivesTest()", "439": "PdfTokenizerTest::::primitivesTest()", "440": "PdfTokenizerTest::::primitivesTest()", "441": "PdfTokenizerTest::::primitivesTest()", "442": "PdfTokenizerTest::::primitivesTest()", "443": "PdfTokenizerTest::::primitivesTest()", "444": "PdfTokenizerTest::::primitivesTest()", "445": "PdfTokenizerTest::::primitivesTest()", "446": "PdfTokenizerTest::::primitivesTest()", "447": "PdfTokenizerTest::::primitivesTest()", "448": "PdfTokenizerTest::::primitivesTest()", "449": "PdfTokenizerTest::::primitivesTest()", "450": "PdfTokenizerTest::::primitivesTest()", "451": "PdfTokenizerTest::::primitivesTest()", "452": "PdfTokenizerTest::::primitivesTest()", "453": "PdfTokenizerTest::::primitivesTest()", "454": "PdfTokenizerTest::::primitivesTest()", "455": "PdfTokenizerTest::::primitivesTest()", "456": "PdfTokenizerTest::::primitivesTest()", "457": "PdfTokenizerTest::::primitivesTest()", "458": "PdfTokenizerTest::::primitivesTest()", "459": "PdfTokenizerTest::::primitivesTest()", "460": "PdfTokenizerTest::::primitivesTest()", "461": "PdfTokenizerTest::::primitivesTest()", "462": "PdfTokenizerTest::::primitivesTest()", "463": "PdfTokenizerTest::::primitivesTest()", "464": "PdfTokenizerTest::::primitivesTest()", "465": "PdfTokenizerTest::::primitivesTest()", "466": "PdfTokenizerTest::::primitivesTest()", "467": "PdfTokenizerTest::::primitivesTest()", "468": "PdfTokenizerTest::::primitivesTest()", "469": "PdfTokenizerTest::::primitivesTest()", "470": "PdfTokenizerTest::::primitivesTest()", "471": "PdfTokenizerTest::::primitivesTest()", "472": "PdfTokenizerTest::::primitivesTest()", "473": "PdfTokenizerTest::::primitivesTest()", "474": "PdfTokenizerTest::::primitivesTest()", "475": "PdfTokenizerTest::::primitivesTest()", "476": "PdfTokenizerTest::::primitivesTest()", "477": "PdfTokenizerTest::::primitivesTest()", "478": "PdfTokenizerTest::::primitivesTest()", "479": "PdfTokenizerTest::::primitivesTest()", "480": "PdfTokenizerTest::::primitivesTest()", "481": "PdfTokenizerTest::::primitivesTest()", "483": "PdfTokenizerTest::::octalNumberLong1Test()", "484": "PdfTokenizerTest::::octalNumberLong1Test()", "485": "PdfTokenizerTest::::octalNumberLong1Test()", "486": "PdfTokenizerTest::::octalNumberLong1Test()", "487": "PdfTokenizerTest::::octalNumberLong1Test()", "488": "PdfTokenizerTest::::octalNumberLong1Test()", "489": "PdfTokenizerTest::::octalNumberLong1Test()", "491": "PdfTokenizerTest::::octalNumberLong2Test()", "492": "PdfTokenizerTest::::octalNumberLong2Test()", "493": "PdfTokenizerTest::::octalNumberLong2Test()", "494": "PdfTokenizerTest::::octalNumberLong2Test()", "495": "PdfTokenizerTest::::octalNumberLong2Test()", "496": "PdfTokenizerTest::::octalNumberLong2Test()", "497": "PdfTokenizerTest::::octalNumberLong2Test()", "499": "PdfTokenizerTest::::octalNumberLong3Test()", "500": "PdfTokenizerTest::::octalNumberLong3Test()", "501": "PdfTokenizerTest::::octalNumberLong3Test()", "502": "PdfTokenizerTest::::octalNumberLong3Test()", "503": "PdfTokenizerTest::::octalNumberLong3Test()", "504": "PdfTokenizerTest::::octalNumberLong3Test()", "505": "PdfTokenizerTest::::octalNumberLong3Test()", "507": "PdfTokenizerTest::::slashAfterShortOctalTest()", "508": "PdfTokenizerTest::::slashAfterShortOctalTest()", "509": "PdfTokenizerTest::::slashAfterShortOctalTest()", "510": "PdfTokenizerTest::::slashAfterShortOctalTest()", "511": "PdfTokenizerTest::::slashAfterShortOctalTest()", "512": "PdfTokenizerTest::::slashAfterShortOctalTest()", "513": "PdfTokenizerTest::::slashAfterShortOctalTest()", "515": "PdfTokenizerTest::::notOctalAfterShortOctalTest()", "516": "PdfTokenizerTest::::notOctalAfterShortOctalTest()", "517": "PdfTokenizerTest::::notOctalAfterShortOctalTest()", "518": "PdfTokenizerTest::::notOctalAfterShortOctalTest()", "519": "PdfTokenizerTest::::notOctalAfterShortOctalTest()", "520": "PdfTokenizerTest::::notOctalAfterShortOctalTest()", "521": "PdfTokenizerTest::::notOctalAfterShortOctalTest()", "523": "PdfTokenizerTest::::notOctalAfterShortOctalTest2()", "524": "PdfTokenizerTest::::notOctalAfterShortOctalTest2()", "525": "PdfTokenizerTest::::notOctalAfterShortOctalTest2()", "526": "PdfTokenizerTest::::notOctalAfterShortOctalTest2()", "527": "PdfTokenizerTest::::notOctalAfterShortOctalTest2()", "528": "PdfTokenizerTest::::notOctalAfterShortOctalTest2()", "529": "PdfTokenizerTest::::notOctalAfterShortOctalTest2()", "531": "PdfTokenizerTest::::twoShortOctalsWithGarbageTest()", "532": "PdfTokenizerTest::::twoShortOctalsWithGarbageTest()", "533": "PdfTokenizerTest::::twoShortOctalsWithGarbageTest()", "534": "PdfTokenizerTest::::twoShortOctalsWithGarbageTest()", "535": "PdfTokenizerTest::::twoShortOctalsWithGarbageTest()", "536": "PdfTokenizerTest::::twoShortOctalsWithGarbageTest()", "537": "PdfTokenizerTest::::twoShortOctalsWithGarbageTest()", "550": "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])", "551": "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])", "552": "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])", "553": "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])", "554": "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])", "555": "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])", "556": "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])", "557": "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])", "558": "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])", "559": "PdfTokenizerTest::::checkTokenValues(java.lang.String,byte[][])"}, "tests": [{"test_lines": [42, 69], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 120, 121, 157, 161, 165, 195, 196, 197, 267, 268, 269, 270, 271, 272, 274, 276, 277, 278, 279, 280, 281, 323, 330, 331, 332, 338, 342, 344, 345, 346, 347, 348, 350, 360, 362, 363, 364, 365, 367, 368, 445, 446, 447, 448, 449, 457, 460, 462, 463, 464, 467, 487, 493, 500, 505, 669, 680]}, {"test_lines": [71, 82], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 157, 161, 165, 267, 268, 269, 270, 271, 272, 274, 276, 278, 279, 280, 281, 323, 330, 331, 332, 338, 342, 344, 345, 346, 347, 348, 350, 445, 446, 447, 448, 449, 457, 460, 462, 463, 464, 467, 487, 493, 500, 505, 509, 669, 680]}, {"test_lines": [84, 95], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 157, 161, 165, 267, 268, 269, 270, 271, 272, 274, 276, 278, 279, 280, 281, 323, 330, 331, 332, 338, 342, 344, 345, 346, 347, 348, 350, 445, 446, 447, 448, 449, 457, 460, 462, 463, 464, 467, 487, 493, 500, 505, 513, 669, 680]}, {"test_lines": [97, 110], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 128, 161, 195, 196, 197, 267, 268, 269, 270, 271, 272, 274, 276, 277, 278, 279, 280, 281, 323, 330, 331, 332, 338, 342, 344, 345, 346, 347, 348, 350, 360, 362, 363, 364, 365, 367, 368, 445, 446, 447, 448, 449, 457, 460, 462, 463, 464, 467, 487, 493, 500, 505, 669, 680]}, {"test_lines": [112, 121], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 137]}, {"test_lines": [123, 132], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 137]}, {"test_lines": [134, 148], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 141]}, {"test_lines": [150, 159], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 141, 145, 147, 148, 149, 151, 153]}, {"test_lines": [161, 170], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 141, 145, 147, 148, 149, 151, 153]}, {"test_lines": [172, 181], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 141, 145, 147, 148, 149, 150, 151, 153]}, {"test_lines": [183, 193], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 124, 125, 141, 145, 147, 148, 149, 150, 151, 153]}, {"test_lines": [195, 205], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 124, 125, 141, 145, 147, 148, 149, 150, 151, 153]}, {"test_lines": [207, 217], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 132, 133, 134, 141, 145, 147, 148, 149, 150, 151, 153, 252, 255, 256, 257, 258, 260]}, {"test_lines": [219, 234], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 132, 133, 134, 141, 145, 147, 148, 149, 150, 151, 153, 252, 255, 256, 257, 258, 260, 262]}, {"test_lines": [236, 246], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 132, 133, 134, 141, 145, 147, 148, 149, 150, 151, 153, 252, 255, 256, 257, 258, 260]}, {"test_lines": [248, 264], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 169, 195, 196, 197, 342, 344, 345, 346, 347, 348, 350, 360, 362, 363, 364, 365, 367, 368, 445, 446, 447, 448, 449, 457, 460, 462, 463, 464, 467, 487, 493, 500, 505, 517, 546, 549, 563, 564, 565, 566, 632, 639, 640, 642, 669, 680]}, {"test_lines": [266, 277], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 169, 342, 344, 345, 346, 350, 378, 379, 383, 384, 385, 387, 389, 390, 391, 392, 393, 395, 396, 398, 401, 402, 403, 405, 407, 505, 517, 546, 549, 550, 551, 552, 553, 557, 558, 559, 560, 561, 642, 669, 680]}, {"test_lines": [279, 289], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 698, 699]}, {"test_lines": [291, 294], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 157, 161, 195, 196, 197, 267, 268, 269, 270, 271, 272, 274, 276, 277, 278, 279, 280, 281, 323, 330, 331, 332, 338, 342, 344, 345, 346, 347, 348, 350, 360, 362, 363, 364, 365, 367, 368, 445, 446, 447, 448, 449, 457, 460, 462, 463, 464, 467, 487, 493, 500, 505, 669, 680]}, {"test_lines": [296, 302], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 157, 161, 195, 196, 197, 267, 268, 269, 270, 271, 272, 274, 276, 277, 278, 279, 280, 281, 284, 285, 286, 287, 288, 323, 330, 331, 332, 338, 342, 344, 345, 346, 347, 348, 350, 360, 362, 363, 364, 365, 367, 368, 445, 446, 447, 448, 449, 457, 460, 462, 463, 464, 467, 487, 493, 500, 501, 505, 669, 680]}, {"test_lines": [304, 312], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 157, 161, 173, 176, 177, 180, 181, 183, 195, 196, 197, 267, 268, 269, 270, 271, 272, 274, 276, 277, 278, 279, 280, 281, 284, 285, 286, 287, 288, 290, 291, 292, 295, 296, 297, 298, 300, 301, 310, 311, 323, 330, 338, 342, 344, 345, 346, 347, 348, 350, 352, 353, 356, 357, 360, 362, 363, 364, 365, 367, 368, 371, 372, 374, 375, 378, 379, 380, 381, 383, 384, 385, 387, 389, 390, 391, 392, 393, 395, 396, 398, 401, 402, 403, 405, 407, 445, 446, 447, 448, 449, 457, 460, 462, 463, 464, 467, 487, 493, 494, 496, 497, 498, 500, 501, 505, 669, 680]}, {"test_lines": [314, 322], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 161, 267, 268, 269, 270, 271, 272, 274, 276, 278, 279, 280, 281, 323, 330, 331, 332, 338, 342, 344, 345, 346, 347, 348, 350, 445, 446, 447, 448, 449, 457, 460, 462, 463, 464, 467, 487, 493, 500, 505, 669, 680]}, {"test_lines": [324, 333], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 173, 176, 177, 180, 181, 183, 342, 344, 345, 346, 350, 445, 494, 496, 497, 498, 500, 505, 669, 680]}, {"test_lines": [335, 344], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 173, 174, 342, 344, 345, 346, 350, 445, 494, 496, 497, 498, 500, 505, 669, 680]}, {"test_lines": [346, 355], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 173, 176, 177, 178, 342, 344, 345, 346, 350, 445, 494, 496, 497, 498, 500, 505, 669, 680]}, {"test_lines": [357, 366], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 173, 176, 177, 180, 181, 182, 342, 344, 345, 346, 350, 445, 494, 496, 497, 498, 500, 505, 669, 680]}, {"test_lines": [368, 374], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 141, 145, 147, 148, 149, 150, 151, 153, 212, 213, 214, 215, 217]}, {"test_lines": [376, 382], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 141, 145, 147, 148, 149, 150, 151, 153, 200, 201, 202, 208]}, {"test_lines": [384, 481], "covered_lines": [35, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 105, 114, 115, 116, 117, 157, 161, 173, 176, 177, 180, 181, 183, 187, 191, 195, 196, 197, 267, 268, 269, 270, 271, 272, 273, 274, 276, 277, 278, 279, 280, 281, 284, 285, 286, 287, 288, 290, 291, 292, 295, 296, 297, 298, 300, 301, 310, 311, 320, 321, 322, 323, 342, 344, 345, 346, 350, 352, 353, 356, 357, 360, 362, 363, 364, 365, 367, 368, 371, 372, 374, 375, 378, 379, 380, 381, 383, 384, 385, 387, 389, 391, 392, 393, 395, 396, 398, 399, 401, 402, 403, 405, 407, 412, 414, 415, 416, 419, 420, 421, 423, 424, 426, 428, 429, 430, 431, 432, 438, 440, 445, 446, 447, 448, 449, 452, 453, 454, 455, 457, 460, 462, 463, 464, 467, 468, 469, 470, 474, 475, 479, 480, 481, 483, 487, 490, 491, 493, 494, 496, 497, 498, 500, 501, 505, 517, 669, 680]}, {"test_lines": [483, 489], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 546, 549, 563, 564, 565, 566, 567, 568, 569, 599, 602, 603, 604, 605, 630, 632, 639, 640, 642, 657]}, {"test_lines": [491, 497], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 546, 549, 563, 564, 565, 566, 567, 568, 569, 599, 602, 603, 607, 608, 613, 615, 616, 617, 630, 632, 639, 640, 642, 657]}, {"test_lines": [499, 505], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 546, 549, 563, 564, 565, 566, 567, 568, 569, 599, 602, 603, 607, 608, 613, 615, 619, 620, 625, 626, 627, 630, 632, 639, 640, 642, 657]}, {"test_lines": [507, 513], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 546, 549, 563, 564, 565, 566, 567, 568, 569, 588, 599, 602, 603, 607, 608, 609, 610, 611, 630, 632, 639, 640, 642, 657]}, {"test_lines": [515, 521], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 546, 549, 563, 564, 565, 566, 567, 568, 569, 599, 602, 603, 607, 608, 609, 610, 611, 630, 632, 639, 640, 642, 657]}, {"test_lines": [523, 529], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 546, 549, 563, 564, 565, 566, 567, 568, 569, 599, 602, 603, 607, 608, 613, 615, 619, 620, 621, 622, 623, 630, 632, 639, 640, 642, 657]}, {"test_lines": [531, 537], "covered_lines": [35, 54, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 546, 549, 563, 564, 565, 566, 567, 568, 569, 599, 602, 603, 607, 608, 609, 610, 611, 613, 615, 616, 617, 630, 632, 639, 640, 642]}]}, "/bernard/dataset_construction/prep/repos/itext-java/io/src/main/java/com/itextpdf/io/source/OutputStream.java": {"class_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import com.itextpdf.io.exceptions.IOException;\n", "import com.itextpdf.io.exceptions.IoExceptionMessageConstant;\n", "\n", "\n", "public class OutputStream<T extends java.io.OutputStream> extends java.io.OutputStream {\n", "\n", "\n", "    //long=19 + max frac=6 => 26 => round to 32.\n", "    private final ByteBuffer numBuffer = new ByteBuffer(32);\n", "    private Boolean localHighPrecision;\n", "    protected java.io.OutputStream outputStream = null;\n", "    protected long currentPos = 0;\n", "    protected boolean closeStream = true;\n", "\n", "    /**\n", "     * Gets global high precision setting.\n", "     *\n", "     * @return global high precision setting.\n", "     */\n", "    public static boolean getHighPrecision() {\n", "        return ByteUtils.HighPrecision;\n", "    }\n", "\n", "    /**\n", "     * Sets global high precision setting for all {@link OutputStream} instances.\n", "     *\n", "     * @param value if true, all floats and double will be written with high precision\n", "     *              in all {@link OutputStream} instances.\n", "     */\n", "    public static void setHighPrecision(boolean value) {\n", "        ByteUtils.HighPrecision = value;\n", "    }\n", "\n", "    /**\n", "     * Gets local high precision setting.\n", "     *\n", "     * @return local high precision setting.\n", "     */\n", "    public boolean getLocalHighPrecision() {\n", "        return this.localHighPrecision;\n", "    }\n", "\n", "    /**\n", "     * Sets local high precision setting for the {@link OutputStream}.\n", "     * Global {@link ByteUtils#HighPrecision} setting will be overridden by this one.\n", "     *\n", "     * @param value if true, all floats and double will be written with high precision\n", "     *              in the underlying {@link OutputStream}.\n", "     */\n", "    public void setLocalHighPrecision(boolean value) {\n", "        this.localHighPrecision = value;\n", "    }\n", "\n", "    /**\n", "     * Creates a new {@link OutputStream} instance\n", "     * based on {@link java.io.OutputStream} instance.\n", "     *\n", "     * @param outputStream the {@link OutputStream} instance.\n", "     */\n", "    public OutputStream(java.io.OutputStream outputStream) {\n", "        super();\n", "        this.outputStream = outputStream;\n", "    }\n", "\n", "    /**\n", "     * Do not use this constructor. This is only for internal usage.\n", "     */\n", "    protected OutputStream() {\n", "        super();\n", "    }\n", "\n", "    /**\n", "     * Creates a new {@link OutputStream} instance\n", "     * based on {@link java.io.OutputStream} instance and precision setting value.\n", "     *\n", "     * @param outputStream       the {@link java.io.OutputStream} instance.\n", "     * @param localHighPrecision If true, all float and double values\n", "     *                           will be written with high precision.\n", "     *                           Global {@link ByteUtils#HighPrecision} setting\n", "     *                           will be overridden by this one.\n", "     */\n", "    public OutputStream(java.io.OutputStream outputStream, boolean localHighPrecision) {\n", "        super();\n", "        this.outputStream = outputStream;\n", "        this.localHighPrecision = localHighPrecision;\n", "    }\n", "\n", "    @Override\n", "    public void write(int b) throws java.io.IOException {\n", "        outputStream.write(b);\n", "        currentPos++;\n", "    }\n", "\n", "    @Override\n", "    public void write(byte[] b) throws java.io.IOException {\n", "        outputStream.write(b);\n", "        currentPos += b.length;\n", "    }\n", "\n", "    @Override\n", "    public void write(byte[] b, int off, int len) throws java.io.IOException {\n", "        outputStream.write(b, off, len);\n", "        currentPos += len;\n", "    }\n", "\n", "    /**\n", "     * See {@link java.io.OutputStream#write(int)}.\n", "     *\n", "     * @param value byte to write.\n", "     *\n", "     * @throws IOException if {@link java.io.IOException} occurs.\n", "     */\n", "    public void writeByte(byte value) {\n", "        try {\n", "            write(value);\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.CANNOT_WRITE_BYTE, e);\n", "        }\n", "    }\n", "\n", "    @Override\n", "    public void flush() throws java.io.IOException {\n", "        outputStream.flush();\n", "    }\n", "\n", "    @Override\n", "    public void close() throws java.io.IOException {\n", "        if (closeStream) {\n", "            outputStream.close();\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Writes long to internal {@link java.io.OutputStream} in ISO format.\n", "     *\n", "     * @param value value to write.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeLong(long value) {\n", "        try {\n", "            ByteUtils.getIsoBytes(value, numBuffer.reset());\n", "            write(numBuffer.getInternalBuffer(), numBuffer.capacity() - numBuffer.size(), numBuffer.size());\n", "            return (T) this;\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.CANNOT_WRITE_INT_NUMBER, e);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Writes int to internal {@link java.io.OutputStream} in ISO format.\n", "     *\n", "     * @param value value to write.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeInteger(int value) {\n", "        try {\n", "            ByteUtils.getIsoBytes(value, numBuffer.reset());\n", "            write(numBuffer.getInternalBuffer(), numBuffer.capacity() - numBuffer.size(), numBuffer.size());\n", "            return (T) this;\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.CANNOT_WRITE_INT_NUMBER, e);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Writes float to internal {@link java.io.OutputStream} in ISO format.\n", "     *\n", "     * @param value value to write.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeFloat(float value) {\n", "        return writeFloat(value, localHighPrecision == null ? ByteUtils.HighPrecision : localHighPrecision);\n", "    }\n", "\n", "    /**\n", "     * Writes float to internal {@link java.io.OutputStream} in ISO format.\n", "     *\n", "     * @param value         value to write.\n", "     * @param highPrecision If true, float value will be written with high precision.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeFloat(float value, boolean highPrecision) {\n", "        return writeDouble(value, highPrecision);\n", "    }\n", "\n", "    /**\n", "     * Writes float array to internal {@link java.io.OutputStream} in ISO format.\n", "     *\n", "     * @param value float array to write.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeFloats(float[] value) {\n", "        for (int i = 0; i < value.length; i++) {\n", "            writeFloat(value[i]);\n", "            if (i < value.length - 1) {\n", "                writeSpace();\n", "            }\n", "        }\n", "        return (T) this;\n", "    }\n", "\n", "    /**\n", "     * Writes double to internal {@link java.io.OutputStream} in ISO format.\n", "     *\n", "     * @param value value to write.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeDouble(double value) {\n", "        return writeDouble(value, localHighPrecision == null ? ByteUtils.HighPrecision : localHighPrecision);\n", "    }\n", "\n", "    /**\n", "     * Writes double to internal {@link java.io.OutputStream} in ISO format.\n", "     *\n", "     * @param value         value to write.\n", "     * @param highPrecision If true, double value will be written with high precision.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeDouble(double value, boolean highPrecision) {\n", "        try {\n", "            ByteUtils.getIsoBytes(value, numBuffer.reset(), highPrecision);\n", "            write(numBuffer.getInternalBuffer(), numBuffer.capacity() - numBuffer.size(), numBuffer.size());\n", "            return (T) this;\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.CANNOT_WRITE_FLOAT_NUMBER, e);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Writes byte to internal {@link java.io.OutputStream}.\n", "     *\n", "     * @param value value to write.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeByte(int value) {\n", "        try {\n", "            write(value);\n", "            return (T) this;\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.CANNOT_WRITE_BYTE, e);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Writes space to internal {@link java.io.OutputStream}.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeSpace() {\n", "        return writeByte(' ');\n", "    }\n", "\n", "    /**\n", "     * Writes new line to internal {@link java.io.OutputStream}.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeNewLine() {\n", "        return writeByte('\\n');\n", "    }\n", "\n", "    /**\n", "     * Writes {@code String} to internal {@link java.io.OutputStream} in ISO format.\n", "     *\n", "     * @param value string to write.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     */\n", "    public T writeString(String value) {\n", "        return writeBytes(ByteUtils.getIsoBytes(value));\n", "    }\n", "\n", "    /**\n", "     * See {@link OutputStream#write(byte[])}.\n", "     *\n", "     * @param b byte array to write.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     *\n", "     * @throws com.itextpdf.io.exceptions.IOException if {@link java.io.IOException} is thrown.\n", "     */\n", "    public T writeBytes(byte[] b) {\n", "        try {\n", "            write(b);\n", "            return (T) this;\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.CANNOT_WRITE_BYTES, e);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * See {@link OutputStream#write(byte[], int, int)}.\n", "     *\n", "     * @param      b     the data to write.\n", "     * @param      off   the start offset in the data.\n", "     * @param      len   the number of bytes to write.\n", "     *\n", "     * @return this stream as passed generic stream.\n", "     *\n", "     * @throws com.itextpdf.io.exceptions.IOException if {@link java.io.IOException} is thrown.\n", "     */\n", "    public T writeBytes(byte[] b, int off, int len) {\n", "        try {\n", "            write(b, off, len);\n", "            return (T) this;\n", "        } catch (java.io.IOException e) {\n", "            throw new IOException(IoExceptionMessageConstant.CANNOT_WRITE_BYTES, e);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * Gets current output stream position.\n", "     *\n", "     * @return current output stream position.\n", "     */\n", "    public long getCurrentPos() {\n", "        return currentPos;\n", "    }\n", "\n", "    /**\n", "     * Gets internal {@link java.io.OutputStream}.\n", "     *\n", "     * @return internal {@link java.io.OutputStream}.\n", "     */\n", "    public java.io.OutputStream getOutputStream() {\n", "        return outputStream;\n", "    }\n", "\n", "    /**\n", "     * Returns true, if internal {@link java.io.OutputStream} have to be closed after {@link #close()} call,\n", "     * false otherwise.\n", "     *\n", "     * @return true if stream needs to be closed, false if it's done manually.\n", "     */\n", "    public boolean isCloseStream() {\n", "        return closeStream;\n", "    }\n", "\n", "    /**\n", "     * Sets internal {@link java.io.OutputStream} to be closed after {@link OutputStream#close()}.\n", "     *\n", "     * @param closeStream true if stream needs to be closed, false if it's done manually.\n", "     */\n", "    public void setCloseStream(boolean closeStream) {\n", "        this.closeStream = closeStream;\n", "    }\n", "\n", "    /**\n", "     * See {@link ByteArrayOutputStream#assignBytes(byte[], int)}.\n", "     *\n", "     * @param bytes bytes to assign.\n", "     * @param count number of bytes to assign.\n", "     */\n", "    public void assignBytes(byte[] bytes, int count) {\n", "        if (outputStream instanceof ByteArrayOutputStream) {\n", "            ((ByteArrayOutputStream) outputStream).assignBytes(bytes, count);\n", "            currentPos = count;\n", "        } else {\n", "            throw new IOException(IoExceptionMessageConstant.BYTES_CAN_BE_ASSIGNED_TO_BYTE_ARRAY_OUTPUT_STREAM_ONLY);\n", "        }\n", "    }\n", "\n", "    /**\n", "     * See {@link ByteArrayOutputStream#reset()}.\n", "     *\n", "     * @throws com.itextpdf.io.exceptions.IOException if internal {@link OutputStream}.\n", "     *                                     is not a {@link ByteArrayOutputStream} instance.\n", "     */\n", "    public void reset() {\n", "        if (outputStream instanceof ByteArrayOutputStream) {\n", "            ((ByteArrayOutputStream) outputStream).reset();\n", "            currentPos = 0;\n", "        } else {\n", "            throw new IOException(IoExceptionMessageConstant.BYTES_CAN_BE_RESET_IN_BYTE_ARRAY_OUTPUT_STREAM_ONLY);\n", "        }\n", "    }\n", "}\n"], "test_content": ["/*\n", "    This file is part of the iText (R) project.\n", "    Copyright (c) 1998-2024 Apryse Group NV\n", "    Authors: Apryse Software.\n", "\n", "    This program is offered under a commercial and under the AGPL license.\n", "    For commercial licensing, contact us at https://itextpdf.com/sales.  For AGPL licensing, see below.\n", "\n", "    AGPL licensing:\n", "    This program is free software: you can redistribute it and/or modify\n", "    it under the terms of the GNU Affero General Public License as published by\n", "    the Free Software Foundation, either version 3 of the License, or\n", "    (at your option) any later version.\n", "\n", "    This program is distributed in the hope that it will be useful,\n", "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n", "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n", "    GNU Affero General Public License for more details.\n", "\n", "    You should have received a copy of the GNU Affero General Public License\n", "    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n", " */\n", "package com.itextpdf.io.source;\n", "\n", "import com.itextpdf.io.logs.IoLogMessageConstant;\n", "import com.itextpdf.test.AssertUtil;\n", "import com.itextpdf.test.ExtendedITextTest;\n", "import com.itextpdf.test.annotations.LogMessage;\n", "import com.itextpdf.test.annotations.LogMessages;\n", "import com.itextpdf.test.annotations.type.UnitTest;\n", "\n", "import java.io.FileOutputStream;\n", "import java.nio.charset.StandardCharsets;\n", "import java.util.Objects;\n", "import org.junit.Assert;\n", "import org.junit.Test;\n", "import org.junit.experimental.categories.Category;\n", "\n", "import java.io.IOException;\n", "\n", "@Category(UnitTest.class)\n", "public class OutputStreamTest extends ExtendedITextTest {\n", "\n", "    private static final String SOURCE_FOLDER = \"./src/test/resources/com/itextpdf/io/source/OSTEST.txt\";\n", "    private static java.io.OutputStream IO_EXCEPTION_OUTPUT_STREAM;\n", "\n", "    static {\n", "        try {\n", "            IO_EXCEPTION_OUTPUT_STREAM = new FileOutputStream(SOURCE_FOLDER, true);\n", "            IO_EXCEPTION_OUTPUT_STREAM.close();\n", "        } catch (IOException e) {\n", "            //ignore\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void changePrecisionTest() throws IOException {\n", "        //the data is random\n", "        double expected = 0.100001d;\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes, false)) {\n", "            stream.setLocalHighPrecision(true);\n", "            stream.writeDouble(expected);\n", "            stream.flush();\n", "            Assert.assertEquals(Objects.toString(expected), new String(bytes.toByteArray(), StandardCharsets.UTF_8));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void changePrecisionToFalseTest() throws IOException {\n", "        //the data is random\n", "        double expected = 0.000002d;\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes, false)) {\n", "            stream.setLocalHighPrecision(false);\n", "            stream.writeDouble(expected);\n", "            stream.flush();\n", "            Assert.assertEquals(\"0\", new String(bytes.toByteArray(), StandardCharsets.UTF_8));\n", "        }\n", "    }\n", "\n", "    @LogMessages(messages = {\n", "            @LogMessage(messageTemplate = IoLogMessageConstant.ATTEMPT_PROCESS_NAN, count = 1)\n", "    })\n", "    @Test\n", "    public void writeNanTest() throws IOException {\n", "        //the data is random\n", "        String expected = \"0\";\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes)) {\n", "            stream.writeDouble(Double.NaN);\n", "            stream.flush();\n", "            Assert.assertEquals(expected, new String(bytes.toByteArray(), StandardCharsets.UTF_8));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void writeValidByteArrayTest() throws IOException {\n", "        //the data is random\n", "        byte[] expected = new byte[] {(byte) 68, (byte) 14, (byte) 173, (byte) 105};\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes)) {\n", "            stream.write(expected);\n", "            stream.flush();\n", "            Assert.assertArrayEquals(expected, bytes.toByteArray());\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void writeValidBytesArrayTest() throws IOException {\n", "        //the data is random\n", "        byte[] expected = new byte[] {(byte) 15, (byte) 233, (byte) 58, (byte) 97};\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes)) {\n", "            stream.writeBytes(expected);\n", "            stream.flush();\n", "            Assert.assertArrayEquals(expected, bytes.toByteArray());\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void writeSingleValidByteTest() throws IOException {\n", "        //the data is random\n", "        byte expected = (byte) 193;\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes)) {\n", "            stream.writeByte(expected);\n", "            stream.flush();\n", "            Assert.assertArrayEquals(new byte[] {expected}, bytes.toByteArray());\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void writeSingleValidIntegerTest() throws IOException {\n", "        //the data is random\n", "        int expected = 1695609641;\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes)) {\n", "            stream.writeInteger(expected);\n", "            stream.flush();\n", "            Assert.assertEquals(Objects.toString(expected), new String(bytes.toByteArray(), StandardCharsets.UTF_8));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void writeSingleValidLongTest() throws IOException {\n", "        //the data is random\n", "        long expected = 1695609641552L;\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes)) {\n", "            stream.writeLong(expected);\n", "            stream.flush();\n", "            Assert.assertEquals(Objects.toString(expected), new String(bytes.toByteArray(), StandardCharsets.UTF_8));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void writeValidFloatsArrayTest() throws IOException {\n", "        //the data is random\n", "        float[] expected = new float[] {12.05f, 0.001f};\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes)) {\n", "            stream.writeFloats(expected);\n", "            stream.flush();\n", "            Assert.assertEquals(expected[0] + \" \" + expected[1], new String(bytes.toByteArray(), StandardCharsets.UTF_8));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void writeValidBytesWithOffsetTest() throws IOException {\n", "        //the data is random\n", "        byte[] expected = new byte[] {(byte) 233, (byte) 58};\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes)) {\n", "            stream.writeBytes(new byte[] {(byte) 15, (byte) 233, (byte) 58, (byte) 97}, 1, 2);\n", "            stream.flush();\n", "            Assert.assertArrayEquals(expected, bytes.toByteArray());\n", "        }\n", "    }\n", "\n", "    @Test()\n", "    public void writeBytesIOExceptionTest() throws IOException {\n", "        //Testing that the exception is thrown, not using specific one because of .NET compatability\n", "        Assert.assertThrows(Exception.class,() -> {\n", "            byte[] bytesToWrite = new byte[] {(byte) 71};\n", "            try (java.io.OutputStream bytes = IO_EXCEPTION_OUTPUT_STREAM;\n", "                    OutputStream<ByteArrayOutputStream> stream\n", "                            = new OutputStream<>(bytes)) {\n", "                stream.writeBytes(bytesToWrite);\n", "            }\n", "        });\n", "    }\n", "\n", "    @Test()\n", "    public void writeByteIOExceptionTest() throws IOException {\n", "        //Testing that the exception is thrown, not using specific one because of .NET compatability\n", "        Assert.assertThrows(Exception.class,() -> {\n", "            byte byteToWrite = (byte) 71;\n", "            try (java.io.OutputStream bytes = IO_EXCEPTION_OUTPUT_STREAM;\n", "                    OutputStream<ByteArrayOutputStream> stream\n", "                            = new OutputStream<>(bytes)) {\n", "                stream.writeByte(byteToWrite);\n", "            }\n", "        });\n", "    }\n", "\n", "    @Test()\n", "    public void writeByteIntIOExceptionTest() throws IOException {\n", "        //Testing that the exception is thrown, not using specific one because of .NET compatability\n", "        Assert.assertThrows(Exception.class,() -> {\n", "            //the data is random\n", "            int byteToWrite = 71;\n", "            try (java.io.OutputStream bytes = IO_EXCEPTION_OUTPUT_STREAM;\n", "                    OutputStream<ByteArrayOutputStream> stream\n", "                            = new OutputStream<>(bytes)) {\n", "                stream.writeByte(byteToWrite);\n", "            }\n", "        });\n", "    }\n", "\n", "    @Test()\n", "    public void writeDoubleIOExceptionTest() throws IOException {\n", "        //Testing that the exception is thrown, not using specific one because of .NET compatability\n", "        Assert.assertThrows(Exception.class,() -> {\n", "            //the data is random\n", "            double num = 55.55d;\n", "            try (java.io.OutputStream bytes = IO_EXCEPTION_OUTPUT_STREAM;\n", "                    OutputStream<ByteArrayOutputStream> stream\n", "                            = new OutputStream<>(bytes)) {\n", "                stream.writeDouble(num);\n", "            }\n", "        });\n", "    }\n", "\n", "    @Test()\n", "    public void writeLongIOExceptionTest() throws IOException {\n", "        //Testing that the exception is thrown, not using specific one because of .NET compatability\n", "        Assert.assertThrows(Exception.class,() -> {\n", "            //the data is random\n", "            long num = 55L;\n", "            try (java.io.OutputStream bytes = IO_EXCEPTION_OUTPUT_STREAM;\n", "                    OutputStream<ByteArrayOutputStream> stream\n", "                            = new OutputStream<>(bytes)) {\n", "                stream.writeLong(num);\n", "            }\n", "        });\n", "    }\n", "\n", "    @Test\n", "    public void writeValidStringTest() throws IOException {\n", "        String expected = \"Test string to write\";\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes)) {\n", "            stream.writeString(expected);\n", "            stream.writeNewLine();\n", "            stream.flush();\n", "            Assert.assertEquals(expected + '\\n', new String(bytes.toByteArray(), StandardCharsets.UTF_8));\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void gettersAndSettersTest() throws IOException {\n", "        AssertUtil.doesNotThrow(() -> {\n", "            //testing that stream is not closed, if setCloseStream is false\n", "            OutputStream<java.io.OutputStream> stream\n", "                    = new OutputStream<>(null);\n", "            stream.setCloseStream(false);\n", "            stream.close();\n", "        });\n", "    }\n", "\n", "    @Test\n", "    public void assignBytesArrayTest() throws IOException {\n", "        //the data is random\n", "        byte[] expected = new byte[] {(byte) 15, (byte) 233, (byte) 58, (byte) 97};\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes)) {\n", "            stream.assignBytes(expected, 4);\n", "            Assert.assertArrayEquals(expected, bytes.toByteArray());\n", "        }\n", "    }\n", "\n", "    @Test\n", "    public void assignBytesExceptionTest() throws IOException {\n", "        //Testing that the exception is thrown, not using specific one because of .NET compatability\n", "        Assert.assertThrows(Exception.class,() -> {\n", "            //the data is random\n", "            byte[] bytes = new byte[] {(byte) 15, (byte) 233, (byte) 58, (byte) 97};\n", "            try (java.io.OutputStream outputStream = IO_EXCEPTION_OUTPUT_STREAM;\n", "                    OutputStream<ByteArrayOutputStream> stream\n", "                            = new OutputStream<>(outputStream)) {\n", "                stream.assignBytes(bytes, 4);\n", "            }\n", "        });\n", "    }\n", "\n", "    @Test\n", "    public void resetTestNoException() throws IOException {\n", "            AssertUtil.doesNotThrow(() -> {\n", "                try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                        OutputStream<ByteArrayOutputStream> stream\n", "                                = new OutputStream<>(bytes)) {\n", "                    stream.writeBytes(new byte[] {(byte) 15, (byte) 233, (byte) 58, (byte) 97});\n", "                    stream.flush();\n", "                    stream.reset();\n", "                }\n", "            });\n", "    }\n", "\n", "    @Test\n", "    public void resetExceptionTest() throws IOException {\n", "        //Testing that the exception is thrown, not using specific one because of .NET compatability\n", "        Assert.assertThrows(Exception.class,() -> {\n", "            try (java.io.OutputStream bytes = IO_EXCEPTION_OUTPUT_STREAM;\n", "                    OutputStream<ByteArrayOutputStream> stream\n", "                            = new OutputStream<>(bytes)) {\n", "                stream.reset();\n", "            }\n", "        });\n", "    }\n", "\n", "    @Test\n", "    public void localHighPrecisionOverridesGlobalTest() throws IOException {\n", "\n", "        boolean highPrecision = OutputStream.getHighPrecision();\n", "\n", "        //the data is random\n", "        double numberToWrite = 2.000002d;\n", "        try (ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n", "                OutputStream<ByteArrayOutputStream> stream\n", "                        = new OutputStream<>(bytes, false)) {\n", "            OutputStream.setHighPrecision(true);\n", "            stream.setLocalHighPrecision(false);\n", "            stream.writeDouble(numberToWrite);\n", "            stream.flush();\n", "            Assert.assertEquals(\"2\", new String(bytes.toByteArray(), StandardCharsets.UTF_8));\n", "        } finally {\n", "            OutputStream.setHighPrecision(highPrecision);\n", "        }\n", "    }\n", "}\n"], "method_lines_dic": {"OutputStream::::getHighPrecision()": [44, 46], "OutputStream::::setHighPrecision(boolean)": [54, 56], "OutputStream::::getLocalHighPrecision()": [63, 65], "OutputStream::::setLocalHighPrecision(boolean)": [74, 76], "OutputStream::::write(int)": [112, 116], "OutputStream::::write(byte[])": [118, 122], "OutputStream::::write(byte[],int,int)": [124, 128], "OutputStream::::writeByte(byte)": [137, 143], "OutputStream::::flush()": [145, 148], "OutputStream::::close()": [150, 155], "OutputStream::::writeLong(long)": [164, 172], "OutputStream::::writeInteger(int)": [181, 189], "OutputStream::::writeFloat(float)": [198, 200], "OutputStream::::writeFloat(float,boolean)": [210, 212], "OutputStream::::writeFloats(float[])": [221, 229], "OutputStream::::writeDouble(double)": [238, 240], "OutputStream::::writeDouble(double,boolean)": [250, 258], "OutputStream::::writeByte(int)": [267, 274], "OutputStream::::writeSpace()": [281, 283], "OutputStream::::writeNewLine()": [290, 292], "OutputStream::::writeString(java.lang.String)": [301, 303], "OutputStream::::writeBytes(byte[])": [314, 321], "OutputStream::::writeBytes(byte[],int,int)": [334, 341], "OutputStream::::getCurrentPos()": [348, 350], "OutputStream::::getOutputStream()": [357, 359], "OutputStream::::isCloseStream()": [367, 369], "OutputStream::::setCloseStream(boolean)": [376, 378], "OutputStream::::assignBytes(byte[],int)": [386, 393], "OutputStream::::reset()": [401, 408]}, "test_method_lines_dic": {"OutputStreamTest::::changePrecisionTest()": [56, 68], "OutputStreamTest::::changePrecisionToFalseTest()": [70, 82], "OutputStreamTest::::writeNanTest()": [84, 98], "OutputStreamTest::::writeValidByteArrayTest()": [100, 111], "OutputStreamTest::::writeValidBytesArrayTest()": [113, 124], "OutputStreamTest::::writeSingleValidByteTest()": [126, 137], "OutputStreamTest::::writeSingleValidIntegerTest()": [139, 150], "OutputStreamTest::::writeSingleValidLongTest()": [152, 163], "OutputStreamTest::::writeValidFloatsArrayTest()": [165, 176], "OutputStreamTest::::writeValidBytesWithOffsetTest()": [178, 189], "OutputStreamTest::::writeBytesIOExceptionTest()": [191, 202], "OutputStreamTest::::writeByteIOExceptionTest()": [204, 215], "OutputStreamTest::::writeByteIntIOExceptionTest()": [217, 229], "OutputStreamTest::::writeDoubleIOExceptionTest()": [231, 243], "OutputStreamTest::::writeLongIOExceptionTest()": [245, 257], "OutputStreamTest::::writeValidStringTest()": [259, 270], "OutputStreamTest::::gettersAndSettersTest()": [272, 281], "OutputStreamTest::::assignBytesArrayTest()": [283, 293], "OutputStreamTest::::assignBytesExceptionTest()": [295, 307], "OutputStreamTest::::resetTestNoException()": [309, 320], "OutputStreamTest::::resetExceptionTest()": [322, 332], "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()": [334, 352]}, "reverse_method_lines_dic": {"44": "OutputStream::::getHighPrecision()", "45": "OutputStream::::getHighPrecision()", "46": "OutputStream::::getHighPrecision()", "54": "OutputStream::::setHighPrecision(boolean)", "55": "OutputStream::::setHighPrecision(boolean)", "56": "OutputStream::::setHighPrecision(boolean)", "63": "OutputStream::::getLocalHighPrecision()", "64": "OutputStream::::getLocalHighPrecision()", "65": "OutputStream::::getLocalHighPrecision()", "74": "OutputStream::::setLocalHighPrecision(boolean)", "75": "OutputStream::::setLocalHighPrecision(boolean)", "76": "OutputStream::::setLocalHighPrecision(boolean)", "112": "OutputStream::::write(int)", "113": "OutputStream::::write(int)", "114": "OutputStream::::write(int)", "115": "OutputStream::::write(int)", "116": "OutputStream::::write(int)", "118": "OutputStream::::write(byte[])", "119": "OutputStream::::write(byte[])", "120": "OutputStream::::write(byte[])", "121": "OutputStream::::write(byte[])", "122": "OutputStream::::write(byte[])", "124": "OutputStream::::write(byte[],int,int)", "125": "OutputStream::::write(byte[],int,int)", "126": "OutputStream::::write(byte[],int,int)", "127": "OutputStream::::write(byte[],int,int)", "128": "OutputStream::::write(byte[],int,int)", "137": "OutputStream::::writeByte(byte)", "138": "OutputStream::::writeByte(byte)", "139": "OutputStream::::writeByte(byte)", "140": "OutputStream::::writeByte(byte)", "141": "OutputStream::::writeByte(byte)", "142": "OutputStream::::writeByte(byte)", "143": "OutputStream::::writeByte(byte)", "145": "OutputStream::::flush()", "146": "OutputStream::::flush()", "147": "OutputStream::::flush()", "148": "OutputStream::::flush()", "150": "OutputStream::::close()", "151": "OutputStream::::close()", "152": "OutputStream::::close()", "153": "OutputStream::::close()", "154": "OutputStream::::close()", "155": "OutputStream::::close()", "164": "OutputStream::::writeLong(long)", "165": "OutputStream::::writeLong(long)", "166": "OutputStream::::writeLong(long)", "167": "OutputStream::::writeLong(long)", "168": "OutputStream::::writeLong(long)", "169": "OutputStream::::writeLong(long)", "170": "OutputStream::::writeLong(long)", "171": "OutputStream::::writeLong(long)", "172": "OutputStream::::writeLong(long)", "181": "OutputStream::::writeInteger(int)", "182": "OutputStream::::writeInteger(int)", "183": "OutputStream::::writeInteger(int)", "184": "OutputStream::::writeInteger(int)", "185": "OutputStream::::writeInteger(int)", "186": "OutputStream::::writeInteger(int)", "187": "OutputStream::::writeInteger(int)", "188": "OutputStream::::writeInteger(int)", "189": "OutputStream::::writeInteger(int)", "198": "OutputStream::::writeFloat(float)", "199": "OutputStream::::writeFloat(float)", "200": "OutputStream::::writeFloat(float)", "210": "OutputStream::::writeFloat(float,boolean)", "211": "OutputStream::::writeFloat(float,boolean)", "212": "OutputStream::::writeFloat(float,boolean)", "221": "OutputStream::::writeFloats(float[])", "222": "OutputStream::::writeFloats(float[])", "223": "OutputStream::::writeFloats(float[])", "224": "OutputStream::::writeFloats(float[])", "225": "OutputStream::::writeFloats(float[])", "226": "OutputStream::::writeFloats(float[])", "227": "OutputStream::::writeFloats(float[])", "228": "OutputStream::::writeFloats(float[])", "229": "OutputStream::::writeFloats(float[])", "238": "OutputStream::::writeDouble(double)", "239": "OutputStream::::writeDouble(double)", "240": "OutputStream::::writeDouble(double)", "250": "OutputStream::::writeDouble(double,boolean)", "251": "OutputStream::::writeDouble(double,boolean)", "252": "OutputStream::::writeDouble(double,boolean)", "253": "OutputStream::::writeDouble(double,boolean)", "254": "OutputStream::::writeDouble(double,boolean)", "255": "OutputStream::::writeDouble(double,boolean)", "256": "OutputStream::::writeDouble(double,boolean)", "257": "OutputStream::::writeDouble(double,boolean)", "258": "OutputStream::::writeDouble(double,boolean)", "267": "OutputStream::::writeByte(int)", "268": "OutputStream::::writeByte(int)", "269": "OutputStream::::writeByte(int)", "270": "OutputStream::::writeByte(int)", "271": "OutputStream::::writeByte(int)", "272": "OutputStream::::writeByte(int)", "273": "OutputStream::::writeByte(int)", "274": "OutputStream::::writeByte(int)", "281": "OutputStream::::writeSpace()", "282": "OutputStream::::writeSpace()", "283": "OutputStream::::writeSpace()", "290": "OutputStream::::writeNewLine()", "291": "OutputStream::::writeNewLine()", "292": "OutputStream::::writeNewLine()", "301": "OutputStream::::writeString(java.lang.String)", "302": "OutputStream::::writeString(java.lang.String)", "303": "OutputStream::::writeString(java.lang.String)", "314": "OutputStream::::writeBytes(byte[])", "315": "OutputStream::::writeBytes(byte[])", "316": "OutputStream::::writeBytes(byte[])", "317": "OutputStream::::writeBytes(byte[])", "318": "OutputStream::::writeBytes(byte[])", "319": "OutputStream::::writeBytes(byte[])", "320": "OutputStream::::writeBytes(byte[])", "321": "OutputStream::::writeBytes(byte[])", "334": "OutputStream::::writeBytes(byte[],int,int)", "335": "OutputStream::::writeBytes(byte[],int,int)", "336": "OutputStream::::writeBytes(byte[],int,int)", "337": "OutputStream::::writeBytes(byte[],int,int)", "338": "OutputStream::::writeBytes(byte[],int,int)", "339": "OutputStream::::writeBytes(byte[],int,int)", "340": "OutputStream::::writeBytes(byte[],int,int)", "341": "OutputStream::::writeBytes(byte[],int,int)", "348": "OutputStream::::getCurrentPos()", "349": "OutputStream::::getCurrentPos()", "350": "OutputStream::::getCurrentPos()", "357": "OutputStream::::getOutputStream()", "358": "OutputStream::::getOutputStream()", "359": "OutputStream::::getOutputStream()", "367": "OutputStream::::isCloseStream()", "368": "OutputStream::::isCloseStream()", "369": "OutputStream::::isCloseStream()", "376": "OutputStream::::setCloseStream(boolean)", "377": "OutputStream::::setCloseStream(boolean)", "378": "OutputStream::::setCloseStream(boolean)", "386": "OutputStream::::assignBytes(byte[],int)", "387": "OutputStream::::assignBytes(byte[],int)", "388": "OutputStream::::assignBytes(byte[],int)", "389": "OutputStream::::assignBytes(byte[],int)", "390": "OutputStream::::assignBytes(byte[],int)", "391": "OutputStream::::assignBytes(byte[],int)", "392": "OutputStream::::assignBytes(byte[],int)", "393": "OutputStream::::assignBytes(byte[],int)", "401": "OutputStream::::reset()", "402": "OutputStream::::reset()", "403": "OutputStream::::reset()", "404": "OutputStream::::reset()", "405": "OutputStream::::reset()", "406": "OutputStream::::reset()", "407": "OutputStream::::reset()", "408": "OutputStream::::reset()"}, "test_reverse_method_lines_dic": {"56": "OutputStreamTest::::changePrecisionTest()", "57": "OutputStreamTest::::changePrecisionTest()", "58": "OutputStreamTest::::changePrecisionTest()", "59": "OutputStreamTest::::changePrecisionTest()", "60": "OutputStreamTest::::changePrecisionTest()", "61": "OutputStreamTest::::changePrecisionTest()", "62": "OutputStreamTest::::changePrecisionTest()", "63": "OutputStreamTest::::changePrecisionTest()", "64": "OutputStreamTest::::changePrecisionTest()", "65": "OutputStreamTest::::changePrecisionTest()", "66": "OutputStreamTest::::changePrecisionTest()", "67": "OutputStreamTest::::changePrecisionTest()", "68": "OutputStreamTest::::changePrecisionTest()", "70": "OutputStreamTest::::changePrecisionToFalseTest()", "71": "OutputStreamTest::::changePrecisionToFalseTest()", "72": "OutputStreamTest::::changePrecisionToFalseTest()", "73": "OutputStreamTest::::changePrecisionToFalseTest()", "74": "OutputStreamTest::::changePrecisionToFalseTest()", "75": "OutputStreamTest::::changePrecisionToFalseTest()", "76": "OutputStreamTest::::changePrecisionToFalseTest()", "77": "OutputStreamTest::::changePrecisionToFalseTest()", "78": "OutputStreamTest::::changePrecisionToFalseTest()", "79": "OutputStreamTest::::changePrecisionToFalseTest()", "80": "OutputStreamTest::::changePrecisionToFalseTest()", "81": "OutputStreamTest::::changePrecisionToFalseTest()", "82": "OutputStreamTest::::changePrecisionToFalseTest()", "84": "OutputStreamTest::::writeNanTest()", "85": "OutputStreamTest::::writeNanTest()", "86": "OutputStreamTest::::writeNanTest()", "87": "OutputStreamTest::::writeNanTest()", "88": "OutputStreamTest::::writeNanTest()", "89": "OutputStreamTest::::writeNanTest()", "90": "OutputStreamTest::::writeNanTest()", "91": "OutputStreamTest::::writeNanTest()", "92": "OutputStreamTest::::writeNanTest()", "93": "OutputStreamTest::::writeNanTest()", "94": "OutputStreamTest::::writeNanTest()", "95": "OutputStreamTest::::writeNanTest()", "96": "OutputStreamTest::::writeNanTest()", "97": "OutputStreamTest::::writeNanTest()", "98": "OutputStreamTest::::writeNanTest()", "100": "OutputStreamTest::::writeValidByteArrayTest()", "101": "OutputStreamTest::::writeValidByteArrayTest()", "102": "OutputStreamTest::::writeValidByteArrayTest()", "103": "OutputStreamTest::::writeValidByteArrayTest()", "104": "OutputStreamTest::::writeValidByteArrayTest()", "105": "OutputStreamTest::::writeValidByteArrayTest()", "106": "OutputStreamTest::::writeValidByteArrayTest()", "107": "OutputStreamTest::::writeValidByteArrayTest()", "108": "OutputStreamTest::::writeValidByteArrayTest()", "109": "OutputStreamTest::::writeValidByteArrayTest()", "110": "OutputStreamTest::::writeValidByteArrayTest()", "111": "OutputStreamTest::::writeValidByteArrayTest()", "113": "OutputStreamTest::::writeValidBytesArrayTest()", "114": "OutputStreamTest::::writeValidBytesArrayTest()", "115": "OutputStreamTest::::writeValidBytesArrayTest()", "116": "OutputStreamTest::::writeValidBytesArrayTest()", "117": "OutputStreamTest::::writeValidBytesArrayTest()", "118": "OutputStreamTest::::writeValidBytesArrayTest()", "119": "OutputStreamTest::::writeValidBytesArrayTest()", "120": "OutputStreamTest::::writeValidBytesArrayTest()", "121": "OutputStreamTest::::writeValidBytesArrayTest()", "122": "OutputStreamTest::::writeValidBytesArrayTest()", "123": "OutputStreamTest::::writeValidBytesArrayTest()", "124": "OutputStreamTest::::writeValidBytesArrayTest()", "126": "OutputStreamTest::::writeSingleValidByteTest()", "127": "OutputStreamTest::::writeSingleValidByteTest()", "128": "OutputStreamTest::::writeSingleValidByteTest()", "129": "OutputStreamTest::::writeSingleValidByteTest()", "130": "OutputStreamTest::::writeSingleValidByteTest()", "131": "OutputStreamTest::::writeSingleValidByteTest()", "132": "OutputStreamTest::::writeSingleValidByteTest()", "133": "OutputStreamTest::::writeSingleValidByteTest()", "134": "OutputStreamTest::::writeSingleValidByteTest()", "135": "OutputStreamTest::::writeSingleValidByteTest()", "136": "OutputStreamTest::::writeSingleValidByteTest()", "137": "OutputStreamTest::::writeSingleValidByteTest()", "139": "OutputStreamTest::::writeSingleValidIntegerTest()", "140": "OutputStreamTest::::writeSingleValidIntegerTest()", "141": "OutputStreamTest::::writeSingleValidIntegerTest()", "142": "OutputStreamTest::::writeSingleValidIntegerTest()", "143": "OutputStreamTest::::writeSingleValidIntegerTest()", "144": "OutputStreamTest::::writeSingleValidIntegerTest()", "145": "OutputStreamTest::::writeSingleValidIntegerTest()", "146": "OutputStreamTest::::writeSingleValidIntegerTest()", "147": "OutputStreamTest::::writeSingleValidIntegerTest()", "148": "OutputStreamTest::::writeSingleValidIntegerTest()", "149": "OutputStreamTest::::writeSingleValidIntegerTest()", "150": "OutputStreamTest::::writeSingleValidIntegerTest()", "152": "OutputStreamTest::::writeSingleValidLongTest()", "153": "OutputStreamTest::::writeSingleValidLongTest()", "154": "OutputStreamTest::::writeSingleValidLongTest()", "155": "OutputStreamTest::::writeSingleValidLongTest()", "156": "OutputStreamTest::::writeSingleValidLongTest()", "157": "OutputStreamTest::::writeSingleValidLongTest()", "158": "OutputStreamTest::::writeSingleValidLongTest()", "159": "OutputStreamTest::::writeSingleValidLongTest()", "160": "OutputStreamTest::::writeSingleValidLongTest()", "161": "OutputStreamTest::::writeSingleValidLongTest()", "162": "OutputStreamTest::::writeSingleValidLongTest()", "163": "OutputStreamTest::::writeSingleValidLongTest()", "165": "OutputStreamTest::::writeValidFloatsArrayTest()", "166": "OutputStreamTest::::writeValidFloatsArrayTest()", "167": "OutputStreamTest::::writeValidFloatsArrayTest()", "168": "OutputStreamTest::::writeValidFloatsArrayTest()", "169": "OutputStreamTest::::writeValidFloatsArrayTest()", "170": "OutputStreamTest::::writeValidFloatsArrayTest()", "171": "OutputStreamTest::::writeValidFloatsArrayTest()", "172": "OutputStreamTest::::writeValidFloatsArrayTest()", "173": "OutputStreamTest::::writeValidFloatsArrayTest()", "174": "OutputStreamTest::::writeValidFloatsArrayTest()", "175": "OutputStreamTest::::writeValidFloatsArrayTest()", "176": "OutputStreamTest::::writeValidFloatsArrayTest()", "178": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "179": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "180": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "181": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "182": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "183": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "184": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "185": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "186": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "187": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "188": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "189": "OutputStreamTest::::writeValidBytesWithOffsetTest()", "191": "OutputStreamTest::::writeBytesIOExceptionTest()", "192": "OutputStreamTest::::writeBytesIOExceptionTest()", "193": "OutputStreamTest::::writeBytesIOExceptionTest()", "194": "OutputStreamTest::::writeBytesIOExceptionTest()", "195": "OutputStreamTest::::writeBytesIOExceptionTest()", "196": "OutputStreamTest::::writeBytesIOExceptionTest()", "197": "OutputStreamTest::::writeBytesIOExceptionTest()", "198": "OutputStreamTest::::writeBytesIOExceptionTest()", "199": "OutputStreamTest::::writeBytesIOExceptionTest()", "200": "OutputStreamTest::::writeBytesIOExceptionTest()", "201": "OutputStreamTest::::writeBytesIOExceptionTest()", "202": "OutputStreamTest::::writeBytesIOExceptionTest()", "204": "OutputStreamTest::::writeByteIOExceptionTest()", "205": "OutputStreamTest::::writeByteIOExceptionTest()", "206": "OutputStreamTest::::writeByteIOExceptionTest()", "207": "OutputStreamTest::::writeByteIOExceptionTest()", "208": "OutputStreamTest::::writeByteIOExceptionTest()", "209": "OutputStreamTest::::writeByteIOExceptionTest()", "210": "OutputStreamTest::::writeByteIOExceptionTest()", "211": "OutputStreamTest::::writeByteIOExceptionTest()", "212": "OutputStreamTest::::writeByteIOExceptionTest()", "213": "OutputStreamTest::::writeByteIOExceptionTest()", "214": "OutputStreamTest::::writeByteIOExceptionTest()", "215": "OutputStreamTest::::writeByteIOExceptionTest()", "217": "OutputStreamTest::::writeByteIntIOExceptionTest()", "218": "OutputStreamTest::::writeByteIntIOExceptionTest()", "219": "OutputStreamTest::::writeByteIntIOExceptionTest()", "220": "OutputStreamTest::::writeByteIntIOExceptionTest()", "221": "OutputStreamTest::::writeByteIntIOExceptionTest()", "222": "OutputStreamTest::::writeByteIntIOExceptionTest()", "223": "OutputStreamTest::::writeByteIntIOExceptionTest()", "224": "OutputStreamTest::::writeByteIntIOExceptionTest()", "225": "OutputStreamTest::::writeByteIntIOExceptionTest()", "226": "OutputStreamTest::::writeByteIntIOExceptionTest()", "227": "OutputStreamTest::::writeByteIntIOExceptionTest()", "228": "OutputStreamTest::::writeByteIntIOExceptionTest()", "229": "OutputStreamTest::::writeByteIntIOExceptionTest()", "231": "OutputStreamTest::::writeDoubleIOExceptionTest()", "232": "OutputStreamTest::::writeDoubleIOExceptionTest()", "233": "OutputStreamTest::::writeDoubleIOExceptionTest()", "234": "OutputStreamTest::::writeDoubleIOExceptionTest()", "235": "OutputStreamTest::::writeDoubleIOExceptionTest()", "236": "OutputStreamTest::::writeDoubleIOExceptionTest()", "237": "OutputStreamTest::::writeDoubleIOExceptionTest()", "238": "OutputStreamTest::::writeDoubleIOExceptionTest()", "239": "OutputStreamTest::::writeDoubleIOExceptionTest()", "240": "OutputStreamTest::::writeDoubleIOExceptionTest()", "241": "OutputStreamTest::::writeDoubleIOExceptionTest()", "242": "OutputStreamTest::::writeDoubleIOExceptionTest()", "243": "OutputStreamTest::::writeDoubleIOExceptionTest()", "245": "OutputStreamTest::::writeLongIOExceptionTest()", "246": "OutputStreamTest::::writeLongIOExceptionTest()", "247": "OutputStreamTest::::writeLongIOExceptionTest()", "248": "OutputStreamTest::::writeLongIOExceptionTest()", "249": "OutputStreamTest::::writeLongIOExceptionTest()", "250": "OutputStreamTest::::writeLongIOExceptionTest()", "251": "OutputStreamTest::::writeLongIOExceptionTest()", "252": "OutputStreamTest::::writeLongIOExceptionTest()", "253": "OutputStreamTest::::writeLongIOExceptionTest()", "254": "OutputStreamTest::::writeLongIOExceptionTest()", "255": "OutputStreamTest::::writeLongIOExceptionTest()", "256": "OutputStreamTest::::writeLongIOExceptionTest()", "257": "OutputStreamTest::::writeLongIOExceptionTest()", "259": "OutputStreamTest::::writeValidStringTest()", "260": "OutputStreamTest::::writeValidStringTest()", "261": "OutputStreamTest::::writeValidStringTest()", "262": "OutputStreamTest::::writeValidStringTest()", "263": "OutputStreamTest::::writeValidStringTest()", "264": "OutputStreamTest::::writeValidStringTest()", "265": "OutputStreamTest::::writeValidStringTest()", "266": "OutputStreamTest::::writeValidStringTest()", "267": "OutputStreamTest::::writeValidStringTest()", "268": "OutputStreamTest::::writeValidStringTest()", "269": "OutputStreamTest::::writeValidStringTest()", "270": "OutputStreamTest::::writeValidStringTest()", "272": "OutputStreamTest::::gettersAndSettersTest()", "273": "OutputStreamTest::::gettersAndSettersTest()", "274": "OutputStreamTest::::gettersAndSettersTest()", "275": "OutputStreamTest::::gettersAndSettersTest()", "276": "OutputStreamTest::::gettersAndSettersTest()", "277": "OutputStreamTest::::gettersAndSettersTest()", "278": "OutputStreamTest::::gettersAndSettersTest()", "279": "OutputStreamTest::::gettersAndSettersTest()", "280": "OutputStreamTest::::gettersAndSettersTest()", "281": "OutputStreamTest::::gettersAndSettersTest()", "283": "OutputStreamTest::::assignBytesArrayTest()", "284": "OutputStreamTest::::assignBytesArrayTest()", "285": "OutputStreamTest::::assignBytesArrayTest()", "286": "OutputStreamTest::::assignBytesArrayTest()", "287": "OutputStreamTest::::assignBytesArrayTest()", "288": "OutputStreamTest::::assignBytesArrayTest()", "289": "OutputStreamTest::::assignBytesArrayTest()", "290": "OutputStreamTest::::assignBytesArrayTest()", "291": "OutputStreamTest::::assignBytesArrayTest()", "292": "OutputStreamTest::::assignBytesArrayTest()", "293": "OutputStreamTest::::assignBytesArrayTest()", "295": "OutputStreamTest::::assignBytesExceptionTest()", "296": "OutputStreamTest::::assignBytesExceptionTest()", "297": "OutputStreamTest::::assignBytesExceptionTest()", "298": "OutputStreamTest::::assignBytesExceptionTest()", "299": "OutputStreamTest::::assignBytesExceptionTest()", "300": "OutputStreamTest::::assignBytesExceptionTest()", "301": "OutputStreamTest::::assignBytesExceptionTest()", "302": "OutputStreamTest::::assignBytesExceptionTest()", "303": "OutputStreamTest::::assignBytesExceptionTest()", "304": "OutputStreamTest::::assignBytesExceptionTest()", "305": "OutputStreamTest::::assignBytesExceptionTest()", "306": "OutputStreamTest::::assignBytesExceptionTest()", "307": "OutputStreamTest::::assignBytesExceptionTest()", "309": "OutputStreamTest::::resetTestNoException()", "310": "OutputStreamTest::::resetTestNoException()", "311": "OutputStreamTest::::resetTestNoException()", "312": "OutputStreamTest::::resetTestNoException()", "313": "OutputStreamTest::::resetTestNoException()", "314": "OutputStreamTest::::resetTestNoException()", "315": "OutputStreamTest::::resetTestNoException()", "316": "OutputStreamTest::::resetTestNoException()", "317": "OutputStreamTest::::resetTestNoException()", "318": "OutputStreamTest::::resetTestNoException()", "319": "OutputStreamTest::::resetTestNoException()", "320": "OutputStreamTest::::resetTestNoException()", "322": "OutputStreamTest::::resetExceptionTest()", "323": "OutputStreamTest::::resetExceptionTest()", "324": "OutputStreamTest::::resetExceptionTest()", "325": "OutputStreamTest::::resetExceptionTest()", "326": "OutputStreamTest::::resetExceptionTest()", "327": "OutputStreamTest::::resetExceptionTest()", "328": "OutputStreamTest::::resetExceptionTest()", "329": "OutputStreamTest::::resetExceptionTest()", "330": "OutputStreamTest::::resetExceptionTest()", "331": "OutputStreamTest::::resetExceptionTest()", "332": "OutputStreamTest::::resetExceptionTest()", "334": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "335": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "336": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "337": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "338": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "339": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "340": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "341": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "342": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "343": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "344": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "345": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "346": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "347": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "348": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "349": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "350": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "351": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()", "352": "OutputStreamTest::::localHighPrecisionOverridesGlobalTest()"}, "tests": [{"test_lines": [56, 68], "covered_lines": [33, 35, 36, 37, 75, 76, 107, 108, 109, 110, 126, 127, 128, 147, 148, 152, 153, 155, 239, 252, 253, 254]}, {"test_lines": [70, 82], "covered_lines": [33, 35, 36, 37, 75, 76, 107, 108, 109, 110, 126, 127, 128, 147, 148, 152, 153, 155, 239, 252, 253, 254]}, {"test_lines": [84, 98], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 126, 127, 128, 147, 148, 152, 153, 155, 239, 252, 253, 254]}, {"test_lines": [100, 111], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 120, 121, 122, 147, 148, 152, 153, 155]}, {"test_lines": [113, 124], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 120, 121, 122, 147, 148, 152, 153, 155, 316, 317]}, {"test_lines": [126, 137], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 114, 115, 116, 139, 142, 143, 147, 148, 152, 153, 155]}, {"test_lines": [139, 150], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 126, 127, 128, 147, 148, 152, 153, 155, 183, 184, 185]}, {"test_lines": [152, 163], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 126, 127, 128, 147, 148, 152, 153, 155, 166, 167, 168]}, {"test_lines": [165, 176], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 114, 115, 116, 126, 127, 128, 147, 148, 152, 153, 155, 199, 211, 222, 223, 224, 225, 228, 252, 253, 254, 269, 270, 282]}, {"test_lines": [178, 189], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 126, 127, 128, 147, 148, 152, 153, 155, 336, 337]}, {"test_lines": [191, 202], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 152, 153, 155, 318, 319]}, {"test_lines": [204, 215], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 140, 141, 152, 153, 155]}, {"test_lines": [217, 229], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 152, 153, 155, 271, 272]}, {"test_lines": [231, 243], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 152, 153, 155, 239, 252, 255, 256]}, {"test_lines": [245, 257], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 152, 153, 155, 166, 169, 170]}, {"test_lines": [259, 270], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 114, 115, 116, 120, 121, 122, 147, 148, 152, 153, 155, 269, 270, 291, 302, 316, 317]}, {"test_lines": [272, 281], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 152, 155, 377, 378]}, {"test_lines": [283, 293], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 152, 153, 155, 387, 388, 389, 393]}, {"test_lines": [295, 307], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 152, 153, 155, 387, 391]}, {"test_lines": [309, 320], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 120, 121, 122, 147, 148, 152, 153, 155, 316, 317, 402, 403, 404, 408]}, {"test_lines": [322, 332], "covered_lines": [33, 35, 36, 37, 85, 86, 87, 152, 153, 155, 402, 406]}, {"test_lines": [334, 352], "covered_lines": [33, 35, 36, 37, 45, 55, 56, 75, 76, 107, 108, 109, 110, 126, 127, 128, 147, 148, 152, 153, 155, 239, 252, 253, 254]}]}}