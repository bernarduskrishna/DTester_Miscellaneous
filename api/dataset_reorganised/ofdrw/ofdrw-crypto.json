{"/bernard/dataset_construction/prep/repos/ofdrw/ofdrw-crypto/src/main/java/org/ofdrw/crypto/OFDEncryptor.java":{"class_content":["package org.ofdrw.crypto;\n","\n","import org.apache.commons.io.FileUtils;\n","import org.bouncycastle.crypto.CipherParameters;\n","import org.bouncycastle.crypto.CryptoException;\n","import org.bouncycastle.crypto.InvalidCipherTextException;\n","import org.bouncycastle.crypto.engines.SM4Engine;\n","import org.bouncycastle.crypto.modes.CBCBlockCipher;\n","import org.bouncycastle.crypto.paddings.PKCS7Padding;\n","import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\n","import org.bouncycastle.crypto.params.KeyParameter;\n","import org.bouncycastle.crypto.params.ParametersWithIV;\n","import org.dom4j.Element;\n","import org.jetbrains.annotations.NotNull;\n","import org.jetbrains.annotations.Nullable;\n","import org.ofdrw.core.crypto.ProtectionCaseID;\n","import org.ofdrw.core.crypto.encryt.*;\n","import org.ofdrw.core.signatures.sig.Parameters;\n","import org.ofdrw.crypto.enryptor.UserFEKEncryptor;\n","import org.ofdrw.gv.GlobalVar;\n","import org.ofdrw.pkg.container.OFDDir;\n","import org.ofdrw.pkg.tool.ElemCup;\n","import org.ofdrw.reader.ZipUtil;\n","\n","import java.io.*;\n","import java.nio.file.Files;\n","import java.nio.file.Path;\n","import java.security.GeneralSecurityException;\n","import java.security.SecureRandom;\n","import java.time.LocalDateTime;\n","import java.util.ArrayList;\n","import java.util.List;\n","import java.util.stream.Collectors;\n","\n","/**\n"," * OFD加密器\n"," *\n"," * @author 权观宇\n"," * @since 2021-07-13 18:10:12\n"," */\n","public class OFDEncryptor implements Closeable {\n","\n","\n","    /**\n","     * OFD虚拟容器根目录\n","     */\n","    private final OFDDir ofdDir;\n","\n","    /**\n","     * 加密后文件输出位置\n","     */\n","    private Path dest;\n","\n","    /**\n","     * 工作过程中的工作目录\n","     * <p>\n","     * 用于存放解压后的OFD文档容器内容\n","     */\n","    private Path workDir;\n","\n","    /**\n","     * 是否已经关闭\n","     */\n","    private boolean closed;\n","\n","    /**\n","     * 随机源\n","     * <p>\n","     * 默认使用软件随机源\n","     */\n","    private SecureRandom random;\n","\n","    /**\n","     * CBC模式分块加密，填充模式PKCS#7\n","     */\n","    private PaddedBufferedBlockCipher blockCipher;\n","\n","    /**\n","     * 用户提供的加密器列表\n","     */\n","    private List<UserFEKEncryptor> userEncryptorList;\n","\n","    /**\n","     * 容器文件过滤器\n","     * <p>\n","     * 用于判断文件是否需要被加密，返回false表示不需要加密\n","     */\n","    private ContainerFileFilter cfFilter;\n","\n","    /**\n","     * 加密操作的附加描述集合\n","     */\n","    private Parameters parameters;\n","\n","    private OFDEncryptor() {\n","        this.ofdDir = null;\n","    }\n","\n","    /**\n","     * 创建OFD加密器\n","     *\n","     * @param ofdFile 待加密的OFD文件路径\n","     * @param dest    加密后的OFD路径\n","     * @throws IOException IO操作异常\n","     */\n","    public OFDEncryptor(@NotNull Path ofdFile, @NotNull Path dest) throws IOException {\n","        if (ofdFile == null || Files.notExists(ofdFile)) {\n","            throw new IllegalArgumentException(\"文件位置(ofdFile)不正确\");\n","        }\n","        if (dest == null) {\n","            throw new IllegalArgumentException(\"加密后文件位置(out)为空\");\n","        }\n","        this.dest = dest;\n","        this.workDir = Files.createTempDirectory(\"ofd-tmp-\");\n","        // 解压文档，到临时的工作目录\n","        ZipUtil.unZipFiles(ofdFile.toFile(), this.workDir.toAbsolutePath() + File.separator);\n","        this.userEncryptorList = new ArrayList<>(3);\n","        this.ofdDir = new OFDDir(workDir.toAbsolutePath());\n","        this.random = new SecureRandom();\n","        this.blockCipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new SM4Engine()), new PKCS7Padding());\n","    }\n","\n","    /**\n","     * 添加加密用户\n","     *\n","     * @param encryptor 加密用户的加密器\n","     * @return this\n","     */\n","    public OFDEncryptor addUser(@NotNull UserFEKEncryptor encryptor) {\n","        if (encryptor == null) {\n","            return this;\n","        }\n","        this.userEncryptorList.add(encryptor);\n","        return this;\n","    }\n","\n","    /**\n","     * 设置随机源\n","     *\n","     * @param random 随机源\n","     * @return this\n","     */\n","    public OFDEncryptor setRandom(@NotNull SecureRandom random) {\n","        if (random == null) {\n","            return this;\n","        }\n","        this.random = random;\n","        return this;\n","    }\n","\n","    /**\n","     * 设置 容器文件过滤器\n","     * <p>\n","     * 该过滤器用于决定哪些文件将会被加密\n","     * <p>\n","     * 过滤器结果为false 那么该文件将不会被加密\n","     *\n","     * @param filter 过滤器\n","     * @return this\n","     */\n","    public OFDEncryptor setContainerFileFilter(ContainerFileFilter filter) {\n","        if (filter == null) {\n","            return this;\n","        }\n","        this.cfFilter = filter;\n","        return this;\n","    }\n","\n","    /**\n","     * 执行加密\n","     *\n","     * @return this\n","     * @throws IOException              加密\n","     * @throws CryptoException          加密异常\n","     * @throws GeneralSecurityException 证书解析异常\n","     */\n","    public OFDEncryptor encrypt() throws IOException, CryptoException, GeneralSecurityException {\n","        if (this.userEncryptorList.isEmpty()) {\n","            throw new IllegalArgumentException(\"没有可用加密用户(UserFEKEncryptor)\");\n","        }\n","        if (!Files.exists(this.dest)) {\n","            Files.createDirectories(this.dest.getParent());\n","        }\n","        // 获取 解密入口文件对象。\n","        final Encryptions encryptions = this.ofdDir.obtainEncryptions();\n","        // 获取新的加密标识符：内最大 加密标识符 + 1\n","        final String id = Integer.toString(encryptions.maxID() + 1);\n","\n","        // 待加密文件列表\n","        final List<ContainerPath> tbEncArr = this.getToBeEncFiles();\n","        // 加密块大小\n","        int blockSize = blockCipher.getBlockSize();\n","        byte[] fek = new byte[blockSize];\n","        byte[] iv = new byte[blockSize];\n","        // a) 生成用于ZIP包内文件加密的对称密钥\n","        random.nextBytes(fek);\n","        random.nextBytes(iv);\n","        ParametersWithIV keyParam = new ParametersWithIV(new KeyParameter(fek), iv);\n","\n","        // b) 根据加密方案，使用步骤 a)生成的文件加密对称密钥调用对称密码算法加密包内文件并写入ZIP包内；\n","        // c) 根据加密方案，对已经生成密文的明文文件进行处理，部分写入ZIP包；\n","        final EncryptEntries encryptEntries = this.encryptFiles(tbEncArr, keyParam);\n","        encryptEntries.setID(id);\n","        // d) 组装明密文映射表文件，根据加密方案对齐进行加密后或直接写入ZIP包。\n","        final ContainerPath entriesMapCp = encryptElement(encryptEntries, \"entriesmap.dat\", keyParam);\n","        // e) 组装加密入口文件，明文写入ZIP包内\n","        CT_EncryptInfo encryptInfo = newEncryptInfo(id);\n","        encryptions.addEncryptInfo(encryptInfo);\n","        encryptInfo.setEncryptScope(\"All\");\n","        // 密钥描述文件位置配置\n","        final ContainerPath decryptseedCp = ContainerPath.newDatFile(\"decryptseed\", this.workDir.toAbsolutePath());\n","        encryptInfo.setDecryptSeedLoc(decryptseedCp.getPath());\n","        // 明密文映射表或其加密后的文件存储的路径\n","        encryptInfo.setEntriesMapLoc(entriesMapCp.getPath());\n","        // 创建密钥描述文件\n","        DecyptSeed decyptSeedObj = new DecyptSeed()\n","                .setID(id)\n","                .setExtendParams(new ExtendParams());\n","        // f) 根据加密方案，对文件加密对称密钥进行密钥包装或非对称加密生成文件对称加密的包装密钥；\n","        String encryptCaseId = null;\n","        for (UserFEKEncryptor fekEncryptor : userEncryptorList) {\n","            if (encryptCaseId == null) {\n","                encryptCaseId = fekEncryptor.encryptCaseId();\n","            }\n","            // 加密 文件加密对称密钥，生成\n","            final UserInfo userInfo = fekEncryptor.encrypt(fek, iv);\n","\n","            // 如果是证书加密，需要获取证书\n","            if (ProtectionCaseID.EncryptGMCert.getId().equals(fekEncryptor.encryptCaseId())) {\n","                // 证书加密使用的证书\n","                final byte[] certBin = fekEncryptor.userCert();\n","                if (certBin == null || certBin.length == 0) {\n","                    throw new CryptoException(\"无法获取加密证书\");\n","                }\n","                userInfo.setUserCert(certBin);\n","            }\n","            decyptSeedObj.addUserInfo(userInfo);\n","            // g) 如果电子文件访问者为多人，则重复 7.3.4 的步骤 e)；\n","        }\n","        // h) 组装密钥描述文件，并写入ZIP包。\n","        ElemCup.dump(decyptSeedObj, decryptseedCp.getAbs());\n","\n","        // 执行打包程序\n","        this.ofdDir.jar(dest);\n","        return this;\n","    }\n","\n","    /**\n","     * 创建 加密描述信息\n","     *\n","     * @param id 加密操作标识\n","     * @return 加密描述信息\n","     */\n","    private CT_EncryptInfo newEncryptInfo(String id) {\n","        CT_EncryptInfo encryptInfo = new CT_EncryptInfo().setID(id);\n","        if (this.parameters != null) {\n","            // 设置 加密操作的附加描述集合\n","            encryptInfo.setParameters(this.parameters);\n","        }\n","\n","        // 设置提供者信息\n","        final Provider provider = new Provider();\n","        provider.setCompany(\"ofdrw.org\")\n","                .setProviderName(\"ofdrw-crypto\")\n","                .setVersion(GlobalVar.Version);\n","        encryptInfo.setProvider(provider);\n","        // 设置加密时间\n","        encryptInfo.setEncryptDate(LocalDateTime.now());\n","\n","        return encryptInfo;\n","    }\n","\n","\n","    /**\n","     * 获取待加密文件列表\n","     * <p>\n","     * 执行过滤器过滤文件\n","     *\n","     * @return 待加密文件列表\n","     * @throws IOException IO读写异常\n","     */\n","    private List<ContainerPath> getToBeEncFiles() throws IOException {\n","        return Files.walk(this.workDir)\n","                // 移除目录文件\n","                .filter(Files::isRegularFile)\n","                // 通过过滤器过滤加密得到文件\n","                .map((path) -> {\n","                    String cfPath = path.toAbsolutePath().toString()\n","                            .replace(this.workDir.toAbsolutePath().toString(), \"\")\n","                            .replace(\"\\\\\", \"/\");\n","                    return new ContainerPath(cfPath, path);\n","                })\n","                .filter((cf) -> {\n","                    if (this.cfFilter == null) {\n","                        return true;\n","                    }\n","                    // 过滤\n","                    return this.cfFilter.filter(cf.getPath(), cf.getAbs());\n","                }).collect(Collectors.toList());\n","    }\n","\n","    /**\n","     * 加密文件\n","     *\n","     * @param tbEncArr 待加密文件列表\n","     * @param keyParam 加密密钥参数\n","     * @return 明密文映射表\n","     * @throws IOException                文件读写异常\n","     * @throws InvalidCipherTextException 加密过程中异常\n","     */\n","    private EncryptEntries encryptFiles(List<ContainerPath> tbEncArr, ParametersWithIV keyParam) throws IOException, InvalidCipherTextException {\n","        // 创建明密文映射表\n","        EncryptEntries entriesMap = new EncryptEntries();\n","        for (ContainerPath plaintextCp : tbEncArr) {\n","            // 根据加密方案，使用步骤 a)生成的文件加密对称密钥调用对称密码算法加密包内文件并写入ZIP包内\n","            // 并且对已经生成密文的明文文件进行删除；\n","            final ContainerPath encryptedCp = encryptFile(plaintextCp, keyParam);\n","            // 添加明密文映射表的映射关系\n","            entriesMap.addEncryptEntry(plaintextCp.getPath(), encryptedCp.getPath());\n","        }\n","        return entriesMap;\n","    }\n","\n","    /**\n","     * 加密单个文件\n","     * <p>\n","     * 加密后原文件将被删除\n","     *\n","     * @param plaintextCp 待加密容器内文件\n","     * @param keyParam    加密密钥\n","     * @return 加密后文件在容器内的位置\n","     * @throws IOException                文件读写异常\n","     * @throws InvalidCipherTextException 加密运算异常\n","     */\n","    private ContainerPath encryptFile(ContainerPath plaintextCp, CipherParameters keyParam) throws IOException, InvalidCipherTextException {\n","        int bytesProcessed = 0;\n","        int len = 0;\n","        byte[] buffIn = new byte[4096];\n","        byte[] buffOut = new byte[4096 + this.blockCipher.getBlockSize()];\n","        // 创建加密后的文件\n","        final ContainerPath encryptedCp = plaintextCp.createEncryptedFile();\n","        try (InputStream in = Files.newInputStream(plaintextCp.getAbs());\n","             OutputStream out = Files.newOutputStream(encryptedCp.getAbs())) {\n","            this.blockCipher.init(true, keyParam);\n","            while ((len = in.read(buffIn)) != -1) {\n","                // 分块加密\n","                bytesProcessed = this.blockCipher.processBytes(buffIn, 0, len, buffOut, 0);\n","                if (bytesProcessed > 0) {\n","                    out.write(buffOut, 0, bytesProcessed);\n","                }\n","            }\n","            // 执行最后一个分块的加密和填充\n","            bytesProcessed = this.blockCipher.doFinal(buffOut, 0);\n","            out.write(buffOut, 0, bytesProcessed);\n","            this.blockCipher.reset();\n","        }\n","        // 加密完成后，删除源文件\n","        Files.delete(plaintextCp.getAbs());\n","        return encryptedCp;\n","    }\n","\n","    /**\n","     * 加密OFD对象\n","     *\n","     * @param obj      OFD对象\n","     * @param outPath  加密后存放路径，容器内路径\n","     * @param keyParam 加密密钥\n","     * @return 加密后文件在容器的路径\n","     * @throws IOException                文件读写异常\n","     * @throws InvalidCipherTextException 加密运算异常\n","     */\n","    private ContainerPath encryptElement(Element obj, String outPath, CipherParameters keyParam) throws IOException, InvalidCipherTextException {\n","        if (outPath.startsWith(\"/\")) {\n","            outPath = outPath.substring(1);\n","        }\n","        // 创建加密后保存的文件路径\n","        final ContainerPath res = ContainerPath.newDatFile(outPath, workDir);\n","\n","        int len = 0;\n","        int bytesProcessed = 0;\n","        byte[] buffIn = new byte[4096];\n","        byte[] buffOut = new byte[4096 + this.blockCipher.getBlockSize()];\n","        ByteArrayInputStream in = new ByteArrayInputStream(ElemCup.dump(obj));\n","        this.blockCipher.init(true, keyParam);\n","        try (OutputStream out = Files.newOutputStream(res.getAbs())) {\n","            while ((len = in.read(buffIn)) != -1) {\n","                // 分块加密\n","                bytesProcessed = this.blockCipher.processBytes(buffIn, 0, len, buffOut, 0);\n","                if (bytesProcessed > 0) {\n","                    out.write(buffOut, 0, bytesProcessed);\n","                }\n","            }\n","            // 执行最后一个分块的加密和填充\n","            bytesProcessed = this.blockCipher.doFinal(buffOut, 0);\n","            out.write(buffOut, 0, bytesProcessed);\n","            this.blockCipher.reset();\n","        }\n","        return res;\n","    }\n","\n","    /**\n","     * 获取 加密操作的附加描述集合\n","     *\n","     * @return 加密操作的附加描述集合，可能为空\n","     */\n","    @Nullable\n","    public Parameters getParameters() {\n","        return parameters;\n","    }\n","\n","    /**\n","     * 设置 加密操作的附加描述集合\n","     *\n","     * @param parameters 加密操作的附加描述集合，可能为空\n","     * @return this\n","     */\n","    public OFDEncryptor setParameters(Parameters parameters) {\n","        this.parameters = parameters;\n","        return this;\n","    }\n","\n","    /**\n","     * 关闭文档\n","     * <p>\n","     * 删除工作区\n","     *\n","     * @throws IOException 工作区删除异常\n","     */\n","    @Override\n","    public void close() throws IOException {\n","        if (closed) {\n","            return;\n","        }\n","        closed = true;\n","        if (workDir != null && Files.exists(workDir)) {\n","            try {\n","                FileUtils.deleteDirectory(workDir.toFile());\n","            } catch (IOException e) {\n","                throw new IOException(\"无法删除Reader的工作空间，原因：\" + e.getMessage(), e);\n","            }\n","        }\n","    }\n","}\n"],"test_content":["package org.ofdrw.crypto;\n","\n","import org.bouncycastle.crypto.CryptoException;\n","import org.bouncycastle.crypto.engines.SM4Engine;\n","import org.bouncycastle.crypto.modes.CBCBlockCipher;\n","import org.bouncycastle.crypto.paddings.PKCS7Padding;\n","import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\n","import org.bouncycastle.crypto.params.KeyParameter;\n","import org.bouncycastle.crypto.params.ParametersWithIV;\n","import org.jetbrains.annotations.NotNull;\n","import org.jetbrains.annotations.Nullable;\n","import org.junit.jupiter.api.Test;\n","import org.ofdrw.crypto.enryptor.UserCertEncryptor;\n","import org.ofdrw.crypto.enryptor.UserFEKEncryptor;\n","import org.ofdrw.crypto.enryptor.UserPasswordEncryptor;\n","import org.ofdrw.gm.cert.PEMLoader;\n","\n","import java.io.IOException;\n","import java.io.InputStream;\n","import java.io.OutputStream;\n","import java.nio.file.Files;\n","import java.nio.file.Path;\n","import java.nio.file.Paths;\n","import java.security.GeneralSecurityException;\n","import java.security.SecureRandom;\n","import java.security.cert.Certificate;\n","\n","/**\n"," * @author 权观宇\n"," * @since 2021-07-15 18:20:18\n"," */\n","class OFDEncryptorTest {\n","\n","    @Test\n","    public void ofCase() throws Exception {\n","        SecureRandom random = new SecureRandom();\n","        PaddedBufferedBlockCipher blockCipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new SM4Engine()), new PKCS7Padding());\n","        final int blockSize = blockCipher.getBlockSize();\n","        byte[] fek = new byte[blockSize];\n","        byte[] iv = new byte[blockSize];\n","        random.nextBytes(fek);\n","        random.nextBytes(iv);\n","        ParametersWithIV keyParam = new ParametersWithIV(new KeyParameter(fek), iv);\n","        blockCipher.init(true,keyParam);\n","\n","        Path src = Paths.get(\"src/test/resources/byte16.bin\");\n","        Path dst = Paths.get(\"target/byte16.enc\");\n","\n","        byte[] buffIn = new byte[1024];\n","        byte[] buffOut = new byte[1024 + blockSize];\n","\n","        int len = 0;\n","        try(final InputStream in = Files.newInputStream(src);\n","            final OutputStream out = Files.newOutputStream(dst)){\n","            int bytesProcessed = 0;\n","            while ((len = in.read(buffIn)) != -1) {\n","                bytesProcessed = blockCipher.processBytes(buffIn, 0, len, buffOut, 0);\n","                if (bytesProcessed > 0){\n","                    out.write(buffOut, 0, bytesProcessed);\n","                }\n","            }\n","            bytesProcessed = blockCipher.doFinal(buffOut, 0);\n","            out.write(buffOut, 0, bytesProcessed);\n","            blockCipher.reset();\n","        }\n","    }\n","\n","    @Test\n","    void encryptPassword() throws IOException, CryptoException, GeneralSecurityException {\n","        Path src = Paths.get(\"src/test/resources/hello.ofd\");\n","        Path out = Paths.get(\"target/hello-enc.ofd\");\n","        try (OFDEncryptor ofdEncryptor = new OFDEncryptor(src, out)) {\n","            final UserFEKEncryptor encryptor = new UserPasswordEncryptor(\"777\", \"12345678\");\n","            ofdEncryptor.addUser(encryptor);\n","            ofdEncryptor.encrypt();\n","        }\n","        System.out.println(\">> \" + out.toAbsolutePath().toString());\n","    }\n","\n","    @Test\n","    void encryptCert() throws IOException, CryptoException, GeneralSecurityException {\n","        Path src = Paths.get(\"src/test/resources/hello.ofd\");\n","        Path out = Paths.get(\"target/hello-enc.ofd\");\n","        Path certPath  =  Paths.get(\"src/test/resources\", \"sign_cert.pem\");\n","        final Certificate certificate = PEMLoader.loadCert(certPath);\n","\n","        try (OFDEncryptor ofdEncryptor = new OFDEncryptor(src, out)) {\n","            final UserFEKEncryptor encryptor = new UserCertEncryptor(\"777\", certificate);\n","            ofdEncryptor.addUser(encryptor);\n","            ofdEncryptor.encrypt();\n","        }\n","        System.out.println(\">> \" + out.toAbsolutePath());\n","    }\n","}"],"method_lines_dic":{"OFDEncryptor::::addUser(org.ofdrw.crypto.enryptor.UserFEKEncryptor)":[129,135],"OFDEncryptor::::setRandom(java.security.SecureRandom)":[143,149],"OFDEncryptor::::setContainerFileFilter(org.ofdrw.crypto.ContainerFileFilter)":[161,167],"OFDEncryptor::::encrypt()":[177,246],"OFDEncryptor::::newEncryptInfo(java.lang.String)":[254,271],"OFDEncryptor::::getToBeEncFiles()":[282,300],"OFDEncryptor::::getParameters()":[406,409],"OFDEncryptor::::close()":[429,442]},"test_method_lines_dic":{"OFDEncryptorTest::::ofCase()":[34,66],"OFDEncryptorTest::::encryptPassword()":[68,78],"OFDEncryptorTest::::encryptCert()":[80,93]},"reverse_method_lines_dic":{"129":"OFDEncryptor::::addUser(org.ofdrw.crypto.enryptor.UserFEKEncryptor)","130":"OFDEncryptor::::addUser(org.ofdrw.crypto.enryptor.UserFEKEncryptor)","131":"OFDEncryptor::::addUser(org.ofdrw.crypto.enryptor.UserFEKEncryptor)","132":"OFDEncryptor::::addUser(org.ofdrw.crypto.enryptor.UserFEKEncryptor)","133":"OFDEncryptor::::addUser(org.ofdrw.crypto.enryptor.UserFEKEncryptor)","134":"OFDEncryptor::::addUser(org.ofdrw.crypto.enryptor.UserFEKEncryptor)","135":"OFDEncryptor::::addUser(org.ofdrw.crypto.enryptor.UserFEKEncryptor)","143":"OFDEncryptor::::setRandom(java.security.SecureRandom)","144":"OFDEncryptor::::setRandom(java.security.SecureRandom)","145":"OFDEncryptor::::setRandom(java.security.SecureRandom)","146":"OFDEncryptor::::setRandom(java.security.SecureRandom)","147":"OFDEncryptor::::setRandom(java.security.SecureRandom)","148":"OFDEncryptor::::setRandom(java.security.SecureRandom)","149":"OFDEncryptor::::setRandom(java.security.SecureRandom)","161":"OFDEncryptor::::setContainerFileFilter(org.ofdrw.crypto.ContainerFileFilter)","162":"OFDEncryptor::::setContainerFileFilter(org.ofdrw.crypto.ContainerFileFilter)","163":"OFDEncryptor::::setContainerFileFilter(org.ofdrw.crypto.ContainerFileFilter)","164":"OFDEncryptor::::setContainerFileFilter(org.ofdrw.crypto.ContainerFileFilter)","165":"OFDEncryptor::::setContainerFileFilter(org.ofdrw.crypto.ContainerFileFilter)","166":"OFDEncryptor::::setContainerFileFilter(org.ofdrw.crypto.ContainerFileFilter)","167":"OFDEncryptor::::setContainerFileFilter(org.ofdrw.crypto.ContainerFileFilter)","177":"OFDEncryptor::::encrypt()","178":"OFDEncryptor::::encrypt()","179":"OFDEncryptor::::encrypt()","180":"OFDEncryptor::::encrypt()","181":"OFDEncryptor::::encrypt()","182":"OFDEncryptor::::encrypt()","183":"OFDEncryptor::::encrypt()","184":"OFDEncryptor::::encrypt()","185":"OFDEncryptor::::encrypt()","186":"OFDEncryptor::::encrypt()","187":"OFDEncryptor::::encrypt()","188":"OFDEncryptor::::encrypt()","189":"OFDEncryptor::::encrypt()","190":"OFDEncryptor::::encrypt()","191":"OFDEncryptor::::encrypt()","192":"OFDEncryptor::::encrypt()","193":"OFDEncryptor::::encrypt()","194":"OFDEncryptor::::encrypt()","195":"OFDEncryptor::::encrypt()","196":"OFDEncryptor::::encrypt()","197":"OFDEncryptor::::encrypt()","198":"OFDEncryptor::::encrypt()","199":"OFDEncryptor::::encrypt()","200":"OFDEncryptor::::encrypt()","201":"OFDEncryptor::::encrypt()","202":"OFDEncryptor::::encrypt()","203":"OFDEncryptor::::encrypt()","204":"OFDEncryptor::::encrypt()","205":"OFDEncryptor::::encrypt()","206":"OFDEncryptor::::encrypt()","207":"OFDEncryptor::::encrypt()","208":"OFDEncryptor::::encrypt()","209":"OFDEncryptor::::encrypt()","210":"OFDEncryptor::::encrypt()","211":"OFDEncryptor::::encrypt()","212":"OFDEncryptor::::encrypt()","213":"OFDEncryptor::::encrypt()","214":"OFDEncryptor::::encrypt()","215":"OFDEncryptor::::encrypt()","216":"OFDEncryptor::::encrypt()","217":"OFDEncryptor::::encrypt()","218":"OFDEncryptor::::encrypt()","219":"OFDEncryptor::::encrypt()","220":"OFDEncryptor::::encrypt()","221":"OFDEncryptor::::encrypt()","222":"OFDEncryptor::::encrypt()","223":"OFDEncryptor::::encrypt()","224":"OFDEncryptor::::encrypt()","225":"OFDEncryptor::::encrypt()","226":"OFDEncryptor::::encrypt()","227":"OFDEncryptor::::encrypt()","228":"OFDEncryptor::::encrypt()","229":"OFDEncryptor::::encrypt()","230":"OFDEncryptor::::encrypt()","231":"OFDEncryptor::::encrypt()","232":"OFDEncryptor::::encrypt()","233":"OFDEncryptor::::encrypt()","234":"OFDEncryptor::::encrypt()","235":"OFDEncryptor::::encrypt()","236":"OFDEncryptor::::encrypt()","237":"OFDEncryptor::::encrypt()","238":"OFDEncryptor::::encrypt()","239":"OFDEncryptor::::encrypt()","240":"OFDEncryptor::::encrypt()","241":"OFDEncryptor::::encrypt()","242":"OFDEncryptor::::encrypt()","243":"OFDEncryptor::::encrypt()","244":"OFDEncryptor::::encrypt()","245":"OFDEncryptor::::encrypt()","246":"OFDEncryptor::::encrypt()","254":"OFDEncryptor::::newEncryptInfo(java.lang.String)","255":"OFDEncryptor::::newEncryptInfo(java.lang.String)","256":"OFDEncryptor::::newEncryptInfo(java.lang.String)","257":"OFDEncryptor::::newEncryptInfo(java.lang.String)","258":"OFDEncryptor::::newEncryptInfo(java.lang.String)","259":"OFDEncryptor::::newEncryptInfo(java.lang.String)","260":"OFDEncryptor::::newEncryptInfo(java.lang.String)","261":"OFDEncryptor::::newEncryptInfo(java.lang.String)","262":"OFDEncryptor::::newEncryptInfo(java.lang.String)","263":"OFDEncryptor::::newEncryptInfo(java.lang.String)","264":"OFDEncryptor::::newEncryptInfo(java.lang.String)","265":"OFDEncryptor::::newEncryptInfo(java.lang.String)","266":"OFDEncryptor::::newEncryptInfo(java.lang.String)","267":"OFDEncryptor::::newEncryptInfo(java.lang.String)","268":"OFDEncryptor::::newEncryptInfo(java.lang.String)","269":"OFDEncryptor::::newEncryptInfo(java.lang.String)","270":"OFDEncryptor::::newEncryptInfo(java.lang.String)","271":"OFDEncryptor::::newEncryptInfo(java.lang.String)","282":"OFDEncryptor::::getToBeEncFiles()","283":"OFDEncryptor::::getToBeEncFiles()","284":"OFDEncryptor::::getToBeEncFiles()","285":"OFDEncryptor::::getToBeEncFiles()","286":"OFDEncryptor::::getToBeEncFiles()","287":"OFDEncryptor::::getToBeEncFiles()","288":"OFDEncryptor::::getToBeEncFiles()","289":"OFDEncryptor::::getToBeEncFiles()","290":"OFDEncryptor::::getToBeEncFiles()","291":"OFDEncryptor::::getToBeEncFiles()","292":"OFDEncryptor::::getToBeEncFiles()","293":"OFDEncryptor::::getToBeEncFiles()","294":"OFDEncryptor::::getToBeEncFiles()","295":"OFDEncryptor::::getToBeEncFiles()","296":"OFDEncryptor::::getToBeEncFiles()","297":"OFDEncryptor::::getToBeEncFiles()","298":"OFDEncryptor::::getToBeEncFiles()","299":"OFDEncryptor::::getToBeEncFiles()","300":"OFDEncryptor::::getToBeEncFiles()","406":"OFDEncryptor::::getParameters()","407":"OFDEncryptor::::getParameters()","408":"OFDEncryptor::::getParameters()","409":"OFDEncryptor::::getParameters()","429":"OFDEncryptor::::close()","430":"OFDEncryptor::::close()","431":"OFDEncryptor::::close()","432":"OFDEncryptor::::close()","433":"OFDEncryptor::::close()","434":"OFDEncryptor::::close()","435":"OFDEncryptor::::close()","436":"OFDEncryptor::::close()","437":"OFDEncryptor::::close()","438":"OFDEncryptor::::close()","439":"OFDEncryptor::::close()","440":"OFDEncryptor::::close()","441":"OFDEncryptor::::close()","442":"OFDEncryptor::::close()"},"test_reverse_method_lines_dic":{"34":"OFDEncryptorTest::::ofCase()","35":"OFDEncryptorTest::::ofCase()","36":"OFDEncryptorTest::::ofCase()","37":"OFDEncryptorTest::::ofCase()","38":"OFDEncryptorTest::::ofCase()","39":"OFDEncryptorTest::::ofCase()","40":"OFDEncryptorTest::::ofCase()","41":"OFDEncryptorTest::::ofCase()","42":"OFDEncryptorTest::::ofCase()","43":"OFDEncryptorTest::::ofCase()","44":"OFDEncryptorTest::::ofCase()","45":"OFDEncryptorTest::::ofCase()","46":"OFDEncryptorTest::::ofCase()","47":"OFDEncryptorTest::::ofCase()","48":"OFDEncryptorTest::::ofCase()","49":"OFDEncryptorTest::::ofCase()","50":"OFDEncryptorTest::::ofCase()","51":"OFDEncryptorTest::::ofCase()","52":"OFDEncryptorTest::::ofCase()","53":"OFDEncryptorTest::::ofCase()","54":"OFDEncryptorTest::::ofCase()","55":"OFDEncryptorTest::::ofCase()","56":"OFDEncryptorTest::::ofCase()","57":"OFDEncryptorTest::::ofCase()","58":"OFDEncryptorTest::::ofCase()","59":"OFDEncryptorTest::::ofCase()","60":"OFDEncryptorTest::::ofCase()","61":"OFDEncryptorTest::::ofCase()","62":"OFDEncryptorTest::::ofCase()","63":"OFDEncryptorTest::::ofCase()","64":"OFDEncryptorTest::::ofCase()","65":"OFDEncryptorTest::::ofCase()","66":"OFDEncryptorTest::::ofCase()","68":"OFDEncryptorTest::::encryptPassword()","69":"OFDEncryptorTest::::encryptPassword()","70":"OFDEncryptorTest::::encryptPassword()","71":"OFDEncryptorTest::::encryptPassword()","72":"OFDEncryptorTest::::encryptPassword()","73":"OFDEncryptorTest::::encryptPassword()","74":"OFDEncryptorTest::::encryptPassword()","75":"OFDEncryptorTest::::encryptPassword()","76":"OFDEncryptorTest::::encryptPassword()","77":"OFDEncryptorTest::::encryptPassword()","78":"OFDEncryptorTest::::encryptPassword()","80":"OFDEncryptorTest::::encryptCert()","81":"OFDEncryptorTest::::encryptCert()","82":"OFDEncryptorTest::::encryptCert()","83":"OFDEncryptorTest::::encryptCert()","84":"OFDEncryptorTest::::encryptCert()","85":"OFDEncryptorTest::::encryptCert()","86":"OFDEncryptorTest::::encryptCert()","87":"OFDEncryptorTest::::encryptCert()","88":"OFDEncryptorTest::::encryptCert()","89":"OFDEncryptorTest::::encryptCert()","90":"OFDEncryptorTest::::encryptCert()","91":"OFDEncryptorTest::::encryptCert()","92":"OFDEncryptorTest::::encryptCert()","93":"OFDEncryptorTest::::encryptCert()"},"tests":[{"test_lines":[68,78],"covered_lines":[106,107,110,113,114,116,117,118,119,120,121,130,133,134,178,181,182,185,187,190,192,193,194,196,197,198,202,203,205,207,208,209,211,212,214,216,217,218,220,221,222,223,226,229,237,239,241,244,245,255,256,262,263,264,265,266,268,270,283,285,287,288,289,290,291,293,294,295,299,313,314,317,319,320,321,336,337,338,339,341,342,343,344,345,347,348,349,353,354,355,356,358,359,373,377,379,380,381,382,383,384,385,386,388,389,390,394,395,396,397,398,431,434,435,437,440,442],"label":"OFDEncryptor::::encrypt()"},{"test_lines":[80,93],"covered_lines":[106,107,110,113,114,116,117,118,119,120,121,130,133,134,178,181,182,185,187,190,192,193,194,196,197,198,202,203,205,207,208,209,211,212,214,216,217,218,220,221,222,223,226,229,231,232,235,237,239,241,244,245,255,256,262,263,264,265,266,268,270,283,285,287,288,289,290,291,293,294,295,299,313,314,317,319,320,321,336,337,338,339,341,342,343,344,345,347,348,349,353,354,355,356,358,359,373,377,379,380,381,382,383,384,385,386,388,389,390,394,395,396,397,398,431,434,435,437,440,442],"label":"OFDEncryptor::::encrypt()"}]},"/bernard/dataset_construction/prep/repos/ofdrw/ofdrw-crypto/src/main/java/org/ofdrw/crypto/ContainerPath.java":{"class_content":["package org.ofdrw.crypto;\n","\n","import org.ofdrw.core.basicType.ST_Loc;\n","\n","import java.io.IOException;\n","import java.nio.file.Files;\n","import java.nio.file.Path;\n","\n","/**\n"," * 文件在容器中的路径\n"," *\n"," * @author 权观宇\n"," * @since 2021-07-15 18:57:45\n"," */\n","public class ContainerPath {\n","    /**\n","     * 容器内绝对路径\n","     */\n","    private String path;\n","    /**\n","     * 文件系统内绝对路径\n","     */\n","    private Path abs;\n","\n","    private ContainerPath() {\n","    }\n","\n","    /**\n","     * 创建  文件在容器中的路径\n","     *\n","     * @param path 容器内绝对路径\n","     * @param abs  文件系统内绝对路径\n","     */\n","    public ContainerPath(String path, Path abs) {\n","        this.path = path;\n","        this.abs = abs;\n","    }\n","\n","    public String getPath() {\n","        return path;\n","    }\n","\n","    public Path getAbs() {\n","        return abs;\n","    }\n","\n","\n","    /**\n","     * 创建加密后的文件路径（空）\n","     * <p>\n","     * 输出加密文件命名规则 原文件名全小写 + .dat 后缀，如果重复，那么在文件名后面增加后缀\n","     *\n","     * @return 创建加密后输出文件\n","     * @throws IOException 文件操作异常\n","     */\n","    public ContainerPath createEncryptedFile() throws IOException {\n","        return newDatFile(this.path, abs.toAbsolutePath().getParent());\n","    }\n","\n","    /**\n","     * 创建 后缀为.dat 的文件\n","     * <p>\n","     * 加密文件为 原文件 后缀改为 .dat\n","     * 若文件存在，则在文件名后追加下滑线序号 _N\n","     *\n","     * @param cAbs   容器内绝对路径\n","     * @param parent 生成的加密文件存储目录\n","     * @return 容器路径对象\n","     * @throws IOException 文件操作异常\n","     */\n","    public static ContainerPath newDatFile(String cAbs, Path parent) throws IOException {\n","        if (cAbs.charAt(0) != '/') {\n","            cAbs = '/' + cAbs;\n","        }\n","        if (Files.notExists(parent)) {\n","            Files.createDirectories(parent);\n","        }\n","        final ST_Loc containerLoc = ST_Loc.getInstance(cAbs);\n","        // 获取文件名\n","        String originalName = containerLoc.getFileName();\n","        int off = originalName.lastIndexOf('.');\n","        String name = originalName;\n","        if (off != -1) {\n","            name = originalName.substring(0, off);\n","        }\n","        String encFileName = name.toLowerCase() + \".dat\";\n","        Path resPath = parent.resolve(encFileName);\n","        int cnt = 1;\n","        // 输出加密文件命名规则 原文件名全小写 + .dat 后缀，如果重复，那么在文件名后面增加后缀\n","        while (Files.exists(resPath)) {\n","            encFileName = name.toLowerCase() + \"_\" + cnt + \".dat\";\n","            resPath = parent.resolve(encFileName);\n","            cnt++;\n","        }\n","        // 创建文件\n","        Files.createFile(resPath);\n","        return new ContainerPath(containerLoc.parent() + \"/\" + encFileName, resPath);\n","    }\n","}\n"],"test_content":["package org.ofdrw.crypto;\n","\n","import org.junit.jupiter.api.Test;\n","\n","import java.io.IOException;\n","import java.io.InputStream;\n","import java.io.OutputStream;\n","import java.nio.charset.StandardCharsets;\n","import java.nio.file.Files;\n","import java.nio.file.Path;\n","import java.nio.file.Paths;\n","\n","import static org.junit.jupiter.api.Assertions.*;\n","\n","/**\n"," * @author 权观宇\n"," * @since 2021-07-19 19:19:41\n"," */\n","class ContainerPathTest {\n","\n","    @Test\n","    void createEncryptedFile() throws IOException {\n","\n","        Path src = Paths.get(\"target/Doc_0/Page_0/Content.xml\");\n","        Files.createDirectories(src.getParent());\n","        try (OutputStream out = Files.newOutputStream(src);) {\n","            out.write(\"Hello\".getBytes(StandardCharsets.UTF_8));\n","        }\n","\n","        ContainerPath cp = new ContainerPath(\"/Doc_0/Page_0/Content.xml\", src);\n","        final ContainerPath actual = cp.createEncryptedFile();\n","        Path encryptedFile = actual.getAbs();\n","        assertTrue(Files.exists(encryptedFile));\n","        assertEquals(\"/Doc_0/Page_0/content.dat\", actual.getPath());\n","        System.out.println(actual.getPath());\n","        System.out.println(encryptedFile.toAbsolutePath());\n","    }\n","\n","\n","    @Test\n","    public void resolve() throws Exception {\n","        Path src = Paths.get(\"\");\n","        final Path resolve = src.resolve(\"not/exist/dir\");\n","        System.out.println(Files.notExists(resolve));\n","        System.out.println(resolve.toAbsolutePath());\n","    }\n","}"],"method_lines_dic":{"ContainerPath::::getPath()":[39,41],"ContainerPath::::getAbs()":[43,45],"ContainerPath::::createEncryptedFile()":[56,58],"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)":[71,98]},"test_method_lines_dic":{"ContainerPathTest::::createEncryptedFile()":[21,37],"ContainerPathTest::::resolve()":[40,46]},"reverse_method_lines_dic":{"39":"ContainerPath::::getPath()","40":"ContainerPath::::getPath()","41":"ContainerPath::::getPath()","43":"ContainerPath::::getAbs()","44":"ContainerPath::::getAbs()","45":"ContainerPath::::getAbs()","56":"ContainerPath::::createEncryptedFile()","57":"ContainerPath::::createEncryptedFile()","58":"ContainerPath::::createEncryptedFile()","71":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","72":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","73":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","74":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","75":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","76":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","77":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","78":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","79":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","80":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","81":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","82":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","83":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","84":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","85":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","86":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","87":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","88":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","89":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","90":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","91":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","92":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","93":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","94":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","95":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","96":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","97":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)","98":"ContainerPath::::newDatFile(java.lang.String,java.nio.file.Path)"},"test_reverse_method_lines_dic":{"21":"ContainerPathTest::::createEncryptedFile()","22":"ContainerPathTest::::createEncryptedFile()","23":"ContainerPathTest::::createEncryptedFile()","24":"ContainerPathTest::::createEncryptedFile()","25":"ContainerPathTest::::createEncryptedFile()","26":"ContainerPathTest::::createEncryptedFile()","27":"ContainerPathTest::::createEncryptedFile()","28":"ContainerPathTest::::createEncryptedFile()","29":"ContainerPathTest::::createEncryptedFile()","30":"ContainerPathTest::::createEncryptedFile()","31":"ContainerPathTest::::createEncryptedFile()","32":"ContainerPathTest::::createEncryptedFile()","33":"ContainerPathTest::::createEncryptedFile()","34":"ContainerPathTest::::createEncryptedFile()","35":"ContainerPathTest::::createEncryptedFile()","36":"ContainerPathTest::::createEncryptedFile()","37":"ContainerPathTest::::createEncryptedFile()","40":"ContainerPathTest::::resolve()","41":"ContainerPathTest::::resolve()","42":"ContainerPathTest::::resolve()","43":"ContainerPathTest::::resolve()","44":"ContainerPathTest::::resolve()","45":"ContainerPathTest::::resolve()","46":"ContainerPathTest::::resolve()"},"tests":[{"test_lines":[21,37],"covered_lines":[34,35,36,37,40,44,57,72,75,78,80,81,82,83,84,86,87,88,90,96,97],"label":"ContainerPath::::createEncryptedFile()"}]},"/bernard/dataset_construction/prep/repos/ofdrw/ofdrw-crypto/src/main/java/org/ofdrw/crypto/integrity/OFDIntegrityVerifier.java":{"class_content":["package org.ofdrw.crypto.integrity;\n","\n","import org.apache.commons.io.FileUtils;\n","import org.dom4j.DocumentException;\n","import org.dom4j.Element;\n","import org.ofdrw.core.Holder;\n","import org.ofdrw.core.basicType.ST_Loc;\n","import org.ofdrw.core.integrity.FileList;\n","import org.ofdrw.core.integrity.OFDEntries;\n","import org.ofdrw.pkg.container.OFDDir;\n","import org.ofdrw.pkg.tool.ElemCup;\n","import org.ofdrw.reader.ZipUtil;\n","\n","import java.io.File;\n","import java.io.IOException;\n","import java.nio.file.*;\n","import java.security.GeneralSecurityException;\n","import java.util.HashSet;\n","import java.util.Set;\n","\n","/**\n"," * OFD完整性协议校验\n"," * <p>\n"," * 协议遵循《GB/T 0099》 7.4.6 校验流程\n"," *\n"," * @author 权观宇\n"," * @since 2021-08-23 19:44:54\n"," */\n","public class OFDIntegrityVerifier {\n","\n","    public OFDIntegrityVerifier() {\n","    }\n","\n","    /**\n","     * 执行OFD的完整性校验流程\n","     *\n","     * @param in       待校验的OFD文件路径\n","     * @param verifier 签名值验证器\n","     * @return 校验结果：true - 文件完整且没有夹带；false - 文件存在夹带\n","     * @throws IOException              文件不存在或IO操作异常\n","     * @throws GeneralSecurityException 安全计算异常\n","     * @throws DocumentException        无法解析文档内容，可能是文件格式不正确\n","     */\n","    public boolean integrity(Path in, ProtectVerifier verifier) throws IOException, GeneralSecurityException, DocumentException {\n","        if (in == null || Files.notExists(in)) {\n","            throw new IllegalArgumentException(\"待校验的OFD文件路径(in)为空或不存在\");\n","        }\n","        if (verifier == null) {\n","            throw new IllegalArgumentException(\"签名值验证器(verifier)为空\");\n","        }\n","\n","        Path workDir = null;\n","        try {\n","            workDir = Files.createTempDirectory(\"ofd-tmp-\");\n","            // 解压文档，到临时的工作目录\n","            ZipUtil.unZipFiles(in.toFile(), workDir.toAbsolutePath() + File.separator);\n","            OFDDir ofdDir = new OFDDir(workDir.toAbsolutePath());\n","            // a) 读取完整性保护描述文件\n","            // 此处如果文件不存在会抛出FNE异常\n","            final Path ofdEntriesPath = ofdDir.getFile(OFDDir.OFDEntriesFileName);\n","            // b) 根据签名方案，调用杂凑算法计算完整性保护文件得到杂凑值\n","            // c) 读取签名值文件，进行签名验证\n","            final Element e = ElemCup.inject(ofdEntriesPath);\n","            OFDEntries ofdEntries = new OFDEntries(e);\n","            final ST_Loc signedValueLoc = ofdEntries.getSignedValueLoc();\n","            final Path sigValuePath = Paths.get(workDir.toString(), signedValueLoc.toString());\n","            final byte[] signedValue = Files.readAllBytes(sigValuePath);\n","            // 调用杂凑算法计算完整性保护文件得到杂凑值，进行签名验证\n","            boolean integrity = verifier.digestThenVerify(ofdEntriesPath, signedValue);\n","            // 为了保证没有而外夹带的文件还需要，根据文件表和示例包内的文件进行对比\n","            boolean hasExtraFile = checkNoExtraFile(ofdDir, ofdEntries);\n","            return integrity && hasExtraFile;\n","        } finally {\n","            if (workDir != null) {\n","                // 删除用于校验的临时目录\n","                FileUtils.deleteDirectory(workDir.toFile());\n","            }\n","        }\n","    }\n","\n","    /**\n","     * 检查是否存在 防止夹带文件列表 中存在的夹带文件\n","     *\n","     * @param ofdDir     OFD容器\n","     * @param ofdEntries 完整性保护描述对象\n","     * @return true - 没有夹带; false - 存在夹带\n","     */\n","    private boolean checkNoExtraFile(OFDDir ofdDir, OFDEntries ofdEntries) throws IOException {\n","        final FileList fileList = ofdEntries.getFileList();\n","        // 建立文件MAP 用于检查映射情况\n","        Set<String> pkgFileSet = new HashSet<>();\n","        fileList.getFiles().forEach((f) -> {\n","            String loc = f.getFileLoc().toString();\n","            if (loc.charAt(0) != '/') {\n","                loc = String.format(\"/%s\", loc);\n","            }\n","            pkgFileSet.add(loc);\n","        });\n","        // 签名值文件也加入 Set中用于检查\n","        final ST_Loc signedValueLoc = ofdEntries.getSignedValueLoc();\n","        String loc = signedValueLoc.toString();\n","        if (loc.charAt(0) != '/') {\n","            loc = String.format(\"/%s\", loc);\n","        }\n","        pkgFileSet.add(loc);\n","\n","        Holder<String> invalidFileLocHolder = new Holder<>(null);\n","        // 遍历包内出现的所有文件\n","        ofdDir.walk(((pkgAbsPath, path) -> {\n","            // 忽略防止夹带文件本身\n","            if (\"/OFDEntries.xml\".equals(pkgAbsPath)){\n","                return true;\n","            }\n","             boolean exist = pkgFileSet.contains(pkgAbsPath);\n","            if (!exist) {\n","                // 文件不在 完整性保护文件列表中，那么认为是发生了文件的夹带\n","                invalidFileLocHolder.value = pkgAbsPath;\n","                // 停止文件的继续遍历\n","                return false;\n","            }\n","            return true;\n","        }));\n","        // 如果非法文件路径为空表示没有出现夹带情况\n","        return invalidFileLocHolder.value == null;\n","    }\n","}\n"],"test_content":["package org.ofdrw.crypto.integrity;\n","\n","import org.dom4j.DocumentException;\n","import org.junit.jupiter.api.Test;\n","\n","import java.io.IOException;\n","import java.nio.file.Path;\n","import java.nio.file.Paths;\n","import java.security.GeneralSecurityException;\n","\n","import static org.junit.jupiter.api.Assertions.*;\n","\n","/**\n"," * 测试验证OFD完整性\n"," *\n"," * @author 权观宇\n"," * @since 2021-08-24 19:45:25\n"," */\n","class OFDIntegrityVerifierTest {\n","\n","    /**\n","     * 完整性验证测试用例\n","     */\n","    @Test\n","    void integrity() throws GeneralSecurityException, IOException, DocumentException {\n","        Path in = Paths.get(\"src/test/resources/hello-integrity.ofd\");\n","        // 1. 创建OFD完整性验证器。\n","        OFDIntegrityVerifier ofdIntegrityVerifier = new OFDIntegrityVerifier();\n","        // 2. 创建用于验证签名值的验证器。\n","        GMProtectVerifier gmProtectVerifier = new GMProtectVerifier();\n","        // 3. 执行完整性验证，获取验证结果。\n","        final boolean integrity = ofdIntegrityVerifier.integrity(in, gmProtectVerifier);\n","        System.out.println(\">> OFD完整性校验: \" + integrity);\n","        assertTrue(integrity);\n","    }\n","\n","}"],"method_lines_dic":{"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)":[44,79]},"test_method_lines_dic":{"OFDIntegrityVerifierTest::::integrity()":[24,35]},"reverse_method_lines_dic":{"44":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","45":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","46":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","47":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","48":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","49":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","50":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","51":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","52":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","53":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","54":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","55":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","56":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","57":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","58":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","59":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","60":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","61":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","62":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","63":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","64":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","65":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","66":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","67":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","68":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","69":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","70":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","71":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","72":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","73":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","74":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","75":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","76":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","77":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","78":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)","79":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)"},"test_reverse_method_lines_dic":{"24":"OFDIntegrityVerifierTest::::integrity()","25":"OFDIntegrityVerifierTest::::integrity()","26":"OFDIntegrityVerifierTest::::integrity()","27":"OFDIntegrityVerifierTest::::integrity()","28":"OFDIntegrityVerifierTest::::integrity()","29":"OFDIntegrityVerifierTest::::integrity()","30":"OFDIntegrityVerifierTest::::integrity()","31":"OFDIntegrityVerifierTest::::integrity()","32":"OFDIntegrityVerifierTest::::integrity()","33":"OFDIntegrityVerifierTest::::integrity()","34":"OFDIntegrityVerifierTest::::integrity()","35":"OFDIntegrityVerifierTest::::integrity()"},"tests":[{"test_lines":[24,35],"covered_lines":[31,32,45,48,52,54,56,57,60,63,64,65,66,67,69,71,72,74,76,89,91,92,93,94,97,98,100,101,102,105,107,109,111,112,114,115,121,124],"label":"OFDIntegrityVerifier::::integrity(java.nio.file.Path,org.ofdrw.crypto.integrity.ProtectVerifier)"}]},"/bernard/dataset_construction/prep/repos/ofdrw/ofdrw-crypto/src/main/java/org/ofdrw/crypto/integrity/OFDIntegrity.java":{"class_content":["package org.ofdrw.crypto.integrity;\n","\n","import org.apache.commons.io.FileUtils;\n","import org.apache.commons.io.FilenameUtils;\n","import org.jetbrains.annotations.NotNull;\n","import org.ofdrw.core.basicType.ST_Loc;\n","import org.ofdrw.core.integrity.FileList;\n","import org.ofdrw.core.integrity.OFDEntries;\n","import org.ofdrw.gv.GlobalVar;\n","import org.ofdrw.pkg.container.OFDDir;\n","import org.ofdrw.pkg.tool.ElemCup;\n","import org.ofdrw.reader.ZipUtil;\n","\n","import java.io.Closeable;\n","import java.io.File;\n","import java.io.IOException;\n","import java.nio.file.FileVisitResult;\n","import java.nio.file.Files;\n","import java.nio.file.Path;\n","import java.nio.file.SimpleFileVisitor;\n","import java.nio.file.attribute.BasicFileAttributes;\n","import java.security.GeneralSecurityException;\n","import java.time.LocalDateTime;\n","import java.util.concurrent.atomic.AtomicInteger;\n","\n","/**\n"," * OFD完整性保护协议实现\n"," *\n"," * @author 权观宇\n"," * @since 2021-08-17 19:41:53\n"," */\n","public class OFDIntegrity implements Closeable {\n","    /**\n","     * OFD虚拟容器根目录\n","     */\n","    private OFDDir ofdDir;\n","\n","    /**\n","     * 加密后文件输出位置\n","     */\n","    private Path dest;\n","\n","    /**\n","     * 工作过程中的工作目录\n","     * <p>\n","     * 用于存放解压后的OFD文档容器内容\n","     */\n","    private Path workDir;\n","\n","    private boolean closed;\n","\n","    private AtomicInteger idProvider;\n","\n","    public OFDIntegrity(@NotNull Path ofdFile, @NotNull Path dest) throws IOException {\n","        if (ofdFile == null || Files.notExists(ofdFile)) {\n","            throw new IllegalArgumentException(\"待保护文件位置(ofdFile)不正确\");\n","        }\n","        if (dest == null) {\n","            throw new IllegalArgumentException(\"完整性保护文件输出位置(out)为空\");\n","        }\n","        idProvider = new AtomicInteger(0);\n","        this.dest = dest;\n","        this.workDir = Files.createTempDirectory(\"ofd-tmp-\");\n","        // 解压文档，到临时的工作目录\n","        ZipUtil.unZipFiles(ofdFile.toFile(), this.workDir.toAbsolutePath() + File.separator);\n","        this.ofdDir = new OFDDir(workDir.toAbsolutePath());\n","    }\n","\n","    /**\n","     * 对文件实行完整性保护\n","     * <p>\n","     * 请在完成保护后务必调用{@link #close()} 以清除工作过程中的临时文件！\n","     *\n","     * @param signer 签名实现\n","     * @throws IOException IO操作异常\n","     * @throws GeneralSecurityException 密码运算相关问题\n","     */\n","    public void protect(@NotNull ProtectSigner signer) throws IOException, GeneralSecurityException {\n","        if (signer == null) {\n","            throw new IllegalArgumentException(\"请提供 签名实现\");\n","        }\n","        final FileList fileList = new FileList();\n","        final OFDEntries ofdEntries = new OFDEntries()\n","                .setID(String.valueOf(this.idProvider.incrementAndGet()))\n","                .setCreatorName(\"ofdrw-crypto\")\n","                .setVersion(GlobalVar.Version)\n","                .setCreationDate(LocalDateTime.now());\n","\n","        ofdEntries.setSignedValueLoc(ST_Loc.getInstance(\"/signedvalue.dat\"))\n","                .setFileList(fileList);\n","\n","        Path ofdEntriesPath = this.workDir.resolve(\"OFDEntries.xml\");\n","        Path signedValuePath = this.workDir.resolve(\"signedvalue.dat\");\n","        // a) 确认文件包内的所有文件\n","        // 文件系统中的容器Unix类型绝对路径，如：\"/home/root/tmp\"\n","        String sysRoot = FilenameUtils.separatorsToUnix(this.workDir.toAbsolutePath().toString());\n","        Files.walkFileTree(this.workDir, new SimpleFileVisitor<Path>() {\n","            @Override\n","            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n","                // 路径转换为Unix类型的绝对路径\n","                String abxFilePath = FilenameUtils.separatorsToUnix(file.toAbsolutePath().toString());\n","                // 替换文件系统的根路径，这样就为容器系统中的绝对路径\n","                abxFilePath = abxFilePath.replace(sysRoot, \"\");\n","                String id = String.valueOf(idProvider.incrementAndGet());\n","                // b) 组装 签名完整性保护文件\n","                fileList.addFile(id, abxFilePath);\n","                return FileVisitResult.CONTINUE;\n","            }\n","        });\n","        // 把清单写入文件\n","        ElemCup.dump(ofdEntries, ofdEntriesPath);\n","        // c) 根据签名方案，计算完整性保护文件的杂凑值；\n","        // d) 根据签名方案，使用版式文件合成者的签名私钥对杂凑值进行数字签名；\n","        // 执行签名\n","        final byte[] signature = signer.digestThenSign(ofdEntriesPath);\n","        // e) 将数字签名结果写入签名值文件\n","        // 把签名值写入文件\n","        Files.write(signedValuePath, signature);\n","        // 执行打包程序\n","        this.ofdDir.jar(dest);\n","    }\n","\n","\n","    /**\n","     * 请务必在程序结束时调用该方法释放\n","     * <p>\n","     * 工作过程中产生的临时文件\n","     *\n","     * @throws IOException 文件删除IO异常\n","     */\n","    @Override\n","    public void close() throws IOException {\n","        if (closed) {\n","            return;\n","        }\n","        closed = true;\n","        if (workDir != null && Files.exists(workDir)) {\n","            try {\n","                FileUtils.deleteDirectory(workDir.toFile());\n","            } catch (IOException e) {\n","                throw new IOException(\"无法删除Reader的工作空间，原因：\" + e.getMessage(), e);\n","            }\n","        }\n","    }\n","}\n"],"test_content":["package org.ofdrw.crypto.integrity;\n","\n","import org.bouncycastle.jce.provider.BouncyCastleProvider;\n","import org.junit.jupiter.api.Test;\n","import org.ofdrw.crypto.OFDEncryptor;\n","import org.ofdrw.crypto.enryptor.UserFEKEncryptor;\n","import org.ofdrw.crypto.enryptor.UserPasswordEncryptor;\n","import org.ofdrw.gm.cert.PEMLoader;\n","\n","import java.io.IOException;\n","import java.nio.file.Path;\n","import java.nio.file.Paths;\n","import java.security.GeneralSecurityException;\n","import java.security.PrivateKey;\n","import java.security.Security;\n","import java.security.cert.Certificate;\n","\n","import static org.junit.jupiter.api.Assertions.*;\n","\n","/**\n"," * OFD完整性保护协议\n"," *\n"," * @author 权观宇\n"," * @since 2021-08-17 20:09:59\n"," */\n","class OFDIntegrityTest {\n","\n","    /**\n","     * 完整性保护示例\n","     */\n","    @Test\n","    void protect() throws IOException, GeneralSecurityException {\n","        Security.addProvider(new BouncyCastleProvider());\n","\n","        Path src = Paths.get(\"src/test/resources/hello.ofd\");\n","        Path out = Paths.get(\"target/hello-integrity.ofd\");\n","\n","        Path certPemFile = Paths.get(\"src/test/resources\", \"sign_cert.pem\");\n","        Path keyPemFile = Paths.get(\"src/test/resources\", \"sign_key.pem\");\n","\n","        // 1. 准备 签名私钥 和 签名证书\n","        final PrivateKey privateKey = PEMLoader.loadPrivateKey(keyPemFile);\n","        final Certificate certificate = PEMLoader.loadCert(certPemFile);\n","\n","        // 2. 创建完整性保护对象\n","        try (OFDIntegrity ofdIntegrity = new OFDIntegrity(src, out)) {\n","            // 3. 创建签名实现容器\n","            GMProtectSigner gmSigner = new GMProtectSigner(privateKey, certificate);\n","            // 4. 执行完整性保护\n","            ofdIntegrity.protect(gmSigner);\n","        }\n","        // 5. 关闭对象，清除临时文件 try()\n","        System.out.println(\">> \" + out.toAbsolutePath());\n","    }\n","}"],"method_lines_dic":{"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)":[78,121],"OFDIntegrity::::close()":[131,144]},"test_method_lines_dic":{"OFDIntegrityTest::::protect()":[31,54]},"reverse_method_lines_dic":{"78":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","79":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","80":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","81":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","82":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","83":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","84":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","85":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","86":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","87":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","88":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","89":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","90":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","91":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","92":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","93":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","94":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","95":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","96":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","97":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","98":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","99":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","100":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","101":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","102":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","103":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","104":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","105":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","106":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","107":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","108":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","109":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","110":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","111":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","112":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","113":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","114":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","115":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","116":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","117":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","118":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","119":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","120":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","121":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)","131":"OFDIntegrity::::close()","132":"OFDIntegrity::::close()","133":"OFDIntegrity::::close()","134":"OFDIntegrity::::close()","135":"OFDIntegrity::::close()","136":"OFDIntegrity::::close()","137":"OFDIntegrity::::close()","138":"OFDIntegrity::::close()","139":"OFDIntegrity::::close()","140":"OFDIntegrity::::close()","141":"OFDIntegrity::::close()","142":"OFDIntegrity::::close()","143":"OFDIntegrity::::close()","144":"OFDIntegrity::::close()"},"test_reverse_method_lines_dic":{"31":"OFDIntegrityTest::::protect()","32":"OFDIntegrityTest::::protect()","33":"OFDIntegrityTest::::protect()","34":"OFDIntegrityTest::::protect()","35":"OFDIntegrityTest::::protect()","36":"OFDIntegrityTest::::protect()","37":"OFDIntegrityTest::::protect()","38":"OFDIntegrityTest::::protect()","39":"OFDIntegrityTest::::protect()","40":"OFDIntegrityTest::::protect()","41":"OFDIntegrityTest::::protect()","42":"OFDIntegrityTest::::protect()","43":"OFDIntegrityTest::::protect()","44":"OFDIntegrityTest::::protect()","45":"OFDIntegrityTest::::protect()","46":"OFDIntegrityTest::::protect()","47":"OFDIntegrityTest::::protect()","48":"OFDIntegrityTest::::protect()","49":"OFDIntegrityTest::::protect()","50":"OFDIntegrityTest::::protect()","51":"OFDIntegrityTest::::protect()","52":"OFDIntegrityTest::::protect()","53":"OFDIntegrityTest::::protect()","54":"OFDIntegrityTest::::protect()"},"tests":[{"test_lines":[31,54],"covered_lines":[54,55,58,61,62,63,65,66,67,79,82,83,84,85,86,87,89,90,92,93,96,97,101,103,104,106,107,111,115,118,120,121,133,136,137,139,142,144],"label":"OFDIntegrity::::protect(org.ofdrw.crypto.integrity.ProtectSigner)"}]}}